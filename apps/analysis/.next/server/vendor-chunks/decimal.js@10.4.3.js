"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/decimal.js@10.4.3";
exports.ids = ["vendor-chunks/decimal.js@10.4.3"];
exports.modules = {

/***/ "(ssr)/../../node_modules/.pnpm/decimal.js@10.4.3/node_modules/decimal.js/decimal.mjs":
/*!**************************************************************************************!*\
  !*** ../../node_modules/.pnpm/decimal.js@10.4.3/node_modules/decimal.js/decimal.mjs ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Decimal: () => (/* binding */ Decimal),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/*!\r\n *  decimal.js v10.4.3\r\n *  An arbitrary-precision Decimal type for JavaScript.\r\n *  https://github.com/MikeMcl/decimal.js\r\n *  Copyright (c) 2022 Michael Mclaughlin <M8ch88l@gmail.com>\r\n *  MIT Licence\r\n */ // -----------------------------------  EDITABLE DEFAULTS  ------------------------------------ //\n// The maximum exponent magnitude.\n// The limit on the value of `toExpNeg`, `toExpPos`, `minE` and `maxE`.\nvar EXP_LIMIT = 9e15, // The limit on the value of `precision`, and on the value of the first argument to\n// `toDecimalPlaces`, `toExponential`, `toFixed`, `toPrecision` and `toSignificantDigits`.\nMAX_DIGITS = 1e9, // Base conversion alphabet.\nNUMERALS = \"0123456789abcdef\", // The natural logarithm of 10 (1025 digits).\nLN10 = \"2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058\", // Pi (1025 digits).\nPI = \"3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789\", // The initial configuration properties of the Decimal constructor.\nDEFAULTS = {\n    // These values must be integers within the stated ranges (inclusive).\n    // Most of these values can be changed at run-time using the `Decimal.config` method.\n    // The maximum number of significant digits of the result of a calculation or base conversion.\n    // E.g. `Decimal.config({ precision: 20 });`\n    precision: 20,\n    // The rounding mode used when rounding to `precision`.\n    //\n    // ROUND_UP         0 Away from zero.\n    // ROUND_DOWN       1 Towards zero.\n    // ROUND_CEIL       2 Towards +Infinity.\n    // ROUND_FLOOR      3 Towards -Infinity.\n    // ROUND_HALF_UP    4 Towards nearest neighbour. If equidistant, up.\n    // ROUND_HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.\n    // ROUND_HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.\n    // ROUND_HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.\n    // ROUND_HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.\n    //\n    // E.g.\n    // `Decimal.rounding = 4;`\n    // `Decimal.rounding = Decimal.ROUND_HALF_UP;`\n    rounding: 4,\n    // The modulo mode used when calculating the modulus: a mod n.\n    // The quotient (q = a / n) is calculated according to the corresponding rounding mode.\n    // The remainder (r) is calculated as: r = a - n * q.\n    //\n    // UP         0 The remainder is positive if the dividend is negative, else is negative.\n    // DOWN       1 The remainder has the same sign as the dividend (JavaScript %).\n    // FLOOR      3 The remainder has the same sign as the divisor (Python %).\n    // HALF_EVEN  6 The IEEE 754 remainder function.\n    // EUCLID     9 Euclidian division. q = sign(n) * floor(a / abs(n)). Always positive.\n    //\n    // Truncated division (1), floored division (3), the IEEE 754 remainder (6), and Euclidian\n    // division (9) are commonly used for the modulus operation. The other rounding modes can also\n    // be used, but they may not give useful results.\n    modulo: 1,\n    // The exponent value at and beneath which `toString` returns exponential notation.\n    // JavaScript numbers: -7\n    toExpNeg: -7,\n    // The exponent value at and above which `toString` returns exponential notation.\n    // JavaScript numbers: 21\n    toExpPos: 21,\n    // The minimum exponent value, beneath which underflow to zero occurs.\n    // JavaScript numbers: -324  (5e-324)\n    minE: -EXP_LIMIT,\n    // The maximum exponent value, above which overflow to Infinity occurs.\n    // JavaScript numbers: 308  (1.7976931348623157e+308)\n    maxE: EXP_LIMIT,\n    // Whether to use cryptographically-secure random number generation, if available.\n    crypto: false // true/false\n}, // ----------------------------------- END OF EDITABLE DEFAULTS ------------------------------- //\ninexact, quadrant, external = true, decimalError = \"[DecimalError] \", invalidArgument = decimalError + \"Invalid argument: \", precisionLimitExceeded = decimalError + \"Precision limit exceeded\", cryptoUnavailable = decimalError + \"crypto unavailable\", tag = \"[object Decimal]\", mathfloor = Math.floor, mathpow = Math.pow, isBinary = /^0b([01]+(\\.[01]*)?|\\.[01]+)(p[+-]?\\d+)?$/i, isHex = /^0x([0-9a-f]+(\\.[0-9a-f]*)?|\\.[0-9a-f]+)(p[+-]?\\d+)?$/i, isOctal = /^0o([0-7]+(\\.[0-7]*)?|\\.[0-7]+)(p[+-]?\\d+)?$/i, isDecimal = /^(\\d+(\\.\\d*)?|\\.\\d+)(e[+-]?\\d+)?$/i, BASE = 1e7, LOG_BASE = 7, MAX_SAFE_INTEGER = 9007199254740991, LN10_PRECISION = LN10.length - 1, PI_PRECISION = PI.length - 1, // Decimal.prototype object\nP = {\n    toStringTag: tag\n};\n// Decimal prototype methods\n/*\r\n *  absoluteValue             abs\r\n *  ceil\r\n *  clampedTo                 clamp\r\n *  comparedTo                cmp\r\n *  cosine                    cos\r\n *  cubeRoot                  cbrt\r\n *  decimalPlaces             dp\r\n *  dividedBy                 div\r\n *  dividedToIntegerBy        divToInt\r\n *  equals                    eq\r\n *  floor\r\n *  greaterThan               gt\r\n *  greaterThanOrEqualTo      gte\r\n *  hyperbolicCosine          cosh\r\n *  hyperbolicSine            sinh\r\n *  hyperbolicTangent         tanh\r\n *  inverseCosine             acos\r\n *  inverseHyperbolicCosine   acosh\r\n *  inverseHyperbolicSine     asinh\r\n *  inverseHyperbolicTangent  atanh\r\n *  inverseSine               asin\r\n *  inverseTangent            atan\r\n *  isFinite\r\n *  isInteger                 isInt\r\n *  isNaN\r\n *  isNegative                isNeg\r\n *  isPositive                isPos\r\n *  isZero\r\n *  lessThan                  lt\r\n *  lessThanOrEqualTo         lte\r\n *  logarithm                 log\r\n *  [maximum]                 [max]\r\n *  [minimum]                 [min]\r\n *  minus                     sub\r\n *  modulo                    mod\r\n *  naturalExponential        exp\r\n *  naturalLogarithm          ln\r\n *  negated                   neg\r\n *  plus                      add\r\n *  precision                 sd\r\n *  round\r\n *  sine                      sin\r\n *  squareRoot                sqrt\r\n *  tangent                   tan\r\n *  times                     mul\r\n *  toBinary\r\n *  toDecimalPlaces           toDP\r\n *  toExponential\r\n *  toFixed\r\n *  toFraction\r\n *  toHexadecimal             toHex\r\n *  toNearest\r\n *  toNumber\r\n *  toOctal\r\n *  toPower                   pow\r\n *  toPrecision\r\n *  toSignificantDigits       toSD\r\n *  toString\r\n *  truncated                 trunc\r\n *  valueOf                   toJSON\r\n */ /*\r\n * Return a new Decimal whose value is the absolute value of this Decimal.\r\n *\r\n */ P.absoluteValue = P.abs = function() {\n    var x = new this.constructor(this);\n    if (x.s < 0) x.s = 1;\n    return finalise(x);\n};\n/*\r\n * Return a new Decimal whose value is the value of this Decimal rounded to a whole number in the\r\n * direction of positive Infinity.\r\n *\r\n */ P.ceil = function() {\n    return finalise(new this.constructor(this), this.e + 1, 2);\n};\n/*\r\n * Return a new Decimal whose value is the value of this Decimal clamped to the range\r\n * delineated by `min` and `max`.\r\n *\r\n * min {number|string|Decimal}\r\n * max {number|string|Decimal}\r\n *\r\n */ P.clampedTo = P.clamp = function(min, max) {\n    var k, x = this, Ctor = x.constructor;\n    min = new Ctor(min);\n    max = new Ctor(max);\n    if (!min.s || !max.s) return new Ctor(NaN);\n    if (min.gt(max)) throw Error(invalidArgument + max);\n    k = x.cmp(min);\n    return k < 0 ? min : x.cmp(max) > 0 ? max : new Ctor(x);\n};\n/*\r\n * Return\r\n *   1    if the value of this Decimal is greater than the value of `y`,\r\n *  -1    if the value of this Decimal is less than the value of `y`,\r\n *   0    if they have the same value,\r\n *   NaN  if the value of either Decimal is NaN.\r\n *\r\n */ P.comparedTo = P.cmp = function(y) {\n    var i, j, xdL, ydL, x = this, xd = x.d, yd = (y = new x.constructor(y)).d, xs = x.s, ys = y.s;\n    // Either NaN or ±Infinity?\n    if (!xd || !yd) {\n        return !xs || !ys ? NaN : xs !== ys ? xs : xd === yd ? 0 : !xd ^ xs < 0 ? 1 : -1;\n    }\n    // Either zero?\n    if (!xd[0] || !yd[0]) return xd[0] ? xs : yd[0] ? -ys : 0;\n    // Signs differ?\n    if (xs !== ys) return xs;\n    // Compare exponents.\n    if (x.e !== y.e) return x.e > y.e ^ xs < 0 ? 1 : -1;\n    xdL = xd.length;\n    ydL = yd.length;\n    // Compare digit by digit.\n    for(i = 0, j = xdL < ydL ? xdL : ydL; i < j; ++i){\n        if (xd[i] !== yd[i]) return xd[i] > yd[i] ^ xs < 0 ? 1 : -1;\n    }\n    // Compare lengths.\n    return xdL === ydL ? 0 : xdL > ydL ^ xs < 0 ? 1 : -1;\n};\n/*\r\n * Return a new Decimal whose value is the cosine of the value in radians of this Decimal.\r\n *\r\n * Domain: [-Infinity, Infinity]\r\n * Range: [-1, 1]\r\n *\r\n * cos(0)         = 1\r\n * cos(-0)        = 1\r\n * cos(Infinity)  = NaN\r\n * cos(-Infinity) = NaN\r\n * cos(NaN)       = NaN\r\n *\r\n */ P.cosine = P.cos = function() {\n    var pr, rm, x = this, Ctor = x.constructor;\n    if (!x.d) return new Ctor(NaN);\n    // cos(0) = cos(-0) = 1\n    if (!x.d[0]) return new Ctor(1);\n    pr = Ctor.precision;\n    rm = Ctor.rounding;\n    Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;\n    Ctor.rounding = 1;\n    x = cosine(Ctor, toLessThanHalfPi(Ctor, x));\n    Ctor.precision = pr;\n    Ctor.rounding = rm;\n    return finalise(quadrant == 2 || quadrant == 3 ? x.neg() : x, pr, rm, true);\n};\n/*\r\n *\r\n * Return a new Decimal whose value is the cube root of the value of this Decimal, rounded to\r\n * `precision` significant digits using rounding mode `rounding`.\r\n *\r\n *  cbrt(0)  =  0\r\n *  cbrt(-0) = -0\r\n *  cbrt(1)  =  1\r\n *  cbrt(-1) = -1\r\n *  cbrt(N)  =  N\r\n *  cbrt(-I) = -I\r\n *  cbrt(I)  =  I\r\n *\r\n * Math.cbrt(x) = (x < 0 ? -Math.pow(-x, 1/3) : Math.pow(x, 1/3))\r\n *\r\n */ P.cubeRoot = P.cbrt = function() {\n    var e, m, n, r, rep, s, sd, t, t3, t3plusx, x = this, Ctor = x.constructor;\n    if (!x.isFinite() || x.isZero()) return new Ctor(x);\n    external = false;\n    // Initial estimate.\n    s = x.s * mathpow(x.s * x, 1 / 3);\n    // Math.cbrt underflow/overflow?\n    // Pass x to Math.pow as integer, then adjust the exponent of the result.\n    if (!s || Math.abs(s) == 1 / 0) {\n        n = digitsToString(x.d);\n        e = x.e;\n        // Adjust n exponent so it is a multiple of 3 away from x exponent.\n        if (s = (e - n.length + 1) % 3) n += s == 1 || s == -2 ? \"0\" : \"00\";\n        s = mathpow(n, 1 / 3);\n        // Rarely, e may be one less than the result exponent value.\n        e = mathfloor((e + 1) / 3) - (e % 3 == (e < 0 ? -1 : 2));\n        if (s == 1 / 0) {\n            n = \"5e\" + e;\n        } else {\n            n = s.toExponential();\n            n = n.slice(0, n.indexOf(\"e\") + 1) + e;\n        }\n        r = new Ctor(n);\n        r.s = x.s;\n    } else {\n        r = new Ctor(s.toString());\n    }\n    sd = (e = Ctor.precision) + 3;\n    // Halley's method.\n    // TODO? Compare Newton's method.\n    for(;;){\n        t = r;\n        t3 = t.times(t).times(t);\n        t3plusx = t3.plus(x);\n        r = divide(t3plusx.plus(x).times(t), t3plusx.plus(t3), sd + 2, 1);\n        // TODO? Replace with for-loop and checkRoundingDigits.\n        if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {\n            n = n.slice(sd - 3, sd + 1);\n            // The 4th rounding digit may be in error by -1 so if the 4 rounding digits are 9999 or 4999\n            // , i.e. approaching a rounding boundary, continue the iteration.\n            if (n == \"9999\" || !rep && n == \"4999\") {\n                // On the first iteration only, check to see if rounding up gives the exact result as the\n                // nines may infinitely repeat.\n                if (!rep) {\n                    finalise(t, e + 1, 0);\n                    if (t.times(t).times(t).eq(x)) {\n                        r = t;\n                        break;\n                    }\n                }\n                sd += 4;\n                rep = 1;\n            } else {\n                // If the rounding digits are null, 0{0,4} or 50{0,3}, check for an exact result.\n                // If not, then there are further digits and m will be truthy.\n                if (!+n || !+n.slice(1) && n.charAt(0) == \"5\") {\n                    // Truncate to the first rounding digit.\n                    finalise(r, e + 1, 1);\n                    m = !r.times(r).times(r).eq(x);\n                }\n                break;\n            }\n        }\n    }\n    external = true;\n    return finalise(r, e, Ctor.rounding, m);\n};\n/*\r\n * Return the number of decimal places of the value of this Decimal.\r\n *\r\n */ P.decimalPlaces = P.dp = function() {\n    var w, d = this.d, n = NaN;\n    if (d) {\n        w = d.length - 1;\n        n = (w - mathfloor(this.e / LOG_BASE)) * LOG_BASE;\n        // Subtract the number of trailing zeros of the last word.\n        w = d[w];\n        if (w) for(; w % 10 == 0; w /= 10)n--;\n        if (n < 0) n = 0;\n    }\n    return n;\n};\n/*\r\n *  n / 0 = I\r\n *  n / N = N\r\n *  n / I = 0\r\n *  0 / n = 0\r\n *  0 / 0 = N\r\n *  0 / N = N\r\n *  0 / I = 0\r\n *  N / n = N\r\n *  N / 0 = N\r\n *  N / N = N\r\n *  N / I = N\r\n *  I / n = I\r\n *  I / 0 = I\r\n *  I / N = N\r\n *  I / I = N\r\n *\r\n * Return a new Decimal whose value is the value of this Decimal divided by `y`, rounded to\r\n * `precision` significant digits using rounding mode `rounding`.\r\n *\r\n */ P.dividedBy = P.div = function(y) {\n    return divide(this, new this.constructor(y));\n};\n/*\r\n * Return a new Decimal whose value is the integer part of dividing the value of this Decimal\r\n * by the value of `y`, rounded to `precision` significant digits using rounding mode `rounding`.\r\n *\r\n */ P.dividedToIntegerBy = P.divToInt = function(y) {\n    var x = this, Ctor = x.constructor;\n    return finalise(divide(x, new Ctor(y), 0, 1, 1), Ctor.precision, Ctor.rounding);\n};\n/*\r\n * Return true if the value of this Decimal is equal to the value of `y`, otherwise return false.\r\n *\r\n */ P.equals = P.eq = function(y) {\n    return this.cmp(y) === 0;\n};\n/*\r\n * Return a new Decimal whose value is the value of this Decimal rounded to a whole number in the\r\n * direction of negative Infinity.\r\n *\r\n */ P.floor = function() {\n    return finalise(new this.constructor(this), this.e + 1, 3);\n};\n/*\r\n * Return true if the value of this Decimal is greater than the value of `y`, otherwise return\r\n * false.\r\n *\r\n */ P.greaterThan = P.gt = function(y) {\n    return this.cmp(y) > 0;\n};\n/*\r\n * Return true if the value of this Decimal is greater than or equal to the value of `y`,\r\n * otherwise return false.\r\n *\r\n */ P.greaterThanOrEqualTo = P.gte = function(y) {\n    var k = this.cmp(y);\n    return k == 1 || k === 0;\n};\n/*\r\n * Return a new Decimal whose value is the hyperbolic cosine of the value in radians of this\r\n * Decimal.\r\n *\r\n * Domain: [-Infinity, Infinity]\r\n * Range: [1, Infinity]\r\n *\r\n * cosh(x) = 1 + x^2/2! + x^4/4! + x^6/6! + ...\r\n *\r\n * cosh(0)         = 1\r\n * cosh(-0)        = 1\r\n * cosh(Infinity)  = Infinity\r\n * cosh(-Infinity) = Infinity\r\n * cosh(NaN)       = NaN\r\n *\r\n *  x        time taken (ms)   result\r\n * 1000      9                 9.8503555700852349694e+433\r\n * 10000     25                4.4034091128314607936e+4342\r\n * 100000    171               1.4033316802130615897e+43429\r\n * 1000000   3817              1.5166076984010437725e+434294\r\n * 10000000  abandoned after 2 minute wait\r\n *\r\n * TODO? Compare performance of cosh(x) = 0.5 * (exp(x) + exp(-x))\r\n *\r\n */ P.hyperbolicCosine = P.cosh = function() {\n    var k, n, pr, rm, len, x = this, Ctor = x.constructor, one = new Ctor(1);\n    if (!x.isFinite()) return new Ctor(x.s ? 1 / 0 : NaN);\n    if (x.isZero()) return one;\n    pr = Ctor.precision;\n    rm = Ctor.rounding;\n    Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;\n    Ctor.rounding = 1;\n    len = x.d.length;\n    // Argument reduction: cos(4x) = 1 - 8cos^2(x) + 8cos^4(x) + 1\n    // i.e. cos(x) = 1 - cos^2(x/4)(8 - 8cos^2(x/4))\n    // Estimate the optimum number of times to use the argument reduction.\n    // TODO? Estimation reused from cosine() and may not be optimal here.\n    if (len < 32) {\n        k = Math.ceil(len / 3);\n        n = (1 / tinyPow(4, k)).toString();\n    } else {\n        k = 16;\n        n = \"2.3283064365386962890625e-10\";\n    }\n    x = taylorSeries(Ctor, 1, x.times(n), new Ctor(1), true);\n    // Reverse argument reduction\n    var cosh2_x, i = k, d8 = new Ctor(8);\n    for(; i--;){\n        cosh2_x = x.times(x);\n        x = one.minus(cosh2_x.times(d8.minus(cosh2_x.times(d8))));\n    }\n    return finalise(x, Ctor.precision = pr, Ctor.rounding = rm, true);\n};\n/*\r\n * Return a new Decimal whose value is the hyperbolic sine of the value in radians of this\r\n * Decimal.\r\n *\r\n * Domain: [-Infinity, Infinity]\r\n * Range: [-Infinity, Infinity]\r\n *\r\n * sinh(x) = x + x^3/3! + x^5/5! + x^7/7! + ...\r\n *\r\n * sinh(0)         = 0\r\n * sinh(-0)        = -0\r\n * sinh(Infinity)  = Infinity\r\n * sinh(-Infinity) = -Infinity\r\n * sinh(NaN)       = NaN\r\n *\r\n * x        time taken (ms)\r\n * 10       2 ms\r\n * 100      5 ms\r\n * 1000     14 ms\r\n * 10000    82 ms\r\n * 100000   886 ms            1.4033316802130615897e+43429\r\n * 200000   2613 ms\r\n * 300000   5407 ms\r\n * 400000   8824 ms\r\n * 500000   13026 ms          8.7080643612718084129e+217146\r\n * 1000000  48543 ms\r\n *\r\n * TODO? Compare performance of sinh(x) = 0.5 * (exp(x) - exp(-x))\r\n *\r\n */ P.hyperbolicSine = P.sinh = function() {\n    var k, pr, rm, len, x = this, Ctor = x.constructor;\n    if (!x.isFinite() || x.isZero()) return new Ctor(x);\n    pr = Ctor.precision;\n    rm = Ctor.rounding;\n    Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;\n    Ctor.rounding = 1;\n    len = x.d.length;\n    if (len < 3) {\n        x = taylorSeries(Ctor, 2, x, x, true);\n    } else {\n        // Alternative argument reduction: sinh(3x) = sinh(x)(3 + 4sinh^2(x))\n        // i.e. sinh(x) = sinh(x/3)(3 + 4sinh^2(x/3))\n        // 3 multiplications and 1 addition\n        // Argument reduction: sinh(5x) = sinh(x)(5 + sinh^2(x)(20 + 16sinh^2(x)))\n        // i.e. sinh(x) = sinh(x/5)(5 + sinh^2(x/5)(20 + 16sinh^2(x/5)))\n        // 4 multiplications and 2 additions\n        // Estimate the optimum number of times to use the argument reduction.\n        k = 1.4 * Math.sqrt(len);\n        k = k > 16 ? 16 : k | 0;\n        x = x.times(1 / tinyPow(5, k));\n        x = taylorSeries(Ctor, 2, x, x, true);\n        // Reverse argument reduction\n        var sinh2_x, d5 = new Ctor(5), d16 = new Ctor(16), d20 = new Ctor(20);\n        for(; k--;){\n            sinh2_x = x.times(x);\n            x = x.times(d5.plus(sinh2_x.times(d16.times(sinh2_x).plus(d20))));\n        }\n    }\n    Ctor.precision = pr;\n    Ctor.rounding = rm;\n    return finalise(x, pr, rm, true);\n};\n/*\r\n * Return a new Decimal whose value is the hyperbolic tangent of the value in radians of this\r\n * Decimal.\r\n *\r\n * Domain: [-Infinity, Infinity]\r\n * Range: [-1, 1]\r\n *\r\n * tanh(x) = sinh(x) / cosh(x)\r\n *\r\n * tanh(0)         = 0\r\n * tanh(-0)        = -0\r\n * tanh(Infinity)  = 1\r\n * tanh(-Infinity) = -1\r\n * tanh(NaN)       = NaN\r\n *\r\n */ P.hyperbolicTangent = P.tanh = function() {\n    var pr, rm, x = this, Ctor = x.constructor;\n    if (!x.isFinite()) return new Ctor(x.s);\n    if (x.isZero()) return new Ctor(x);\n    pr = Ctor.precision;\n    rm = Ctor.rounding;\n    Ctor.precision = pr + 7;\n    Ctor.rounding = 1;\n    return divide(x.sinh(), x.cosh(), Ctor.precision = pr, Ctor.rounding = rm);\n};\n/*\r\n * Return a new Decimal whose value is the arccosine (inverse cosine) in radians of the value of\r\n * this Decimal.\r\n *\r\n * Domain: [-1, 1]\r\n * Range: [0, pi]\r\n *\r\n * acos(x) = pi/2 - asin(x)\r\n *\r\n * acos(0)       = pi/2\r\n * acos(-0)      = pi/2\r\n * acos(1)       = 0\r\n * acos(-1)      = pi\r\n * acos(1/2)     = pi/3\r\n * acos(-1/2)    = 2*pi/3\r\n * acos(|x| > 1) = NaN\r\n * acos(NaN)     = NaN\r\n *\r\n */ P.inverseCosine = P.acos = function() {\n    var halfPi, x = this, Ctor = x.constructor, k = x.abs().cmp(1), pr = Ctor.precision, rm = Ctor.rounding;\n    if (k !== -1) {\n        return k === 0 ? x.isNeg() ? getPi(Ctor, pr, rm) : new Ctor(0) : new Ctor(NaN);\n    }\n    if (x.isZero()) return getPi(Ctor, pr + 4, rm).times(0.5);\n    // TODO? Special case acos(0.5) = pi/3 and acos(-0.5) = 2*pi/3\n    Ctor.precision = pr + 6;\n    Ctor.rounding = 1;\n    x = x.asin();\n    halfPi = getPi(Ctor, pr + 4, rm).times(0.5);\n    Ctor.precision = pr;\n    Ctor.rounding = rm;\n    return halfPi.minus(x);\n};\n/*\r\n * Return a new Decimal whose value is the inverse of the hyperbolic cosine in radians of the\r\n * value of this Decimal.\r\n *\r\n * Domain: [1, Infinity]\r\n * Range: [0, Infinity]\r\n *\r\n * acosh(x) = ln(x + sqrt(x^2 - 1))\r\n *\r\n * acosh(x < 1)     = NaN\r\n * acosh(NaN)       = NaN\r\n * acosh(Infinity)  = Infinity\r\n * acosh(-Infinity) = NaN\r\n * acosh(0)         = NaN\r\n * acosh(-0)        = NaN\r\n * acosh(1)         = 0\r\n * acosh(-1)        = NaN\r\n *\r\n */ P.inverseHyperbolicCosine = P.acosh = function() {\n    var pr, rm, x = this, Ctor = x.constructor;\n    if (x.lte(1)) return new Ctor(x.eq(1) ? 0 : NaN);\n    if (!x.isFinite()) return new Ctor(x);\n    pr = Ctor.precision;\n    rm = Ctor.rounding;\n    Ctor.precision = pr + Math.max(Math.abs(x.e), x.sd()) + 4;\n    Ctor.rounding = 1;\n    external = false;\n    x = x.times(x).minus(1).sqrt().plus(x);\n    external = true;\n    Ctor.precision = pr;\n    Ctor.rounding = rm;\n    return x.ln();\n};\n/*\r\n * Return a new Decimal whose value is the inverse of the hyperbolic sine in radians of the value\r\n * of this Decimal.\r\n *\r\n * Domain: [-Infinity, Infinity]\r\n * Range: [-Infinity, Infinity]\r\n *\r\n * asinh(x) = ln(x + sqrt(x^2 + 1))\r\n *\r\n * asinh(NaN)       = NaN\r\n * asinh(Infinity)  = Infinity\r\n * asinh(-Infinity) = -Infinity\r\n * asinh(0)         = 0\r\n * asinh(-0)        = -0\r\n *\r\n */ P.inverseHyperbolicSine = P.asinh = function() {\n    var pr, rm, x = this, Ctor = x.constructor;\n    if (!x.isFinite() || x.isZero()) return new Ctor(x);\n    pr = Ctor.precision;\n    rm = Ctor.rounding;\n    Ctor.precision = pr + 2 * Math.max(Math.abs(x.e), x.sd()) + 6;\n    Ctor.rounding = 1;\n    external = false;\n    x = x.times(x).plus(1).sqrt().plus(x);\n    external = true;\n    Ctor.precision = pr;\n    Ctor.rounding = rm;\n    return x.ln();\n};\n/*\r\n * Return a new Decimal whose value is the inverse of the hyperbolic tangent in radians of the\r\n * value of this Decimal.\r\n *\r\n * Domain: [-1, 1]\r\n * Range: [-Infinity, Infinity]\r\n *\r\n * atanh(x) = 0.5 * ln((1 + x) / (1 - x))\r\n *\r\n * atanh(|x| > 1)   = NaN\r\n * atanh(NaN)       = NaN\r\n * atanh(Infinity)  = NaN\r\n * atanh(-Infinity) = NaN\r\n * atanh(0)         = 0\r\n * atanh(-0)        = -0\r\n * atanh(1)         = Infinity\r\n * atanh(-1)        = -Infinity\r\n *\r\n */ P.inverseHyperbolicTangent = P.atanh = function() {\n    var pr, rm, wpr, xsd, x = this, Ctor = x.constructor;\n    if (!x.isFinite()) return new Ctor(NaN);\n    if (x.e >= 0) return new Ctor(x.abs().eq(1) ? x.s / 0 : x.isZero() ? x : NaN);\n    pr = Ctor.precision;\n    rm = Ctor.rounding;\n    xsd = x.sd();\n    if (Math.max(xsd, pr) < 2 * -x.e - 1) return finalise(new Ctor(x), pr, rm, true);\n    Ctor.precision = wpr = xsd - x.e;\n    x = divide(x.plus(1), new Ctor(1).minus(x), wpr + pr, 1);\n    Ctor.precision = pr + 4;\n    Ctor.rounding = 1;\n    x = x.ln();\n    Ctor.precision = pr;\n    Ctor.rounding = rm;\n    return x.times(0.5);\n};\n/*\r\n * Return a new Decimal whose value is the arcsine (inverse sine) in radians of the value of this\r\n * Decimal.\r\n *\r\n * Domain: [-Infinity, Infinity]\r\n * Range: [-pi/2, pi/2]\r\n *\r\n * asin(x) = 2*atan(x/(1 + sqrt(1 - x^2)))\r\n *\r\n * asin(0)       = 0\r\n * asin(-0)      = -0\r\n * asin(1/2)     = pi/6\r\n * asin(-1/2)    = -pi/6\r\n * asin(1)       = pi/2\r\n * asin(-1)      = -pi/2\r\n * asin(|x| > 1) = NaN\r\n * asin(NaN)     = NaN\r\n *\r\n * TODO? Compare performance of Taylor series.\r\n *\r\n */ P.inverseSine = P.asin = function() {\n    var halfPi, k, pr, rm, x = this, Ctor = x.constructor;\n    if (x.isZero()) return new Ctor(x);\n    k = x.abs().cmp(1);\n    pr = Ctor.precision;\n    rm = Ctor.rounding;\n    if (k !== -1) {\n        // |x| is 1\n        if (k === 0) {\n            halfPi = getPi(Ctor, pr + 4, rm).times(0.5);\n            halfPi.s = x.s;\n            return halfPi;\n        }\n        // |x| > 1 or x is NaN\n        return new Ctor(NaN);\n    }\n    // TODO? Special case asin(1/2) = pi/6 and asin(-1/2) = -pi/6\n    Ctor.precision = pr + 6;\n    Ctor.rounding = 1;\n    x = x.div(new Ctor(1).minus(x.times(x)).sqrt().plus(1)).atan();\n    Ctor.precision = pr;\n    Ctor.rounding = rm;\n    return x.times(2);\n};\n/*\r\n * Return a new Decimal whose value is the arctangent (inverse tangent) in radians of the value\r\n * of this Decimal.\r\n *\r\n * Domain: [-Infinity, Infinity]\r\n * Range: [-pi/2, pi/2]\r\n *\r\n * atan(x) = x - x^3/3 + x^5/5 - x^7/7 + ...\r\n *\r\n * atan(0)         = 0\r\n * atan(-0)        = -0\r\n * atan(1)         = pi/4\r\n * atan(-1)        = -pi/4\r\n * atan(Infinity)  = pi/2\r\n * atan(-Infinity) = -pi/2\r\n * atan(NaN)       = NaN\r\n *\r\n */ P.inverseTangent = P.atan = function() {\n    var i, j, k, n, px, t, r, wpr, x2, x = this, Ctor = x.constructor, pr = Ctor.precision, rm = Ctor.rounding;\n    if (!x.isFinite()) {\n        if (!x.s) return new Ctor(NaN);\n        if (pr + 4 <= PI_PRECISION) {\n            r = getPi(Ctor, pr + 4, rm).times(0.5);\n            r.s = x.s;\n            return r;\n        }\n    } else if (x.isZero()) {\n        return new Ctor(x);\n    } else if (x.abs().eq(1) && pr + 4 <= PI_PRECISION) {\n        r = getPi(Ctor, pr + 4, rm).times(0.25);\n        r.s = x.s;\n        return r;\n    }\n    Ctor.precision = wpr = pr + 10;\n    Ctor.rounding = 1;\n    // TODO? if (x >= 1 && pr <= PI_PRECISION) atan(x) = halfPi * x.s - atan(1 / x);\n    // Argument reduction\n    // Ensure |x| < 0.42\n    // atan(x) = 2 * atan(x / (1 + sqrt(1 + x^2)))\n    k = Math.min(28, wpr / LOG_BASE + 2 | 0);\n    for(i = k; i; --i)x = x.div(x.times(x).plus(1).sqrt().plus(1));\n    external = false;\n    j = Math.ceil(wpr / LOG_BASE);\n    n = 1;\n    x2 = x.times(x);\n    r = new Ctor(x);\n    px = x;\n    // atan(x) = x - x^3/3 + x^5/5 - x^7/7 + ...\n    for(; i !== -1;){\n        px = px.times(x2);\n        t = r.minus(px.div(n += 2));\n        px = px.times(x2);\n        r = t.plus(px.div(n += 2));\n        if (r.d[j] !== void 0) for(i = j; r.d[i] === t.d[i] && i--;);\n    }\n    if (k) r = r.times(2 << k - 1);\n    external = true;\n    return finalise(r, Ctor.precision = pr, Ctor.rounding = rm, true);\n};\n/*\r\n * Return true if the value of this Decimal is a finite number, otherwise return false.\r\n *\r\n */ P.isFinite = function() {\n    return !!this.d;\n};\n/*\r\n * Return true if the value of this Decimal is an integer, otherwise return false.\r\n *\r\n */ P.isInteger = P.isInt = function() {\n    return !!this.d && mathfloor(this.e / LOG_BASE) > this.d.length - 2;\n};\n/*\r\n * Return true if the value of this Decimal is NaN, otherwise return false.\r\n *\r\n */ P.isNaN = function() {\n    return !this.s;\n};\n/*\r\n * Return true if the value of this Decimal is negative, otherwise return false.\r\n *\r\n */ P.isNegative = P.isNeg = function() {\n    return this.s < 0;\n};\n/*\r\n * Return true if the value of this Decimal is positive, otherwise return false.\r\n *\r\n */ P.isPositive = P.isPos = function() {\n    return this.s > 0;\n};\n/*\r\n * Return true if the value of this Decimal is 0 or -0, otherwise return false.\r\n *\r\n */ P.isZero = function() {\n    return !!this.d && this.d[0] === 0;\n};\n/*\r\n * Return true if the value of this Decimal is less than `y`, otherwise return false.\r\n *\r\n */ P.lessThan = P.lt = function(y) {\n    return this.cmp(y) < 0;\n};\n/*\r\n * Return true if the value of this Decimal is less than or equal to `y`, otherwise return false.\r\n *\r\n */ P.lessThanOrEqualTo = P.lte = function(y) {\n    return this.cmp(y) < 1;\n};\n/*\r\n * Return the logarithm of the value of this Decimal to the specified base, rounded to `precision`\r\n * significant digits using rounding mode `rounding`.\r\n *\r\n * If no base is specified, return log[10](arg).\r\n *\r\n * log[base](arg) = ln(arg) / ln(base)\r\n *\r\n * The result will always be correctly rounded if the base of the log is 10, and 'almost always'\r\n * otherwise:\r\n *\r\n * Depending on the rounding mode, the result may be incorrectly rounded if the first fifteen\r\n * rounding digits are [49]99999999999999 or [50]00000000000000. In that case, the maximum error\r\n * between the result and the correctly rounded result will be one ulp (unit in the last place).\r\n *\r\n * log[-b](a)       = NaN\r\n * log[0](a)        = NaN\r\n * log[1](a)        = NaN\r\n * log[NaN](a)      = NaN\r\n * log[Infinity](a) = NaN\r\n * log[b](0)        = -Infinity\r\n * log[b](-0)       = -Infinity\r\n * log[b](-a)       = NaN\r\n * log[b](1)        = 0\r\n * log[b](Infinity) = Infinity\r\n * log[b](NaN)      = NaN\r\n *\r\n * [base] {number|string|Decimal} The base of the logarithm.\r\n *\r\n */ P.logarithm = P.log = function(base) {\n    var isBase10, d, denominator, k, inf, num, sd, r, arg = this, Ctor = arg.constructor, pr = Ctor.precision, rm = Ctor.rounding, guard = 5;\n    // Default base is 10.\n    if (base == null) {\n        base = new Ctor(10);\n        isBase10 = true;\n    } else {\n        base = new Ctor(base);\n        d = base.d;\n        // Return NaN if base is negative, or non-finite, or is 0 or 1.\n        if (base.s < 0 || !d || !d[0] || base.eq(1)) return new Ctor(NaN);\n        isBase10 = base.eq(10);\n    }\n    d = arg.d;\n    // Is arg negative, non-finite, 0 or 1?\n    if (arg.s < 0 || !d || !d[0] || arg.eq(1)) {\n        return new Ctor(d && !d[0] ? -1 / 0 : arg.s != 1 ? NaN : d ? 0 : 1 / 0);\n    }\n    // The result will have a non-terminating decimal expansion if base is 10 and arg is not an\n    // integer power of 10.\n    if (isBase10) {\n        if (d.length > 1) {\n            inf = true;\n        } else {\n            for(k = d[0]; k % 10 === 0;)k /= 10;\n            inf = k !== 1;\n        }\n    }\n    external = false;\n    sd = pr + guard;\n    num = naturalLogarithm(arg, sd);\n    denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);\n    // The result will have 5 rounding digits.\n    r = divide(num, denominator, sd, 1);\n    // If at a rounding boundary, i.e. the result's rounding digits are [49]9999 or [50]0000,\n    // calculate 10 further digits.\n    //\n    // If the result is known to have an infinite decimal expansion, repeat this until it is clear\n    // that the result is above or below the boundary. Otherwise, if after calculating the 10\n    // further digits, the last 14 are nines, round up and assume the result is exact.\n    // Also assume the result is exact if the last 14 are zero.\n    //\n    // Example of a result that will be incorrectly rounded:\n    // log[1048576](4503599627370502) = 2.60000000000000009610279511444746...\n    // The above result correctly rounded using ROUND_CEIL to 1 decimal place should be 2.7, but it\n    // will be given as 2.6 as there are 15 zeros immediately after the requested decimal place, so\n    // the exact result would be assumed to be 2.6, which rounded using ROUND_CEIL to 1 decimal\n    // place is still 2.6.\n    if (checkRoundingDigits(r.d, k = pr, rm)) {\n        do {\n            sd += 10;\n            num = naturalLogarithm(arg, sd);\n            denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);\n            r = divide(num, denominator, sd, 1);\n            if (!inf) {\n                // Check for 14 nines from the 2nd rounding digit, as the first may be 4.\n                if (+digitsToString(r.d).slice(k + 1, k + 15) + 1 == 1e14) {\n                    r = finalise(r, pr + 1, 0);\n                }\n                break;\n            }\n        }while (checkRoundingDigits(r.d, k += 10, rm));\n    }\n    external = true;\n    return finalise(r, pr, rm);\n};\n/*\r\n * Return a new Decimal whose value is the maximum of the arguments and the value of this Decimal.\r\n *\r\n * arguments {number|string|Decimal}\r\n *\r\nP.max = function () {\r\n  Array.prototype.push.call(arguments, this);\r\n  return maxOrMin(this.constructor, arguments, 'lt');\r\n};\r\n */ /*\r\n * Return a new Decimal whose value is the minimum of the arguments and the value of this Decimal.\r\n *\r\n * arguments {number|string|Decimal}\r\n *\r\nP.min = function () {\r\n  Array.prototype.push.call(arguments, this);\r\n  return maxOrMin(this.constructor, arguments, 'gt');\r\n};\r\n */ /*\r\n *  n - 0 = n\r\n *  n - N = N\r\n *  n - I = -I\r\n *  0 - n = -n\r\n *  0 - 0 = 0\r\n *  0 - N = N\r\n *  0 - I = -I\r\n *  N - n = N\r\n *  N - 0 = N\r\n *  N - N = N\r\n *  N - I = N\r\n *  I - n = I\r\n *  I - 0 = I\r\n *  I - N = N\r\n *  I - I = N\r\n *\r\n * Return a new Decimal whose value is the value of this Decimal minus `y`, rounded to `precision`\r\n * significant digits using rounding mode `rounding`.\r\n *\r\n */ P.minus = P.sub = function(y) {\n    var d, e, i, j, k, len, pr, rm, xd, xe, xLTy, yd, x = this, Ctor = x.constructor;\n    y = new Ctor(y);\n    // If either is not finite...\n    if (!x.d || !y.d) {\n        // Return NaN if either is NaN.\n        if (!x.s || !y.s) y = new Ctor(NaN);\n        else if (x.d) y.s = -y.s;\n        else y = new Ctor(y.d || x.s !== y.s ? x : NaN);\n        return y;\n    }\n    // If signs differ...\n    if (x.s != y.s) {\n        y.s = -y.s;\n        return x.plus(y);\n    }\n    xd = x.d;\n    yd = y.d;\n    pr = Ctor.precision;\n    rm = Ctor.rounding;\n    // If either is zero...\n    if (!xd[0] || !yd[0]) {\n        // Return y negated if x is zero and y is non-zero.\n        if (yd[0]) y.s = -y.s;\n        else if (xd[0]) y = new Ctor(x);\n        else return new Ctor(rm === 3 ? -0 : 0);\n        return external ? finalise(y, pr, rm) : y;\n    }\n    // x and y are finite, non-zero numbers with the same sign.\n    // Calculate base 1e7 exponents.\n    e = mathfloor(y.e / LOG_BASE);\n    xe = mathfloor(x.e / LOG_BASE);\n    xd = xd.slice();\n    k = xe - e;\n    // If base 1e7 exponents differ...\n    if (k) {\n        xLTy = k < 0;\n        if (xLTy) {\n            d = xd;\n            k = -k;\n            len = yd.length;\n        } else {\n            d = yd;\n            e = xe;\n            len = xd.length;\n        }\n        // Numbers with massively different exponents would result in a very high number of\n        // zeros needing to be prepended, but this can be avoided while still ensuring correct\n        // rounding by limiting the number of zeros to `Math.ceil(pr / LOG_BASE) + 2`.\n        i = Math.max(Math.ceil(pr / LOG_BASE), len) + 2;\n        if (k > i) {\n            k = i;\n            d.length = 1;\n        }\n        // Prepend zeros to equalise exponents.\n        d.reverse();\n        for(i = k; i--;)d.push(0);\n        d.reverse();\n    // Base 1e7 exponents equal.\n    } else {\n        // Check digits to determine which is the bigger number.\n        i = xd.length;\n        len = yd.length;\n        xLTy = i < len;\n        if (xLTy) len = i;\n        for(i = 0; i < len; i++){\n            if (xd[i] != yd[i]) {\n                xLTy = xd[i] < yd[i];\n                break;\n            }\n        }\n        k = 0;\n    }\n    if (xLTy) {\n        d = xd;\n        xd = yd;\n        yd = d;\n        y.s = -y.s;\n    }\n    len = xd.length;\n    // Append zeros to `xd` if shorter.\n    // Don't add zeros to `yd` if shorter as subtraction only needs to start at `yd` length.\n    for(i = yd.length - len; i > 0; --i)xd[len++] = 0;\n    // Subtract yd from xd.\n    for(i = yd.length; i > k;){\n        if (xd[--i] < yd[i]) {\n            for(j = i; j && xd[--j] === 0;)xd[j] = BASE - 1;\n            --xd[j];\n            xd[i] += BASE;\n        }\n        xd[i] -= yd[i];\n    }\n    // Remove trailing zeros.\n    for(; xd[--len] === 0;)xd.pop();\n    // Remove leading zeros and adjust exponent accordingly.\n    for(; xd[0] === 0; xd.shift())--e;\n    // Zero?\n    if (!xd[0]) return new Ctor(rm === 3 ? -0 : 0);\n    y.d = xd;\n    y.e = getBase10Exponent(xd, e);\n    return external ? finalise(y, pr, rm) : y;\n};\n/*\r\n *   n % 0 =  N\r\n *   n % N =  N\r\n *   n % I =  n\r\n *   0 % n =  0\r\n *  -0 % n = -0\r\n *   0 % 0 =  N\r\n *   0 % N =  N\r\n *   0 % I =  0\r\n *   N % n =  N\r\n *   N % 0 =  N\r\n *   N % N =  N\r\n *   N % I =  N\r\n *   I % n =  N\r\n *   I % 0 =  N\r\n *   I % N =  N\r\n *   I % I =  N\r\n *\r\n * Return a new Decimal whose value is the value of this Decimal modulo `y`, rounded to\r\n * `precision` significant digits using rounding mode `rounding`.\r\n *\r\n * The result depends on the modulo mode.\r\n *\r\n */ P.modulo = P.mod = function(y) {\n    var q, x = this, Ctor = x.constructor;\n    y = new Ctor(y);\n    // Return NaN if x is ±Infinity or NaN, or y is NaN or ±0.\n    if (!x.d || !y.s || y.d && !y.d[0]) return new Ctor(NaN);\n    // Return x if y is ±Infinity or x is ±0.\n    if (!y.d || x.d && !x.d[0]) {\n        return finalise(new Ctor(x), Ctor.precision, Ctor.rounding);\n    }\n    // Prevent rounding of intermediate calculations.\n    external = false;\n    if (Ctor.modulo == 9) {\n        // Euclidian division: q = sign(y) * floor(x / abs(y))\n        // result = x - q * y    where  0 <= result < abs(y)\n        q = divide(x, y.abs(), 0, 3, 1);\n        q.s *= y.s;\n    } else {\n        q = divide(x, y, 0, Ctor.modulo, 1);\n    }\n    q = q.times(y);\n    external = true;\n    return x.minus(q);\n};\n/*\r\n * Return a new Decimal whose value is the natural exponential of the value of this Decimal,\r\n * i.e. the base e raised to the power the value of this Decimal, rounded to `precision`\r\n * significant digits using rounding mode `rounding`.\r\n *\r\n */ P.naturalExponential = P.exp = function() {\n    return naturalExponential(this);\n};\n/*\r\n * Return a new Decimal whose value is the natural logarithm of the value of this Decimal,\r\n * rounded to `precision` significant digits using rounding mode `rounding`.\r\n *\r\n */ P.naturalLogarithm = P.ln = function() {\n    return naturalLogarithm(this);\n};\n/*\r\n * Return a new Decimal whose value is the value of this Decimal negated, i.e. as if multiplied by\r\n * -1.\r\n *\r\n */ P.negated = P.neg = function() {\n    var x = new this.constructor(this);\n    x.s = -x.s;\n    return finalise(x);\n};\n/*\r\n *  n + 0 = n\r\n *  n + N = N\r\n *  n + I = I\r\n *  0 + n = n\r\n *  0 + 0 = 0\r\n *  0 + N = N\r\n *  0 + I = I\r\n *  N + n = N\r\n *  N + 0 = N\r\n *  N + N = N\r\n *  N + I = N\r\n *  I + n = I\r\n *  I + 0 = I\r\n *  I + N = N\r\n *  I + I = I\r\n *\r\n * Return a new Decimal whose value is the value of this Decimal plus `y`, rounded to `precision`\r\n * significant digits using rounding mode `rounding`.\r\n *\r\n */ P.plus = P.add = function(y) {\n    var carry, d, e, i, k, len, pr, rm, xd, yd, x = this, Ctor = x.constructor;\n    y = new Ctor(y);\n    // If either is not finite...\n    if (!x.d || !y.d) {\n        // Return NaN if either is NaN.\n        if (!x.s || !y.s) y = new Ctor(NaN);\n        else if (!x.d) y = new Ctor(y.d || x.s === y.s ? x : NaN);\n        return y;\n    }\n    // If signs differ...\n    if (x.s != y.s) {\n        y.s = -y.s;\n        return x.minus(y);\n    }\n    xd = x.d;\n    yd = y.d;\n    pr = Ctor.precision;\n    rm = Ctor.rounding;\n    // If either is zero...\n    if (!xd[0] || !yd[0]) {\n        // Return x if y is zero.\n        // Return y if y is non-zero.\n        if (!yd[0]) y = new Ctor(x);\n        return external ? finalise(y, pr, rm) : y;\n    }\n    // x and y are finite, non-zero numbers with the same sign.\n    // Calculate base 1e7 exponents.\n    k = mathfloor(x.e / LOG_BASE);\n    e = mathfloor(y.e / LOG_BASE);\n    xd = xd.slice();\n    i = k - e;\n    // If base 1e7 exponents differ...\n    if (i) {\n        if (i < 0) {\n            d = xd;\n            i = -i;\n            len = yd.length;\n        } else {\n            d = yd;\n            e = k;\n            len = xd.length;\n        }\n        // Limit number of zeros prepended to max(ceil(pr / LOG_BASE), len) + 1.\n        k = Math.ceil(pr / LOG_BASE);\n        len = k > len ? k + 1 : len + 1;\n        if (i > len) {\n            i = len;\n            d.length = 1;\n        }\n        // Prepend zeros to equalise exponents. Note: Faster to use reverse then do unshifts.\n        d.reverse();\n        for(; i--;)d.push(0);\n        d.reverse();\n    }\n    len = xd.length;\n    i = yd.length;\n    // If yd is longer than xd, swap xd and yd so xd points to the longer array.\n    if (len - i < 0) {\n        i = len;\n        d = yd;\n        yd = xd;\n        xd = d;\n    }\n    // Only start adding at yd.length - 1 as the further digits of xd can be left as they are.\n    for(carry = 0; i;){\n        carry = (xd[--i] = xd[i] + yd[i] + carry) / BASE | 0;\n        xd[i] %= BASE;\n    }\n    if (carry) {\n        xd.unshift(carry);\n        ++e;\n    }\n    // Remove trailing zeros.\n    // No need to check for zero, as +x + +y != 0 && -x + -y != 0\n    for(len = xd.length; xd[--len] == 0;)xd.pop();\n    y.d = xd;\n    y.e = getBase10Exponent(xd, e);\n    return external ? finalise(y, pr, rm) : y;\n};\n/*\r\n * Return the number of significant digits of the value of this Decimal.\r\n *\r\n * [z] {boolean|number} Whether to count integer-part trailing zeros: true, false, 1 or 0.\r\n *\r\n */ P.precision = P.sd = function(z) {\n    var k, x = this;\n    if (z !== void 0 && z !== !!z && z !== 1 && z !== 0) throw Error(invalidArgument + z);\n    if (x.d) {\n        k = getPrecision(x.d);\n        if (z && x.e + 1 > k) k = x.e + 1;\n    } else {\n        k = NaN;\n    }\n    return k;\n};\n/*\r\n * Return a new Decimal whose value is the value of this Decimal rounded to a whole number using\r\n * rounding mode `rounding`.\r\n *\r\n */ P.round = function() {\n    var x = this, Ctor = x.constructor;\n    return finalise(new Ctor(x), x.e + 1, Ctor.rounding);\n};\n/*\r\n * Return a new Decimal whose value is the sine of the value in radians of this Decimal.\r\n *\r\n * Domain: [-Infinity, Infinity]\r\n * Range: [-1, 1]\r\n *\r\n * sin(x) = x - x^3/3! + x^5/5! - ...\r\n *\r\n * sin(0)         = 0\r\n * sin(-0)        = -0\r\n * sin(Infinity)  = NaN\r\n * sin(-Infinity) = NaN\r\n * sin(NaN)       = NaN\r\n *\r\n */ P.sine = P.sin = function() {\n    var pr, rm, x = this, Ctor = x.constructor;\n    if (!x.isFinite()) return new Ctor(NaN);\n    if (x.isZero()) return new Ctor(x);\n    pr = Ctor.precision;\n    rm = Ctor.rounding;\n    Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;\n    Ctor.rounding = 1;\n    x = sine(Ctor, toLessThanHalfPi(Ctor, x));\n    Ctor.precision = pr;\n    Ctor.rounding = rm;\n    return finalise(quadrant > 2 ? x.neg() : x, pr, rm, true);\n};\n/*\r\n * Return a new Decimal whose value is the square root of this Decimal, rounded to `precision`\r\n * significant digits using rounding mode `rounding`.\r\n *\r\n *  sqrt(-n) =  N\r\n *  sqrt(N)  =  N\r\n *  sqrt(-I) =  N\r\n *  sqrt(I)  =  I\r\n *  sqrt(0)  =  0\r\n *  sqrt(-0) = -0\r\n *\r\n */ P.squareRoot = P.sqrt = function() {\n    var m, n, sd, r, rep, t, x = this, d = x.d, e = x.e, s = x.s, Ctor = x.constructor;\n    // Negative/NaN/Infinity/zero?\n    if (s !== 1 || !d || !d[0]) {\n        return new Ctor(!s || s < 0 && (!d || d[0]) ? NaN : d ? x : 1 / 0);\n    }\n    external = false;\n    // Initial estimate.\n    s = Math.sqrt(+x);\n    // Math.sqrt underflow/overflow?\n    // Pass x to Math.sqrt as integer, then adjust the exponent of the result.\n    if (s == 0 || s == 1 / 0) {\n        n = digitsToString(d);\n        if ((n.length + e) % 2 == 0) n += \"0\";\n        s = Math.sqrt(n);\n        e = mathfloor((e + 1) / 2) - (e < 0 || e % 2);\n        if (s == 1 / 0) {\n            n = \"5e\" + e;\n        } else {\n            n = s.toExponential();\n            n = n.slice(0, n.indexOf(\"e\") + 1) + e;\n        }\n        r = new Ctor(n);\n    } else {\n        r = new Ctor(s.toString());\n    }\n    sd = (e = Ctor.precision) + 3;\n    // Newton-Raphson iteration.\n    for(;;){\n        t = r;\n        r = t.plus(divide(x, t, sd + 2, 1)).times(0.5);\n        // TODO? Replace with for-loop and checkRoundingDigits.\n        if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {\n            n = n.slice(sd - 3, sd + 1);\n            // The 4th rounding digit may be in error by -1 so if the 4 rounding digits are 9999 or\n            // 4999, i.e. approaching a rounding boundary, continue the iteration.\n            if (n == \"9999\" || !rep && n == \"4999\") {\n                // On the first iteration only, check to see if rounding up gives the exact result as the\n                // nines may infinitely repeat.\n                if (!rep) {\n                    finalise(t, e + 1, 0);\n                    if (t.times(t).eq(x)) {\n                        r = t;\n                        break;\n                    }\n                }\n                sd += 4;\n                rep = 1;\n            } else {\n                // If the rounding digits are null, 0{0,4} or 50{0,3}, check for an exact result.\n                // If not, then there are further digits and m will be truthy.\n                if (!+n || !+n.slice(1) && n.charAt(0) == \"5\") {\n                    // Truncate to the first rounding digit.\n                    finalise(r, e + 1, 1);\n                    m = !r.times(r).eq(x);\n                }\n                break;\n            }\n        }\n    }\n    external = true;\n    return finalise(r, e, Ctor.rounding, m);\n};\n/*\r\n * Return a new Decimal whose value is the tangent of the value in radians of this Decimal.\r\n *\r\n * Domain: [-Infinity, Infinity]\r\n * Range: [-Infinity, Infinity]\r\n *\r\n * tan(0)         = 0\r\n * tan(-0)        = -0\r\n * tan(Infinity)  = NaN\r\n * tan(-Infinity) = NaN\r\n * tan(NaN)       = NaN\r\n *\r\n */ P.tangent = P.tan = function() {\n    var pr, rm, x = this, Ctor = x.constructor;\n    if (!x.isFinite()) return new Ctor(NaN);\n    if (x.isZero()) return new Ctor(x);\n    pr = Ctor.precision;\n    rm = Ctor.rounding;\n    Ctor.precision = pr + 10;\n    Ctor.rounding = 1;\n    x = x.sin();\n    x.s = 1;\n    x = divide(x, new Ctor(1).minus(x.times(x)).sqrt(), pr + 10, 0);\n    Ctor.precision = pr;\n    Ctor.rounding = rm;\n    return finalise(quadrant == 2 || quadrant == 4 ? x.neg() : x, pr, rm, true);\n};\n/*\r\n *  n * 0 = 0\r\n *  n * N = N\r\n *  n * I = I\r\n *  0 * n = 0\r\n *  0 * 0 = 0\r\n *  0 * N = N\r\n *  0 * I = N\r\n *  N * n = N\r\n *  N * 0 = N\r\n *  N * N = N\r\n *  N * I = N\r\n *  I * n = I\r\n *  I * 0 = N\r\n *  I * N = N\r\n *  I * I = I\r\n *\r\n * Return a new Decimal whose value is this Decimal times `y`, rounded to `precision` significant\r\n * digits using rounding mode `rounding`.\r\n *\r\n */ P.times = P.mul = function(y) {\n    var carry, e, i, k, r, rL, t, xdL, ydL, x = this, Ctor = x.constructor, xd = x.d, yd = (y = new Ctor(y)).d;\n    y.s *= x.s;\n    // If either is NaN, ±Infinity or ±0...\n    if (!xd || !xd[0] || !yd || !yd[0]) {\n        return new Ctor(!y.s || xd && !xd[0] && !yd || yd && !yd[0] && !xd ? NaN : !xd || !yd ? y.s / 0 : y.s * 0);\n    }\n    e = mathfloor(x.e / LOG_BASE) + mathfloor(y.e / LOG_BASE);\n    xdL = xd.length;\n    ydL = yd.length;\n    // Ensure xd points to the longer array.\n    if (xdL < ydL) {\n        r = xd;\n        xd = yd;\n        yd = r;\n        rL = xdL;\n        xdL = ydL;\n        ydL = rL;\n    }\n    // Initialise the result array with zeros.\n    r = [];\n    rL = xdL + ydL;\n    for(i = rL; i--;)r.push(0);\n    // Multiply!\n    for(i = ydL; --i >= 0;){\n        carry = 0;\n        for(k = xdL + i; k > i;){\n            t = r[k] + yd[i] * xd[k - i - 1] + carry;\n            r[k--] = t % BASE | 0;\n            carry = t / BASE | 0;\n        }\n        r[k] = (r[k] + carry) % BASE | 0;\n    }\n    // Remove trailing zeros.\n    for(; !r[--rL];)r.pop();\n    if (carry) ++e;\n    else r.shift();\n    y.d = r;\n    y.e = getBase10Exponent(r, e);\n    return external ? finalise(y, Ctor.precision, Ctor.rounding) : y;\n};\n/*\r\n * Return a string representing the value of this Decimal in base 2, round to `sd` significant\r\n * digits using rounding mode `rm`.\r\n *\r\n * If the optional `sd` argument is present then return binary exponential notation.\r\n *\r\n * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.\r\n * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n *\r\n */ P.toBinary = function(sd, rm) {\n    return toStringBinary(this, 2, sd, rm);\n};\n/*\r\n * Return a new Decimal whose value is the value of this Decimal rounded to a maximum of `dp`\r\n * decimal places using rounding mode `rm` or `rounding` if `rm` is omitted.\r\n *\r\n * If `dp` is omitted, return a new Decimal whose value is the value of this Decimal.\r\n *\r\n * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.\r\n * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n *\r\n */ P.toDecimalPlaces = P.toDP = function(dp, rm) {\n    var x = this, Ctor = x.constructor;\n    x = new Ctor(x);\n    if (dp === void 0) return x;\n    checkInt32(dp, 0, MAX_DIGITS);\n    if (rm === void 0) rm = Ctor.rounding;\n    else checkInt32(rm, 0, 8);\n    return finalise(x, dp + x.e + 1, rm);\n};\n/*\r\n * Return a string representing the value of this Decimal in exponential notation rounded to\r\n * `dp` fixed decimal places using rounding mode `rounding`.\r\n *\r\n * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.\r\n * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n *\r\n */ P.toExponential = function(dp, rm) {\n    var str, x = this, Ctor = x.constructor;\n    if (dp === void 0) {\n        str = finiteToString(x, true);\n    } else {\n        checkInt32(dp, 0, MAX_DIGITS);\n        if (rm === void 0) rm = Ctor.rounding;\n        else checkInt32(rm, 0, 8);\n        x = finalise(new Ctor(x), dp + 1, rm);\n        str = finiteToString(x, true, dp + 1);\n    }\n    return x.isNeg() && !x.isZero() ? \"-\" + str : str;\n};\n/*\r\n * Return a string representing the value of this Decimal in normal (fixed-point) notation to\r\n * `dp` fixed decimal places and rounded using rounding mode `rm` or `rounding` if `rm` is\r\n * omitted.\r\n *\r\n * As with JavaScript numbers, (-0).toFixed(0) is '0', but e.g. (-0.00001).toFixed(0) is '-0'.\r\n *\r\n * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.\r\n * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n *\r\n * (-0).toFixed(0) is '0', but (-0.1).toFixed(0) is '-0'.\r\n * (-0).toFixed(1) is '0.0', but (-0.01).toFixed(1) is '-0.0'.\r\n * (-0).toFixed(3) is '0.000'.\r\n * (-0.5).toFixed(0) is '-0'.\r\n *\r\n */ P.toFixed = function(dp, rm) {\n    var str, y, x = this, Ctor = x.constructor;\n    if (dp === void 0) {\n        str = finiteToString(x);\n    } else {\n        checkInt32(dp, 0, MAX_DIGITS);\n        if (rm === void 0) rm = Ctor.rounding;\n        else checkInt32(rm, 0, 8);\n        y = finalise(new Ctor(x), dp + x.e + 1, rm);\n        str = finiteToString(y, false, dp + y.e + 1);\n    }\n    // To determine whether to add the minus sign look at the value before it was rounded,\n    // i.e. look at `x` rather than `y`.\n    return x.isNeg() && !x.isZero() ? \"-\" + str : str;\n};\n/*\r\n * Return an array representing the value of this Decimal as a simple fraction with an integer\r\n * numerator and an integer denominator.\r\n *\r\n * The denominator will be a positive non-zero value less than or equal to the specified maximum\r\n * denominator. If a maximum denominator is not specified, the denominator will be the lowest\r\n * value necessary to represent the number exactly.\r\n *\r\n * [maxD] {number|string|Decimal} Maximum denominator. Integer >= 1 and < Infinity.\r\n *\r\n */ P.toFraction = function(maxD) {\n    var d, d0, d1, d2, e, k, n, n0, n1, pr, q, r, x = this, xd = x.d, Ctor = x.constructor;\n    if (!xd) return new Ctor(x);\n    n1 = d0 = new Ctor(1);\n    d1 = n0 = new Ctor(0);\n    d = new Ctor(d1);\n    e = d.e = getPrecision(xd) - x.e - 1;\n    k = e % LOG_BASE;\n    d.d[0] = mathpow(10, k < 0 ? LOG_BASE + k : k);\n    if (maxD == null) {\n        // d is 10**e, the minimum max-denominator needed.\n        maxD = e > 0 ? d : n1;\n    } else {\n        n = new Ctor(maxD);\n        if (!n.isInt() || n.lt(n1)) throw Error(invalidArgument + n);\n        maxD = n.gt(d) ? e > 0 ? d : n1 : n;\n    }\n    external = false;\n    n = new Ctor(digitsToString(xd));\n    pr = Ctor.precision;\n    Ctor.precision = e = xd.length * LOG_BASE * 2;\n    for(;;){\n        q = divide(n, d, 0, 1, 1);\n        d2 = d0.plus(q.times(d1));\n        if (d2.cmp(maxD) == 1) break;\n        d0 = d1;\n        d1 = d2;\n        d2 = n1;\n        n1 = n0.plus(q.times(d2));\n        n0 = d2;\n        d2 = d;\n        d = n.minus(q.times(d2));\n        n = d2;\n    }\n    d2 = divide(maxD.minus(d0), d1, 0, 1, 1);\n    n0 = n0.plus(d2.times(n1));\n    d0 = d0.plus(d2.times(d1));\n    n0.s = n1.s = x.s;\n    // Determine which fraction is closer to x, n0/d0 or n1/d1?\n    r = divide(n1, d1, e, 1).minus(x).abs().cmp(divide(n0, d0, e, 1).minus(x).abs()) < 1 ? [\n        n1,\n        d1\n    ] : [\n        n0,\n        d0\n    ];\n    Ctor.precision = pr;\n    external = true;\n    return r;\n};\n/*\r\n * Return a string representing the value of this Decimal in base 16, round to `sd` significant\r\n * digits using rounding mode `rm`.\r\n *\r\n * If the optional `sd` argument is present then return binary exponential notation.\r\n *\r\n * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.\r\n * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n *\r\n */ P.toHexadecimal = P.toHex = function(sd, rm) {\n    return toStringBinary(this, 16, sd, rm);\n};\n/*\r\n * Returns a new Decimal whose value is the nearest multiple of `y` in the direction of rounding\r\n * mode `rm`, or `Decimal.rounding` if `rm` is omitted, to the value of this Decimal.\r\n *\r\n * The return value will always have the same sign as this Decimal, unless either this Decimal\r\n * or `y` is NaN, in which case the return value will be also be NaN.\r\n *\r\n * The return value is not affected by the value of `precision`.\r\n *\r\n * y {number|string|Decimal} The magnitude to round to a multiple of.\r\n * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n *\r\n * 'toNearest() rounding mode not an integer: {rm}'\r\n * 'toNearest() rounding mode out of range: {rm}'\r\n *\r\n */ P.toNearest = function(y, rm) {\n    var x = this, Ctor = x.constructor;\n    x = new Ctor(x);\n    if (y == null) {\n        // If x is not finite, return x.\n        if (!x.d) return x;\n        y = new Ctor(1);\n        rm = Ctor.rounding;\n    } else {\n        y = new Ctor(y);\n        if (rm === void 0) {\n            rm = Ctor.rounding;\n        } else {\n            checkInt32(rm, 0, 8);\n        }\n        // If x is not finite, return x if y is not NaN, else NaN.\n        if (!x.d) return y.s ? x : y;\n        // If y is not finite, return Infinity with the sign of x if y is Infinity, else NaN.\n        if (!y.d) {\n            if (y.s) y.s = x.s;\n            return y;\n        }\n    }\n    // If y is not zero, calculate the nearest multiple of y to x.\n    if (y.d[0]) {\n        external = false;\n        x = divide(x, y, 0, rm, 1).times(y);\n        external = true;\n        finalise(x);\n    // If y is zero, return zero with the sign of x.\n    } else {\n        y.s = x.s;\n        x = y;\n    }\n    return x;\n};\n/*\r\n * Return the value of this Decimal converted to a number primitive.\r\n * Zero keeps its sign.\r\n *\r\n */ P.toNumber = function() {\n    return +this;\n};\n/*\r\n * Return a string representing the value of this Decimal in base 8, round to `sd` significant\r\n * digits using rounding mode `rm`.\r\n *\r\n * If the optional `sd` argument is present then return binary exponential notation.\r\n *\r\n * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.\r\n * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n *\r\n */ P.toOctal = function(sd, rm) {\n    return toStringBinary(this, 8, sd, rm);\n};\n/*\r\n * Return a new Decimal whose value is the value of this Decimal raised to the power `y`, rounded\r\n * to `precision` significant digits using rounding mode `rounding`.\r\n *\r\n * ECMAScript compliant.\r\n *\r\n *   pow(x, NaN)                           = NaN\r\n *   pow(x, ±0)                            = 1\r\n\r\n *   pow(NaN, non-zero)                    = NaN\r\n *   pow(abs(x) > 1, +Infinity)            = +Infinity\r\n *   pow(abs(x) > 1, -Infinity)            = +0\r\n *   pow(abs(x) == 1, ±Infinity)           = NaN\r\n *   pow(abs(x) < 1, +Infinity)            = +0\r\n *   pow(abs(x) < 1, -Infinity)            = +Infinity\r\n *   pow(+Infinity, y > 0)                 = +Infinity\r\n *   pow(+Infinity, y < 0)                 = +0\r\n *   pow(-Infinity, odd integer > 0)       = -Infinity\r\n *   pow(-Infinity, even integer > 0)      = +Infinity\r\n *   pow(-Infinity, odd integer < 0)       = -0\r\n *   pow(-Infinity, even integer < 0)      = +0\r\n *   pow(+0, y > 0)                        = +0\r\n *   pow(+0, y < 0)                        = +Infinity\r\n *   pow(-0, odd integer > 0)              = -0\r\n *   pow(-0, even integer > 0)             = +0\r\n *   pow(-0, odd integer < 0)              = -Infinity\r\n *   pow(-0, even integer < 0)             = +Infinity\r\n *   pow(finite x < 0, finite non-integer) = NaN\r\n *\r\n * For non-integer or very large exponents pow(x, y) is calculated using\r\n *\r\n *   x^y = exp(y*ln(x))\r\n *\r\n * Assuming the first 15 rounding digits are each equally likely to be any digit 0-9, the\r\n * probability of an incorrectly rounded result\r\n * P([49]9{14} | [50]0{14}) = 2 * 0.2 * 10^-14 = 4e-15 = 1/2.5e+14\r\n * i.e. 1 in 250,000,000,000,000\r\n *\r\n * If a result is incorrectly rounded the maximum error will be 1 ulp (unit in last place).\r\n *\r\n * y {number|string|Decimal} The power to which to raise this Decimal.\r\n *\r\n */ P.toPower = P.pow = function(y) {\n    var e, k, pr, r, rm, s, x = this, Ctor = x.constructor, yn = +(y = new Ctor(y));\n    // Either ±Infinity, NaN or ±0?\n    if (!x.d || !y.d || !x.d[0] || !y.d[0]) return new Ctor(mathpow(+x, yn));\n    x = new Ctor(x);\n    if (x.eq(1)) return x;\n    pr = Ctor.precision;\n    rm = Ctor.rounding;\n    if (y.eq(1)) return finalise(x, pr, rm);\n    // y exponent\n    e = mathfloor(y.e / LOG_BASE);\n    // If y is a small integer use the 'exponentiation by squaring' algorithm.\n    if (e >= y.d.length - 1 && (k = yn < 0 ? -yn : yn) <= MAX_SAFE_INTEGER) {\n        r = intPow(Ctor, x, k, pr);\n        return y.s < 0 ? new Ctor(1).div(r) : finalise(r, pr, rm);\n    }\n    s = x.s;\n    // if x is negative\n    if (s < 0) {\n        // if y is not an integer\n        if (e < y.d.length - 1) return new Ctor(NaN);\n        // Result is positive if x is negative and the last digit of integer y is even.\n        if ((y.d[e] & 1) == 0) s = 1;\n        // if x.eq(-1)\n        if (x.e == 0 && x.d[0] == 1 && x.d.length == 1) {\n            x.s = s;\n            return x;\n        }\n    }\n    // Estimate result exponent.\n    // x^y = 10^e,  where e = y * log10(x)\n    // log10(x) = log10(x_significand) + x_exponent\n    // log10(x_significand) = ln(x_significand) / ln(10)\n    k = mathpow(+x, yn);\n    e = k == 0 || !isFinite(k) ? mathfloor(yn * (Math.log(\"0.\" + digitsToString(x.d)) / Math.LN10 + x.e + 1)) : new Ctor(k + \"\").e;\n    // Exponent estimate may be incorrect e.g. x: 0.999999999999999999, y: 2.29, e: 0, r.e: -1.\n    // Overflow/underflow?\n    if (e > Ctor.maxE + 1 || e < Ctor.minE - 1) return new Ctor(e > 0 ? s / 0 : 0);\n    external = false;\n    Ctor.rounding = x.s = 1;\n    // Estimate the extra guard digits needed to ensure five correct rounding digits from\n    // naturalLogarithm(x). Example of failure without these extra digits (precision: 10):\n    // new Decimal(2.32456).pow('2087987436534566.46411')\n    // should be 1.162377823e+764914905173815, but is 1.162355823e+764914905173815\n    k = Math.min(12, (e + \"\").length);\n    // r = x^y = exp(y*ln(x))\n    r = naturalExponential(y.times(naturalLogarithm(x, pr + k)), pr);\n    // r may be Infinity, e.g. (0.9999999999999999).pow(-1e+40)\n    if (r.d) {\n        // Truncate to the required precision plus five rounding digits.\n        r = finalise(r, pr + 5, 1);\n        // If the rounding digits are [49]9999 or [50]0000 increase the precision by 10 and recalculate\n        // the result.\n        if (checkRoundingDigits(r.d, pr, rm)) {\n            e = pr + 10;\n            // Truncate to the increased precision plus five rounding digits.\n            r = finalise(naturalExponential(y.times(naturalLogarithm(x, e + k)), e), e + 5, 1);\n            // Check for 14 nines from the 2nd rounding digit (the first rounding digit may be 4 or 9).\n            if (+digitsToString(r.d).slice(pr + 1, pr + 15) + 1 == 1e14) {\n                r = finalise(r, pr + 1, 0);\n            }\n        }\n    }\n    r.s = s;\n    external = true;\n    Ctor.rounding = rm;\n    return finalise(r, pr, rm);\n};\n/*\r\n * Return a string representing the value of this Decimal rounded to `sd` significant digits\r\n * using rounding mode `rounding`.\r\n *\r\n * Return exponential notation if `sd` is less than the number of digits necessary to represent\r\n * the integer part of the value in normal notation.\r\n *\r\n * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.\r\n * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n *\r\n */ P.toPrecision = function(sd, rm) {\n    var str, x = this, Ctor = x.constructor;\n    if (sd === void 0) {\n        str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);\n    } else {\n        checkInt32(sd, 1, MAX_DIGITS);\n        if (rm === void 0) rm = Ctor.rounding;\n        else checkInt32(rm, 0, 8);\n        x = finalise(new Ctor(x), sd, rm);\n        str = finiteToString(x, sd <= x.e || x.e <= Ctor.toExpNeg, sd);\n    }\n    return x.isNeg() && !x.isZero() ? \"-\" + str : str;\n};\n/*\r\n * Return a new Decimal whose value is the value of this Decimal rounded to a maximum of `sd`\r\n * significant digits using rounding mode `rm`, or to `precision` and `rounding` respectively if\r\n * omitted.\r\n *\r\n * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.\r\n * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n *\r\n * 'toSD() digits out of range: {sd}'\r\n * 'toSD() digits not an integer: {sd}'\r\n * 'toSD() rounding mode not an integer: {rm}'\r\n * 'toSD() rounding mode out of range: {rm}'\r\n *\r\n */ P.toSignificantDigits = P.toSD = function(sd, rm) {\n    var x = this, Ctor = x.constructor;\n    if (sd === void 0) {\n        sd = Ctor.precision;\n        rm = Ctor.rounding;\n    } else {\n        checkInt32(sd, 1, MAX_DIGITS);\n        if (rm === void 0) rm = Ctor.rounding;\n        else checkInt32(rm, 0, 8);\n    }\n    return finalise(new Ctor(x), sd, rm);\n};\n/*\r\n * Return a string representing the value of this Decimal.\r\n *\r\n * Return exponential notation if this Decimal has a positive exponent equal to or greater than\r\n * `toExpPos`, or a negative exponent equal to or less than `toExpNeg`.\r\n *\r\n */ P.toString = function() {\n    var x = this, Ctor = x.constructor, str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);\n    return x.isNeg() && !x.isZero() ? \"-\" + str : str;\n};\n/*\r\n * Return a new Decimal whose value is the value of this Decimal truncated to a whole number.\r\n *\r\n */ P.truncated = P.trunc = function() {\n    return finalise(new this.constructor(this), this.e + 1, 1);\n};\n/*\r\n * Return a string representing the value of this Decimal.\r\n * Unlike `toString`, negative zero will include the minus sign.\r\n *\r\n */ P.valueOf = P.toJSON = function() {\n    var x = this, Ctor = x.constructor, str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);\n    return x.isNeg() ? \"-\" + str : str;\n};\n// Helper functions for Decimal.prototype (P) and/or Decimal methods, and their callers.\n/*\r\n *  digitsToString           P.cubeRoot, P.logarithm, P.squareRoot, P.toFraction, P.toPower,\r\n *                           finiteToString, naturalExponential, naturalLogarithm\r\n *  checkInt32               P.toDecimalPlaces, P.toExponential, P.toFixed, P.toNearest,\r\n *                           P.toPrecision, P.toSignificantDigits, toStringBinary, random\r\n *  checkRoundingDigits      P.logarithm, P.toPower, naturalExponential, naturalLogarithm\r\n *  convertBase              toStringBinary, parseOther\r\n *  cos                      P.cos\r\n *  divide                   P.atanh, P.cubeRoot, P.dividedBy, P.dividedToIntegerBy,\r\n *                           P.logarithm, P.modulo, P.squareRoot, P.tan, P.tanh, P.toFraction,\r\n *                           P.toNearest, toStringBinary, naturalExponential, naturalLogarithm,\r\n *                           taylorSeries, atan2, parseOther\r\n *  finalise                 P.absoluteValue, P.atan, P.atanh, P.ceil, P.cos, P.cosh,\r\n *                           P.cubeRoot, P.dividedToIntegerBy, P.floor, P.logarithm, P.minus,\r\n *                           P.modulo, P.negated, P.plus, P.round, P.sin, P.sinh, P.squareRoot,\r\n *                           P.tan, P.times, P.toDecimalPlaces, P.toExponential, P.toFixed,\r\n *                           P.toNearest, P.toPower, P.toPrecision, P.toSignificantDigits,\r\n *                           P.truncated, divide, getLn10, getPi, naturalExponential,\r\n *                           naturalLogarithm, ceil, floor, round, trunc\r\n *  finiteToString           P.toExponential, P.toFixed, P.toPrecision, P.toString, P.valueOf,\r\n *                           toStringBinary\r\n *  getBase10Exponent        P.minus, P.plus, P.times, parseOther\r\n *  getLn10                  P.logarithm, naturalLogarithm\r\n *  getPi                    P.acos, P.asin, P.atan, toLessThanHalfPi, atan2\r\n *  getPrecision             P.precision, P.toFraction\r\n *  getZeroString            digitsToString, finiteToString\r\n *  intPow                   P.toPower, parseOther\r\n *  isOdd                    toLessThanHalfPi\r\n *  maxOrMin                 max, min\r\n *  naturalExponential       P.naturalExponential, P.toPower\r\n *  naturalLogarithm         P.acosh, P.asinh, P.atanh, P.logarithm, P.naturalLogarithm,\r\n *                           P.toPower, naturalExponential\r\n *  nonFiniteToString        finiteToString, toStringBinary\r\n *  parseDecimal             Decimal\r\n *  parseOther               Decimal\r\n *  sin                      P.sin\r\n *  taylorSeries             P.cosh, P.sinh, cos, sin\r\n *  toLessThanHalfPi         P.cos, P.sin\r\n *  toStringBinary           P.toBinary, P.toHexadecimal, P.toOctal\r\n *  truncate                 intPow\r\n *\r\n *  Throws:                  P.logarithm, P.precision, P.toFraction, checkInt32, getLn10, getPi,\r\n *                           naturalLogarithm, config, parseOther, random, Decimal\r\n */ function digitsToString(d) {\n    var i, k, ws, indexOfLastWord = d.length - 1, str = \"\", w = d[0];\n    if (indexOfLastWord > 0) {\n        str += w;\n        for(i = 1; i < indexOfLastWord; i++){\n            ws = d[i] + \"\";\n            k = LOG_BASE - ws.length;\n            if (k) str += getZeroString(k);\n            str += ws;\n        }\n        w = d[i];\n        ws = w + \"\";\n        k = LOG_BASE - ws.length;\n        if (k) str += getZeroString(k);\n    } else if (w === 0) {\n        return \"0\";\n    }\n    // Remove trailing zeros of last w.\n    for(; w % 10 === 0;)w /= 10;\n    return str + w;\n}\nfunction checkInt32(i, min, max) {\n    if (i !== ~~i || i < min || i > max) {\n        throw Error(invalidArgument + i);\n    }\n}\n/*\r\n * Check 5 rounding digits if `repeating` is null, 4 otherwise.\r\n * `repeating == null` if caller is `log` or `pow`,\r\n * `repeating != null` if caller is `naturalLogarithm` or `naturalExponential`.\r\n */ function checkRoundingDigits(d, i, rm, repeating) {\n    var di, k, r, rd;\n    // Get the length of the first word of the array d.\n    for(k = d[0]; k >= 10; k /= 10)--i;\n    // Is the rounding digit in the first word of d?\n    if (--i < 0) {\n        i += LOG_BASE;\n        di = 0;\n    } else {\n        di = Math.ceil((i + 1) / LOG_BASE);\n        i %= LOG_BASE;\n    }\n    // i is the index (0 - 6) of the rounding digit.\n    // E.g. if within the word 3487563 the first rounding digit is 5,\n    // then i = 4, k = 1000, rd = 3487563 % 1000 = 563\n    k = mathpow(10, LOG_BASE - i);\n    rd = d[di] % k | 0;\n    if (repeating == null) {\n        if (i < 3) {\n            if (i == 0) rd = rd / 100 | 0;\n            else if (i == 1) rd = rd / 10 | 0;\n            r = rm < 4 && rd == 99999 || rm > 3 && rd == 49999 || rd == 50000 || rd == 0;\n        } else {\n            r = (rm < 4 && rd + 1 == k || rm > 3 && rd + 1 == k / 2) && (d[di + 1] / k / 100 | 0) == mathpow(10, i - 2) - 1 || (rd == k / 2 || rd == 0) && (d[di + 1] / k / 100 | 0) == 0;\n        }\n    } else {\n        if (i < 4) {\n            if (i == 0) rd = rd / 1000 | 0;\n            else if (i == 1) rd = rd / 100 | 0;\n            else if (i == 2) rd = rd / 10 | 0;\n            r = (repeating || rm < 4) && rd == 9999 || !repeating && rm > 3 && rd == 4999;\n        } else {\n            r = ((repeating || rm < 4) && rd + 1 == k || !repeating && rm > 3 && rd + 1 == k / 2) && (d[di + 1] / k / 1000 | 0) == mathpow(10, i - 3) - 1;\n        }\n    }\n    return r;\n}\n// Convert string of `baseIn` to an array of numbers of `baseOut`.\n// Eg. convertBase('255', 10, 16) returns [15, 15].\n// Eg. convertBase('ff', 16, 10) returns [2, 5, 5].\nfunction convertBase(str, baseIn, baseOut) {\n    var j, arr = [\n        0\n    ], arrL, i = 0, strL = str.length;\n    for(; i < strL;){\n        for(arrL = arr.length; arrL--;)arr[arrL] *= baseIn;\n        arr[0] += NUMERALS.indexOf(str.charAt(i++));\n        for(j = 0; j < arr.length; j++){\n            if (arr[j] > baseOut - 1) {\n                if (arr[j + 1] === void 0) arr[j + 1] = 0;\n                arr[j + 1] += arr[j] / baseOut | 0;\n                arr[j] %= baseOut;\n            }\n        }\n    }\n    return arr.reverse();\n}\n/*\r\n * cos(x) = 1 - x^2/2! + x^4/4! - ...\r\n * |x| < pi/2\r\n *\r\n */ function cosine(Ctor, x) {\n    var k, len, y;\n    if (x.isZero()) return x;\n    // Argument reduction: cos(4x) = 8*(cos^4(x) - cos^2(x)) + 1\n    // i.e. cos(x) = 8*(cos^4(x/4) - cos^2(x/4)) + 1\n    // Estimate the optimum number of times to use the argument reduction.\n    len = x.d.length;\n    if (len < 32) {\n        k = Math.ceil(len / 3);\n        y = (1 / tinyPow(4, k)).toString();\n    } else {\n        k = 16;\n        y = \"2.3283064365386962890625e-10\";\n    }\n    Ctor.precision += k;\n    x = taylorSeries(Ctor, 1, x.times(y), new Ctor(1));\n    // Reverse argument reduction\n    for(var i = k; i--;){\n        var cos2x = x.times(x);\n        x = cos2x.times(cos2x).minus(cos2x).times(8).plus(1);\n    }\n    Ctor.precision -= k;\n    return x;\n}\n/*\r\n * Perform division in the specified base.\r\n */ var divide = function() {\n    // Assumes non-zero x and k, and hence non-zero result.\n    function multiplyInteger(x, k, base) {\n        var temp, carry = 0, i = x.length;\n        for(x = x.slice(); i--;){\n            temp = x[i] * k + carry;\n            x[i] = temp % base | 0;\n            carry = temp / base | 0;\n        }\n        if (carry) x.unshift(carry);\n        return x;\n    }\n    function compare(a, b, aL, bL) {\n        var i, r;\n        if (aL != bL) {\n            r = aL > bL ? 1 : -1;\n        } else {\n            for(i = r = 0; i < aL; i++){\n                if (a[i] != b[i]) {\n                    r = a[i] > b[i] ? 1 : -1;\n                    break;\n                }\n            }\n        }\n        return r;\n    }\n    function subtract(a, b, aL, base) {\n        var i = 0;\n        // Subtract b from a.\n        for(; aL--;){\n            a[aL] -= i;\n            i = a[aL] < b[aL] ? 1 : 0;\n            a[aL] = i * base + a[aL] - b[aL];\n        }\n        // Remove leading zeros.\n        for(; !a[0] && a.length > 1;)a.shift();\n    }\n    return function(x, y, pr, rm, dp, base) {\n        var cmp, e, i, k, logBase, more, prod, prodL, q, qd, rem, remL, rem0, sd, t, xi, xL, yd0, yL, yz, Ctor = x.constructor, sign = x.s == y.s ? 1 : -1, xd = x.d, yd = y.d;\n        // Either NaN, Infinity or 0?\n        if (!xd || !xd[0] || !yd || !yd[0]) {\n            return new Ctor(!x.s || !y.s || (xd ? yd && xd[0] == yd[0] : !yd) ? NaN : // Return ±0 if x is 0 or y is ±Infinity, or return ±Infinity as y is 0.\n            xd && xd[0] == 0 || !yd ? sign * 0 : sign / 0);\n        }\n        if (base) {\n            logBase = 1;\n            e = x.e - y.e;\n        } else {\n            base = BASE;\n            logBase = LOG_BASE;\n            e = mathfloor(x.e / logBase) - mathfloor(y.e / logBase);\n        }\n        yL = yd.length;\n        xL = xd.length;\n        q = new Ctor(sign);\n        qd = q.d = [];\n        // Result exponent may be one less than e.\n        // The digit array of a Decimal from toStringBinary may have trailing zeros.\n        for(i = 0; yd[i] == (xd[i] || 0); i++);\n        if (yd[i] > (xd[i] || 0)) e--;\n        if (pr == null) {\n            sd = pr = Ctor.precision;\n            rm = Ctor.rounding;\n        } else if (dp) {\n            sd = pr + (x.e - y.e) + 1;\n        } else {\n            sd = pr;\n        }\n        if (sd < 0) {\n            qd.push(1);\n            more = true;\n        } else {\n            // Convert precision in number of base 10 digits to base 1e7 digits.\n            sd = sd / logBase + 2 | 0;\n            i = 0;\n            // divisor < 1e7\n            if (yL == 1) {\n                k = 0;\n                yd = yd[0];\n                sd++;\n                // k is the carry.\n                for(; (i < xL || k) && sd--; i++){\n                    t = k * base + (xd[i] || 0);\n                    qd[i] = t / yd | 0;\n                    k = t % yd | 0;\n                }\n                more = k || i < xL;\n            // divisor >= 1e7\n            } else {\n                // Normalise xd and yd so highest order digit of yd is >= base/2\n                k = base / (yd[0] + 1) | 0;\n                if (k > 1) {\n                    yd = multiplyInteger(yd, k, base);\n                    xd = multiplyInteger(xd, k, base);\n                    yL = yd.length;\n                    xL = xd.length;\n                }\n                xi = yL;\n                rem = xd.slice(0, yL);\n                remL = rem.length;\n                // Add zeros to make remainder as long as divisor.\n                for(; remL < yL;)rem[remL++] = 0;\n                yz = yd.slice();\n                yz.unshift(0);\n                yd0 = yd[0];\n                if (yd[1] >= base / 2) ++yd0;\n                do {\n                    k = 0;\n                    // Compare divisor and remainder.\n                    cmp = compare(yd, rem, yL, remL);\n                    // If divisor < remainder.\n                    if (cmp < 0) {\n                        // Calculate trial digit, k.\n                        rem0 = rem[0];\n                        if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);\n                        // k will be how many times the divisor goes into the current remainder.\n                        k = rem0 / yd0 | 0;\n                        //  Algorithm:\n                        //  1. product = divisor * trial digit (k)\n                        //  2. if product > remainder: product -= divisor, k--\n                        //  3. remainder -= product\n                        //  4. if product was < remainder at 2:\n                        //    5. compare new remainder and divisor\n                        //    6. If remainder > divisor: remainder -= divisor, k++\n                        if (k > 1) {\n                            if (k >= base) k = base - 1;\n                            // product = divisor * trial digit.\n                            prod = multiplyInteger(yd, k, base);\n                            prodL = prod.length;\n                            remL = rem.length;\n                            // Compare product and remainder.\n                            cmp = compare(prod, rem, prodL, remL);\n                            // product > remainder.\n                            if (cmp == 1) {\n                                k--;\n                                // Subtract divisor from product.\n                                subtract(prod, yL < prodL ? yz : yd, prodL, base);\n                            }\n                        } else {\n                            // cmp is -1.\n                            // If k is 0, there is no need to compare yd and rem again below, so change cmp to 1\n                            // to avoid it. If k is 1 there is a need to compare yd and rem again below.\n                            if (k == 0) cmp = k = 1;\n                            prod = yd.slice();\n                        }\n                        prodL = prod.length;\n                        if (prodL < remL) prod.unshift(0);\n                        // Subtract product from remainder.\n                        subtract(rem, prod, remL, base);\n                        // If product was < previous remainder.\n                        if (cmp == -1) {\n                            remL = rem.length;\n                            // Compare divisor and new remainder.\n                            cmp = compare(yd, rem, yL, remL);\n                            // If divisor < new remainder, subtract divisor from remainder.\n                            if (cmp < 1) {\n                                k++;\n                                // Subtract divisor from remainder.\n                                subtract(rem, yL < remL ? yz : yd, remL, base);\n                            }\n                        }\n                        remL = rem.length;\n                    } else if (cmp === 0) {\n                        k++;\n                        rem = [\n                            0\n                        ];\n                    } // if cmp === 1, k will be 0\n                    // Add the next digit, k, to the result array.\n                    qd[i++] = k;\n                    // Update the remainder.\n                    if (cmp && rem[0]) {\n                        rem[remL++] = xd[xi] || 0;\n                    } else {\n                        rem = [\n                            xd[xi]\n                        ];\n                        remL = 1;\n                    }\n                }while ((xi++ < xL || rem[0] !== void 0) && sd--);\n                more = rem[0] !== void 0;\n            }\n            // Leading zero?\n            if (!qd[0]) qd.shift();\n        }\n        // logBase is 1 when divide is being used for base conversion.\n        if (logBase == 1) {\n            q.e = e;\n            inexact = more;\n        } else {\n            // To calculate q.e, first get the number of digits of qd[0].\n            for(i = 1, k = qd[0]; k >= 10; k /= 10)i++;\n            q.e = i + e * logBase - 1;\n            finalise(q, dp ? pr + q.e + 1 : pr, rm, more);\n        }\n        return q;\n    };\n}();\n/*\r\n * Round `x` to `sd` significant digits using rounding mode `rm`.\r\n * Check for over/under-flow.\r\n */ function finalise(x, sd, rm, isTruncated) {\n    var digits, i, j, k, rd, roundUp, w, xd, xdi, Ctor = x.constructor;\n    // Don't round if sd is null or undefined.\n    out: if (sd != null) {\n        xd = x.d;\n        // Infinity/NaN.\n        if (!xd) return x;\n        // rd: the rounding digit, i.e. the digit after the digit that may be rounded up.\n        // w: the word of xd containing rd, a base 1e7 number.\n        // xdi: the index of w within xd.\n        // digits: the number of digits of w.\n        // i: what would be the index of rd within w if all the numbers were 7 digits long (i.e. if\n        // they had leading zeros)\n        // j: if > 0, the actual index of rd within w (if < 0, rd is a leading zero).\n        // Get the length of the first word of the digits array xd.\n        for(digits = 1, k = xd[0]; k >= 10; k /= 10)digits++;\n        i = sd - digits;\n        // Is the rounding digit in the first word of xd?\n        if (i < 0) {\n            i += LOG_BASE;\n            j = sd;\n            w = xd[xdi = 0];\n            // Get the rounding digit at index j of w.\n            rd = w / mathpow(10, digits - j - 1) % 10 | 0;\n        } else {\n            xdi = Math.ceil((i + 1) / LOG_BASE);\n            k = xd.length;\n            if (xdi >= k) {\n                if (isTruncated) {\n                    // Needed by `naturalExponential`, `naturalLogarithm` and `squareRoot`.\n                    for(; k++ <= xdi;)xd.push(0);\n                    w = rd = 0;\n                    digits = 1;\n                    i %= LOG_BASE;\n                    j = i - LOG_BASE + 1;\n                } else {\n                    break out;\n                }\n            } else {\n                w = k = xd[xdi];\n                // Get the number of digits of w.\n                for(digits = 1; k >= 10; k /= 10)digits++;\n                // Get the index of rd within w.\n                i %= LOG_BASE;\n                // Get the index of rd within w, adjusted for leading zeros.\n                // The number of leading zeros of w is given by LOG_BASE - digits.\n                j = i - LOG_BASE + digits;\n                // Get the rounding digit at index j of w.\n                rd = j < 0 ? 0 : w / mathpow(10, digits - j - 1) % 10 | 0;\n            }\n        }\n        // Are there any non-zero digits after the rounding digit?\n        isTruncated = isTruncated || sd < 0 || xd[xdi + 1] !== void 0 || (j < 0 ? w : w % mathpow(10, digits - j - 1));\n        // The expression `w % mathpow(10, digits - j - 1)` returns all the digits of w to the right\n        // of the digit at (left-to-right) index j, e.g. if w is 908714 and j is 2, the expression\n        // will give 714.\n        roundUp = rm < 4 ? (rd || isTruncated) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || isTruncated || rm == 6 && (i > 0 ? j > 0 ? w / mathpow(10, digits - j) : 0 : xd[xdi - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));\n        if (sd < 1 || !xd[0]) {\n            xd.length = 0;\n            if (roundUp) {\n                // Convert sd to decimal places.\n                sd -= x.e + 1;\n                // 1, 0.1, 0.01, 0.001, 0.0001 etc.\n                xd[0] = mathpow(10, (LOG_BASE - sd % LOG_BASE) % LOG_BASE);\n                x.e = -sd || 0;\n            } else {\n                // Zero.\n                xd[0] = x.e = 0;\n            }\n            return x;\n        }\n        // Remove excess digits.\n        if (i == 0) {\n            xd.length = xdi;\n            k = 1;\n            xdi--;\n        } else {\n            xd.length = xdi + 1;\n            k = mathpow(10, LOG_BASE - i);\n            // E.g. 56700 becomes 56000 if 7 is the rounding digit.\n            // j > 0 means i > number of leading zeros of w.\n            xd[xdi] = j > 0 ? (w / mathpow(10, digits - j) % mathpow(10, j) | 0) * k : 0;\n        }\n        if (roundUp) {\n            for(;;){\n                // Is the digit to be rounded up in the first word of xd?\n                if (xdi == 0) {\n                    // i will be the length of xd[0] before k is added.\n                    for(i = 1, j = xd[0]; j >= 10; j /= 10)i++;\n                    j = xd[0] += k;\n                    for(k = 1; j >= 10; j /= 10)k++;\n                    // if i != k the length has increased.\n                    if (i != k) {\n                        x.e++;\n                        if (xd[0] == BASE) xd[0] = 1;\n                    }\n                    break;\n                } else {\n                    xd[xdi] += k;\n                    if (xd[xdi] != BASE) break;\n                    xd[xdi--] = 0;\n                    k = 1;\n                }\n            }\n        }\n        // Remove trailing zeros.\n        for(i = xd.length; xd[--i] === 0;)xd.pop();\n    }\n    if (external) {\n        // Overflow?\n        if (x.e > Ctor.maxE) {\n            // Infinity.\n            x.d = null;\n            x.e = NaN;\n        // Underflow?\n        } else if (x.e < Ctor.minE) {\n            // Zero.\n            x.e = 0;\n            x.d = [\n                0\n            ];\n        // Ctor.underflow = true;\n        } // else Ctor.underflow = false;\n    }\n    return x;\n}\nfunction finiteToString(x, isExp, sd) {\n    if (!x.isFinite()) return nonFiniteToString(x);\n    var k, e = x.e, str = digitsToString(x.d), len = str.length;\n    if (isExp) {\n        if (sd && (k = sd - len) > 0) {\n            str = str.charAt(0) + \".\" + str.slice(1) + getZeroString(k);\n        } else if (len > 1) {\n            str = str.charAt(0) + \".\" + str.slice(1);\n        }\n        str = str + (x.e < 0 ? \"e\" : \"e+\") + x.e;\n    } else if (e < 0) {\n        str = \"0.\" + getZeroString(-e - 1) + str;\n        if (sd && (k = sd - len) > 0) str += getZeroString(k);\n    } else if (e >= len) {\n        str += getZeroString(e + 1 - len);\n        if (sd && (k = sd - e - 1) > 0) str = str + \".\" + getZeroString(k);\n    } else {\n        if ((k = e + 1) < len) str = str.slice(0, k) + \".\" + str.slice(k);\n        if (sd && (k = sd - len) > 0) {\n            if (e + 1 === len) str += \".\";\n            str += getZeroString(k);\n        }\n    }\n    return str;\n}\n// Calculate the base 10 exponent from the base 1e7 exponent.\nfunction getBase10Exponent(digits, e) {\n    var w = digits[0];\n    // Add the number of digits of the first word of the digits array.\n    for(e *= LOG_BASE; w >= 10; w /= 10)e++;\n    return e;\n}\nfunction getLn10(Ctor, sd, pr) {\n    if (sd > LN10_PRECISION) {\n        // Reset global state in case the exception is caught.\n        external = true;\n        if (pr) Ctor.precision = pr;\n        throw Error(precisionLimitExceeded);\n    }\n    return finalise(new Ctor(LN10), sd, 1, true);\n}\nfunction getPi(Ctor, sd, rm) {\n    if (sd > PI_PRECISION) throw Error(precisionLimitExceeded);\n    return finalise(new Ctor(PI), sd, rm, true);\n}\nfunction getPrecision(digits) {\n    var w = digits.length - 1, len = w * LOG_BASE + 1;\n    w = digits[w];\n    // If non-zero...\n    if (w) {\n        // Subtract the number of trailing zeros of the last word.\n        for(; w % 10 == 0; w /= 10)len--;\n        // Add the number of digits of the first word.\n        for(w = digits[0]; w >= 10; w /= 10)len++;\n    }\n    return len;\n}\nfunction getZeroString(k) {\n    var zs = \"\";\n    for(; k--;)zs += \"0\";\n    return zs;\n}\n/*\r\n * Return a new Decimal whose value is the value of Decimal `x` to the power `n`, where `n` is an\r\n * integer of type number.\r\n *\r\n * Implements 'exponentiation by squaring'. Called by `pow` and `parseOther`.\r\n *\r\n */ function intPow(Ctor, x, n, pr) {\n    var isTruncated, r = new Ctor(1), // Max n of 9007199254740991 takes 53 loop iterations.\n    // Maximum digits array length; leaves [28, 34] guard digits.\n    k = Math.ceil(pr / LOG_BASE + 4);\n    external = false;\n    for(;;){\n        if (n % 2) {\n            r = r.times(x);\n            if (truncate(r.d, k)) isTruncated = true;\n        }\n        n = mathfloor(n / 2);\n        if (n === 0) {\n            // To ensure correct rounding when r.d is truncated, increment the last word if it is zero.\n            n = r.d.length - 1;\n            if (isTruncated && r.d[n] === 0) ++r.d[n];\n            break;\n        }\n        x = x.times(x);\n        truncate(x.d, k);\n    }\n    external = true;\n    return r;\n}\nfunction isOdd(n) {\n    return n.d[n.d.length - 1] & 1;\n}\n/*\r\n * Handle `max` and `min`. `ltgt` is 'lt' or 'gt'.\r\n */ function maxOrMin(Ctor, args, ltgt) {\n    var y, x = new Ctor(args[0]), i = 0;\n    for(; ++i < args.length;){\n        y = new Ctor(args[i]);\n        if (!y.s) {\n            x = y;\n            break;\n        } else if (x[ltgt](y)) {\n            x = y;\n        }\n    }\n    return x;\n}\n/*\r\n * Return a new Decimal whose value is the natural exponential of `x` rounded to `sd` significant\r\n * digits.\r\n *\r\n * Taylor/Maclaurin series.\r\n *\r\n * exp(x) = x^0/0! + x^1/1! + x^2/2! + x^3/3! + ...\r\n *\r\n * Argument reduction:\r\n *   Repeat x = x / 32, k += 5, until |x| < 0.1\r\n *   exp(x) = exp(x / 2^k)^(2^k)\r\n *\r\n * Previously, the argument was initially reduced by\r\n * exp(x) = exp(r) * 10^k  where r = x - k * ln10, k = floor(x / ln10)\r\n * to first put r in the range [0, ln10], before dividing by 32 until |x| < 0.1, but this was\r\n * found to be slower than just dividing repeatedly by 32 as above.\r\n *\r\n * Max integer argument: exp('20723265836946413') = 6.3e+9000000000000000\r\n * Min integer argument: exp('-20723265836946411') = 1.2e-9000000000000000\r\n * (Math object integer min/max: Math.exp(709) = 8.2e+307, Math.exp(-745) = 5e-324)\r\n *\r\n *  exp(Infinity)  = Infinity\r\n *  exp(-Infinity) = 0\r\n *  exp(NaN)       = NaN\r\n *  exp(±0)        = 1\r\n *\r\n *  exp(x) is non-terminating for any finite, non-zero x.\r\n *\r\n *  The result will always be correctly rounded.\r\n *\r\n */ function naturalExponential(x, sd) {\n    var denominator, guard, j, pow, sum, t, wpr, rep = 0, i = 0, k = 0, Ctor = x.constructor, rm = Ctor.rounding, pr = Ctor.precision;\n    // 0/NaN/Infinity?\n    if (!x.d || !x.d[0] || x.e > 17) {\n        return new Ctor(x.d ? !x.d[0] ? 1 : x.s < 0 ? 0 : 1 / 0 : x.s ? x.s < 0 ? 0 : x : 0 / 0);\n    }\n    if (sd == null) {\n        external = false;\n        wpr = pr;\n    } else {\n        wpr = sd;\n    }\n    t = new Ctor(0.03125);\n    // while abs(x) >= 0.1\n    while(x.e > -2){\n        // x = x / 2^5\n        x = x.times(t);\n        k += 5;\n    }\n    // Use 2 * log10(2^k) + 5 (empirically derived) to estimate the increase in precision\n    // necessary to ensure the first 4 rounding digits are correct.\n    guard = Math.log(mathpow(2, k)) / Math.LN10 * 2 + 5 | 0;\n    wpr += guard;\n    denominator = pow = sum = new Ctor(1);\n    Ctor.precision = wpr;\n    for(;;){\n        pow = finalise(pow.times(x), wpr, 1);\n        denominator = denominator.times(++i);\n        t = sum.plus(divide(pow, denominator, wpr, 1));\n        if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum.d).slice(0, wpr)) {\n            j = k;\n            while(j--)sum = finalise(sum.times(sum), wpr, 1);\n            // Check to see if the first 4 rounding digits are [49]999.\n            // If so, repeat the summation with a higher precision, otherwise\n            // e.g. with precision: 18, rounding: 1\n            // exp(18.404272462595034083567793919843761) = 98372560.1229999999 (should be 98372560.123)\n            // `wpr - guard` is the index of first rounding digit.\n            if (sd == null) {\n                if (rep < 3 && checkRoundingDigits(sum.d, wpr - guard, rm, rep)) {\n                    Ctor.precision = wpr += 10;\n                    denominator = pow = t = new Ctor(1);\n                    i = 0;\n                    rep++;\n                } else {\n                    return finalise(sum, Ctor.precision = pr, rm, external = true);\n                }\n            } else {\n                Ctor.precision = pr;\n                return sum;\n            }\n        }\n        sum = t;\n    }\n}\n/*\r\n * Return a new Decimal whose value is the natural logarithm of `x` rounded to `sd` significant\r\n * digits.\r\n *\r\n *  ln(-n)        = NaN\r\n *  ln(0)         = -Infinity\r\n *  ln(-0)        = -Infinity\r\n *  ln(1)         = 0\r\n *  ln(Infinity)  = Infinity\r\n *  ln(-Infinity) = NaN\r\n *  ln(NaN)       = NaN\r\n *\r\n *  ln(n) (n != 1) is non-terminating.\r\n *\r\n */ function naturalLogarithm(y, sd) {\n    var c, c0, denominator, e, numerator, rep, sum, t, wpr, x1, x2, n = 1, guard = 10, x = y, xd = x.d, Ctor = x.constructor, rm = Ctor.rounding, pr = Ctor.precision;\n    // Is x negative or Infinity, NaN, 0 or 1?\n    if (x.s < 0 || !xd || !xd[0] || !x.e && xd[0] == 1 && xd.length == 1) {\n        return new Ctor(xd && !xd[0] ? -1 / 0 : x.s != 1 ? NaN : xd ? 0 : x);\n    }\n    if (sd == null) {\n        external = false;\n        wpr = pr;\n    } else {\n        wpr = sd;\n    }\n    Ctor.precision = wpr += guard;\n    c = digitsToString(xd);\n    c0 = c.charAt(0);\n    if (Math.abs(e = x.e) < 1.5e15) {\n        // Argument reduction.\n        // The series converges faster the closer the argument is to 1, so using\n        // ln(a^b) = b * ln(a),   ln(a) = ln(a^b) / b\n        // multiply the argument by itself until the leading digits of the significand are 7, 8, 9,\n        // 10, 11, 12 or 13, recording the number of multiplications so the sum of the series can\n        // later be divided by this number, then separate out the power of 10 using\n        // ln(a*10^b) = ln(a) + b*ln(10).\n        // max n is 21 (gives 0.9, 1.0 or 1.1) (9e15 / 21 = 4.2e14).\n        //while (c0 < 9 && c0 != 1 || c0 == 1 && c.charAt(1) > 1) {\n        // max n is 6 (gives 0.7 - 1.3)\n        while(c0 < 7 && c0 != 1 || c0 == 1 && c.charAt(1) > 3){\n            x = x.times(y);\n            c = digitsToString(x.d);\n            c0 = c.charAt(0);\n            n++;\n        }\n        e = x.e;\n        if (c0 > 1) {\n            x = new Ctor(\"0.\" + c);\n            e++;\n        } else {\n            x = new Ctor(c0 + \".\" + c.slice(1));\n        }\n    } else {\n        // The argument reduction method above may result in overflow if the argument y is a massive\n        // number with exponent >= 1500000000000000 (9e15 / 6 = 1.5e15), so instead recall this\n        // function using ln(x*10^e) = ln(x) + e*ln(10).\n        t = getLn10(Ctor, wpr + 2, pr).times(e + \"\");\n        x = naturalLogarithm(new Ctor(c0 + \".\" + c.slice(1)), wpr - guard).plus(t);\n        Ctor.precision = pr;\n        return sd == null ? finalise(x, pr, rm, external = true) : x;\n    }\n    // x1 is x reduced to a value near 1.\n    x1 = x;\n    // Taylor series.\n    // ln(y) = ln((1 + x)/(1 - x)) = 2(x + x^3/3 + x^5/5 + x^7/7 + ...)\n    // where x = (y - 1)/(y + 1)    (|x| < 1)\n    sum = numerator = x = divide(x.minus(1), x.plus(1), wpr, 1);\n    x2 = finalise(x.times(x), wpr, 1);\n    denominator = 3;\n    for(;;){\n        numerator = finalise(numerator.times(x2), wpr, 1);\n        t = sum.plus(divide(numerator, new Ctor(denominator), wpr, 1));\n        if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum.d).slice(0, wpr)) {\n            sum = sum.times(2);\n            // Reverse the argument reduction. Check that e is not 0 because, besides preventing an\n            // unnecessary calculation, -0 + 0 = +0 and to ensure correct rounding -0 needs to stay -0.\n            if (e !== 0) sum = sum.plus(getLn10(Ctor, wpr + 2, pr).times(e + \"\"));\n            sum = divide(sum, new Ctor(n), wpr, 1);\n            // Is rm > 3 and the first 4 rounding digits 4999, or rm < 4 (or the summation has\n            // been repeated previously) and the first 4 rounding digits 9999?\n            // If so, restart the summation with a higher precision, otherwise\n            // e.g. with precision: 12, rounding: 1\n            // ln(135520028.6126091714265381533) = 18.7246299999 when it should be 18.72463.\n            // `wpr - guard` is the index of first rounding digit.\n            if (sd == null) {\n                if (checkRoundingDigits(sum.d, wpr - guard, rm, rep)) {\n                    Ctor.precision = wpr += guard;\n                    t = numerator = x = divide(x1.minus(1), x1.plus(1), wpr, 1);\n                    x2 = finalise(x.times(x), wpr, 1);\n                    denominator = rep = 1;\n                } else {\n                    return finalise(sum, Ctor.precision = pr, rm, external = true);\n                }\n            } else {\n                Ctor.precision = pr;\n                return sum;\n            }\n        }\n        sum = t;\n        denominator += 2;\n    }\n}\n// ±Infinity, NaN.\nfunction nonFiniteToString(x) {\n    // Unsigned.\n    return String(x.s * x.s / 0);\n}\n/*\r\n * Parse the value of a new Decimal `x` from string `str`.\r\n */ function parseDecimal(x, str) {\n    var e, i, len;\n    // Decimal point?\n    if ((e = str.indexOf(\".\")) > -1) str = str.replace(\".\", \"\");\n    // Exponential form?\n    if ((i = str.search(/e/i)) > 0) {\n        // Determine exponent.\n        if (e < 0) e = i;\n        e += +str.slice(i + 1);\n        str = str.substring(0, i);\n    } else if (e < 0) {\n        // Integer.\n        e = str.length;\n    }\n    // Determine leading zeros.\n    for(i = 0; str.charCodeAt(i) === 48; i++);\n    // Determine trailing zeros.\n    for(len = str.length; str.charCodeAt(len - 1) === 48; --len);\n    str = str.slice(i, len);\n    if (str) {\n        len -= i;\n        x.e = e = e - i - 1;\n        x.d = [];\n        // Transform base\n        // e is the base 10 exponent.\n        // i is where to slice str to get the first word of the digits array.\n        i = (e + 1) % LOG_BASE;\n        if (e < 0) i += LOG_BASE;\n        if (i < len) {\n            if (i) x.d.push(+str.slice(0, i));\n            for(len -= LOG_BASE; i < len;)x.d.push(+str.slice(i, i += LOG_BASE));\n            str = str.slice(i);\n            i = LOG_BASE - str.length;\n        } else {\n            i -= len;\n        }\n        for(; i--;)str += \"0\";\n        x.d.push(+str);\n        if (external) {\n            // Overflow?\n            if (x.e > x.constructor.maxE) {\n                // Infinity.\n                x.d = null;\n                x.e = NaN;\n            // Underflow?\n            } else if (x.e < x.constructor.minE) {\n                // Zero.\n                x.e = 0;\n                x.d = [\n                    0\n                ];\n            // x.constructor.underflow = true;\n            } // else x.constructor.underflow = false;\n        }\n    } else {\n        // Zero.\n        x.e = 0;\n        x.d = [\n            0\n        ];\n    }\n    return x;\n}\n/*\r\n * Parse the value of a new Decimal `x` from a string `str`, which is not a decimal value.\r\n */ function parseOther(x, str) {\n    var base, Ctor, divisor, i, isFloat, len, p, xd, xe;\n    if (str.indexOf(\"_\") > -1) {\n        str = str.replace(/(\\d)_(?=\\d)/g, \"$1\");\n        if (isDecimal.test(str)) return parseDecimal(x, str);\n    } else if (str === \"Infinity\" || str === \"NaN\") {\n        if (!+str) x.s = NaN;\n        x.e = NaN;\n        x.d = null;\n        return x;\n    }\n    if (isHex.test(str)) {\n        base = 16;\n        str = str.toLowerCase();\n    } else if (isBinary.test(str)) {\n        base = 2;\n    } else if (isOctal.test(str)) {\n        base = 8;\n    } else {\n        throw Error(invalidArgument + str);\n    }\n    // Is there a binary exponent part?\n    i = str.search(/p/i);\n    if (i > 0) {\n        p = +str.slice(i + 1);\n        str = str.substring(2, i);\n    } else {\n        str = str.slice(2);\n    }\n    // Convert `str` as an integer then divide the result by `base` raised to a power such that the\n    // fraction part will be restored.\n    i = str.indexOf(\".\");\n    isFloat = i >= 0;\n    Ctor = x.constructor;\n    if (isFloat) {\n        str = str.replace(\".\", \"\");\n        len = str.length;\n        i = len - i;\n        // log[10](16) = 1.2041... , log[10](88) = 1.9444....\n        divisor = intPow(Ctor, new Ctor(base), i, i * 2);\n    }\n    xd = convertBase(str, base, BASE);\n    xe = xd.length - 1;\n    // Remove trailing zeros.\n    for(i = xe; xd[i] === 0; --i)xd.pop();\n    if (i < 0) return new Ctor(x.s * 0);\n    x.e = getBase10Exponent(xd, xe);\n    x.d = xd;\n    external = false;\n    // At what precision to perform the division to ensure exact conversion?\n    // maxDecimalIntegerPartDigitCount = ceil(log[10](b) * otherBaseIntegerPartDigitCount)\n    // log[10](2) = 0.30103, log[10](8) = 0.90309, log[10](16) = 1.20412\n    // E.g. ceil(1.2 * 3) = 4, so up to 4 decimal digits are needed to represent 3 hex int digits.\n    // maxDecimalFractionPartDigitCount = {Hex:4|Oct:3|Bin:1} * otherBaseFractionPartDigitCount\n    // Therefore using 4 * the number of digits of str will always be enough.\n    if (isFloat) x = divide(x, divisor, len * 4);\n    // Multiply by the binary exponent part if present.\n    if (p) x = x.times(Math.abs(p) < 54 ? mathpow(2, p) : Decimal.pow(2, p));\n    external = true;\n    return x;\n}\n/*\r\n * sin(x) = x - x^3/3! + x^5/5! - ...\r\n * |x| < pi/2\r\n *\r\n */ function sine(Ctor, x) {\n    var k, len = x.d.length;\n    if (len < 3) {\n        return x.isZero() ? x : taylorSeries(Ctor, 2, x, x);\n    }\n    // Argument reduction: sin(5x) = 16*sin^5(x) - 20*sin^3(x) + 5*sin(x)\n    // i.e. sin(x) = 16*sin^5(x/5) - 20*sin^3(x/5) + 5*sin(x/5)\n    // and  sin(x) = sin(x/5)(5 + sin^2(x/5)(16sin^2(x/5) - 20))\n    // Estimate the optimum number of times to use the argument reduction.\n    k = 1.4 * Math.sqrt(len);\n    k = k > 16 ? 16 : k | 0;\n    x = x.times(1 / tinyPow(5, k));\n    x = taylorSeries(Ctor, 2, x, x);\n    // Reverse argument reduction\n    var sin2_x, d5 = new Ctor(5), d16 = new Ctor(16), d20 = new Ctor(20);\n    for(; k--;){\n        sin2_x = x.times(x);\n        x = x.times(d5.plus(sin2_x.times(d16.times(sin2_x).minus(d20))));\n    }\n    return x;\n}\n// Calculate Taylor series for `cos`, `cosh`, `sin` and `sinh`.\nfunction taylorSeries(Ctor, n, x, y, isHyperbolic) {\n    var j, t, u, x2, i = 1, pr = Ctor.precision, k = Math.ceil(pr / LOG_BASE);\n    external = false;\n    x2 = x.times(x);\n    u = new Ctor(y);\n    for(;;){\n        t = divide(u.times(x2), new Ctor(n++ * n++), pr, 1);\n        u = isHyperbolic ? y.plus(t) : y.minus(t);\n        y = divide(t.times(x2), new Ctor(n++ * n++), pr, 1);\n        t = u.plus(y);\n        if (t.d[k] !== void 0) {\n            for(j = k; t.d[j] === u.d[j] && j--;);\n            if (j == -1) break;\n        }\n        j = u;\n        u = y;\n        y = t;\n        t = j;\n        i++;\n    }\n    external = true;\n    t.d.length = k + 1;\n    return t;\n}\n// Exponent e must be positive and non-zero.\nfunction tinyPow(b, e) {\n    var n = b;\n    while(--e)n *= b;\n    return n;\n}\n// Return the absolute value of `x` reduced to less than or equal to half pi.\nfunction toLessThanHalfPi(Ctor, x) {\n    var t, isNeg = x.s < 0, pi = getPi(Ctor, Ctor.precision, 1), halfPi = pi.times(0.5);\n    x = x.abs();\n    if (x.lte(halfPi)) {\n        quadrant = isNeg ? 4 : 1;\n        return x;\n    }\n    t = x.divToInt(pi);\n    if (t.isZero()) {\n        quadrant = isNeg ? 3 : 2;\n    } else {\n        x = x.minus(t.times(pi));\n        // 0 <= x < pi\n        if (x.lte(halfPi)) {\n            quadrant = isOdd(t) ? isNeg ? 2 : 3 : isNeg ? 4 : 1;\n            return x;\n        }\n        quadrant = isOdd(t) ? isNeg ? 1 : 4 : isNeg ? 3 : 2;\n    }\n    return x.minus(pi).abs();\n}\n/*\r\n * Return the value of Decimal `x` as a string in base `baseOut`.\r\n *\r\n * If the optional `sd` argument is present include a binary exponent suffix.\r\n */ function toStringBinary(x, baseOut, sd, rm) {\n    var base, e, i, k, len, roundUp, str, xd, y, Ctor = x.constructor, isExp = sd !== void 0;\n    if (isExp) {\n        checkInt32(sd, 1, MAX_DIGITS);\n        if (rm === void 0) rm = Ctor.rounding;\n        else checkInt32(rm, 0, 8);\n    } else {\n        sd = Ctor.precision;\n        rm = Ctor.rounding;\n    }\n    if (!x.isFinite()) {\n        str = nonFiniteToString(x);\n    } else {\n        str = finiteToString(x);\n        i = str.indexOf(\".\");\n        // Use exponential notation according to `toExpPos` and `toExpNeg`? No, but if required:\n        // maxBinaryExponent = floor((decimalExponent + 1) * log[2](10))\n        // minBinaryExponent = floor(decimalExponent * log[2](10))\n        // log[2](10) = 3.321928094887362347870319429489390175864\n        if (isExp) {\n            base = 2;\n            if (baseOut == 16) {\n                sd = sd * 4 - 3;\n            } else if (baseOut == 8) {\n                sd = sd * 3 - 2;\n            }\n        } else {\n            base = baseOut;\n        }\n        // Convert the number as an integer then divide the result by its base raised to a power such\n        // that the fraction part will be restored.\n        // Non-integer.\n        if (i >= 0) {\n            str = str.replace(\".\", \"\");\n            y = new Ctor(1);\n            y.e = str.length - i;\n            y.d = convertBase(finiteToString(y), 10, base);\n            y.e = y.d.length;\n        }\n        xd = convertBase(str, 10, base);\n        e = len = xd.length;\n        // Remove trailing zeros.\n        for(; xd[--len] == 0;)xd.pop();\n        if (!xd[0]) {\n            str = isExp ? \"0p+0\" : \"0\";\n        } else {\n            if (i < 0) {\n                e--;\n            } else {\n                x = new Ctor(x);\n                x.d = xd;\n                x.e = e;\n                x = divide(x, y, sd, rm, 0, base);\n                xd = x.d;\n                e = x.e;\n                roundUp = inexact;\n            }\n            // The rounding digit, i.e. the digit after the digit that may be rounded up.\n            i = xd[sd];\n            k = base / 2;\n            roundUp = roundUp || xd[sd + 1] !== void 0;\n            roundUp = rm < 4 ? (i !== void 0 || roundUp) && (rm === 0 || rm === (x.s < 0 ? 3 : 2)) : i > k || i === k && (rm === 4 || roundUp || rm === 6 && xd[sd - 1] & 1 || rm === (x.s < 0 ? 8 : 7));\n            xd.length = sd;\n            if (roundUp) {\n                // Rounding up may mean the previous digit has to be rounded up and so on.\n                for(; ++xd[--sd] > base - 1;){\n                    xd[sd] = 0;\n                    if (!sd) {\n                        ++e;\n                        xd.unshift(1);\n                    }\n                }\n            }\n            // Determine trailing zeros.\n            for(len = xd.length; !xd[len - 1]; --len);\n            // E.g. [4, 11, 15] becomes 4bf.\n            for(i = 0, str = \"\"; i < len; i++)str += NUMERALS.charAt(xd[i]);\n            // Add binary exponent suffix?\n            if (isExp) {\n                if (len > 1) {\n                    if (baseOut == 16 || baseOut == 8) {\n                        i = baseOut == 16 ? 4 : 3;\n                        for(--len; len % i; len++)str += \"0\";\n                        xd = convertBase(str, base, baseOut);\n                        for(len = xd.length; !xd[len - 1]; --len);\n                        // xd[0] will always be be 1\n                        for(i = 1, str = \"1.\"; i < len; i++)str += NUMERALS.charAt(xd[i]);\n                    } else {\n                        str = str.charAt(0) + \".\" + str.slice(1);\n                    }\n                }\n                str = str + (e < 0 ? \"p\" : \"p+\") + e;\n            } else if (e < 0) {\n                for(; ++e;)str = \"0\" + str;\n                str = \"0.\" + str;\n            } else {\n                if (++e > len) for(e -= len; e--;)str += \"0\";\n                else if (e < len) str = str.slice(0, e) + \".\" + str.slice(e);\n            }\n        }\n        str = (baseOut == 16 ? \"0x\" : baseOut == 2 ? \"0b\" : baseOut == 8 ? \"0o\" : \"\") + str;\n    }\n    return x.s < 0 ? \"-\" + str : str;\n}\n// Does not strip trailing zeros.\nfunction truncate(arr, len) {\n    if (arr.length > len) {\n        arr.length = len;\n        return true;\n    }\n}\n// Decimal methods\n/*\r\n *  abs\r\n *  acos\r\n *  acosh\r\n *  add\r\n *  asin\r\n *  asinh\r\n *  atan\r\n *  atanh\r\n *  atan2\r\n *  cbrt\r\n *  ceil\r\n *  clamp\r\n *  clone\r\n *  config\r\n *  cos\r\n *  cosh\r\n *  div\r\n *  exp\r\n *  floor\r\n *  hypot\r\n *  ln\r\n *  log\r\n *  log2\r\n *  log10\r\n *  max\r\n *  min\r\n *  mod\r\n *  mul\r\n *  pow\r\n *  random\r\n *  round\r\n *  set\r\n *  sign\r\n *  sin\r\n *  sinh\r\n *  sqrt\r\n *  sub\r\n *  sum\r\n *  tan\r\n *  tanh\r\n *  trunc\r\n */ /*\r\n * Return a new Decimal whose value is the absolute value of `x`.\r\n *\r\n * x {number|string|Decimal}\r\n *\r\n */ function abs(x) {\n    return new this(x).abs();\n}\n/*\r\n * Return a new Decimal whose value is the arccosine in radians of `x`.\r\n *\r\n * x {number|string|Decimal}\r\n *\r\n */ function acos(x) {\n    return new this(x).acos();\n}\n/*\r\n * Return a new Decimal whose value is the inverse of the hyperbolic cosine of `x`, rounded to\r\n * `precision` significant digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal} A value in radians.\r\n *\r\n */ function acosh(x) {\n    return new this(x).acosh();\n}\n/*\r\n * Return a new Decimal whose value is the sum of `x` and `y`, rounded to `precision` significant\r\n * digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal}\r\n * y {number|string|Decimal}\r\n *\r\n */ function add(x, y) {\n    return new this(x).plus(y);\n}\n/*\r\n * Return a new Decimal whose value is the arcsine in radians of `x`, rounded to `precision`\r\n * significant digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal}\r\n *\r\n */ function asin(x) {\n    return new this(x).asin();\n}\n/*\r\n * Return a new Decimal whose value is the inverse of the hyperbolic sine of `x`, rounded to\r\n * `precision` significant digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal} A value in radians.\r\n *\r\n */ function asinh(x) {\n    return new this(x).asinh();\n}\n/*\r\n * Return a new Decimal whose value is the arctangent in radians of `x`, rounded to `precision`\r\n * significant digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal}\r\n *\r\n */ function atan(x) {\n    return new this(x).atan();\n}\n/*\r\n * Return a new Decimal whose value is the inverse of the hyperbolic tangent of `x`, rounded to\r\n * `precision` significant digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal} A value in radians.\r\n *\r\n */ function atanh(x) {\n    return new this(x).atanh();\n}\n/*\r\n * Return a new Decimal whose value is the arctangent in radians of `y/x` in the range -pi to pi\r\n * (inclusive), rounded to `precision` significant digits using rounding mode `rounding`.\r\n *\r\n * Domain: [-Infinity, Infinity]\r\n * Range: [-pi, pi]\r\n *\r\n * y {number|string|Decimal} The y-coordinate.\r\n * x {number|string|Decimal} The x-coordinate.\r\n *\r\n * atan2(±0, -0)               = ±pi\r\n * atan2(±0, +0)               = ±0\r\n * atan2(±0, -x)               = ±pi for x > 0\r\n * atan2(±0, x)                = ±0 for x > 0\r\n * atan2(-y, ±0)               = -pi/2 for y > 0\r\n * atan2(y, ±0)                = pi/2 for y > 0\r\n * atan2(±y, -Infinity)        = ±pi for finite y > 0\r\n * atan2(±y, +Infinity)        = ±0 for finite y > 0\r\n * atan2(±Infinity, x)         = ±pi/2 for finite x\r\n * atan2(±Infinity, -Infinity) = ±3*pi/4\r\n * atan2(±Infinity, +Infinity) = ±pi/4\r\n * atan2(NaN, x) = NaN\r\n * atan2(y, NaN) = NaN\r\n *\r\n */ function atan2(y, x) {\n    y = new this(y);\n    x = new this(x);\n    var r, pr = this.precision, rm = this.rounding, wpr = pr + 4;\n    // Either NaN\n    if (!y.s || !x.s) {\n        r = new this(NaN);\n    // Both ±Infinity\n    } else if (!y.d && !x.d) {\n        r = getPi(this, wpr, 1).times(x.s > 0 ? 0.25 : 0.75);\n        r.s = y.s;\n    // x is ±Infinity or y is ±0\n    } else if (!x.d || y.isZero()) {\n        r = x.s < 0 ? getPi(this, pr, rm) : new this(0);\n        r.s = y.s;\n    // y is ±Infinity or x is ±0\n    } else if (!y.d || x.isZero()) {\n        r = getPi(this, wpr, 1).times(0.5);\n        r.s = y.s;\n    // Both non-zero and finite\n    } else if (x.s < 0) {\n        this.precision = wpr;\n        this.rounding = 1;\n        r = this.atan(divide(y, x, wpr, 1));\n        x = getPi(this, wpr, 1);\n        this.precision = pr;\n        this.rounding = rm;\n        r = y.s < 0 ? r.minus(x) : r.plus(x);\n    } else {\n        r = this.atan(divide(y, x, wpr, 1));\n    }\n    return r;\n}\n/*\r\n * Return a new Decimal whose value is the cube root of `x`, rounded to `precision` significant\r\n * digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal}\r\n *\r\n */ function cbrt(x) {\n    return new this(x).cbrt();\n}\n/*\r\n * Return a new Decimal whose value is `x` rounded to an integer using `ROUND_CEIL`.\r\n *\r\n * x {number|string|Decimal}\r\n *\r\n */ function ceil(x) {\n    return finalise(x = new this(x), x.e + 1, 2);\n}\n/*\r\n * Return a new Decimal whose value is `x` clamped to the range delineated by `min` and `max`.\r\n *\r\n * x {number|string|Decimal}\r\n * min {number|string|Decimal}\r\n * max {number|string|Decimal}\r\n *\r\n */ function clamp(x, min, max) {\n    return new this(x).clamp(min, max);\n}\n/*\r\n * Configure global settings for a Decimal constructor.\r\n *\r\n * `obj` is an object with one or more of the following properties,\r\n *\r\n *   precision  {number}\r\n *   rounding   {number}\r\n *   toExpNeg   {number}\r\n *   toExpPos   {number}\r\n *   maxE       {number}\r\n *   minE       {number}\r\n *   modulo     {number}\r\n *   crypto     {boolean|number}\r\n *   defaults   {true}\r\n *\r\n * E.g. Decimal.config({ precision: 20, rounding: 4 })\r\n *\r\n */ function config(obj) {\n    if (!obj || typeof obj !== \"object\") throw Error(decimalError + \"Object expected\");\n    var i, p, v, useDefaults = obj.defaults === true, ps = [\n        \"precision\",\n        1,\n        MAX_DIGITS,\n        \"rounding\",\n        0,\n        8,\n        \"toExpNeg\",\n        -EXP_LIMIT,\n        0,\n        \"toExpPos\",\n        0,\n        EXP_LIMIT,\n        \"maxE\",\n        0,\n        EXP_LIMIT,\n        \"minE\",\n        -EXP_LIMIT,\n        0,\n        \"modulo\",\n        0,\n        9\n    ];\n    for(i = 0; i < ps.length; i += 3){\n        if (p = ps[i], useDefaults) this[p] = DEFAULTS[p];\n        if ((v = obj[p]) !== void 0) {\n            if (mathfloor(v) === v && v >= ps[i + 1] && v <= ps[i + 2]) this[p] = v;\n            else throw Error(invalidArgument + p + \": \" + v);\n        }\n    }\n    if (p = \"crypto\", useDefaults) this[p] = DEFAULTS[p];\n    if ((v = obj[p]) !== void 0) {\n        if (v === true || v === false || v === 0 || v === 1) {\n            if (v) {\n                if (typeof crypto != \"undefined\" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {\n                    this[p] = true;\n                } else {\n                    throw Error(cryptoUnavailable);\n                }\n            } else {\n                this[p] = false;\n            }\n        } else {\n            throw Error(invalidArgument + p + \": \" + v);\n        }\n    }\n    return this;\n}\n/*\r\n * Return a new Decimal whose value is the cosine of `x`, rounded to `precision` significant\r\n * digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal} A value in radians.\r\n *\r\n */ function cos(x) {\n    return new this(x).cos();\n}\n/*\r\n * Return a new Decimal whose value is the hyperbolic cosine of `x`, rounded to precision\r\n * significant digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal} A value in radians.\r\n *\r\n */ function cosh(x) {\n    return new this(x).cosh();\n}\n/*\r\n * Create and return a Decimal constructor with the same configuration properties as this Decimal\r\n * constructor.\r\n *\r\n */ function clone(obj) {\n    var i, p, ps;\n    /*\r\n   * The Decimal constructor and exported function.\r\n   * Return a new Decimal instance.\r\n   *\r\n   * v {number|string|Decimal} A numeric value.\r\n   *\r\n   */ function Decimal(v) {\n        var e, i, t, x = this;\n        // Decimal called without new.\n        if (!(x instanceof Decimal)) return new Decimal(v);\n        // Retain a reference to this Decimal constructor, and shadow Decimal.prototype.constructor\n        // which points to Object.\n        x.constructor = Decimal;\n        // Duplicate.\n        if (isDecimalInstance(v)) {\n            x.s = v.s;\n            if (external) {\n                if (!v.d || v.e > Decimal.maxE) {\n                    // Infinity.\n                    x.e = NaN;\n                    x.d = null;\n                } else if (v.e < Decimal.minE) {\n                    // Zero.\n                    x.e = 0;\n                    x.d = [\n                        0\n                    ];\n                } else {\n                    x.e = v.e;\n                    x.d = v.d.slice();\n                }\n            } else {\n                x.e = v.e;\n                x.d = v.d ? v.d.slice() : v.d;\n            }\n            return;\n        }\n        t = typeof v;\n        if (t === \"number\") {\n            if (v === 0) {\n                x.s = 1 / v < 0 ? -1 : 1;\n                x.e = 0;\n                x.d = [\n                    0\n                ];\n                return;\n            }\n            if (v < 0) {\n                v = -v;\n                x.s = -1;\n            } else {\n                x.s = 1;\n            }\n            // Fast path for small integers.\n            if (v === ~~v && v < 1e7) {\n                for(e = 0, i = v; i >= 10; i /= 10)e++;\n                if (external) {\n                    if (e > Decimal.maxE) {\n                        x.e = NaN;\n                        x.d = null;\n                    } else if (e < Decimal.minE) {\n                        x.e = 0;\n                        x.d = [\n                            0\n                        ];\n                    } else {\n                        x.e = e;\n                        x.d = [\n                            v\n                        ];\n                    }\n                } else {\n                    x.e = e;\n                    x.d = [\n                        v\n                    ];\n                }\n                return;\n            // Infinity, NaN.\n            } else if (v * 0 !== 0) {\n                if (!v) x.s = NaN;\n                x.e = NaN;\n                x.d = null;\n                return;\n            }\n            return parseDecimal(x, v.toString());\n        } else if (t !== \"string\") {\n            throw Error(invalidArgument + v);\n        }\n        // Minus sign?\n        if ((i = v.charCodeAt(0)) === 45) {\n            v = v.slice(1);\n            x.s = -1;\n        } else {\n            // Plus sign?\n            if (i === 43) v = v.slice(1);\n            x.s = 1;\n        }\n        return isDecimal.test(v) ? parseDecimal(x, v) : parseOther(x, v);\n    }\n    Decimal.prototype = P;\n    Decimal.ROUND_UP = 0;\n    Decimal.ROUND_DOWN = 1;\n    Decimal.ROUND_CEIL = 2;\n    Decimal.ROUND_FLOOR = 3;\n    Decimal.ROUND_HALF_UP = 4;\n    Decimal.ROUND_HALF_DOWN = 5;\n    Decimal.ROUND_HALF_EVEN = 6;\n    Decimal.ROUND_HALF_CEIL = 7;\n    Decimal.ROUND_HALF_FLOOR = 8;\n    Decimal.EUCLID = 9;\n    Decimal.config = Decimal.set = config;\n    Decimal.clone = clone;\n    Decimal.isDecimal = isDecimalInstance;\n    Decimal.abs = abs;\n    Decimal.acos = acos;\n    Decimal.acosh = acosh; // ES6\n    Decimal.add = add;\n    Decimal.asin = asin;\n    Decimal.asinh = asinh; // ES6\n    Decimal.atan = atan;\n    Decimal.atanh = atanh; // ES6\n    Decimal.atan2 = atan2;\n    Decimal.cbrt = cbrt; // ES6\n    Decimal.ceil = ceil;\n    Decimal.clamp = clamp;\n    Decimal.cos = cos;\n    Decimal.cosh = cosh; // ES6\n    Decimal.div = div;\n    Decimal.exp = exp;\n    Decimal.floor = floor;\n    Decimal.hypot = hypot; // ES6\n    Decimal.ln = ln;\n    Decimal.log = log;\n    Decimal.log10 = log10; // ES6\n    Decimal.log2 = log2; // ES6\n    Decimal.max = max;\n    Decimal.min = min;\n    Decimal.mod = mod;\n    Decimal.mul = mul;\n    Decimal.pow = pow;\n    Decimal.random = random;\n    Decimal.round = round;\n    Decimal.sign = sign; // ES6\n    Decimal.sin = sin;\n    Decimal.sinh = sinh; // ES6\n    Decimal.sqrt = sqrt;\n    Decimal.sub = sub;\n    Decimal.sum = sum;\n    Decimal.tan = tan;\n    Decimal.tanh = tanh; // ES6\n    Decimal.trunc = trunc; // ES6\n    if (obj === void 0) obj = {};\n    if (obj) {\n        if (obj.defaults !== true) {\n            ps = [\n                \"precision\",\n                \"rounding\",\n                \"toExpNeg\",\n                \"toExpPos\",\n                \"maxE\",\n                \"minE\",\n                \"modulo\",\n                \"crypto\"\n            ];\n            for(i = 0; i < ps.length;)if (!obj.hasOwnProperty(p = ps[i++])) obj[p] = this[p];\n        }\n    }\n    Decimal.config(obj);\n    return Decimal;\n}\n/*\r\n * Return a new Decimal whose value is `x` divided by `y`, rounded to `precision` significant\r\n * digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal}\r\n * y {number|string|Decimal}\r\n *\r\n */ function div(x, y) {\n    return new this(x).div(y);\n}\n/*\r\n * Return a new Decimal whose value is the natural exponential of `x`, rounded to `precision`\r\n * significant digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal} The power to which to raise the base of the natural log.\r\n *\r\n */ function exp(x) {\n    return new this(x).exp();\n}\n/*\r\n * Return a new Decimal whose value is `x` round to an integer using `ROUND_FLOOR`.\r\n *\r\n * x {number|string|Decimal}\r\n *\r\n */ function floor(x) {\n    return finalise(x = new this(x), x.e + 1, 3);\n}\n/*\r\n * Return a new Decimal whose value is the square root of the sum of the squares of the arguments,\r\n * rounded to `precision` significant digits using rounding mode `rounding`.\r\n *\r\n * hypot(a, b, ...) = sqrt(a^2 + b^2 + ...)\r\n *\r\n * arguments {number|string|Decimal}\r\n *\r\n */ function hypot() {\n    var i, n, t = new this(0);\n    external = false;\n    for(i = 0; i < arguments.length;){\n        n = new this(arguments[i++]);\n        if (!n.d) {\n            if (n.s) {\n                external = true;\n                return new this(1 / 0);\n            }\n            t = n;\n        } else if (t.d) {\n            t = t.plus(n.times(n));\n        }\n    }\n    external = true;\n    return t.sqrt();\n}\n/*\r\n * Return true if object is a Decimal instance (where Decimal is any Decimal constructor),\r\n * otherwise return false.\r\n *\r\n */ function isDecimalInstance(obj) {\n    return obj instanceof Decimal || obj && obj.toStringTag === tag || false;\n}\n/*\r\n * Return a new Decimal whose value is the natural logarithm of `x`, rounded to `precision`\r\n * significant digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal}\r\n *\r\n */ function ln(x) {\n    return new this(x).ln();\n}\n/*\r\n * Return a new Decimal whose value is the log of `x` to the base `y`, or to base 10 if no base\r\n * is specified, rounded to `precision` significant digits using rounding mode `rounding`.\r\n *\r\n * log[y](x)\r\n *\r\n * x {number|string|Decimal} The argument of the logarithm.\r\n * y {number|string|Decimal} The base of the logarithm.\r\n *\r\n */ function log(x, y) {\n    return new this(x).log(y);\n}\n/*\r\n * Return a new Decimal whose value is the base 2 logarithm of `x`, rounded to `precision`\r\n * significant digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal}\r\n *\r\n */ function log2(x) {\n    return new this(x).log(2);\n}\n/*\r\n * Return a new Decimal whose value is the base 10 logarithm of `x`, rounded to `precision`\r\n * significant digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal}\r\n *\r\n */ function log10(x) {\n    return new this(x).log(10);\n}\n/*\r\n * Return a new Decimal whose value is the maximum of the arguments.\r\n *\r\n * arguments {number|string|Decimal}\r\n *\r\n */ function max() {\n    return maxOrMin(this, arguments, \"lt\");\n}\n/*\r\n * Return a new Decimal whose value is the minimum of the arguments.\r\n *\r\n * arguments {number|string|Decimal}\r\n *\r\n */ function min() {\n    return maxOrMin(this, arguments, \"gt\");\n}\n/*\r\n * Return a new Decimal whose value is `x` modulo `y`, rounded to `precision` significant digits\r\n * using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal}\r\n * y {number|string|Decimal}\r\n *\r\n */ function mod(x, y) {\n    return new this(x).mod(y);\n}\n/*\r\n * Return a new Decimal whose value is `x` multiplied by `y`, rounded to `precision` significant\r\n * digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal}\r\n * y {number|string|Decimal}\r\n *\r\n */ function mul(x, y) {\n    return new this(x).mul(y);\n}\n/*\r\n * Return a new Decimal whose value is `x` raised to the power `y`, rounded to precision\r\n * significant digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal} The base.\r\n * y {number|string|Decimal} The exponent.\r\n *\r\n */ function pow(x, y) {\n    return new this(x).pow(y);\n}\n/*\r\n * Returns a new Decimal with a random value equal to or greater than 0 and less than 1, and with\r\n * `sd`, or `Decimal.precision` if `sd` is omitted, significant digits (or less if trailing zeros\r\n * are produced).\r\n *\r\n * [sd] {number} Significant digits. Integer, 0 to MAX_DIGITS inclusive.\r\n *\r\n */ function random(sd) {\n    var d, e, k, n, i = 0, r = new this(1), rd = [];\n    if (sd === void 0) sd = this.precision;\n    else checkInt32(sd, 1, MAX_DIGITS);\n    k = Math.ceil(sd / LOG_BASE);\n    if (!this.crypto) {\n        for(; i < k;)rd[i++] = Math.random() * 1e7 | 0;\n    // Browsers supporting crypto.getRandomValues.\n    } else if (crypto.getRandomValues) {\n        d = crypto.getRandomValues(new Uint32Array(k));\n        for(; i < k;){\n            n = d[i];\n            // 0 <= n < 4294967296\n            // Probability n >= 4.29e9, is 4967296 / 4294967296 = 0.00116 (1 in 865).\n            if (n >= 4.29e9) {\n                d[i] = crypto.getRandomValues(new Uint32Array(1))[0];\n            } else {\n                // 0 <= n <= 4289999999\n                // 0 <= (n % 1e7) <= 9999999\n                rd[i++] = n % 1e7;\n            }\n        }\n    // Node.js supporting crypto.randomBytes.\n    } else if (crypto.randomBytes) {\n        // buffer\n        d = crypto.randomBytes(k *= 4);\n        for(; i < k;){\n            // 0 <= n < 2147483648\n            n = d[i] + (d[i + 1] << 8) + (d[i + 2] << 16) + ((d[i + 3] & 0x7f) << 24);\n            // Probability n >= 2.14e9, is 7483648 / 2147483648 = 0.0035 (1 in 286).\n            if (n >= 2.14e9) {\n                crypto.randomBytes(4).copy(d, i);\n            } else {\n                // 0 <= n <= 2139999999\n                // 0 <= (n % 1e7) <= 9999999\n                rd.push(n % 1e7);\n                i += 4;\n            }\n        }\n        i = k / 4;\n    } else {\n        throw Error(cryptoUnavailable);\n    }\n    k = rd[--i];\n    sd %= LOG_BASE;\n    // Convert trailing digits to zeros according to sd.\n    if (k && sd) {\n        n = mathpow(10, LOG_BASE - sd);\n        rd[i] = (k / n | 0) * n;\n    }\n    // Remove trailing words which are zero.\n    for(; rd[i] === 0; i--)rd.pop();\n    // Zero?\n    if (i < 0) {\n        e = 0;\n        rd = [\n            0\n        ];\n    } else {\n        e = -1;\n        // Remove leading words which are zero and adjust exponent accordingly.\n        for(; rd[0] === 0; e -= LOG_BASE)rd.shift();\n        // Count the digits of the first word of rd to determine leading zeros.\n        for(k = 1, n = rd[0]; n >= 10; n /= 10)k++;\n        // Adjust the exponent for leading zeros of the first word of rd.\n        if (k < LOG_BASE) e -= LOG_BASE - k;\n    }\n    r.e = e;\n    r.d = rd;\n    return r;\n}\n/*\r\n * Return a new Decimal whose value is `x` rounded to an integer using rounding mode `rounding`.\r\n *\r\n * To emulate `Math.round`, set rounding to 7 (ROUND_HALF_CEIL).\r\n *\r\n * x {number|string|Decimal}\r\n *\r\n */ function round(x) {\n    return finalise(x = new this(x), x.e + 1, this.rounding);\n}\n/*\r\n * Return\r\n *   1    if x > 0,\r\n *  -1    if x < 0,\r\n *   0    if x is 0,\r\n *  -0    if x is -0,\r\n *   NaN  otherwise\r\n *\r\n * x {number|string|Decimal}\r\n *\r\n */ function sign(x) {\n    x = new this(x);\n    return x.d ? x.d[0] ? x.s : 0 * x.s : x.s || NaN;\n}\n/*\r\n * Return a new Decimal whose value is the sine of `x`, rounded to `precision` significant digits\r\n * using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal} A value in radians.\r\n *\r\n */ function sin(x) {\n    return new this(x).sin();\n}\n/*\r\n * Return a new Decimal whose value is the hyperbolic sine of `x`, rounded to `precision`\r\n * significant digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal} A value in radians.\r\n *\r\n */ function sinh(x) {\n    return new this(x).sinh();\n}\n/*\r\n * Return a new Decimal whose value is the square root of `x`, rounded to `precision` significant\r\n * digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal}\r\n *\r\n */ function sqrt(x) {\n    return new this(x).sqrt();\n}\n/*\r\n * Return a new Decimal whose value is `x` minus `y`, rounded to `precision` significant digits\r\n * using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal}\r\n * y {number|string|Decimal}\r\n *\r\n */ function sub(x, y) {\n    return new this(x).sub(y);\n}\n/*\r\n * Return a new Decimal whose value is the sum of the arguments, rounded to `precision`\r\n * significant digits using rounding mode `rounding`.\r\n *\r\n * Only the result is rounded, not the intermediate calculations.\r\n *\r\n * arguments {number|string|Decimal}\r\n *\r\n */ function sum() {\n    var i = 0, args = arguments, x = new this(args[i]);\n    external = false;\n    for(; x.s && ++i < args.length;)x = x.plus(args[i]);\n    external = true;\n    return finalise(x, this.precision, this.rounding);\n}\n/*\r\n * Return a new Decimal whose value is the tangent of `x`, rounded to `precision` significant\r\n * digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal} A value in radians.\r\n *\r\n */ function tan(x) {\n    return new this(x).tan();\n}\n/*\r\n * Return a new Decimal whose value is the hyperbolic tangent of `x`, rounded to `precision`\r\n * significant digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|Decimal} A value in radians.\r\n *\r\n */ function tanh(x) {\n    return new this(x).tanh();\n}\n/*\r\n * Return a new Decimal whose value is `x` truncated to an integer.\r\n *\r\n * x {number|string|Decimal}\r\n *\r\n */ function trunc(x) {\n    return finalise(x = new this(x), x.e + 1, 1);\n}\nP[Symbol.for(\"nodejs.util.inspect.custom\")] = P.toString;\nP[Symbol.toStringTag] = \"Decimal\";\n// Create and configure initial Decimal constructor.\nvar Decimal = P.constructor = clone(DEFAULTS);\n// Create the internal constants from their string values.\nLN10 = new Decimal(LN10);\nPI = new Decimal(PI);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Decimal);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2RlY2ltYWwuanNAMTAuNC4zL25vZGVfbW9kdWxlcy9kZWNpbWFsLmpzL2RlY2ltYWwubWpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7Ozs7OztDQU1DLEdBR0Qsa0dBQWtHO0FBR2hHLGtDQUFrQztBQUNsQyx1RUFBdUU7QUFDekUsSUFBSUEsWUFBWSxNQUVkLG1GQUFtRjtBQUNuRiwwRkFBMEY7QUFDMUZDLGFBQWEsS0FFYiw0QkFBNEI7QUFDNUJDLFdBQVcsb0JBRVgsNkNBQTZDO0FBQzdDQyxPQUFPLHNnQ0FFUCxvQkFBb0I7QUFDcEJDLEtBQUssc2dDQUdMLG1FQUFtRTtBQUNuRUMsV0FBVztJQUVULHNFQUFzRTtJQUN0RSxxRkFBcUY7SUFFckYsOEZBQThGO0lBQzlGLDRDQUE0QztJQUM1Q0MsV0FBVztJQUVYLHVEQUF1RDtJQUN2RCxFQUFFO0lBQ0YscUNBQXFDO0lBQ3JDLG1DQUFtQztJQUNuQyx3Q0FBd0M7SUFDeEMsd0NBQXdDO0lBQ3hDLG9FQUFvRTtJQUNwRSxzRUFBc0U7SUFDdEUsd0ZBQXdGO0lBQ3hGLG1GQUFtRjtJQUNuRixtRkFBbUY7SUFDbkYsRUFBRTtJQUNGLE9BQU87SUFDUCwwQkFBMEI7SUFDMUIsOENBQThDO0lBQzlDQyxVQUFVO0lBRVYsOERBQThEO0lBQzlELHVGQUF1RjtJQUN2RixxREFBcUQ7SUFDckQsRUFBRTtJQUNGLHdGQUF3RjtJQUN4RiwrRUFBK0U7SUFDL0UsMEVBQTBFO0lBQzFFLGdEQUFnRDtJQUNoRCxxRkFBcUY7SUFDckYsRUFBRTtJQUNGLDBGQUEwRjtJQUMxRiw4RkFBOEY7SUFDOUYsaURBQWlEO0lBQ2pEQyxRQUFRO0lBRVIsbUZBQW1GO0lBQ25GLHlCQUF5QjtJQUN6QkMsVUFBVSxDQUFDO0lBRVgsaUZBQWlGO0lBQ2pGLHlCQUF5QjtJQUN6QkMsVUFBVztJQUVYLHNFQUFzRTtJQUN0RSxxQ0FBcUM7SUFDckNDLE1BQU0sQ0FBQ1g7SUFFUCx1RUFBdUU7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MERBQTBEO0FBQzFERixPQUFPLElBQUk2UixRQUFRN1I7QUFDbkJDLEtBQUssSUFBSTRSLFFBQVE1UjtBQUVqQixpRUFBZTRSLE9BQU9BLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2RlY2ltYWwuanNAMTAuNC4zL25vZGVfbW9kdWxlcy9kZWNpbWFsLmpzL2RlY2ltYWwubWpzP2FlZWYiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXHJcbiAqICBkZWNpbWFsLmpzIHYxMC40LjNcclxuICogIEFuIGFyYml0cmFyeS1wcmVjaXNpb24gRGVjaW1hbCB0eXBlIGZvciBKYXZhU2NyaXB0LlxyXG4gKiAgaHR0cHM6Ly9naXRodWIuY29tL01pa2VNY2wvZGVjaW1hbC5qc1xyXG4gKiAgQ29weXJpZ2h0IChjKSAyMDIyIE1pY2hhZWwgTWNsYXVnaGxpbiA8TThjaDg4bEBnbWFpbC5jb20+XHJcbiAqICBNSVQgTGljZW5jZVxyXG4gKi9cclxuXHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAgRURJVEFCTEUgREVGQVVMVFMgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xyXG5cclxuXHJcbiAgLy8gVGhlIG1heGltdW0gZXhwb25lbnQgbWFnbml0dWRlLlxyXG4gIC8vIFRoZSBsaW1pdCBvbiB0aGUgdmFsdWUgb2YgYHRvRXhwTmVnYCwgYHRvRXhwUG9zYCwgYG1pbkVgIGFuZCBgbWF4RWAuXHJcbnZhciBFWFBfTElNSVQgPSA5ZTE1LCAgICAgICAgICAgICAgICAgICAgICAvLyAwIHRvIDllMTVcclxuXHJcbiAgLy8gVGhlIGxpbWl0IG9uIHRoZSB2YWx1ZSBvZiBgcHJlY2lzaW9uYCwgYW5kIG9uIHRoZSB2YWx1ZSBvZiB0aGUgZmlyc3QgYXJndW1lbnQgdG9cclxuICAvLyBgdG9EZWNpbWFsUGxhY2VzYCwgYHRvRXhwb25lbnRpYWxgLCBgdG9GaXhlZGAsIGB0b1ByZWNpc2lvbmAgYW5kIGB0b1NpZ25pZmljYW50RGlnaXRzYC5cclxuICBNQVhfRElHSVRTID0gMWU5LCAgICAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gMWU5XHJcblxyXG4gIC8vIEJhc2UgY29udmVyc2lvbiBhbHBoYWJldC5cclxuICBOVU1FUkFMUyA9ICcwMTIzNDU2Nzg5YWJjZGVmJyxcclxuXHJcbiAgLy8gVGhlIG5hdHVyYWwgbG9nYXJpdGhtIG9mIDEwICgxMDI1IGRpZ2l0cykuXHJcbiAgTE4xMCA9ICcyLjMwMjU4NTA5Mjk5NDA0NTY4NDAxNzk5MTQ1NDY4NDM2NDIwNzYwMTEwMTQ4ODYyODc3Mjk3NjAzMzMyNzkwMDk2NzU3MjYwOTY3NzM1MjQ4MDIzNTk5NzIwNTA4OTU5ODI5ODM0MTk2Nzc4NDA0MjI4NjI0ODYzMzQwOTUyNTQ2NTA4MjgwNjc1NjY2NjI4NzM2OTA5ODc4MTY4OTQ4MjkwNzIwODMyNTU1NDY4MDg0Mzc5OTg5NDgyNjIzMzE5ODUyODM5MzUwNTMwODk2NTM3NzczMjYyODg0NjE2MzM2NjIyMjI4NzY5ODIxOTg4Njc0NjU0MzY2NzQ3NDQwNDI0MzI3NDM2NTE1NTA0ODkzNDMxNDkzOTM5MTQ3OTYxOTQwNDQwMDIyMjEwNTEwMTcxNDE3NDgwMDM2ODgwODQwMTI2NDcwODA2ODU1Njc3NDMyMTYyMjgzNTUyMjAxMTQ4MDQ2NjM3MTU2NTkxMjEzNzM0NTA3NDc4NTY5NDc2ODM0NjM2MTY3OTIxMDE4MDY0NDUwNzA2NDgwMDAyNzc1MDI2ODQ5MTY3NDY1NTA1ODY4NTY5MzU2NzM0MjA2NzA1ODExMzY0MjkyMjQ1NTQ0MDU3NTg5MjU3MjQyMDgyNDEzMTQ2OTU2ODkwMTY3NTg5NDAyNTY3NzYzMTEzNTY5MTkyOTIwMzMzNzY1ODcxNDE2NjAyMzAxMDU3MDMwODk2MzQ1NzIwNzU0NDAzNzA4NDc0Njk5NDAxNjgyNjkyODI4MDg0ODExODQyODkzMTQ4NDg1MjQ5NDg2NDQ4NzE5Mjc4MDk2NzYyNzEyNzU3NzUzOTcwMjc2Njg2MDU5NTI0OTY3MTY2NzQxODM0ODU3MDQ0MjI1MDcxOTc5NjUwMDQ3MTQ5NTEwNTA0OTIyMTQ3NzY1Njc2MzY5Mzg2NjI5NzY5Nzk1MjIxMTA3MTgyNjQ1NDk3MzQ3NzI2NjI0MjU3MDk0MjkzMjI1ODI3OTg1MDI1ODU1MDk3ODUyNjUzODMyMDc2MDY3MjYzMTcxNjQzMDk1MDU5OTUwODc4MDc1MjM3MTAzMzMxMDExOTc4NTc1NDczMzE1NDE0MjE4MDg0Mjc1NDM4NjM1OTE3NzgxMTcwNTQzMDk4Mjc0ODIzODUwNDU2NDgwMTkwOTU2MTAyOTkyOTE4MjQzMTgyMzc1MjUzNTc3MDk3NTA1Mzk1NjUxODc2OTc1MTAzNzQ5NzA4ODg2OTIxODAyMDUxODkzMzk1MDcyMzg1MzkyMDUxNDQ2MzQxOTcyNjUyODcyODY5NjUxMTA4NjI1NzE0OTIxOTg4NDk5Nzg3NDg4NzM3NzEzNDU2ODYyMDkxNjcwNTgnLFxyXG5cclxuICAvLyBQaSAoMTAyNSBkaWdpdHMpLlxyXG4gIFBJID0gJzMuMTQxNTkyNjUzNTg5NzkzMjM4NDYyNjQzMzgzMjc5NTAyODg0MTk3MTY5Mzk5Mzc1MTA1ODIwOTc0OTQ0NTkyMzA3ODE2NDA2Mjg2MjA4OTk4NjI4MDM0ODI1MzQyMTE3MDY3OTgyMTQ4MDg2NTEzMjgyMzA2NjQ3MDkzODQ0NjA5NTUwNTgyMjMxNzI1MzU5NDA4MTI4NDgxMTE3NDUwMjg0MTAyNzAxOTM4NTIxMTA1NTU5NjQ0NjIyOTQ4OTU0OTMwMzgxOTY0NDI4ODEwOTc1NjY1OTMzNDQ2MTI4NDc1NjQ4MjMzNzg2NzgzMTY1MjcxMjAxOTA5MTQ1NjQ4NTY2OTIzNDYwMzQ4NjEwNDU0MzI2NjQ4MjEzMzkzNjA3MjYwMjQ5MTQxMjczNzI0NTg3MDA2NjA2MzE1NTg4MTc0ODgxNTIwOTIwOTYyODI5MjU0MDkxNzE1MzY0MzY3ODkyNTkwMzYwMDExMzMwNTMwNTQ4ODIwNDY2NTIxMzg0MTQ2OTUxOTQxNTExNjA5NDMzMDU3MjcwMzY1NzU5NTkxOTUzMDkyMTg2MTE3MzgxOTMyNjExNzkzMTA1MTE4NTQ4MDc0NDYyMzc5OTYyNzQ5NTY3MzUxODg1NzUyNzI0ODkxMjI3OTM4MTgzMDExOTQ5MTI5ODMzNjczMzYyNDQwNjU2NjQzMDg2MDIxMzk0OTQ2Mzk1MjI0NzM3MTkwNzAyMTc5ODYwOTQzNzAyNzcwNTM5MjE3MTc2MjkzMTc2NzUyMzg0Njc0ODE4NDY3NjY5NDA1MTMyMDAwNTY4MTI3MTQ1MjYzNTYwODI3Nzg1NzcxMzQyNzU3Nzg5NjA5MTczNjM3MTc4NzIxNDY4NDQwOTAxMjI0OTUzNDMwMTQ2NTQ5NTg1MzcxMDUwNzkyMjc5Njg5MjU4OTIzNTQyMDE5OTU2MTEyMTI5MDIxOTYwODY0MDM0NDE4MTU5ODEzNjI5Nzc0NzcxMzA5OTYwNTE4NzA3MjExMzQ5OTk5OTk4MzcyOTc4MDQ5OTUxMDU5NzMxNzMyODE2MDk2MzE4NTk1MDI0NDU5NDU1MzQ2OTA4MzAyNjQyNTIyMzA4MjUzMzQ0Njg1MDM1MjYxOTMxMTg4MTcxMDEwMDAzMTM3ODM4NzUyODg2NTg3NTMzMjA4MzgxNDIwNjE3MTc3NjY5MTQ3MzAzNTk4MjUzNDkwNDI4NzU1NDY4NzMxMTU5NTYyODYzODgyMzUzNzg3NTkzNzUxOTU3NzgxODU3NzgwNTMyMTcxMjI2ODA2NjEzMDAxOTI3ODc2NjExMTk1OTA5MjE2NDIwMTk4OTM4MDk1MjU3MjAxMDY1NDg1ODYzMjc4OScsXHJcblxyXG5cclxuICAvLyBUaGUgaW5pdGlhbCBjb25maWd1cmF0aW9uIHByb3BlcnRpZXMgb2YgdGhlIERlY2ltYWwgY29uc3RydWN0b3IuXHJcbiAgREVGQVVMVFMgPSB7XHJcblxyXG4gICAgLy8gVGhlc2UgdmFsdWVzIG11c3QgYmUgaW50ZWdlcnMgd2l0aGluIHRoZSBzdGF0ZWQgcmFuZ2VzIChpbmNsdXNpdmUpLlxyXG4gICAgLy8gTW9zdCBvZiB0aGVzZSB2YWx1ZXMgY2FuIGJlIGNoYW5nZWQgYXQgcnVuLXRpbWUgdXNpbmcgdGhlIGBEZWNpbWFsLmNvbmZpZ2AgbWV0aG9kLlxyXG5cclxuICAgIC8vIFRoZSBtYXhpbXVtIG51bWJlciBvZiBzaWduaWZpY2FudCBkaWdpdHMgb2YgdGhlIHJlc3VsdCBvZiBhIGNhbGN1bGF0aW9uIG9yIGJhc2UgY29udmVyc2lvbi5cclxuICAgIC8vIEUuZy4gYERlY2ltYWwuY29uZmlnKHsgcHJlY2lzaW9uOiAyMCB9KTtgXHJcbiAgICBwcmVjaXNpb246IDIwLCAgICAgICAgICAgICAgICAgICAgICAgICAvLyAxIHRvIE1BWF9ESUdJVFNcclxuXHJcbiAgICAvLyBUaGUgcm91bmRpbmcgbW9kZSB1c2VkIHdoZW4gcm91bmRpbmcgdG8gYHByZWNpc2lvbmAuXHJcbiAgICAvL1xyXG4gICAgLy8gUk9VTkRfVVAgICAgICAgICAwIEF3YXkgZnJvbSB6ZXJvLlxyXG4gICAgLy8gUk9VTkRfRE9XTiAgICAgICAxIFRvd2FyZHMgemVyby5cclxuICAgIC8vIFJPVU5EX0NFSUwgICAgICAgMiBUb3dhcmRzICtJbmZpbml0eS5cclxuICAgIC8vIFJPVU5EX0ZMT09SICAgICAgMyBUb3dhcmRzIC1JbmZpbml0eS5cclxuICAgIC8vIFJPVU5EX0hBTEZfVVAgICAgNCBUb3dhcmRzIG5lYXJlc3QgbmVpZ2hib3VyLiBJZiBlcXVpZGlzdGFudCwgdXAuXHJcbiAgICAvLyBST1VORF9IQUxGX0RPV04gIDUgVG93YXJkcyBuZWFyZXN0IG5laWdoYm91ci4gSWYgZXF1aWRpc3RhbnQsIGRvd24uXHJcbiAgICAvLyBST1VORF9IQUxGX0VWRU4gIDYgVG93YXJkcyBuZWFyZXN0IG5laWdoYm91ci4gSWYgZXF1aWRpc3RhbnQsIHRvd2FyZHMgZXZlbiBuZWlnaGJvdXIuXHJcbiAgICAvLyBST1VORF9IQUxGX0NFSUwgIDcgVG93YXJkcyBuZWFyZXN0IG5laWdoYm91ci4gSWYgZXF1aWRpc3RhbnQsIHRvd2FyZHMgK0luZmluaXR5LlxyXG4gICAgLy8gUk9VTkRfSEFMRl9GTE9PUiA4IFRvd2FyZHMgbmVhcmVzdCBuZWlnaGJvdXIuIElmIGVxdWlkaXN0YW50LCB0b3dhcmRzIC1JbmZpbml0eS5cclxuICAgIC8vXHJcbiAgICAvLyBFLmcuXHJcbiAgICAvLyBgRGVjaW1hbC5yb3VuZGluZyA9IDQ7YFxyXG4gICAgLy8gYERlY2ltYWwucm91bmRpbmcgPSBEZWNpbWFsLlJPVU5EX0hBTEZfVVA7YFxyXG4gICAgcm91bmRpbmc6IDQsICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMCB0byA4XHJcblxyXG4gICAgLy8gVGhlIG1vZHVsbyBtb2RlIHVzZWQgd2hlbiBjYWxjdWxhdGluZyB0aGUgbW9kdWx1czogYSBtb2Qgbi5cclxuICAgIC8vIFRoZSBxdW90aWVudCAocSA9IGEgLyBuKSBpcyBjYWxjdWxhdGVkIGFjY29yZGluZyB0byB0aGUgY29ycmVzcG9uZGluZyByb3VuZGluZyBtb2RlLlxyXG4gICAgLy8gVGhlIHJlbWFpbmRlciAocikgaXMgY2FsY3VsYXRlZCBhczogciA9IGEgLSBuICogcS5cclxuICAgIC8vXHJcbiAgICAvLyBVUCAgICAgICAgIDAgVGhlIHJlbWFpbmRlciBpcyBwb3NpdGl2ZSBpZiB0aGUgZGl2aWRlbmQgaXMgbmVnYXRpdmUsIGVsc2UgaXMgbmVnYXRpdmUuXHJcbiAgICAvLyBET1dOICAgICAgIDEgVGhlIHJlbWFpbmRlciBoYXMgdGhlIHNhbWUgc2lnbiBhcyB0aGUgZGl2aWRlbmQgKEphdmFTY3JpcHQgJSkuXHJcbiAgICAvLyBGTE9PUiAgICAgIDMgVGhlIHJlbWFpbmRlciBoYXMgdGhlIHNhbWUgc2lnbiBhcyB0aGUgZGl2aXNvciAoUHl0aG9uICUpLlxyXG4gICAgLy8gSEFMRl9FVkVOICA2IFRoZSBJRUVFIDc1NCByZW1haW5kZXIgZnVuY3Rpb24uXHJcbiAgICAvLyBFVUNMSUQgICAgIDkgRXVjbGlkaWFuIGRpdmlzaW9uLiBxID0gc2lnbihuKSAqIGZsb29yKGEgLyBhYnMobikpLiBBbHdheXMgcG9zaXRpdmUuXHJcbiAgICAvL1xyXG4gICAgLy8gVHJ1bmNhdGVkIGRpdmlzaW9uICgxKSwgZmxvb3JlZCBkaXZpc2lvbiAoMyksIHRoZSBJRUVFIDc1NCByZW1haW5kZXIgKDYpLCBhbmQgRXVjbGlkaWFuXHJcbiAgICAvLyBkaXZpc2lvbiAoOSkgYXJlIGNvbW1vbmx5IHVzZWQgZm9yIHRoZSBtb2R1bHVzIG9wZXJhdGlvbi4gVGhlIG90aGVyIHJvdW5kaW5nIG1vZGVzIGNhbiBhbHNvXHJcbiAgICAvLyBiZSB1c2VkLCBidXQgdGhleSBtYXkgbm90IGdpdmUgdXNlZnVsIHJlc3VsdHMuXHJcbiAgICBtb2R1bG86IDEsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAwIHRvIDlcclxuXHJcbiAgICAvLyBUaGUgZXhwb25lbnQgdmFsdWUgYXQgYW5kIGJlbmVhdGggd2hpY2ggYHRvU3RyaW5nYCByZXR1cm5zIGV4cG9uZW50aWFsIG5vdGF0aW9uLlxyXG4gICAgLy8gSmF2YVNjcmlwdCBudW1iZXJzOiAtN1xyXG4gICAgdG9FeHBOZWc6IC03LCAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMCB0byAtRVhQX0xJTUlUXHJcblxyXG4gICAgLy8gVGhlIGV4cG9uZW50IHZhbHVlIGF0IGFuZCBhYm92ZSB3aGljaCBgdG9TdHJpbmdgIHJldHVybnMgZXhwb25lbnRpYWwgbm90YXRpb24uXHJcbiAgICAvLyBKYXZhU2NyaXB0IG51bWJlcnM6IDIxXHJcbiAgICB0b0V4cFBvczogIDIxLCAgICAgICAgICAgICAgICAgICAgICAgICAvLyAwIHRvIEVYUF9MSU1JVFxyXG5cclxuICAgIC8vIFRoZSBtaW5pbXVtIGV4cG9uZW50IHZhbHVlLCBiZW5lYXRoIHdoaWNoIHVuZGVyZmxvdyB0byB6ZXJvIG9jY3Vycy5cclxuICAgIC8vIEphdmFTY3JpcHQgbnVtYmVyczogLTMyNCAgKDVlLTMyNClcclxuICAgIG1pbkU6IC1FWFBfTElNSVQsICAgICAgICAgICAgICAgICAgICAgIC8vIC0xIHRvIC1FWFBfTElNSVRcclxuXHJcbiAgICAvLyBUaGUgbWF4aW11bSBleHBvbmVudCB2YWx1ZSwgYWJvdmUgd2hpY2ggb3ZlcmZsb3cgdG8gSW5maW5pdHkgb2NjdXJzLlxyXG4gICAgLy8gSmF2YVNjcmlwdCBudW1iZXJzOiAzMDggICgxLjc5NzY5MzEzNDg2MjMxNTdlKzMwOClcclxuICAgIG1heEU6IEVYUF9MSU1JVCwgICAgICAgICAgICAgICAgICAgICAgIC8vIDEgdG8gRVhQX0xJTUlUXHJcblxyXG4gICAgLy8gV2hldGhlciB0byB1c2UgY3J5cHRvZ3JhcGhpY2FsbHktc2VjdXJlIHJhbmRvbSBudW1iZXIgZ2VuZXJhdGlvbiwgaWYgYXZhaWxhYmxlLlxyXG4gICAgY3J5cHRvOiBmYWxzZSAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHJ1ZS9mYWxzZVxyXG4gIH0sXHJcblxyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gRU5EIE9GIEVESVRBQkxFIERFRkFVTFRTIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cclxuXHJcblxyXG4gIGluZXhhY3QsIHF1YWRyYW50LFxyXG4gIGV4dGVybmFsID0gdHJ1ZSxcclxuXHJcbiAgZGVjaW1hbEVycm9yID0gJ1tEZWNpbWFsRXJyb3JdICcsXHJcbiAgaW52YWxpZEFyZ3VtZW50ID0gZGVjaW1hbEVycm9yICsgJ0ludmFsaWQgYXJndW1lbnQ6ICcsXHJcbiAgcHJlY2lzaW9uTGltaXRFeGNlZWRlZCA9IGRlY2ltYWxFcnJvciArICdQcmVjaXNpb24gbGltaXQgZXhjZWVkZWQnLFxyXG4gIGNyeXB0b1VuYXZhaWxhYmxlID0gZGVjaW1hbEVycm9yICsgJ2NyeXB0byB1bmF2YWlsYWJsZScsXHJcbiAgdGFnID0gJ1tvYmplY3QgRGVjaW1hbF0nLFxyXG5cclxuICBtYXRoZmxvb3IgPSBNYXRoLmZsb29yLFxyXG4gIG1hdGhwb3cgPSBNYXRoLnBvdyxcclxuXHJcbiAgaXNCaW5hcnkgPSAvXjBiKFswMV0rKFxcLlswMV0qKT98XFwuWzAxXSspKHBbKy1dP1xcZCspPyQvaSxcclxuICBpc0hleCA9IC9eMHgoWzAtOWEtZl0rKFxcLlswLTlhLWZdKik/fFxcLlswLTlhLWZdKykocFsrLV0/XFxkKyk/JC9pLFxyXG4gIGlzT2N0YWwgPSAvXjBvKFswLTddKyhcXC5bMC03XSopP3xcXC5bMC03XSspKHBbKy1dP1xcZCspPyQvaSxcclxuICBpc0RlY2ltYWwgPSAvXihcXGQrKFxcLlxcZCopP3xcXC5cXGQrKShlWystXT9cXGQrKT8kL2ksXHJcblxyXG4gIEJBU0UgPSAxZTcsXHJcbiAgTE9HX0JBU0UgPSA3LFxyXG4gIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxLFxyXG5cclxuICBMTjEwX1BSRUNJU0lPTiA9IExOMTAubGVuZ3RoIC0gMSxcclxuICBQSV9QUkVDSVNJT04gPSBQSS5sZW5ndGggLSAxLFxyXG5cclxuICAvLyBEZWNpbWFsLnByb3RvdHlwZSBvYmplY3RcclxuICBQID0geyB0b1N0cmluZ1RhZzogdGFnIH07XHJcblxyXG5cclxuLy8gRGVjaW1hbCBwcm90b3R5cGUgbWV0aG9kc1xyXG5cclxuXHJcbi8qXHJcbiAqICBhYnNvbHV0ZVZhbHVlICAgICAgICAgICAgIGFic1xyXG4gKiAgY2VpbFxyXG4gKiAgY2xhbXBlZFRvICAgICAgICAgICAgICAgICBjbGFtcFxyXG4gKiAgY29tcGFyZWRUbyAgICAgICAgICAgICAgICBjbXBcclxuICogIGNvc2luZSAgICAgICAgICAgICAgICAgICAgY29zXHJcbiAqICBjdWJlUm9vdCAgICAgICAgICAgICAgICAgIGNicnRcclxuICogIGRlY2ltYWxQbGFjZXMgICAgICAgICAgICAgZHBcclxuICogIGRpdmlkZWRCeSAgICAgICAgICAgICAgICAgZGl2XHJcbiAqICBkaXZpZGVkVG9JbnRlZ2VyQnkgICAgICAgIGRpdlRvSW50XHJcbiAqICBlcXVhbHMgICAgICAgICAgICAgICAgICAgIGVxXHJcbiAqICBmbG9vclxyXG4gKiAgZ3JlYXRlclRoYW4gICAgICAgICAgICAgICBndFxyXG4gKiAgZ3JlYXRlclRoYW5PckVxdWFsVG8gICAgICBndGVcclxuICogIGh5cGVyYm9saWNDb3NpbmUgICAgICAgICAgY29zaFxyXG4gKiAgaHlwZXJib2xpY1NpbmUgICAgICAgICAgICBzaW5oXHJcbiAqICBoeXBlcmJvbGljVGFuZ2VudCAgICAgICAgIHRhbmhcclxuICogIGludmVyc2VDb3NpbmUgICAgICAgICAgICAgYWNvc1xyXG4gKiAgaW52ZXJzZUh5cGVyYm9saWNDb3NpbmUgICBhY29zaFxyXG4gKiAgaW52ZXJzZUh5cGVyYm9saWNTaW5lICAgICBhc2luaFxyXG4gKiAgaW52ZXJzZUh5cGVyYm9saWNUYW5nZW50ICBhdGFuaFxyXG4gKiAgaW52ZXJzZVNpbmUgICAgICAgICAgICAgICBhc2luXHJcbiAqICBpbnZlcnNlVGFuZ2VudCAgICAgICAgICAgIGF0YW5cclxuICogIGlzRmluaXRlXHJcbiAqICBpc0ludGVnZXIgICAgICAgICAgICAgICAgIGlzSW50XHJcbiAqICBpc05hTlxyXG4gKiAgaXNOZWdhdGl2ZSAgICAgICAgICAgICAgICBpc05lZ1xyXG4gKiAgaXNQb3NpdGl2ZSAgICAgICAgICAgICAgICBpc1Bvc1xyXG4gKiAgaXNaZXJvXHJcbiAqICBsZXNzVGhhbiAgICAgICAgICAgICAgICAgIGx0XHJcbiAqICBsZXNzVGhhbk9yRXF1YWxUbyAgICAgICAgIGx0ZVxyXG4gKiAgbG9nYXJpdGhtICAgICAgICAgICAgICAgICBsb2dcclxuICogIFttYXhpbXVtXSAgICAgICAgICAgICAgICAgW21heF1cclxuICogIFttaW5pbXVtXSAgICAgICAgICAgICAgICAgW21pbl1cclxuICogIG1pbnVzICAgICAgICAgICAgICAgICAgICAgc3ViXHJcbiAqICBtb2R1bG8gICAgICAgICAgICAgICAgICAgIG1vZFxyXG4gKiAgbmF0dXJhbEV4cG9uZW50aWFsICAgICAgICBleHBcclxuICogIG5hdHVyYWxMb2dhcml0aG0gICAgICAgICAgbG5cclxuICogIG5lZ2F0ZWQgICAgICAgICAgICAgICAgICAgbmVnXHJcbiAqICBwbHVzICAgICAgICAgICAgICAgICAgICAgIGFkZFxyXG4gKiAgcHJlY2lzaW9uICAgICAgICAgICAgICAgICBzZFxyXG4gKiAgcm91bmRcclxuICogIHNpbmUgICAgICAgICAgICAgICAgICAgICAgc2luXHJcbiAqICBzcXVhcmVSb290ICAgICAgICAgICAgICAgIHNxcnRcclxuICogIHRhbmdlbnQgICAgICAgICAgICAgICAgICAgdGFuXHJcbiAqICB0aW1lcyAgICAgICAgICAgICAgICAgICAgIG11bFxyXG4gKiAgdG9CaW5hcnlcclxuICogIHRvRGVjaW1hbFBsYWNlcyAgICAgICAgICAgdG9EUFxyXG4gKiAgdG9FeHBvbmVudGlhbFxyXG4gKiAgdG9GaXhlZFxyXG4gKiAgdG9GcmFjdGlvblxyXG4gKiAgdG9IZXhhZGVjaW1hbCAgICAgICAgICAgICB0b0hleFxyXG4gKiAgdG9OZWFyZXN0XHJcbiAqICB0b051bWJlclxyXG4gKiAgdG9PY3RhbFxyXG4gKiAgdG9Qb3dlciAgICAgICAgICAgICAgICAgICBwb3dcclxuICogIHRvUHJlY2lzaW9uXHJcbiAqICB0b1NpZ25pZmljYW50RGlnaXRzICAgICAgIHRvU0RcclxuICogIHRvU3RyaW5nXHJcbiAqICB0cnVuY2F0ZWQgICAgICAgICAgICAgICAgIHRydW5jXHJcbiAqICB2YWx1ZU9mICAgICAgICAgICAgICAgICAgIHRvSlNPTlxyXG4gKi9cclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgYWJzb2x1dGUgdmFsdWUgb2YgdGhpcyBEZWNpbWFsLlxyXG4gKlxyXG4gKi9cclxuUC5hYnNvbHV0ZVZhbHVlID0gUC5hYnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIHggPSBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzKTtcclxuICBpZiAoeC5zIDwgMCkgeC5zID0gMTtcclxuICByZXR1cm4gZmluYWxpc2UoeCk7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbCByb3VuZGVkIHRvIGEgd2hvbGUgbnVtYmVyIGluIHRoZVxyXG4gKiBkaXJlY3Rpb24gb2YgcG9zaXRpdmUgSW5maW5pdHkuXHJcbiAqXHJcbiAqL1xyXG5QLmNlaWwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgcmV0dXJuIGZpbmFsaXNlKG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMpLCB0aGlzLmUgKyAxLCAyKTtcclxufTtcclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBEZWNpbWFsIGNsYW1wZWQgdG8gdGhlIHJhbmdlXHJcbiAqIGRlbGluZWF0ZWQgYnkgYG1pbmAgYW5kIGBtYXhgLlxyXG4gKlxyXG4gKiBtaW4ge251bWJlcnxzdHJpbmd8RGVjaW1hbH1cclxuICogbWF4IHtudW1iZXJ8c3RyaW5nfERlY2ltYWx9XHJcbiAqXHJcbiAqL1xyXG5QLmNsYW1wZWRUbyA9IFAuY2xhbXAgPSBmdW5jdGlvbiAobWluLCBtYXgpIHtcclxuICB2YXIgayxcclxuICAgIHggPSB0aGlzLFxyXG4gICAgQ3RvciA9IHguY29uc3RydWN0b3I7XHJcbiAgbWluID0gbmV3IEN0b3IobWluKTtcclxuICBtYXggPSBuZXcgQ3RvcihtYXgpO1xyXG4gIGlmICghbWluLnMgfHwgIW1heC5zKSByZXR1cm4gbmV3IEN0b3IoTmFOKTtcclxuICBpZiAobWluLmd0KG1heCkpIHRocm93IEVycm9yKGludmFsaWRBcmd1bWVudCArIG1heCk7XHJcbiAgayA9IHguY21wKG1pbik7XHJcbiAgcmV0dXJuIGsgPCAwID8gbWluIDogeC5jbXAobWF4KSA+IDAgPyBtYXggOiBuZXcgQ3Rvcih4KTtcclxufTtcclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm5cclxuICogICAxICAgIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwgaXMgZ3JlYXRlciB0aGFuIHRoZSB2YWx1ZSBvZiBgeWAsXHJcbiAqICAtMSAgICBpZiB0aGUgdmFsdWUgb2YgdGhpcyBEZWNpbWFsIGlzIGxlc3MgdGhhbiB0aGUgdmFsdWUgb2YgYHlgLFxyXG4gKiAgIDAgICAgaWYgdGhleSBoYXZlIHRoZSBzYW1lIHZhbHVlLFxyXG4gKiAgIE5hTiAgaWYgdGhlIHZhbHVlIG9mIGVpdGhlciBEZWNpbWFsIGlzIE5hTi5cclxuICpcclxuICovXHJcblAuY29tcGFyZWRUbyA9IFAuY21wID0gZnVuY3Rpb24gKHkpIHtcclxuICB2YXIgaSwgaiwgeGRMLCB5ZEwsXHJcbiAgICB4ID0gdGhpcyxcclxuICAgIHhkID0geC5kLFxyXG4gICAgeWQgPSAoeSA9IG5ldyB4LmNvbnN0cnVjdG9yKHkpKS5kLFxyXG4gICAgeHMgPSB4LnMsXHJcbiAgICB5cyA9IHkucztcclxuXHJcbiAgLy8gRWl0aGVyIE5hTiBvciDCsUluZmluaXR5P1xyXG4gIGlmICgheGQgfHwgIXlkKSB7XHJcbiAgICByZXR1cm4gIXhzIHx8ICF5cyA/IE5hTiA6IHhzICE9PSB5cyA/IHhzIDogeGQgPT09IHlkID8gMCA6ICF4ZCBeIHhzIDwgMCA/IDEgOiAtMTtcclxuICB9XHJcblxyXG4gIC8vIEVpdGhlciB6ZXJvP1xyXG4gIGlmICgheGRbMF0gfHwgIXlkWzBdKSByZXR1cm4geGRbMF0gPyB4cyA6IHlkWzBdID8gLXlzIDogMDtcclxuXHJcbiAgLy8gU2lnbnMgZGlmZmVyP1xyXG4gIGlmICh4cyAhPT0geXMpIHJldHVybiB4cztcclxuXHJcbiAgLy8gQ29tcGFyZSBleHBvbmVudHMuXHJcbiAgaWYgKHguZSAhPT0geS5lKSByZXR1cm4geC5lID4geS5lIF4geHMgPCAwID8gMSA6IC0xO1xyXG5cclxuICB4ZEwgPSB4ZC5sZW5ndGg7XHJcbiAgeWRMID0geWQubGVuZ3RoO1xyXG5cclxuICAvLyBDb21wYXJlIGRpZ2l0IGJ5IGRpZ2l0LlxyXG4gIGZvciAoaSA9IDAsIGogPSB4ZEwgPCB5ZEwgPyB4ZEwgOiB5ZEw7IGkgPCBqOyArK2kpIHtcclxuICAgIGlmICh4ZFtpXSAhPT0geWRbaV0pIHJldHVybiB4ZFtpXSA+IHlkW2ldIF4geHMgPCAwID8gMSA6IC0xO1xyXG4gIH1cclxuXHJcbiAgLy8gQ29tcGFyZSBsZW5ndGhzLlxyXG4gIHJldHVybiB4ZEwgPT09IHlkTCA/IDAgOiB4ZEwgPiB5ZEwgXiB4cyA8IDAgPyAxIDogLTE7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIGNvc2luZSBvZiB0aGUgdmFsdWUgaW4gcmFkaWFucyBvZiB0aGlzIERlY2ltYWwuXHJcbiAqXHJcbiAqIERvbWFpbjogWy1JbmZpbml0eSwgSW5maW5pdHldXHJcbiAqIFJhbmdlOiBbLTEsIDFdXHJcbiAqXHJcbiAqIGNvcygwKSAgICAgICAgID0gMVxyXG4gKiBjb3MoLTApICAgICAgICA9IDFcclxuICogY29zKEluZmluaXR5KSAgPSBOYU5cclxuICogY29zKC1JbmZpbml0eSkgPSBOYU5cclxuICogY29zKE5hTikgICAgICAgPSBOYU5cclxuICpcclxuICovXHJcblAuY29zaW5lID0gUC5jb3MgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIHByLCBybSxcclxuICAgIHggPSB0aGlzLFxyXG4gICAgQ3RvciA9IHguY29uc3RydWN0b3I7XHJcblxyXG4gIGlmICgheC5kKSByZXR1cm4gbmV3IEN0b3IoTmFOKTtcclxuXHJcbiAgLy8gY29zKDApID0gY29zKC0wKSA9IDFcclxuICBpZiAoIXguZFswXSkgcmV0dXJuIG5ldyBDdG9yKDEpO1xyXG5cclxuICBwciA9IEN0b3IucHJlY2lzaW9uO1xyXG4gIHJtID0gQ3Rvci5yb3VuZGluZztcclxuICBDdG9yLnByZWNpc2lvbiA9IHByICsgTWF0aC5tYXgoeC5lLCB4LnNkKCkpICsgTE9HX0JBU0U7XHJcbiAgQ3Rvci5yb3VuZGluZyA9IDE7XHJcblxyXG4gIHggPSBjb3NpbmUoQ3RvciwgdG9MZXNzVGhhbkhhbGZQaShDdG9yLCB4KSk7XHJcblxyXG4gIEN0b3IucHJlY2lzaW9uID0gcHI7XHJcbiAgQ3Rvci5yb3VuZGluZyA9IHJtO1xyXG5cclxuICByZXR1cm4gZmluYWxpc2UocXVhZHJhbnQgPT0gMiB8fCBxdWFkcmFudCA9PSAzID8geC5uZWcoKSA6IHgsIHByLCBybSwgdHJ1ZSk7XHJcbn07XHJcblxyXG5cclxuLypcclxuICpcclxuICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIGN1YmUgcm9vdCBvZiB0aGUgdmFsdWUgb2YgdGhpcyBEZWNpbWFsLCByb3VuZGVkIHRvXHJcbiAqIGBwcmVjaXNpb25gIHNpZ25pZmljYW50IGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIGByb3VuZGluZ2AuXHJcbiAqXHJcbiAqICBjYnJ0KDApICA9ICAwXHJcbiAqICBjYnJ0KC0wKSA9IC0wXHJcbiAqICBjYnJ0KDEpICA9ICAxXHJcbiAqICBjYnJ0KC0xKSA9IC0xXHJcbiAqICBjYnJ0KE4pICA9ICBOXHJcbiAqICBjYnJ0KC1JKSA9IC1JXHJcbiAqICBjYnJ0KEkpICA9ICBJXHJcbiAqXHJcbiAqIE1hdGguY2JydCh4KSA9ICh4IDwgMCA/IC1NYXRoLnBvdygteCwgMS8zKSA6IE1hdGgucG93KHgsIDEvMykpXHJcbiAqXHJcbiAqL1xyXG5QLmN1YmVSb290ID0gUC5jYnJ0ID0gZnVuY3Rpb24gKCkge1xyXG4gIHZhciBlLCBtLCBuLCByLCByZXAsIHMsIHNkLCB0LCB0MywgdDNwbHVzeCxcclxuICAgIHggPSB0aGlzLFxyXG4gICAgQ3RvciA9IHguY29uc3RydWN0b3I7XHJcblxyXG4gIGlmICgheC5pc0Zpbml0ZSgpIHx8IHguaXNaZXJvKCkpIHJldHVybiBuZXcgQ3Rvcih4KTtcclxuICBleHRlcm5hbCA9IGZhbHNlO1xyXG5cclxuICAvLyBJbml0aWFsIGVzdGltYXRlLlxyXG4gIHMgPSB4LnMgKiBtYXRocG93KHgucyAqIHgsIDEgLyAzKTtcclxuXHJcbiAgIC8vIE1hdGguY2JydCB1bmRlcmZsb3cvb3ZlcmZsb3c/XHJcbiAgIC8vIFBhc3MgeCB0byBNYXRoLnBvdyBhcyBpbnRlZ2VyLCB0aGVuIGFkanVzdCB0aGUgZXhwb25lbnQgb2YgdGhlIHJlc3VsdC5cclxuICBpZiAoIXMgfHwgTWF0aC5hYnMocykgPT0gMSAvIDApIHtcclxuICAgIG4gPSBkaWdpdHNUb1N0cmluZyh4LmQpO1xyXG4gICAgZSA9IHguZTtcclxuXHJcbiAgICAvLyBBZGp1c3QgbiBleHBvbmVudCBzbyBpdCBpcyBhIG11bHRpcGxlIG9mIDMgYXdheSBmcm9tIHggZXhwb25lbnQuXHJcbiAgICBpZiAocyA9IChlIC0gbi5sZW5ndGggKyAxKSAlIDMpIG4gKz0gKHMgPT0gMSB8fCBzID09IC0yID8gJzAnIDogJzAwJyk7XHJcbiAgICBzID0gbWF0aHBvdyhuLCAxIC8gMyk7XHJcblxyXG4gICAgLy8gUmFyZWx5LCBlIG1heSBiZSBvbmUgbGVzcyB0aGFuIHRoZSByZXN1bHQgZXhwb25lbnQgdmFsdWUuXHJcbiAgICBlID0gbWF0aGZsb29yKChlICsgMSkgLyAzKSAtIChlICUgMyA9PSAoZSA8IDAgPyAtMSA6IDIpKTtcclxuXHJcbiAgICBpZiAocyA9PSAxIC8gMCkge1xyXG4gICAgICBuID0gJzVlJyArIGU7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBuID0gcy50b0V4cG9uZW50aWFsKCk7XHJcbiAgICAgIG4gPSBuLnNsaWNlKDAsIG4uaW5kZXhPZignZScpICsgMSkgKyBlO1xyXG4gICAgfVxyXG5cclxuICAgIHIgPSBuZXcgQ3RvcihuKTtcclxuICAgIHIucyA9IHgucztcclxuICB9IGVsc2Uge1xyXG4gICAgciA9IG5ldyBDdG9yKHMudG9TdHJpbmcoKSk7XHJcbiAgfVxyXG5cclxuICBzZCA9IChlID0gQ3Rvci5wcmVjaXNpb24pICsgMztcclxuXHJcbiAgLy8gSGFsbGV5J3MgbWV0aG9kLlxyXG4gIC8vIFRPRE8/IENvbXBhcmUgTmV3dG9uJ3MgbWV0aG9kLlxyXG4gIGZvciAoOzspIHtcclxuICAgIHQgPSByO1xyXG4gICAgdDMgPSB0LnRpbWVzKHQpLnRpbWVzKHQpO1xyXG4gICAgdDNwbHVzeCA9IHQzLnBsdXMoeCk7XHJcbiAgICByID0gZGl2aWRlKHQzcGx1c3gucGx1cyh4KS50aW1lcyh0KSwgdDNwbHVzeC5wbHVzKHQzKSwgc2QgKyAyLCAxKTtcclxuXHJcbiAgICAvLyBUT0RPPyBSZXBsYWNlIHdpdGggZm9yLWxvb3AgYW5kIGNoZWNrUm91bmRpbmdEaWdpdHMuXHJcbiAgICBpZiAoZGlnaXRzVG9TdHJpbmcodC5kKS5zbGljZSgwLCBzZCkgPT09IChuID0gZGlnaXRzVG9TdHJpbmcoci5kKSkuc2xpY2UoMCwgc2QpKSB7XHJcbiAgICAgIG4gPSBuLnNsaWNlKHNkIC0gMywgc2QgKyAxKTtcclxuXHJcbiAgICAgIC8vIFRoZSA0dGggcm91bmRpbmcgZGlnaXQgbWF5IGJlIGluIGVycm9yIGJ5IC0xIHNvIGlmIHRoZSA0IHJvdW5kaW5nIGRpZ2l0cyBhcmUgOTk5OSBvciA0OTk5XHJcbiAgICAgIC8vICwgaS5lLiBhcHByb2FjaGluZyBhIHJvdW5kaW5nIGJvdW5kYXJ5LCBjb250aW51ZSB0aGUgaXRlcmF0aW9uLlxyXG4gICAgICBpZiAobiA9PSAnOTk5OScgfHwgIXJlcCAmJiBuID09ICc0OTk5Jykge1xyXG5cclxuICAgICAgICAvLyBPbiB0aGUgZmlyc3QgaXRlcmF0aW9uIG9ubHksIGNoZWNrIHRvIHNlZSBpZiByb3VuZGluZyB1cCBnaXZlcyB0aGUgZXhhY3QgcmVzdWx0IGFzIHRoZVxyXG4gICAgICAgIC8vIG5pbmVzIG1heSBpbmZpbml0ZWx5IHJlcGVhdC5cclxuICAgICAgICBpZiAoIXJlcCkge1xyXG4gICAgICAgICAgZmluYWxpc2UodCwgZSArIDEsIDApO1xyXG5cclxuICAgICAgICAgIGlmICh0LnRpbWVzKHQpLnRpbWVzKHQpLmVxKHgpKSB7XHJcbiAgICAgICAgICAgIHIgPSB0O1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHNkICs9IDQ7XHJcbiAgICAgICAgcmVwID0gMTtcclxuICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgLy8gSWYgdGhlIHJvdW5kaW5nIGRpZ2l0cyBhcmUgbnVsbCwgMHswLDR9IG9yIDUwezAsM30sIGNoZWNrIGZvciBhbiBleGFjdCByZXN1bHQuXHJcbiAgICAgICAgLy8gSWYgbm90LCB0aGVuIHRoZXJlIGFyZSBmdXJ0aGVyIGRpZ2l0cyBhbmQgbSB3aWxsIGJlIHRydXRoeS5cclxuICAgICAgICBpZiAoIStuIHx8ICErbi5zbGljZSgxKSAmJiBuLmNoYXJBdCgwKSA9PSAnNScpIHtcclxuXHJcbiAgICAgICAgICAvLyBUcnVuY2F0ZSB0byB0aGUgZmlyc3Qgcm91bmRpbmcgZGlnaXQuXHJcbiAgICAgICAgICBmaW5hbGlzZShyLCBlICsgMSwgMSk7XHJcbiAgICAgICAgICBtID0gIXIudGltZXMocikudGltZXMocikuZXEoeCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZXh0ZXJuYWwgPSB0cnVlO1xyXG5cclxuICByZXR1cm4gZmluYWxpc2UociwgZSwgQ3Rvci5yb3VuZGluZywgbSk7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIHRoZSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgb2YgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbC5cclxuICpcclxuICovXHJcblAuZGVjaW1hbFBsYWNlcyA9IFAuZHAgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIHcsXHJcbiAgICBkID0gdGhpcy5kLFxyXG4gICAgbiA9IE5hTjtcclxuXHJcbiAgaWYgKGQpIHtcclxuICAgIHcgPSBkLmxlbmd0aCAtIDE7XHJcbiAgICBuID0gKHcgLSBtYXRoZmxvb3IodGhpcy5lIC8gTE9HX0JBU0UpKSAqIExPR19CQVNFO1xyXG5cclxuICAgIC8vIFN1YnRyYWN0IHRoZSBudW1iZXIgb2YgdHJhaWxpbmcgemVyb3Mgb2YgdGhlIGxhc3Qgd29yZC5cclxuICAgIHcgPSBkW3ddO1xyXG4gICAgaWYgKHcpIGZvciAoOyB3ICUgMTAgPT0gMDsgdyAvPSAxMCkgbi0tO1xyXG4gICAgaWYgKG4gPCAwKSBuID0gMDtcclxuICB9XHJcblxyXG4gIHJldHVybiBuO1xyXG59O1xyXG5cclxuXHJcbi8qXHJcbiAqICBuIC8gMCA9IElcclxuICogIG4gLyBOID0gTlxyXG4gKiAgbiAvIEkgPSAwXHJcbiAqICAwIC8gbiA9IDBcclxuICogIDAgLyAwID0gTlxyXG4gKiAgMCAvIE4gPSBOXHJcbiAqICAwIC8gSSA9IDBcclxuICogIE4gLyBuID0gTlxyXG4gKiAgTiAvIDAgPSBOXHJcbiAqICBOIC8gTiA9IE5cclxuICogIE4gLyBJID0gTlxyXG4gKiAgSSAvIG4gPSBJXHJcbiAqICBJIC8gMCA9IElcclxuICogIEkgLyBOID0gTlxyXG4gKiAgSSAvIEkgPSBOXHJcbiAqXHJcbiAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwgZGl2aWRlZCBieSBgeWAsIHJvdW5kZWQgdG9cclxuICogYHByZWNpc2lvbmAgc2lnbmlmaWNhbnQgZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJvdW5kaW5nYC5cclxuICpcclxuICovXHJcblAuZGl2aWRlZEJ5ID0gUC5kaXYgPSBmdW5jdGlvbiAoeSkge1xyXG4gIHJldHVybiBkaXZpZGUodGhpcywgbmV3IHRoaXMuY29uc3RydWN0b3IoeSkpO1xyXG59O1xyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSBpbnRlZ2VyIHBhcnQgb2YgZGl2aWRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbFxyXG4gKiBieSB0aGUgdmFsdWUgb2YgYHlgLCByb3VuZGVkIHRvIGBwcmVjaXNpb25gIHNpZ25pZmljYW50IGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIGByb3VuZGluZ2AuXHJcbiAqXHJcbiAqL1xyXG5QLmRpdmlkZWRUb0ludGVnZXJCeSA9IFAuZGl2VG9JbnQgPSBmdW5jdGlvbiAoeSkge1xyXG4gIHZhciB4ID0gdGhpcyxcclxuICAgIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xyXG4gIHJldHVybiBmaW5hbGlzZShkaXZpZGUoeCwgbmV3IEN0b3IoeSksIDAsIDEsIDEpLCBDdG9yLnByZWNpc2lvbiwgQ3Rvci5yb3VuZGluZyk7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbCBpcyBlcXVhbCB0byB0aGUgdmFsdWUgb2YgYHlgLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gKlxyXG4gKi9cclxuUC5lcXVhbHMgPSBQLmVxID0gZnVuY3Rpb24gKHkpIHtcclxuICByZXR1cm4gdGhpcy5jbXAoeSkgPT09IDA7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbCByb3VuZGVkIHRvIGEgd2hvbGUgbnVtYmVyIGluIHRoZVxyXG4gKiBkaXJlY3Rpb24gb2YgbmVnYXRpdmUgSW5maW5pdHkuXHJcbiAqXHJcbiAqL1xyXG5QLmZsb29yID0gZnVuY3Rpb24gKCkge1xyXG4gIHJldHVybiBmaW5hbGlzZShuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzKSwgdGhpcy5lICsgMSwgMyk7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbCBpcyBncmVhdGVyIHRoYW4gdGhlIHZhbHVlIG9mIGB5YCwgb3RoZXJ3aXNlIHJldHVyblxyXG4gKiBmYWxzZS5cclxuICpcclxuICovXHJcblAuZ3JlYXRlclRoYW4gPSBQLmd0ID0gZnVuY3Rpb24gKHkpIHtcclxuICByZXR1cm4gdGhpcy5jbXAoeSkgPiAwO1xyXG59O1xyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHRoZSB2YWx1ZSBvZiBgeWAsXHJcbiAqIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAqXHJcbiAqL1xyXG5QLmdyZWF0ZXJUaGFuT3JFcXVhbFRvID0gUC5ndGUgPSBmdW5jdGlvbiAoeSkge1xyXG4gIHZhciBrID0gdGhpcy5jbXAoeSk7XHJcbiAgcmV0dXJuIGsgPT0gMSB8fCBrID09PSAwO1xyXG59O1xyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSBoeXBlcmJvbGljIGNvc2luZSBvZiB0aGUgdmFsdWUgaW4gcmFkaWFucyBvZiB0aGlzXHJcbiAqIERlY2ltYWwuXHJcbiAqXHJcbiAqIERvbWFpbjogWy1JbmZpbml0eSwgSW5maW5pdHldXHJcbiAqIFJhbmdlOiBbMSwgSW5maW5pdHldXHJcbiAqXHJcbiAqIGNvc2goeCkgPSAxICsgeF4yLzIhICsgeF40LzQhICsgeF42LzYhICsgLi4uXHJcbiAqXHJcbiAqIGNvc2goMCkgICAgICAgICA9IDFcclxuICogY29zaCgtMCkgICAgICAgID0gMVxyXG4gKiBjb3NoKEluZmluaXR5KSAgPSBJbmZpbml0eVxyXG4gKiBjb3NoKC1JbmZpbml0eSkgPSBJbmZpbml0eVxyXG4gKiBjb3NoKE5hTikgICAgICAgPSBOYU5cclxuICpcclxuICogIHggICAgICAgIHRpbWUgdGFrZW4gKG1zKSAgIHJlc3VsdFxyXG4gKiAxMDAwICAgICAgOSAgICAgICAgICAgICAgICAgOS44NTAzNTU1NzAwODUyMzQ5Njk0ZSs0MzNcclxuICogMTAwMDAgICAgIDI1ICAgICAgICAgICAgICAgIDQuNDAzNDA5MTEyODMxNDYwNzkzNmUrNDM0MlxyXG4gKiAxMDAwMDAgICAgMTcxICAgICAgICAgICAgICAgMS40MDMzMzE2ODAyMTMwNjE1ODk3ZSs0MzQyOVxyXG4gKiAxMDAwMDAwICAgMzgxNyAgICAgICAgICAgICAgMS41MTY2MDc2OTg0MDEwNDM3NzI1ZSs0MzQyOTRcclxuICogMTAwMDAwMDAgIGFiYW5kb25lZCBhZnRlciAyIG1pbnV0ZSB3YWl0XHJcbiAqXHJcbiAqIFRPRE8/IENvbXBhcmUgcGVyZm9ybWFuY2Ugb2YgY29zaCh4KSA9IDAuNSAqIChleHAoeCkgKyBleHAoLXgpKVxyXG4gKlxyXG4gKi9cclxuUC5oeXBlcmJvbGljQ29zaW5lID0gUC5jb3NoID0gZnVuY3Rpb24gKCkge1xyXG4gIHZhciBrLCBuLCBwciwgcm0sIGxlbixcclxuICAgIHggPSB0aGlzLFxyXG4gICAgQ3RvciA9IHguY29uc3RydWN0b3IsXHJcbiAgICBvbmUgPSBuZXcgQ3RvcigxKTtcclxuXHJcbiAgaWYgKCF4LmlzRmluaXRlKCkpIHJldHVybiBuZXcgQ3Rvcih4LnMgPyAxIC8gMCA6IE5hTik7XHJcbiAgaWYgKHguaXNaZXJvKCkpIHJldHVybiBvbmU7XHJcblxyXG4gIHByID0gQ3Rvci5wcmVjaXNpb247XHJcbiAgcm0gPSBDdG9yLnJvdW5kaW5nO1xyXG4gIEN0b3IucHJlY2lzaW9uID0gcHIgKyBNYXRoLm1heCh4LmUsIHguc2QoKSkgKyA0O1xyXG4gIEN0b3Iucm91bmRpbmcgPSAxO1xyXG4gIGxlbiA9IHguZC5sZW5ndGg7XHJcblxyXG4gIC8vIEFyZ3VtZW50IHJlZHVjdGlvbjogY29zKDR4KSA9IDEgLSA4Y29zXjIoeCkgKyA4Y29zXjQoeCkgKyAxXHJcbiAgLy8gaS5lLiBjb3MoeCkgPSAxIC0gY29zXjIoeC80KSg4IC0gOGNvc14yKHgvNCkpXHJcblxyXG4gIC8vIEVzdGltYXRlIHRoZSBvcHRpbXVtIG51bWJlciBvZiB0aW1lcyB0byB1c2UgdGhlIGFyZ3VtZW50IHJlZHVjdGlvbi5cclxuICAvLyBUT0RPPyBFc3RpbWF0aW9uIHJldXNlZCBmcm9tIGNvc2luZSgpIGFuZCBtYXkgbm90IGJlIG9wdGltYWwgaGVyZS5cclxuICBpZiAobGVuIDwgMzIpIHtcclxuICAgIGsgPSBNYXRoLmNlaWwobGVuIC8gMyk7XHJcbiAgICBuID0gKDEgLyB0aW55UG93KDQsIGspKS50b1N0cmluZygpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBrID0gMTY7XHJcbiAgICBuID0gJzIuMzI4MzA2NDM2NTM4Njk2Mjg5MDYyNWUtMTAnO1xyXG4gIH1cclxuXHJcbiAgeCA9IHRheWxvclNlcmllcyhDdG9yLCAxLCB4LnRpbWVzKG4pLCBuZXcgQ3RvcigxKSwgdHJ1ZSk7XHJcblxyXG4gIC8vIFJldmVyc2UgYXJndW1lbnQgcmVkdWN0aW9uXHJcbiAgdmFyIGNvc2gyX3gsXHJcbiAgICBpID0gayxcclxuICAgIGQ4ID0gbmV3IEN0b3IoOCk7XHJcbiAgZm9yICg7IGktLTspIHtcclxuICAgIGNvc2gyX3ggPSB4LnRpbWVzKHgpO1xyXG4gICAgeCA9IG9uZS5taW51cyhjb3NoMl94LnRpbWVzKGQ4Lm1pbnVzKGNvc2gyX3gudGltZXMoZDgpKSkpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGZpbmFsaXNlKHgsIEN0b3IucHJlY2lzaW9uID0gcHIsIEN0b3Iucm91bmRpbmcgPSBybSwgdHJ1ZSk7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIGh5cGVyYm9saWMgc2luZSBvZiB0aGUgdmFsdWUgaW4gcmFkaWFucyBvZiB0aGlzXHJcbiAqIERlY2ltYWwuXHJcbiAqXHJcbiAqIERvbWFpbjogWy1JbmZpbml0eSwgSW5maW5pdHldXHJcbiAqIFJhbmdlOiBbLUluZmluaXR5LCBJbmZpbml0eV1cclxuICpcclxuICogc2luaCh4KSA9IHggKyB4XjMvMyEgKyB4XjUvNSEgKyB4XjcvNyEgKyAuLi5cclxuICpcclxuICogc2luaCgwKSAgICAgICAgID0gMFxyXG4gKiBzaW5oKC0wKSAgICAgICAgPSAtMFxyXG4gKiBzaW5oKEluZmluaXR5KSAgPSBJbmZpbml0eVxyXG4gKiBzaW5oKC1JbmZpbml0eSkgPSAtSW5maW5pdHlcclxuICogc2luaChOYU4pICAgICAgID0gTmFOXHJcbiAqXHJcbiAqIHggICAgICAgIHRpbWUgdGFrZW4gKG1zKVxyXG4gKiAxMCAgICAgICAyIG1zXHJcbiAqIDEwMCAgICAgIDUgbXNcclxuICogMTAwMCAgICAgMTQgbXNcclxuICogMTAwMDAgICAgODIgbXNcclxuICogMTAwMDAwICAgODg2IG1zICAgICAgICAgICAgMS40MDMzMzE2ODAyMTMwNjE1ODk3ZSs0MzQyOVxyXG4gKiAyMDAwMDAgICAyNjEzIG1zXHJcbiAqIDMwMDAwMCAgIDU0MDcgbXNcclxuICogNDAwMDAwICAgODgyNCBtc1xyXG4gKiA1MDAwMDAgICAxMzAyNiBtcyAgICAgICAgICA4LjcwODA2NDM2MTI3MTgwODQxMjllKzIxNzE0NlxyXG4gKiAxMDAwMDAwICA0ODU0MyBtc1xyXG4gKlxyXG4gKiBUT0RPPyBDb21wYXJlIHBlcmZvcm1hbmNlIG9mIHNpbmgoeCkgPSAwLjUgKiAoZXhwKHgpIC0gZXhwKC14KSlcclxuICpcclxuICovXHJcblAuaHlwZXJib2xpY1NpbmUgPSBQLnNpbmggPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIGssIHByLCBybSwgbGVuLFxyXG4gICAgeCA9IHRoaXMsXHJcbiAgICBDdG9yID0geC5jb25zdHJ1Y3RvcjtcclxuXHJcbiAgaWYgKCF4LmlzRmluaXRlKCkgfHwgeC5pc1plcm8oKSkgcmV0dXJuIG5ldyBDdG9yKHgpO1xyXG5cclxuICBwciA9IEN0b3IucHJlY2lzaW9uO1xyXG4gIHJtID0gQ3Rvci5yb3VuZGluZztcclxuICBDdG9yLnByZWNpc2lvbiA9IHByICsgTWF0aC5tYXgoeC5lLCB4LnNkKCkpICsgNDtcclxuICBDdG9yLnJvdW5kaW5nID0gMTtcclxuICBsZW4gPSB4LmQubGVuZ3RoO1xyXG5cclxuICBpZiAobGVuIDwgMykge1xyXG4gICAgeCA9IHRheWxvclNlcmllcyhDdG9yLCAyLCB4LCB4LCB0cnVlKTtcclxuICB9IGVsc2Uge1xyXG5cclxuICAgIC8vIEFsdGVybmF0aXZlIGFyZ3VtZW50IHJlZHVjdGlvbjogc2luaCgzeCkgPSBzaW5oKHgpKDMgKyA0c2luaF4yKHgpKVxyXG4gICAgLy8gaS5lLiBzaW5oKHgpID0gc2luaCh4LzMpKDMgKyA0c2luaF4yKHgvMykpXHJcbiAgICAvLyAzIG11bHRpcGxpY2F0aW9ucyBhbmQgMSBhZGRpdGlvblxyXG5cclxuICAgIC8vIEFyZ3VtZW50IHJlZHVjdGlvbjogc2luaCg1eCkgPSBzaW5oKHgpKDUgKyBzaW5oXjIoeCkoMjAgKyAxNnNpbmheMih4KSkpXHJcbiAgICAvLyBpLmUuIHNpbmgoeCkgPSBzaW5oKHgvNSkoNSArIHNpbmheMih4LzUpKDIwICsgMTZzaW5oXjIoeC81KSkpXHJcbiAgICAvLyA0IG11bHRpcGxpY2F0aW9ucyBhbmQgMiBhZGRpdGlvbnNcclxuXHJcbiAgICAvLyBFc3RpbWF0ZSB0aGUgb3B0aW11bSBudW1iZXIgb2YgdGltZXMgdG8gdXNlIHRoZSBhcmd1bWVudCByZWR1Y3Rpb24uXHJcbiAgICBrID0gMS40ICogTWF0aC5zcXJ0KGxlbik7XHJcbiAgICBrID0gayA+IDE2ID8gMTYgOiBrIHwgMDtcclxuXHJcbiAgICB4ID0geC50aW1lcygxIC8gdGlueVBvdyg1LCBrKSk7XHJcbiAgICB4ID0gdGF5bG9yU2VyaWVzKEN0b3IsIDIsIHgsIHgsIHRydWUpO1xyXG5cclxuICAgIC8vIFJldmVyc2UgYXJndW1lbnQgcmVkdWN0aW9uXHJcbiAgICB2YXIgc2luaDJfeCxcclxuICAgICAgZDUgPSBuZXcgQ3Rvcig1KSxcclxuICAgICAgZDE2ID0gbmV3IEN0b3IoMTYpLFxyXG4gICAgICBkMjAgPSBuZXcgQ3RvcigyMCk7XHJcbiAgICBmb3IgKDsgay0tOykge1xyXG4gICAgICBzaW5oMl94ID0geC50aW1lcyh4KTtcclxuICAgICAgeCA9IHgudGltZXMoZDUucGx1cyhzaW5oMl94LnRpbWVzKGQxNi50aW1lcyhzaW5oMl94KS5wbHVzKGQyMCkpKSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBDdG9yLnByZWNpc2lvbiA9IHByO1xyXG4gIEN0b3Iucm91bmRpbmcgPSBybTtcclxuXHJcbiAgcmV0dXJuIGZpbmFsaXNlKHgsIHByLCBybSwgdHJ1ZSk7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIGh5cGVyYm9saWMgdGFuZ2VudCBvZiB0aGUgdmFsdWUgaW4gcmFkaWFucyBvZiB0aGlzXHJcbiAqIERlY2ltYWwuXHJcbiAqXHJcbiAqIERvbWFpbjogWy1JbmZpbml0eSwgSW5maW5pdHldXHJcbiAqIFJhbmdlOiBbLTEsIDFdXHJcbiAqXHJcbiAqIHRhbmgoeCkgPSBzaW5oKHgpIC8gY29zaCh4KVxyXG4gKlxyXG4gKiB0YW5oKDApICAgICAgICAgPSAwXHJcbiAqIHRhbmgoLTApICAgICAgICA9IC0wXHJcbiAqIHRhbmgoSW5maW5pdHkpICA9IDFcclxuICogdGFuaCgtSW5maW5pdHkpID0gLTFcclxuICogdGFuaChOYU4pICAgICAgID0gTmFOXHJcbiAqXHJcbiAqL1xyXG5QLmh5cGVyYm9saWNUYW5nZW50ID0gUC50YW5oID0gZnVuY3Rpb24gKCkge1xyXG4gIHZhciBwciwgcm0sXHJcbiAgICB4ID0gdGhpcyxcclxuICAgIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xyXG5cclxuICBpZiAoIXguaXNGaW5pdGUoKSkgcmV0dXJuIG5ldyBDdG9yKHgucyk7XHJcbiAgaWYgKHguaXNaZXJvKCkpIHJldHVybiBuZXcgQ3Rvcih4KTtcclxuXHJcbiAgcHIgPSBDdG9yLnByZWNpc2lvbjtcclxuICBybSA9IEN0b3Iucm91bmRpbmc7XHJcbiAgQ3Rvci5wcmVjaXNpb24gPSBwciArIDc7XHJcbiAgQ3Rvci5yb3VuZGluZyA9IDE7XHJcblxyXG4gIHJldHVybiBkaXZpZGUoeC5zaW5oKCksIHguY29zaCgpLCBDdG9yLnByZWNpc2lvbiA9IHByLCBDdG9yLnJvdW5kaW5nID0gcm0pO1xyXG59O1xyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSBhcmNjb3NpbmUgKGludmVyc2UgY29zaW5lKSBpbiByYWRpYW5zIG9mIHRoZSB2YWx1ZSBvZlxyXG4gKiB0aGlzIERlY2ltYWwuXHJcbiAqXHJcbiAqIERvbWFpbjogWy0xLCAxXVxyXG4gKiBSYW5nZTogWzAsIHBpXVxyXG4gKlxyXG4gKiBhY29zKHgpID0gcGkvMiAtIGFzaW4oeClcclxuICpcclxuICogYWNvcygwKSAgICAgICA9IHBpLzJcclxuICogYWNvcygtMCkgICAgICA9IHBpLzJcclxuICogYWNvcygxKSAgICAgICA9IDBcclxuICogYWNvcygtMSkgICAgICA9IHBpXHJcbiAqIGFjb3MoMS8yKSAgICAgPSBwaS8zXHJcbiAqIGFjb3MoLTEvMikgICAgPSAyKnBpLzNcclxuICogYWNvcyh8eHwgPiAxKSA9IE5hTlxyXG4gKiBhY29zKE5hTikgICAgID0gTmFOXHJcbiAqXHJcbiAqL1xyXG5QLmludmVyc2VDb3NpbmUgPSBQLmFjb3MgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIGhhbGZQaSxcclxuICAgIHggPSB0aGlzLFxyXG4gICAgQ3RvciA9IHguY29uc3RydWN0b3IsXHJcbiAgICBrID0geC5hYnMoKS5jbXAoMSksXHJcbiAgICBwciA9IEN0b3IucHJlY2lzaW9uLFxyXG4gICAgcm0gPSBDdG9yLnJvdW5kaW5nO1xyXG5cclxuICBpZiAoayAhPT0gLTEpIHtcclxuICAgIHJldHVybiBrID09PSAwXHJcbiAgICAgIC8vIHx4fCBpcyAxXHJcbiAgICAgID8geC5pc05lZygpID8gZ2V0UGkoQ3RvciwgcHIsIHJtKSA6IG5ldyBDdG9yKDApXHJcbiAgICAgIC8vIHx4fCA+IDEgb3IgeCBpcyBOYU5cclxuICAgICAgOiBuZXcgQ3RvcihOYU4pO1xyXG4gIH1cclxuXHJcbiAgaWYgKHguaXNaZXJvKCkpIHJldHVybiBnZXRQaShDdG9yLCBwciArIDQsIHJtKS50aW1lcygwLjUpO1xyXG5cclxuICAvLyBUT0RPPyBTcGVjaWFsIGNhc2UgYWNvcygwLjUpID0gcGkvMyBhbmQgYWNvcygtMC41KSA9IDIqcGkvM1xyXG5cclxuICBDdG9yLnByZWNpc2lvbiA9IHByICsgNjtcclxuICBDdG9yLnJvdW5kaW5nID0gMTtcclxuXHJcbiAgeCA9IHguYXNpbigpO1xyXG4gIGhhbGZQaSA9IGdldFBpKEN0b3IsIHByICsgNCwgcm0pLnRpbWVzKDAuNSk7XHJcblxyXG4gIEN0b3IucHJlY2lzaW9uID0gcHI7XHJcbiAgQ3Rvci5yb3VuZGluZyA9IHJtO1xyXG5cclxuICByZXR1cm4gaGFsZlBpLm1pbnVzKHgpO1xyXG59O1xyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSBpbnZlcnNlIG9mIHRoZSBoeXBlcmJvbGljIGNvc2luZSBpbiByYWRpYW5zIG9mIHRoZVxyXG4gKiB2YWx1ZSBvZiB0aGlzIERlY2ltYWwuXHJcbiAqXHJcbiAqIERvbWFpbjogWzEsIEluZmluaXR5XVxyXG4gKiBSYW5nZTogWzAsIEluZmluaXR5XVxyXG4gKlxyXG4gKiBhY29zaCh4KSA9IGxuKHggKyBzcXJ0KHheMiAtIDEpKVxyXG4gKlxyXG4gKiBhY29zaCh4IDwgMSkgICAgID0gTmFOXHJcbiAqIGFjb3NoKE5hTikgICAgICAgPSBOYU5cclxuICogYWNvc2goSW5maW5pdHkpICA9IEluZmluaXR5XHJcbiAqIGFjb3NoKC1JbmZpbml0eSkgPSBOYU5cclxuICogYWNvc2goMCkgICAgICAgICA9IE5hTlxyXG4gKiBhY29zaCgtMCkgICAgICAgID0gTmFOXHJcbiAqIGFjb3NoKDEpICAgICAgICAgPSAwXHJcbiAqIGFjb3NoKC0xKSAgICAgICAgPSBOYU5cclxuICpcclxuICovXHJcblAuaW52ZXJzZUh5cGVyYm9saWNDb3NpbmUgPSBQLmFjb3NoID0gZnVuY3Rpb24gKCkge1xyXG4gIHZhciBwciwgcm0sXHJcbiAgICB4ID0gdGhpcyxcclxuICAgIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xyXG5cclxuICBpZiAoeC5sdGUoMSkpIHJldHVybiBuZXcgQ3Rvcih4LmVxKDEpID8gMCA6IE5hTik7XHJcbiAgaWYgKCF4LmlzRmluaXRlKCkpIHJldHVybiBuZXcgQ3Rvcih4KTtcclxuXHJcbiAgcHIgPSBDdG9yLnByZWNpc2lvbjtcclxuICBybSA9IEN0b3Iucm91bmRpbmc7XHJcbiAgQ3Rvci5wcmVjaXNpb24gPSBwciArIE1hdGgubWF4KE1hdGguYWJzKHguZSksIHguc2QoKSkgKyA0O1xyXG4gIEN0b3Iucm91bmRpbmcgPSAxO1xyXG4gIGV4dGVybmFsID0gZmFsc2U7XHJcblxyXG4gIHggPSB4LnRpbWVzKHgpLm1pbnVzKDEpLnNxcnQoKS5wbHVzKHgpO1xyXG5cclxuICBleHRlcm5hbCA9IHRydWU7XHJcbiAgQ3Rvci5wcmVjaXNpb24gPSBwcjtcclxuICBDdG9yLnJvdW5kaW5nID0gcm07XHJcblxyXG4gIHJldHVybiB4LmxuKCk7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIGludmVyc2Ugb2YgdGhlIGh5cGVyYm9saWMgc2luZSBpbiByYWRpYW5zIG9mIHRoZSB2YWx1ZVxyXG4gKiBvZiB0aGlzIERlY2ltYWwuXHJcbiAqXHJcbiAqIERvbWFpbjogWy1JbmZpbml0eSwgSW5maW5pdHldXHJcbiAqIFJhbmdlOiBbLUluZmluaXR5LCBJbmZpbml0eV1cclxuICpcclxuICogYXNpbmgoeCkgPSBsbih4ICsgc3FydCh4XjIgKyAxKSlcclxuICpcclxuICogYXNpbmgoTmFOKSAgICAgICA9IE5hTlxyXG4gKiBhc2luaChJbmZpbml0eSkgID0gSW5maW5pdHlcclxuICogYXNpbmgoLUluZmluaXR5KSA9IC1JbmZpbml0eVxyXG4gKiBhc2luaCgwKSAgICAgICAgID0gMFxyXG4gKiBhc2luaCgtMCkgICAgICAgID0gLTBcclxuICpcclxuICovXHJcblAuaW52ZXJzZUh5cGVyYm9saWNTaW5lID0gUC5hc2luaCA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgcHIsIHJtLFxyXG4gICAgeCA9IHRoaXMsXHJcbiAgICBDdG9yID0geC5jb25zdHJ1Y3RvcjtcclxuXHJcbiAgaWYgKCF4LmlzRmluaXRlKCkgfHwgeC5pc1plcm8oKSkgcmV0dXJuIG5ldyBDdG9yKHgpO1xyXG5cclxuICBwciA9IEN0b3IucHJlY2lzaW9uO1xyXG4gIHJtID0gQ3Rvci5yb3VuZGluZztcclxuICBDdG9yLnByZWNpc2lvbiA9IHByICsgMiAqIE1hdGgubWF4KE1hdGguYWJzKHguZSksIHguc2QoKSkgKyA2O1xyXG4gIEN0b3Iucm91bmRpbmcgPSAxO1xyXG4gIGV4dGVybmFsID0gZmFsc2U7XHJcblxyXG4gIHggPSB4LnRpbWVzKHgpLnBsdXMoMSkuc3FydCgpLnBsdXMoeCk7XHJcblxyXG4gIGV4dGVybmFsID0gdHJ1ZTtcclxuICBDdG9yLnByZWNpc2lvbiA9IHByO1xyXG4gIEN0b3Iucm91bmRpbmcgPSBybTtcclxuXHJcbiAgcmV0dXJuIHgubG4oKTtcclxufTtcclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgaW52ZXJzZSBvZiB0aGUgaHlwZXJib2xpYyB0YW5nZW50IGluIHJhZGlhbnMgb2YgdGhlXHJcbiAqIHZhbHVlIG9mIHRoaXMgRGVjaW1hbC5cclxuICpcclxuICogRG9tYWluOiBbLTEsIDFdXHJcbiAqIFJhbmdlOiBbLUluZmluaXR5LCBJbmZpbml0eV1cclxuICpcclxuICogYXRhbmgoeCkgPSAwLjUgKiBsbigoMSArIHgpIC8gKDEgLSB4KSlcclxuICpcclxuICogYXRhbmgofHh8ID4gMSkgICA9IE5hTlxyXG4gKiBhdGFuaChOYU4pICAgICAgID0gTmFOXHJcbiAqIGF0YW5oKEluZmluaXR5KSAgPSBOYU5cclxuICogYXRhbmgoLUluZmluaXR5KSA9IE5hTlxyXG4gKiBhdGFuaCgwKSAgICAgICAgID0gMFxyXG4gKiBhdGFuaCgtMCkgICAgICAgID0gLTBcclxuICogYXRhbmgoMSkgICAgICAgICA9IEluZmluaXR5XHJcbiAqIGF0YW5oKC0xKSAgICAgICAgPSAtSW5maW5pdHlcclxuICpcclxuICovXHJcblAuaW52ZXJzZUh5cGVyYm9saWNUYW5nZW50ID0gUC5hdGFuaCA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgcHIsIHJtLCB3cHIsIHhzZCxcclxuICAgIHggPSB0aGlzLFxyXG4gICAgQ3RvciA9IHguY29uc3RydWN0b3I7XHJcblxyXG4gIGlmICgheC5pc0Zpbml0ZSgpKSByZXR1cm4gbmV3IEN0b3IoTmFOKTtcclxuICBpZiAoeC5lID49IDApIHJldHVybiBuZXcgQ3Rvcih4LmFicygpLmVxKDEpID8geC5zIC8gMCA6IHguaXNaZXJvKCkgPyB4IDogTmFOKTtcclxuXHJcbiAgcHIgPSBDdG9yLnByZWNpc2lvbjtcclxuICBybSA9IEN0b3Iucm91bmRpbmc7XHJcbiAgeHNkID0geC5zZCgpO1xyXG5cclxuICBpZiAoTWF0aC5tYXgoeHNkLCBwcikgPCAyICogLXguZSAtIDEpIHJldHVybiBmaW5hbGlzZShuZXcgQ3Rvcih4KSwgcHIsIHJtLCB0cnVlKTtcclxuXHJcbiAgQ3Rvci5wcmVjaXNpb24gPSB3cHIgPSB4c2QgLSB4LmU7XHJcblxyXG4gIHggPSBkaXZpZGUoeC5wbHVzKDEpLCBuZXcgQ3RvcigxKS5taW51cyh4KSwgd3ByICsgcHIsIDEpO1xyXG5cclxuICBDdG9yLnByZWNpc2lvbiA9IHByICsgNDtcclxuICBDdG9yLnJvdW5kaW5nID0gMTtcclxuXHJcbiAgeCA9IHgubG4oKTtcclxuXHJcbiAgQ3Rvci5wcmVjaXNpb24gPSBwcjtcclxuICBDdG9yLnJvdW5kaW5nID0gcm07XHJcblxyXG4gIHJldHVybiB4LnRpbWVzKDAuNSk7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIGFyY3NpbmUgKGludmVyc2Ugc2luZSkgaW4gcmFkaWFucyBvZiB0aGUgdmFsdWUgb2YgdGhpc1xyXG4gKiBEZWNpbWFsLlxyXG4gKlxyXG4gKiBEb21haW46IFstSW5maW5pdHksIEluZmluaXR5XVxyXG4gKiBSYW5nZTogWy1waS8yLCBwaS8yXVxyXG4gKlxyXG4gKiBhc2luKHgpID0gMiphdGFuKHgvKDEgKyBzcXJ0KDEgLSB4XjIpKSlcclxuICpcclxuICogYXNpbigwKSAgICAgICA9IDBcclxuICogYXNpbigtMCkgICAgICA9IC0wXHJcbiAqIGFzaW4oMS8yKSAgICAgPSBwaS82XHJcbiAqIGFzaW4oLTEvMikgICAgPSAtcGkvNlxyXG4gKiBhc2luKDEpICAgICAgID0gcGkvMlxyXG4gKiBhc2luKC0xKSAgICAgID0gLXBpLzJcclxuICogYXNpbih8eHwgPiAxKSA9IE5hTlxyXG4gKiBhc2luKE5hTikgICAgID0gTmFOXHJcbiAqXHJcbiAqIFRPRE8/IENvbXBhcmUgcGVyZm9ybWFuY2Ugb2YgVGF5bG9yIHNlcmllcy5cclxuICpcclxuICovXHJcblAuaW52ZXJzZVNpbmUgPSBQLmFzaW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIGhhbGZQaSwgayxcclxuICAgIHByLCBybSxcclxuICAgIHggPSB0aGlzLFxyXG4gICAgQ3RvciA9IHguY29uc3RydWN0b3I7XHJcblxyXG4gIGlmICh4LmlzWmVybygpKSByZXR1cm4gbmV3IEN0b3IoeCk7XHJcblxyXG4gIGsgPSB4LmFicygpLmNtcCgxKTtcclxuICBwciA9IEN0b3IucHJlY2lzaW9uO1xyXG4gIHJtID0gQ3Rvci5yb3VuZGluZztcclxuXHJcbiAgaWYgKGsgIT09IC0xKSB7XHJcblxyXG4gICAgLy8gfHh8IGlzIDFcclxuICAgIGlmIChrID09PSAwKSB7XHJcbiAgICAgIGhhbGZQaSA9IGdldFBpKEN0b3IsIHByICsgNCwgcm0pLnRpbWVzKDAuNSk7XHJcbiAgICAgIGhhbGZQaS5zID0geC5zO1xyXG4gICAgICByZXR1cm4gaGFsZlBpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHx4fCA+IDEgb3IgeCBpcyBOYU5cclxuICAgIHJldHVybiBuZXcgQ3RvcihOYU4pO1xyXG4gIH1cclxuXHJcbiAgLy8gVE9ETz8gU3BlY2lhbCBjYXNlIGFzaW4oMS8yKSA9IHBpLzYgYW5kIGFzaW4oLTEvMikgPSAtcGkvNlxyXG5cclxuICBDdG9yLnByZWNpc2lvbiA9IHByICsgNjtcclxuICBDdG9yLnJvdW5kaW5nID0gMTtcclxuXHJcbiAgeCA9IHguZGl2KG5ldyBDdG9yKDEpLm1pbnVzKHgudGltZXMoeCkpLnNxcnQoKS5wbHVzKDEpKS5hdGFuKCk7XHJcblxyXG4gIEN0b3IucHJlY2lzaW9uID0gcHI7XHJcbiAgQ3Rvci5yb3VuZGluZyA9IHJtO1xyXG5cclxuICByZXR1cm4geC50aW1lcygyKTtcclxufTtcclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgYXJjdGFuZ2VudCAoaW52ZXJzZSB0YW5nZW50KSBpbiByYWRpYW5zIG9mIHRoZSB2YWx1ZVxyXG4gKiBvZiB0aGlzIERlY2ltYWwuXHJcbiAqXHJcbiAqIERvbWFpbjogWy1JbmZpbml0eSwgSW5maW5pdHldXHJcbiAqIFJhbmdlOiBbLXBpLzIsIHBpLzJdXHJcbiAqXHJcbiAqIGF0YW4oeCkgPSB4IC0geF4zLzMgKyB4XjUvNSAtIHheNy83ICsgLi4uXHJcbiAqXHJcbiAqIGF0YW4oMCkgICAgICAgICA9IDBcclxuICogYXRhbigtMCkgICAgICAgID0gLTBcclxuICogYXRhbigxKSAgICAgICAgID0gcGkvNFxyXG4gKiBhdGFuKC0xKSAgICAgICAgPSAtcGkvNFxyXG4gKiBhdGFuKEluZmluaXR5KSAgPSBwaS8yXHJcbiAqIGF0YW4oLUluZmluaXR5KSA9IC1waS8yXHJcbiAqIGF0YW4oTmFOKSAgICAgICA9IE5hTlxyXG4gKlxyXG4gKi9cclxuUC5pbnZlcnNlVGFuZ2VudCA9IFAuYXRhbiA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgaSwgaiwgaywgbiwgcHgsIHQsIHIsIHdwciwgeDIsXHJcbiAgICB4ID0gdGhpcyxcclxuICAgIEN0b3IgPSB4LmNvbnN0cnVjdG9yLFxyXG4gICAgcHIgPSBDdG9yLnByZWNpc2lvbixcclxuICAgIHJtID0gQ3Rvci5yb3VuZGluZztcclxuXHJcbiAgaWYgKCF4LmlzRmluaXRlKCkpIHtcclxuICAgIGlmICgheC5zKSByZXR1cm4gbmV3IEN0b3IoTmFOKTtcclxuICAgIGlmIChwciArIDQgPD0gUElfUFJFQ0lTSU9OKSB7XHJcbiAgICAgIHIgPSBnZXRQaShDdG9yLCBwciArIDQsIHJtKS50aW1lcygwLjUpO1xyXG4gICAgICByLnMgPSB4LnM7XHJcbiAgICAgIHJldHVybiByO1xyXG4gICAgfVxyXG4gIH0gZWxzZSBpZiAoeC5pc1plcm8oKSkge1xyXG4gICAgcmV0dXJuIG5ldyBDdG9yKHgpO1xyXG4gIH0gZWxzZSBpZiAoeC5hYnMoKS5lcSgxKSAmJiBwciArIDQgPD0gUElfUFJFQ0lTSU9OKSB7XHJcbiAgICByID0gZ2V0UGkoQ3RvciwgcHIgKyA0LCBybSkudGltZXMoMC4yNSk7XHJcbiAgICByLnMgPSB4LnM7XHJcbiAgICByZXR1cm4gcjtcclxuICB9XHJcblxyXG4gIEN0b3IucHJlY2lzaW9uID0gd3ByID0gcHIgKyAxMDtcclxuICBDdG9yLnJvdW5kaW5nID0gMTtcclxuXHJcbiAgLy8gVE9ETz8gaWYgKHggPj0gMSAmJiBwciA8PSBQSV9QUkVDSVNJT04pIGF0YW4oeCkgPSBoYWxmUGkgKiB4LnMgLSBhdGFuKDEgLyB4KTtcclxuXHJcbiAgLy8gQXJndW1lbnQgcmVkdWN0aW9uXHJcbiAgLy8gRW5zdXJlIHx4fCA8IDAuNDJcclxuICAvLyBhdGFuKHgpID0gMiAqIGF0YW4oeCAvICgxICsgc3FydCgxICsgeF4yKSkpXHJcblxyXG4gIGsgPSBNYXRoLm1pbigyOCwgd3ByIC8gTE9HX0JBU0UgKyAyIHwgMCk7XHJcblxyXG4gIGZvciAoaSA9IGs7IGk7IC0taSkgeCA9IHguZGl2KHgudGltZXMoeCkucGx1cygxKS5zcXJ0KCkucGx1cygxKSk7XHJcblxyXG4gIGV4dGVybmFsID0gZmFsc2U7XHJcblxyXG4gIGogPSBNYXRoLmNlaWwod3ByIC8gTE9HX0JBU0UpO1xyXG4gIG4gPSAxO1xyXG4gIHgyID0geC50aW1lcyh4KTtcclxuICByID0gbmV3IEN0b3IoeCk7XHJcbiAgcHggPSB4O1xyXG5cclxuICAvLyBhdGFuKHgpID0geCAtIHheMy8zICsgeF41LzUgLSB4XjcvNyArIC4uLlxyXG4gIGZvciAoOyBpICE9PSAtMTspIHtcclxuICAgIHB4ID0gcHgudGltZXMoeDIpO1xyXG4gICAgdCA9IHIubWludXMocHguZGl2KG4gKz0gMikpO1xyXG5cclxuICAgIHB4ID0gcHgudGltZXMoeDIpO1xyXG4gICAgciA9IHQucGx1cyhweC5kaXYobiArPSAyKSk7XHJcblxyXG4gICAgaWYgKHIuZFtqXSAhPT0gdm9pZCAwKSBmb3IgKGkgPSBqOyByLmRbaV0gPT09IHQuZFtpXSAmJiBpLS07KTtcclxuICB9XHJcblxyXG4gIGlmIChrKSByID0gci50aW1lcygyIDw8IChrIC0gMSkpO1xyXG5cclxuICBleHRlcm5hbCA9IHRydWU7XHJcblxyXG4gIHJldHVybiBmaW5hbGlzZShyLCBDdG9yLnByZWNpc2lvbiA9IHByLCBDdG9yLnJvdW5kaW5nID0gcm0sIHRydWUpO1xyXG59O1xyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwgaXMgYSBmaW5pdGUgbnVtYmVyLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gKlxyXG4gKi9cclxuUC5pc0Zpbml0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICByZXR1cm4gISF0aGlzLmQ7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbCBpcyBhbiBpbnRlZ2VyLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gKlxyXG4gKi9cclxuUC5pc0ludGVnZXIgPSBQLmlzSW50ID0gZnVuY3Rpb24gKCkge1xyXG4gIHJldHVybiAhIXRoaXMuZCAmJiBtYXRoZmxvb3IodGhpcy5lIC8gTE9HX0JBU0UpID4gdGhpcy5kLmxlbmd0aCAtIDI7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbCBpcyBOYU4sIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAqXHJcbiAqL1xyXG5QLmlzTmFOID0gZnVuY3Rpb24gKCkge1xyXG4gIHJldHVybiAhdGhpcy5zO1xyXG59O1xyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwgaXMgbmVnYXRpdmUsIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAqXHJcbiAqL1xyXG5QLmlzTmVnYXRpdmUgPSBQLmlzTmVnID0gZnVuY3Rpb24gKCkge1xyXG4gIHJldHVybiB0aGlzLnMgPCAwO1xyXG59O1xyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwgaXMgcG9zaXRpdmUsIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAqXHJcbiAqL1xyXG5QLmlzUG9zaXRpdmUgPSBQLmlzUG9zID0gZnVuY3Rpb24gKCkge1xyXG4gIHJldHVybiB0aGlzLnMgPiAwO1xyXG59O1xyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwgaXMgMCBvciAtMCwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICpcclxuICovXHJcblAuaXNaZXJvID0gZnVuY3Rpb24gKCkge1xyXG4gIHJldHVybiAhIXRoaXMuZCAmJiB0aGlzLmRbMF0gPT09IDA7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbCBpcyBsZXNzIHRoYW4gYHlgLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gKlxyXG4gKi9cclxuUC5sZXNzVGhhbiA9IFAubHQgPSBmdW5jdGlvbiAoeSkge1xyXG4gIHJldHVybiB0aGlzLmNtcCh5KSA8IDA7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbCBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYHlgLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gKlxyXG4gKi9cclxuUC5sZXNzVGhhbk9yRXF1YWxUbyA9IFAubHRlID0gZnVuY3Rpb24gKHkpIHtcclxuICByZXR1cm4gdGhpcy5jbXAoeSkgPCAxO1xyXG59O1xyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiB0aGUgbG9nYXJpdGhtIG9mIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwgdG8gdGhlIHNwZWNpZmllZCBiYXNlLCByb3VuZGVkIHRvIGBwcmVjaXNpb25gXHJcbiAqIHNpZ25pZmljYW50IGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIGByb3VuZGluZ2AuXHJcbiAqXHJcbiAqIElmIG5vIGJhc2UgaXMgc3BlY2lmaWVkLCByZXR1cm4gbG9nWzEwXShhcmcpLlxyXG4gKlxyXG4gKiBsb2dbYmFzZV0oYXJnKSA9IGxuKGFyZykgLyBsbihiYXNlKVxyXG4gKlxyXG4gKiBUaGUgcmVzdWx0IHdpbGwgYWx3YXlzIGJlIGNvcnJlY3RseSByb3VuZGVkIGlmIHRoZSBiYXNlIG9mIHRoZSBsb2cgaXMgMTAsIGFuZCAnYWxtb3N0IGFsd2F5cydcclxuICogb3RoZXJ3aXNlOlxyXG4gKlxyXG4gKiBEZXBlbmRpbmcgb24gdGhlIHJvdW5kaW5nIG1vZGUsIHRoZSByZXN1bHQgbWF5IGJlIGluY29ycmVjdGx5IHJvdW5kZWQgaWYgdGhlIGZpcnN0IGZpZnRlZW5cclxuICogcm91bmRpbmcgZGlnaXRzIGFyZSBbNDldOTk5OTk5OTk5OTk5OTkgb3IgWzUwXTAwMDAwMDAwMDAwMDAwLiBJbiB0aGF0IGNhc2UsIHRoZSBtYXhpbXVtIGVycm9yXHJcbiAqIGJldHdlZW4gdGhlIHJlc3VsdCBhbmQgdGhlIGNvcnJlY3RseSByb3VuZGVkIHJlc3VsdCB3aWxsIGJlIG9uZSB1bHAgKHVuaXQgaW4gdGhlIGxhc3QgcGxhY2UpLlxyXG4gKlxyXG4gKiBsb2dbLWJdKGEpICAgICAgID0gTmFOXHJcbiAqIGxvZ1swXShhKSAgICAgICAgPSBOYU5cclxuICogbG9nWzFdKGEpICAgICAgICA9IE5hTlxyXG4gKiBsb2dbTmFOXShhKSAgICAgID0gTmFOXHJcbiAqIGxvZ1tJbmZpbml0eV0oYSkgPSBOYU5cclxuICogbG9nW2JdKDApICAgICAgICA9IC1JbmZpbml0eVxyXG4gKiBsb2dbYl0oLTApICAgICAgID0gLUluZmluaXR5XHJcbiAqIGxvZ1tiXSgtYSkgICAgICAgPSBOYU5cclxuICogbG9nW2JdKDEpICAgICAgICA9IDBcclxuICogbG9nW2JdKEluZmluaXR5KSA9IEluZmluaXR5XHJcbiAqIGxvZ1tiXShOYU4pICAgICAgPSBOYU5cclxuICpcclxuICogW2Jhc2VdIHtudW1iZXJ8c3RyaW5nfERlY2ltYWx9IFRoZSBiYXNlIG9mIHRoZSBsb2dhcml0aG0uXHJcbiAqXHJcbiAqL1xyXG5QLmxvZ2FyaXRobSA9IFAubG9nID0gZnVuY3Rpb24gKGJhc2UpIHtcclxuICB2YXIgaXNCYXNlMTAsIGQsIGRlbm9taW5hdG9yLCBrLCBpbmYsIG51bSwgc2QsIHIsXHJcbiAgICBhcmcgPSB0aGlzLFxyXG4gICAgQ3RvciA9IGFyZy5jb25zdHJ1Y3RvcixcclxuICAgIHByID0gQ3Rvci5wcmVjaXNpb24sXHJcbiAgICBybSA9IEN0b3Iucm91bmRpbmcsXHJcbiAgICBndWFyZCA9IDU7XHJcblxyXG4gIC8vIERlZmF1bHQgYmFzZSBpcyAxMC5cclxuICBpZiAoYmFzZSA9PSBudWxsKSB7XHJcbiAgICBiYXNlID0gbmV3IEN0b3IoMTApO1xyXG4gICAgaXNCYXNlMTAgPSB0cnVlO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBiYXNlID0gbmV3IEN0b3IoYmFzZSk7XHJcbiAgICBkID0gYmFzZS5kO1xyXG5cclxuICAgIC8vIFJldHVybiBOYU4gaWYgYmFzZSBpcyBuZWdhdGl2ZSwgb3Igbm9uLWZpbml0ZSwgb3IgaXMgMCBvciAxLlxyXG4gICAgaWYgKGJhc2UucyA8IDAgfHwgIWQgfHwgIWRbMF0gfHwgYmFzZS5lcSgxKSkgcmV0dXJuIG5ldyBDdG9yKE5hTik7XHJcblxyXG4gICAgaXNCYXNlMTAgPSBiYXNlLmVxKDEwKTtcclxuICB9XHJcblxyXG4gIGQgPSBhcmcuZDtcclxuXHJcbiAgLy8gSXMgYXJnIG5lZ2F0aXZlLCBub24tZmluaXRlLCAwIG9yIDE/XHJcbiAgaWYgKGFyZy5zIDwgMCB8fCAhZCB8fCAhZFswXSB8fCBhcmcuZXEoMSkpIHtcclxuICAgIHJldHVybiBuZXcgQ3RvcihkICYmICFkWzBdID8gLTEgLyAwIDogYXJnLnMgIT0gMSA/IE5hTiA6IGQgPyAwIDogMSAvIDApO1xyXG4gIH1cclxuXHJcbiAgLy8gVGhlIHJlc3VsdCB3aWxsIGhhdmUgYSBub24tdGVybWluYXRpbmcgZGVjaW1hbCBleHBhbnNpb24gaWYgYmFzZSBpcyAxMCBhbmQgYXJnIGlzIG5vdCBhblxyXG4gIC8vIGludGVnZXIgcG93ZXIgb2YgMTAuXHJcbiAgaWYgKGlzQmFzZTEwKSB7XHJcbiAgICBpZiAoZC5sZW5ndGggPiAxKSB7XHJcbiAgICAgIGluZiA9IHRydWU7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBmb3IgKGsgPSBkWzBdOyBrICUgMTAgPT09IDA7KSBrIC89IDEwO1xyXG4gICAgICBpbmYgPSBrICE9PSAxO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZXh0ZXJuYWwgPSBmYWxzZTtcclxuICBzZCA9IHByICsgZ3VhcmQ7XHJcbiAgbnVtID0gbmF0dXJhbExvZ2FyaXRobShhcmcsIHNkKTtcclxuICBkZW5vbWluYXRvciA9IGlzQmFzZTEwID8gZ2V0TG4xMChDdG9yLCBzZCArIDEwKSA6IG5hdHVyYWxMb2dhcml0aG0oYmFzZSwgc2QpO1xyXG5cclxuICAvLyBUaGUgcmVzdWx0IHdpbGwgaGF2ZSA1IHJvdW5kaW5nIGRpZ2l0cy5cclxuICByID0gZGl2aWRlKG51bSwgZGVub21pbmF0b3IsIHNkLCAxKTtcclxuXHJcbiAgLy8gSWYgYXQgYSByb3VuZGluZyBib3VuZGFyeSwgaS5lLiB0aGUgcmVzdWx0J3Mgcm91bmRpbmcgZGlnaXRzIGFyZSBbNDldOTk5OSBvciBbNTBdMDAwMCxcclxuICAvLyBjYWxjdWxhdGUgMTAgZnVydGhlciBkaWdpdHMuXHJcbiAgLy9cclxuICAvLyBJZiB0aGUgcmVzdWx0IGlzIGtub3duIHRvIGhhdmUgYW4gaW5maW5pdGUgZGVjaW1hbCBleHBhbnNpb24sIHJlcGVhdCB0aGlzIHVudGlsIGl0IGlzIGNsZWFyXHJcbiAgLy8gdGhhdCB0aGUgcmVzdWx0IGlzIGFib3ZlIG9yIGJlbG93IHRoZSBib3VuZGFyeS4gT3RoZXJ3aXNlLCBpZiBhZnRlciBjYWxjdWxhdGluZyB0aGUgMTBcclxuICAvLyBmdXJ0aGVyIGRpZ2l0cywgdGhlIGxhc3QgMTQgYXJlIG5pbmVzLCByb3VuZCB1cCBhbmQgYXNzdW1lIHRoZSByZXN1bHQgaXMgZXhhY3QuXHJcbiAgLy8gQWxzbyBhc3N1bWUgdGhlIHJlc3VsdCBpcyBleGFjdCBpZiB0aGUgbGFzdCAxNCBhcmUgemVyby5cclxuICAvL1xyXG4gIC8vIEV4YW1wbGUgb2YgYSByZXN1bHQgdGhhdCB3aWxsIGJlIGluY29ycmVjdGx5IHJvdW5kZWQ6XHJcbiAgLy8gbG9nWzEwNDg1NzZdKDQ1MDM1OTk2MjczNzA1MDIpID0gMi42MDAwMDAwMDAwMDAwMDAwOTYxMDI3OTUxMTQ0NDc0Ni4uLlxyXG4gIC8vIFRoZSBhYm92ZSByZXN1bHQgY29ycmVjdGx5IHJvdW5kZWQgdXNpbmcgUk9VTkRfQ0VJTCB0byAxIGRlY2ltYWwgcGxhY2Ugc2hvdWxkIGJlIDIuNywgYnV0IGl0XHJcbiAgLy8gd2lsbCBiZSBnaXZlbiBhcyAyLjYgYXMgdGhlcmUgYXJlIDE1IHplcm9zIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSByZXF1ZXN0ZWQgZGVjaW1hbCBwbGFjZSwgc29cclxuICAvLyB0aGUgZXhhY3QgcmVzdWx0IHdvdWxkIGJlIGFzc3VtZWQgdG8gYmUgMi42LCB3aGljaCByb3VuZGVkIHVzaW5nIFJPVU5EX0NFSUwgdG8gMSBkZWNpbWFsXHJcbiAgLy8gcGxhY2UgaXMgc3RpbGwgMi42LlxyXG4gIGlmIChjaGVja1JvdW5kaW5nRGlnaXRzKHIuZCwgayA9IHByLCBybSkpIHtcclxuXHJcbiAgICBkbyB7XHJcbiAgICAgIHNkICs9IDEwO1xyXG4gICAgICBudW0gPSBuYXR1cmFsTG9nYXJpdGhtKGFyZywgc2QpO1xyXG4gICAgICBkZW5vbWluYXRvciA9IGlzQmFzZTEwID8gZ2V0TG4xMChDdG9yLCBzZCArIDEwKSA6IG5hdHVyYWxMb2dhcml0aG0oYmFzZSwgc2QpO1xyXG4gICAgICByID0gZGl2aWRlKG51bSwgZGVub21pbmF0b3IsIHNkLCAxKTtcclxuXHJcbiAgICAgIGlmICghaW5mKSB7XHJcblxyXG4gICAgICAgIC8vIENoZWNrIGZvciAxNCBuaW5lcyBmcm9tIHRoZSAybmQgcm91bmRpbmcgZGlnaXQsIGFzIHRoZSBmaXJzdCBtYXkgYmUgNC5cclxuICAgICAgICBpZiAoK2RpZ2l0c1RvU3RyaW5nKHIuZCkuc2xpY2UoayArIDEsIGsgKyAxNSkgKyAxID09IDFlMTQpIHtcclxuICAgICAgICAgIHIgPSBmaW5hbGlzZShyLCBwciArIDEsIDApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgIH0gd2hpbGUgKGNoZWNrUm91bmRpbmdEaWdpdHMoci5kLCBrICs9IDEwLCBybSkpO1xyXG4gIH1cclxuXHJcbiAgZXh0ZXJuYWwgPSB0cnVlO1xyXG5cclxuICByZXR1cm4gZmluYWxpc2UociwgcHIsIHJtKTtcclxufTtcclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgbWF4aW11bSBvZiB0aGUgYXJndW1lbnRzIGFuZCB0aGUgdmFsdWUgb2YgdGhpcyBEZWNpbWFsLlxyXG4gKlxyXG4gKiBhcmd1bWVudHMge251bWJlcnxzdHJpbmd8RGVjaW1hbH1cclxuICpcclxuUC5tYXggPSBmdW5jdGlvbiAoKSB7XHJcbiAgQXJyYXkucHJvdG90eXBlLnB1c2guY2FsbChhcmd1bWVudHMsIHRoaXMpO1xyXG4gIHJldHVybiBtYXhPck1pbih0aGlzLmNvbnN0cnVjdG9yLCBhcmd1bWVudHMsICdsdCcpO1xyXG59O1xyXG4gKi9cclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgbWluaW11bSBvZiB0aGUgYXJndW1lbnRzIGFuZCB0aGUgdmFsdWUgb2YgdGhpcyBEZWNpbWFsLlxyXG4gKlxyXG4gKiBhcmd1bWVudHMge251bWJlcnxzdHJpbmd8RGVjaW1hbH1cclxuICpcclxuUC5taW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgQXJyYXkucHJvdG90eXBlLnB1c2guY2FsbChhcmd1bWVudHMsIHRoaXMpO1xyXG4gIHJldHVybiBtYXhPck1pbih0aGlzLmNvbnN0cnVjdG9yLCBhcmd1bWVudHMsICdndCcpO1xyXG59O1xyXG4gKi9cclxuXHJcblxyXG4vKlxyXG4gKiAgbiAtIDAgPSBuXHJcbiAqICBuIC0gTiA9IE5cclxuICogIG4gLSBJID0gLUlcclxuICogIDAgLSBuID0gLW5cclxuICogIDAgLSAwID0gMFxyXG4gKiAgMCAtIE4gPSBOXHJcbiAqICAwIC0gSSA9IC1JXHJcbiAqICBOIC0gbiA9IE5cclxuICogIE4gLSAwID0gTlxyXG4gKiAgTiAtIE4gPSBOXHJcbiAqICBOIC0gSSA9IE5cclxuICogIEkgLSBuID0gSVxyXG4gKiAgSSAtIDAgPSBJXHJcbiAqICBJIC0gTiA9IE5cclxuICogIEkgLSBJID0gTlxyXG4gKlxyXG4gKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBEZWNpbWFsIG1pbnVzIGB5YCwgcm91bmRlZCB0byBgcHJlY2lzaW9uYFxyXG4gKiBzaWduaWZpY2FudCBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSBgcm91bmRpbmdgLlxyXG4gKlxyXG4gKi9cclxuUC5taW51cyA9IFAuc3ViID0gZnVuY3Rpb24gKHkpIHtcclxuICB2YXIgZCwgZSwgaSwgaiwgaywgbGVuLCBwciwgcm0sIHhkLCB4ZSwgeExUeSwgeWQsXHJcbiAgICB4ID0gdGhpcyxcclxuICAgIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xyXG5cclxuICB5ID0gbmV3IEN0b3IoeSk7XHJcblxyXG4gIC8vIElmIGVpdGhlciBpcyBub3QgZmluaXRlLi4uXHJcbiAgaWYgKCF4LmQgfHwgIXkuZCkge1xyXG5cclxuICAgIC8vIFJldHVybiBOYU4gaWYgZWl0aGVyIGlzIE5hTi5cclxuICAgIGlmICgheC5zIHx8ICF5LnMpIHkgPSBuZXcgQ3RvcihOYU4pO1xyXG5cclxuICAgIC8vIFJldHVybiB5IG5lZ2F0ZWQgaWYgeCBpcyBmaW5pdGUgYW5kIHkgaXMgwrFJbmZpbml0eS5cclxuICAgIGVsc2UgaWYgKHguZCkgeS5zID0gLXkucztcclxuXHJcbiAgICAvLyBSZXR1cm4geCBpZiB5IGlzIGZpbml0ZSBhbmQgeCBpcyDCsUluZmluaXR5LlxyXG4gICAgLy8gUmV0dXJuIHggaWYgYm90aCBhcmUgwrFJbmZpbml0eSB3aXRoIGRpZmZlcmVudCBzaWducy5cclxuICAgIC8vIFJldHVybiBOYU4gaWYgYm90aCBhcmUgwrFJbmZpbml0eSB3aXRoIHRoZSBzYW1lIHNpZ24uXHJcbiAgICBlbHNlIHkgPSBuZXcgQ3Rvcih5LmQgfHwgeC5zICE9PSB5LnMgPyB4IDogTmFOKTtcclxuXHJcbiAgICByZXR1cm4geTtcclxuICB9XHJcblxyXG4gIC8vIElmIHNpZ25zIGRpZmZlci4uLlxyXG4gIGlmICh4LnMgIT0geS5zKSB7XHJcbiAgICB5LnMgPSAteS5zO1xyXG4gICAgcmV0dXJuIHgucGx1cyh5KTtcclxuICB9XHJcblxyXG4gIHhkID0geC5kO1xyXG4gIHlkID0geS5kO1xyXG4gIHByID0gQ3Rvci5wcmVjaXNpb247XHJcbiAgcm0gPSBDdG9yLnJvdW5kaW5nO1xyXG5cclxuICAvLyBJZiBlaXRoZXIgaXMgemVyby4uLlxyXG4gIGlmICgheGRbMF0gfHwgIXlkWzBdKSB7XHJcblxyXG4gICAgLy8gUmV0dXJuIHkgbmVnYXRlZCBpZiB4IGlzIHplcm8gYW5kIHkgaXMgbm9uLXplcm8uXHJcbiAgICBpZiAoeWRbMF0pIHkucyA9IC15LnM7XHJcblxyXG4gICAgLy8gUmV0dXJuIHggaWYgeSBpcyB6ZXJvIGFuZCB4IGlzIG5vbi16ZXJvLlxyXG4gICAgZWxzZSBpZiAoeGRbMF0pIHkgPSBuZXcgQ3Rvcih4KTtcclxuXHJcbiAgICAvLyBSZXR1cm4gemVybyBpZiBib3RoIGFyZSB6ZXJvLlxyXG4gICAgLy8gRnJvbSBJRUVFIDc1NCAoMjAwOCkgNi4zOiAwIC0gMCA9IC0wIC0gLTAgPSAtMCB3aGVuIHJvdW5kaW5nIHRvIC1JbmZpbml0eS5cclxuICAgIGVsc2UgcmV0dXJuIG5ldyBDdG9yKHJtID09PSAzID8gLTAgOiAwKTtcclxuXHJcbiAgICByZXR1cm4gZXh0ZXJuYWwgPyBmaW5hbGlzZSh5LCBwciwgcm0pIDogeTtcclxuICB9XHJcblxyXG4gIC8vIHggYW5kIHkgYXJlIGZpbml0ZSwgbm9uLXplcm8gbnVtYmVycyB3aXRoIHRoZSBzYW1lIHNpZ24uXHJcblxyXG4gIC8vIENhbGN1bGF0ZSBiYXNlIDFlNyBleHBvbmVudHMuXHJcbiAgZSA9IG1hdGhmbG9vcih5LmUgLyBMT0dfQkFTRSk7XHJcbiAgeGUgPSBtYXRoZmxvb3IoeC5lIC8gTE9HX0JBU0UpO1xyXG5cclxuICB4ZCA9IHhkLnNsaWNlKCk7XHJcbiAgayA9IHhlIC0gZTtcclxuXHJcbiAgLy8gSWYgYmFzZSAxZTcgZXhwb25lbnRzIGRpZmZlci4uLlxyXG4gIGlmIChrKSB7XHJcbiAgICB4TFR5ID0gayA8IDA7XHJcblxyXG4gICAgaWYgKHhMVHkpIHtcclxuICAgICAgZCA9IHhkO1xyXG4gICAgICBrID0gLWs7XHJcbiAgICAgIGxlbiA9IHlkLmxlbmd0aDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGQgPSB5ZDtcclxuICAgICAgZSA9IHhlO1xyXG4gICAgICBsZW4gPSB4ZC5sZW5ndGg7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gTnVtYmVycyB3aXRoIG1hc3NpdmVseSBkaWZmZXJlbnQgZXhwb25lbnRzIHdvdWxkIHJlc3VsdCBpbiBhIHZlcnkgaGlnaCBudW1iZXIgb2ZcclxuICAgIC8vIHplcm9zIG5lZWRpbmcgdG8gYmUgcHJlcGVuZGVkLCBidXQgdGhpcyBjYW4gYmUgYXZvaWRlZCB3aGlsZSBzdGlsbCBlbnN1cmluZyBjb3JyZWN0XHJcbiAgICAvLyByb3VuZGluZyBieSBsaW1pdGluZyB0aGUgbnVtYmVyIG9mIHplcm9zIHRvIGBNYXRoLmNlaWwocHIgLyBMT0dfQkFTRSkgKyAyYC5cclxuICAgIGkgPSBNYXRoLm1heChNYXRoLmNlaWwocHIgLyBMT0dfQkFTRSksIGxlbikgKyAyO1xyXG5cclxuICAgIGlmIChrID4gaSkge1xyXG4gICAgICBrID0gaTtcclxuICAgICAgZC5sZW5ndGggPSAxO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFByZXBlbmQgemVyb3MgdG8gZXF1YWxpc2UgZXhwb25lbnRzLlxyXG4gICAgZC5yZXZlcnNlKCk7XHJcbiAgICBmb3IgKGkgPSBrOyBpLS07KSBkLnB1c2goMCk7XHJcbiAgICBkLnJldmVyc2UoKTtcclxuXHJcbiAgLy8gQmFzZSAxZTcgZXhwb25lbnRzIGVxdWFsLlxyXG4gIH0gZWxzZSB7XHJcblxyXG4gICAgLy8gQ2hlY2sgZGlnaXRzIHRvIGRldGVybWluZSB3aGljaCBpcyB0aGUgYmlnZ2VyIG51bWJlci5cclxuXHJcbiAgICBpID0geGQubGVuZ3RoO1xyXG4gICAgbGVuID0geWQubGVuZ3RoO1xyXG4gICAgeExUeSA9IGkgPCBsZW47XHJcbiAgICBpZiAoeExUeSkgbGVuID0gaTtcclxuXHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgaWYgKHhkW2ldICE9IHlkW2ldKSB7XHJcbiAgICAgICAgeExUeSA9IHhkW2ldIDwgeWRbaV07XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBrID0gMDtcclxuICB9XHJcblxyXG4gIGlmICh4TFR5KSB7XHJcbiAgICBkID0geGQ7XHJcbiAgICB4ZCA9IHlkO1xyXG4gICAgeWQgPSBkO1xyXG4gICAgeS5zID0gLXkucztcclxuICB9XHJcblxyXG4gIGxlbiA9IHhkLmxlbmd0aDtcclxuXHJcbiAgLy8gQXBwZW5kIHplcm9zIHRvIGB4ZGAgaWYgc2hvcnRlci5cclxuICAvLyBEb24ndCBhZGQgemVyb3MgdG8gYHlkYCBpZiBzaG9ydGVyIGFzIHN1YnRyYWN0aW9uIG9ubHkgbmVlZHMgdG8gc3RhcnQgYXQgYHlkYCBsZW5ndGguXHJcbiAgZm9yIChpID0geWQubGVuZ3RoIC0gbGVuOyBpID4gMDsgLS1pKSB4ZFtsZW4rK10gPSAwO1xyXG5cclxuICAvLyBTdWJ0cmFjdCB5ZCBmcm9tIHhkLlxyXG4gIGZvciAoaSA9IHlkLmxlbmd0aDsgaSA+IGs7KSB7XHJcblxyXG4gICAgaWYgKHhkWy0taV0gPCB5ZFtpXSkge1xyXG4gICAgICBmb3IgKGogPSBpOyBqICYmIHhkWy0tal0gPT09IDA7KSB4ZFtqXSA9IEJBU0UgLSAxO1xyXG4gICAgICAtLXhkW2pdO1xyXG4gICAgICB4ZFtpXSArPSBCQVNFO1xyXG4gICAgfVxyXG5cclxuICAgIHhkW2ldIC09IHlkW2ldO1xyXG4gIH1cclxuXHJcbiAgLy8gUmVtb3ZlIHRyYWlsaW5nIHplcm9zLlxyXG4gIGZvciAoOyB4ZFstLWxlbl0gPT09IDA7KSB4ZC5wb3AoKTtcclxuXHJcbiAgLy8gUmVtb3ZlIGxlYWRpbmcgemVyb3MgYW5kIGFkanVzdCBleHBvbmVudCBhY2NvcmRpbmdseS5cclxuICBmb3IgKDsgeGRbMF0gPT09IDA7IHhkLnNoaWZ0KCkpIC0tZTtcclxuXHJcbiAgLy8gWmVybz9cclxuICBpZiAoIXhkWzBdKSByZXR1cm4gbmV3IEN0b3Iocm0gPT09IDMgPyAtMCA6IDApO1xyXG5cclxuICB5LmQgPSB4ZDtcclxuICB5LmUgPSBnZXRCYXNlMTBFeHBvbmVudCh4ZCwgZSk7XHJcblxyXG4gIHJldHVybiBleHRlcm5hbCA/IGZpbmFsaXNlKHksIHByLCBybSkgOiB5O1xyXG59O1xyXG5cclxuXHJcbi8qXHJcbiAqICAgbiAlIDAgPSAgTlxyXG4gKiAgIG4gJSBOID0gIE5cclxuICogICBuICUgSSA9ICBuXHJcbiAqICAgMCAlIG4gPSAgMFxyXG4gKiAgLTAgJSBuID0gLTBcclxuICogICAwICUgMCA9ICBOXHJcbiAqICAgMCAlIE4gPSAgTlxyXG4gKiAgIDAgJSBJID0gIDBcclxuICogICBOICUgbiA9ICBOXHJcbiAqICAgTiAlIDAgPSAgTlxyXG4gKiAgIE4gJSBOID0gIE5cclxuICogICBOICUgSSA9ICBOXHJcbiAqICAgSSAlIG4gPSAgTlxyXG4gKiAgIEkgJSAwID0gIE5cclxuICogICBJICUgTiA9ICBOXHJcbiAqICAgSSAlIEkgPSAgTlxyXG4gKlxyXG4gKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBEZWNpbWFsIG1vZHVsbyBgeWAsIHJvdW5kZWQgdG9cclxuICogYHByZWNpc2lvbmAgc2lnbmlmaWNhbnQgZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJvdW5kaW5nYC5cclxuICpcclxuICogVGhlIHJlc3VsdCBkZXBlbmRzIG9uIHRoZSBtb2R1bG8gbW9kZS5cclxuICpcclxuICovXHJcblAubW9kdWxvID0gUC5tb2QgPSBmdW5jdGlvbiAoeSkge1xyXG4gIHZhciBxLFxyXG4gICAgeCA9IHRoaXMsXHJcbiAgICBDdG9yID0geC5jb25zdHJ1Y3RvcjtcclxuXHJcbiAgeSA9IG5ldyBDdG9yKHkpO1xyXG5cclxuICAvLyBSZXR1cm4gTmFOIGlmIHggaXMgwrFJbmZpbml0eSBvciBOYU4sIG9yIHkgaXMgTmFOIG9yIMKxMC5cclxuICBpZiAoIXguZCB8fCAheS5zIHx8IHkuZCAmJiAheS5kWzBdKSByZXR1cm4gbmV3IEN0b3IoTmFOKTtcclxuXHJcbiAgLy8gUmV0dXJuIHggaWYgeSBpcyDCsUluZmluaXR5IG9yIHggaXMgwrEwLlxyXG4gIGlmICgheS5kIHx8IHguZCAmJiAheC5kWzBdKSB7XHJcbiAgICByZXR1cm4gZmluYWxpc2UobmV3IEN0b3IoeCksIEN0b3IucHJlY2lzaW9uLCBDdG9yLnJvdW5kaW5nKTtcclxuICB9XHJcblxyXG4gIC8vIFByZXZlbnQgcm91bmRpbmcgb2YgaW50ZXJtZWRpYXRlIGNhbGN1bGF0aW9ucy5cclxuICBleHRlcm5hbCA9IGZhbHNlO1xyXG5cclxuICBpZiAoQ3Rvci5tb2R1bG8gPT0gOSkge1xyXG5cclxuICAgIC8vIEV1Y2xpZGlhbiBkaXZpc2lvbjogcSA9IHNpZ24oeSkgKiBmbG9vcih4IC8gYWJzKHkpKVxyXG4gICAgLy8gcmVzdWx0ID0geCAtIHEgKiB5ICAgIHdoZXJlICAwIDw9IHJlc3VsdCA8IGFicyh5KVxyXG4gICAgcSA9IGRpdmlkZSh4LCB5LmFicygpLCAwLCAzLCAxKTtcclxuICAgIHEucyAqPSB5LnM7XHJcbiAgfSBlbHNlIHtcclxuICAgIHEgPSBkaXZpZGUoeCwgeSwgMCwgQ3Rvci5tb2R1bG8sIDEpO1xyXG4gIH1cclxuXHJcbiAgcSA9IHEudGltZXMoeSk7XHJcblxyXG4gIGV4dGVybmFsID0gdHJ1ZTtcclxuXHJcbiAgcmV0dXJuIHgubWludXMocSk7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIG5hdHVyYWwgZXhwb25lbnRpYWwgb2YgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbCxcclxuICogaS5lLiB0aGUgYmFzZSBlIHJhaXNlZCB0byB0aGUgcG93ZXIgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbCwgcm91bmRlZCB0byBgcHJlY2lzaW9uYFxyXG4gKiBzaWduaWZpY2FudCBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSBgcm91bmRpbmdgLlxyXG4gKlxyXG4gKi9cclxuUC5uYXR1cmFsRXhwb25lbnRpYWwgPSBQLmV4cCA9IGZ1bmN0aW9uICgpIHtcclxuICByZXR1cm4gbmF0dXJhbEV4cG9uZW50aWFsKHRoaXMpO1xyXG59O1xyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSBuYXR1cmFsIGxvZ2FyaXRobSBvZiB0aGUgdmFsdWUgb2YgdGhpcyBEZWNpbWFsLFxyXG4gKiByb3VuZGVkIHRvIGBwcmVjaXNpb25gIHNpZ25pZmljYW50IGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIGByb3VuZGluZ2AuXHJcbiAqXHJcbiAqL1xyXG5QLm5hdHVyYWxMb2dhcml0aG0gPSBQLmxuID0gZnVuY3Rpb24gKCkge1xyXG4gIHJldHVybiBuYXR1cmFsTG9nYXJpdGhtKHRoaXMpO1xyXG59O1xyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwgbmVnYXRlZCwgaS5lLiBhcyBpZiBtdWx0aXBsaWVkIGJ5XHJcbiAqIC0xLlxyXG4gKlxyXG4gKi9cclxuUC5uZWdhdGVkID0gUC5uZWcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIHggPSBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzKTtcclxuICB4LnMgPSAteC5zO1xyXG4gIHJldHVybiBmaW5hbGlzZSh4KTtcclxufTtcclxuXHJcblxyXG4vKlxyXG4gKiAgbiArIDAgPSBuXHJcbiAqICBuICsgTiA9IE5cclxuICogIG4gKyBJID0gSVxyXG4gKiAgMCArIG4gPSBuXHJcbiAqICAwICsgMCA9IDBcclxuICogIDAgKyBOID0gTlxyXG4gKiAgMCArIEkgPSBJXHJcbiAqICBOICsgbiA9IE5cclxuICogIE4gKyAwID0gTlxyXG4gKiAgTiArIE4gPSBOXHJcbiAqICBOICsgSSA9IE5cclxuICogIEkgKyBuID0gSVxyXG4gKiAgSSArIDAgPSBJXHJcbiAqICBJICsgTiA9IE5cclxuICogIEkgKyBJID0gSVxyXG4gKlxyXG4gKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBEZWNpbWFsIHBsdXMgYHlgLCByb3VuZGVkIHRvIGBwcmVjaXNpb25gXHJcbiAqIHNpZ25pZmljYW50IGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIGByb3VuZGluZ2AuXHJcbiAqXHJcbiAqL1xyXG5QLnBsdXMgPSBQLmFkZCA9IGZ1bmN0aW9uICh5KSB7XHJcbiAgdmFyIGNhcnJ5LCBkLCBlLCBpLCBrLCBsZW4sIHByLCBybSwgeGQsIHlkLFxyXG4gICAgeCA9IHRoaXMsXHJcbiAgICBDdG9yID0geC5jb25zdHJ1Y3RvcjtcclxuXHJcbiAgeSA9IG5ldyBDdG9yKHkpO1xyXG5cclxuICAvLyBJZiBlaXRoZXIgaXMgbm90IGZpbml0ZS4uLlxyXG4gIGlmICgheC5kIHx8ICF5LmQpIHtcclxuXHJcbiAgICAvLyBSZXR1cm4gTmFOIGlmIGVpdGhlciBpcyBOYU4uXHJcbiAgICBpZiAoIXgucyB8fCAheS5zKSB5ID0gbmV3IEN0b3IoTmFOKTtcclxuXHJcbiAgICAvLyBSZXR1cm4geCBpZiB5IGlzIGZpbml0ZSBhbmQgeCBpcyDCsUluZmluaXR5LlxyXG4gICAgLy8gUmV0dXJuIHggaWYgYm90aCBhcmUgwrFJbmZpbml0eSB3aXRoIHRoZSBzYW1lIHNpZ24uXHJcbiAgICAvLyBSZXR1cm4gTmFOIGlmIGJvdGggYXJlIMKxSW5maW5pdHkgd2l0aCBkaWZmZXJlbnQgc2lnbnMuXHJcbiAgICAvLyBSZXR1cm4geSBpZiB4IGlzIGZpbml0ZSBhbmQgeSBpcyDCsUluZmluaXR5LlxyXG4gICAgZWxzZSBpZiAoIXguZCkgeSA9IG5ldyBDdG9yKHkuZCB8fCB4LnMgPT09IHkucyA/IHggOiBOYU4pO1xyXG5cclxuICAgIHJldHVybiB5O1xyXG4gIH1cclxuXHJcbiAgIC8vIElmIHNpZ25zIGRpZmZlci4uLlxyXG4gIGlmICh4LnMgIT0geS5zKSB7XHJcbiAgICB5LnMgPSAteS5zO1xyXG4gICAgcmV0dXJuIHgubWludXMoeSk7XHJcbiAgfVxyXG5cclxuICB4ZCA9IHguZDtcclxuICB5ZCA9IHkuZDtcclxuICBwciA9IEN0b3IucHJlY2lzaW9uO1xyXG4gIHJtID0gQ3Rvci5yb3VuZGluZztcclxuXHJcbiAgLy8gSWYgZWl0aGVyIGlzIHplcm8uLi5cclxuICBpZiAoIXhkWzBdIHx8ICF5ZFswXSkge1xyXG5cclxuICAgIC8vIFJldHVybiB4IGlmIHkgaXMgemVyby5cclxuICAgIC8vIFJldHVybiB5IGlmIHkgaXMgbm9uLXplcm8uXHJcbiAgICBpZiAoIXlkWzBdKSB5ID0gbmV3IEN0b3IoeCk7XHJcblxyXG4gICAgcmV0dXJuIGV4dGVybmFsID8gZmluYWxpc2UoeSwgcHIsIHJtKSA6IHk7XHJcbiAgfVxyXG5cclxuICAvLyB4IGFuZCB5IGFyZSBmaW5pdGUsIG5vbi16ZXJvIG51bWJlcnMgd2l0aCB0aGUgc2FtZSBzaWduLlxyXG5cclxuICAvLyBDYWxjdWxhdGUgYmFzZSAxZTcgZXhwb25lbnRzLlxyXG4gIGsgPSBtYXRoZmxvb3IoeC5lIC8gTE9HX0JBU0UpO1xyXG4gIGUgPSBtYXRoZmxvb3IoeS5lIC8gTE9HX0JBU0UpO1xyXG5cclxuICB4ZCA9IHhkLnNsaWNlKCk7XHJcbiAgaSA9IGsgLSBlO1xyXG5cclxuICAvLyBJZiBiYXNlIDFlNyBleHBvbmVudHMgZGlmZmVyLi4uXHJcbiAgaWYgKGkpIHtcclxuXHJcbiAgICBpZiAoaSA8IDApIHtcclxuICAgICAgZCA9IHhkO1xyXG4gICAgICBpID0gLWk7XHJcbiAgICAgIGxlbiA9IHlkLmxlbmd0aDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGQgPSB5ZDtcclxuICAgICAgZSA9IGs7XHJcbiAgICAgIGxlbiA9IHhkLmxlbmd0aDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBMaW1pdCBudW1iZXIgb2YgemVyb3MgcHJlcGVuZGVkIHRvIG1heChjZWlsKHByIC8gTE9HX0JBU0UpLCBsZW4pICsgMS5cclxuICAgIGsgPSBNYXRoLmNlaWwocHIgLyBMT0dfQkFTRSk7XHJcbiAgICBsZW4gPSBrID4gbGVuID8gayArIDEgOiBsZW4gKyAxO1xyXG5cclxuICAgIGlmIChpID4gbGVuKSB7XHJcbiAgICAgIGkgPSBsZW47XHJcbiAgICAgIGQubGVuZ3RoID0gMTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBQcmVwZW5kIHplcm9zIHRvIGVxdWFsaXNlIGV4cG9uZW50cy4gTm90ZTogRmFzdGVyIHRvIHVzZSByZXZlcnNlIHRoZW4gZG8gdW5zaGlmdHMuXHJcbiAgICBkLnJldmVyc2UoKTtcclxuICAgIGZvciAoOyBpLS07KSBkLnB1c2goMCk7XHJcbiAgICBkLnJldmVyc2UoKTtcclxuICB9XHJcblxyXG4gIGxlbiA9IHhkLmxlbmd0aDtcclxuICBpID0geWQubGVuZ3RoO1xyXG5cclxuICAvLyBJZiB5ZCBpcyBsb25nZXIgdGhhbiB4ZCwgc3dhcCB4ZCBhbmQgeWQgc28geGQgcG9pbnRzIHRvIHRoZSBsb25nZXIgYXJyYXkuXHJcbiAgaWYgKGxlbiAtIGkgPCAwKSB7XHJcbiAgICBpID0gbGVuO1xyXG4gICAgZCA9IHlkO1xyXG4gICAgeWQgPSB4ZDtcclxuICAgIHhkID0gZDtcclxuICB9XHJcblxyXG4gIC8vIE9ubHkgc3RhcnQgYWRkaW5nIGF0IHlkLmxlbmd0aCAtIDEgYXMgdGhlIGZ1cnRoZXIgZGlnaXRzIG9mIHhkIGNhbiBiZSBsZWZ0IGFzIHRoZXkgYXJlLlxyXG4gIGZvciAoY2FycnkgPSAwOyBpOykge1xyXG4gICAgY2FycnkgPSAoeGRbLS1pXSA9IHhkW2ldICsgeWRbaV0gKyBjYXJyeSkgLyBCQVNFIHwgMDtcclxuICAgIHhkW2ldICU9IEJBU0U7XHJcbiAgfVxyXG5cclxuICBpZiAoY2FycnkpIHtcclxuICAgIHhkLnVuc2hpZnQoY2FycnkpO1xyXG4gICAgKytlO1xyXG4gIH1cclxuXHJcbiAgLy8gUmVtb3ZlIHRyYWlsaW5nIHplcm9zLlxyXG4gIC8vIE5vIG5lZWQgdG8gY2hlY2sgZm9yIHplcm8sIGFzICt4ICsgK3kgIT0gMCAmJiAteCArIC15ICE9IDBcclxuICBmb3IgKGxlbiA9IHhkLmxlbmd0aDsgeGRbLS1sZW5dID09IDA7KSB4ZC5wb3AoKTtcclxuXHJcbiAgeS5kID0geGQ7XHJcbiAgeS5lID0gZ2V0QmFzZTEwRXhwb25lbnQoeGQsIGUpO1xyXG5cclxuICByZXR1cm4gZXh0ZXJuYWwgPyBmaW5hbGlzZSh5LCBwciwgcm0pIDogeTtcclxufTtcclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gdGhlIG51bWJlciBvZiBzaWduaWZpY2FudCBkaWdpdHMgb2YgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbC5cclxuICpcclxuICogW3pdIHtib29sZWFufG51bWJlcn0gV2hldGhlciB0byBjb3VudCBpbnRlZ2VyLXBhcnQgdHJhaWxpbmcgemVyb3M6IHRydWUsIGZhbHNlLCAxIG9yIDAuXHJcbiAqXHJcbiAqL1xyXG5QLnByZWNpc2lvbiA9IFAuc2QgPSBmdW5jdGlvbiAoeikge1xyXG4gIHZhciBrLFxyXG4gICAgeCA9IHRoaXM7XHJcblxyXG4gIGlmICh6ICE9PSB2b2lkIDAgJiYgeiAhPT0gISF6ICYmIHogIT09IDEgJiYgeiAhPT0gMCkgdGhyb3cgRXJyb3IoaW52YWxpZEFyZ3VtZW50ICsgeik7XHJcblxyXG4gIGlmICh4LmQpIHtcclxuICAgIGsgPSBnZXRQcmVjaXNpb24oeC5kKTtcclxuICAgIGlmICh6ICYmIHguZSArIDEgPiBrKSBrID0geC5lICsgMTtcclxuICB9IGVsc2Uge1xyXG4gICAgayA9IE5hTjtcclxuICB9XHJcblxyXG4gIHJldHVybiBrO1xyXG59O1xyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwgcm91bmRlZCB0byBhIHdob2xlIG51bWJlciB1c2luZ1xyXG4gKiByb3VuZGluZyBtb2RlIGByb3VuZGluZ2AuXHJcbiAqXHJcbiAqL1xyXG5QLnJvdW5kID0gZnVuY3Rpb24gKCkge1xyXG4gIHZhciB4ID0gdGhpcyxcclxuICAgIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xyXG5cclxuICByZXR1cm4gZmluYWxpc2UobmV3IEN0b3IoeCksIHguZSArIDEsIEN0b3Iucm91bmRpbmcpO1xyXG59O1xyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSBzaW5lIG9mIHRoZSB2YWx1ZSBpbiByYWRpYW5zIG9mIHRoaXMgRGVjaW1hbC5cclxuICpcclxuICogRG9tYWluOiBbLUluZmluaXR5LCBJbmZpbml0eV1cclxuICogUmFuZ2U6IFstMSwgMV1cclxuICpcclxuICogc2luKHgpID0geCAtIHheMy8zISArIHheNS81ISAtIC4uLlxyXG4gKlxyXG4gKiBzaW4oMCkgICAgICAgICA9IDBcclxuICogc2luKC0wKSAgICAgICAgPSAtMFxyXG4gKiBzaW4oSW5maW5pdHkpICA9IE5hTlxyXG4gKiBzaW4oLUluZmluaXR5KSA9IE5hTlxyXG4gKiBzaW4oTmFOKSAgICAgICA9IE5hTlxyXG4gKlxyXG4gKi9cclxuUC5zaW5lID0gUC5zaW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIHByLCBybSxcclxuICAgIHggPSB0aGlzLFxyXG4gICAgQ3RvciA9IHguY29uc3RydWN0b3I7XHJcblxyXG4gIGlmICgheC5pc0Zpbml0ZSgpKSByZXR1cm4gbmV3IEN0b3IoTmFOKTtcclxuICBpZiAoeC5pc1plcm8oKSkgcmV0dXJuIG5ldyBDdG9yKHgpO1xyXG5cclxuICBwciA9IEN0b3IucHJlY2lzaW9uO1xyXG4gIHJtID0gQ3Rvci5yb3VuZGluZztcclxuICBDdG9yLnByZWNpc2lvbiA9IHByICsgTWF0aC5tYXgoeC5lLCB4LnNkKCkpICsgTE9HX0JBU0U7XHJcbiAgQ3Rvci5yb3VuZGluZyA9IDE7XHJcblxyXG4gIHggPSBzaW5lKEN0b3IsIHRvTGVzc1RoYW5IYWxmUGkoQ3RvciwgeCkpO1xyXG5cclxuICBDdG9yLnByZWNpc2lvbiA9IHByO1xyXG4gIEN0b3Iucm91bmRpbmcgPSBybTtcclxuXHJcbiAgcmV0dXJuIGZpbmFsaXNlKHF1YWRyYW50ID4gMiA/IHgubmVnKCkgOiB4LCBwciwgcm0sIHRydWUpO1xyXG59O1xyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSBzcXVhcmUgcm9vdCBvZiB0aGlzIERlY2ltYWwsIHJvdW5kZWQgdG8gYHByZWNpc2lvbmBcclxuICogc2lnbmlmaWNhbnQgZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJvdW5kaW5nYC5cclxuICpcclxuICogIHNxcnQoLW4pID0gIE5cclxuICogIHNxcnQoTikgID0gIE5cclxuICogIHNxcnQoLUkpID0gIE5cclxuICogIHNxcnQoSSkgID0gIElcclxuICogIHNxcnQoMCkgID0gIDBcclxuICogIHNxcnQoLTApID0gLTBcclxuICpcclxuICovXHJcblAuc3F1YXJlUm9vdCA9IFAuc3FydCA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgbSwgbiwgc2QsIHIsIHJlcCwgdCxcclxuICAgIHggPSB0aGlzLFxyXG4gICAgZCA9IHguZCxcclxuICAgIGUgPSB4LmUsXHJcbiAgICBzID0geC5zLFxyXG4gICAgQ3RvciA9IHguY29uc3RydWN0b3I7XHJcblxyXG4gIC8vIE5lZ2F0aXZlL05hTi9JbmZpbml0eS96ZXJvP1xyXG4gIGlmIChzICE9PSAxIHx8ICFkIHx8ICFkWzBdKSB7XHJcbiAgICByZXR1cm4gbmV3IEN0b3IoIXMgfHwgcyA8IDAgJiYgKCFkIHx8IGRbMF0pID8gTmFOIDogZCA/IHggOiAxIC8gMCk7XHJcbiAgfVxyXG5cclxuICBleHRlcm5hbCA9IGZhbHNlO1xyXG5cclxuICAvLyBJbml0aWFsIGVzdGltYXRlLlxyXG4gIHMgPSBNYXRoLnNxcnQoK3gpO1xyXG5cclxuICAvLyBNYXRoLnNxcnQgdW5kZXJmbG93L292ZXJmbG93P1xyXG4gIC8vIFBhc3MgeCB0byBNYXRoLnNxcnQgYXMgaW50ZWdlciwgdGhlbiBhZGp1c3QgdGhlIGV4cG9uZW50IG9mIHRoZSByZXN1bHQuXHJcbiAgaWYgKHMgPT0gMCB8fCBzID09IDEgLyAwKSB7XHJcbiAgICBuID0gZGlnaXRzVG9TdHJpbmcoZCk7XHJcblxyXG4gICAgaWYgKChuLmxlbmd0aCArIGUpICUgMiA9PSAwKSBuICs9ICcwJztcclxuICAgIHMgPSBNYXRoLnNxcnQobik7XHJcbiAgICBlID0gbWF0aGZsb29yKChlICsgMSkgLyAyKSAtIChlIDwgMCB8fCBlICUgMik7XHJcblxyXG4gICAgaWYgKHMgPT0gMSAvIDApIHtcclxuICAgICAgbiA9ICc1ZScgKyBlO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgbiA9IHMudG9FeHBvbmVudGlhbCgpO1xyXG4gICAgICBuID0gbi5zbGljZSgwLCBuLmluZGV4T2YoJ2UnKSArIDEpICsgZTtcclxuICAgIH1cclxuXHJcbiAgICByID0gbmV3IEN0b3Iobik7XHJcbiAgfSBlbHNlIHtcclxuICAgIHIgPSBuZXcgQ3RvcihzLnRvU3RyaW5nKCkpO1xyXG4gIH1cclxuXHJcbiAgc2QgPSAoZSA9IEN0b3IucHJlY2lzaW9uKSArIDM7XHJcblxyXG4gIC8vIE5ld3Rvbi1SYXBoc29uIGl0ZXJhdGlvbi5cclxuICBmb3IgKDs7KSB7XHJcbiAgICB0ID0gcjtcclxuICAgIHIgPSB0LnBsdXMoZGl2aWRlKHgsIHQsIHNkICsgMiwgMSkpLnRpbWVzKDAuNSk7XHJcblxyXG4gICAgLy8gVE9ETz8gUmVwbGFjZSB3aXRoIGZvci1sb29wIGFuZCBjaGVja1JvdW5kaW5nRGlnaXRzLlxyXG4gICAgaWYgKGRpZ2l0c1RvU3RyaW5nKHQuZCkuc2xpY2UoMCwgc2QpID09PSAobiA9IGRpZ2l0c1RvU3RyaW5nKHIuZCkpLnNsaWNlKDAsIHNkKSkge1xyXG4gICAgICBuID0gbi5zbGljZShzZCAtIDMsIHNkICsgMSk7XHJcblxyXG4gICAgICAvLyBUaGUgNHRoIHJvdW5kaW5nIGRpZ2l0IG1heSBiZSBpbiBlcnJvciBieSAtMSBzbyBpZiB0aGUgNCByb3VuZGluZyBkaWdpdHMgYXJlIDk5OTkgb3JcclxuICAgICAgLy8gNDk5OSwgaS5lLiBhcHByb2FjaGluZyBhIHJvdW5kaW5nIGJvdW5kYXJ5LCBjb250aW51ZSB0aGUgaXRlcmF0aW9uLlxyXG4gICAgICBpZiAobiA9PSAnOTk5OScgfHwgIXJlcCAmJiBuID09ICc0OTk5Jykge1xyXG5cclxuICAgICAgICAvLyBPbiB0aGUgZmlyc3QgaXRlcmF0aW9uIG9ubHksIGNoZWNrIHRvIHNlZSBpZiByb3VuZGluZyB1cCBnaXZlcyB0aGUgZXhhY3QgcmVzdWx0IGFzIHRoZVxyXG4gICAgICAgIC8vIG5pbmVzIG1heSBpbmZpbml0ZWx5IHJlcGVhdC5cclxuICAgICAgICBpZiAoIXJlcCkge1xyXG4gICAgICAgICAgZmluYWxpc2UodCwgZSArIDEsIDApO1xyXG5cclxuICAgICAgICAgIGlmICh0LnRpbWVzKHQpLmVxKHgpKSB7XHJcbiAgICAgICAgICAgIHIgPSB0O1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHNkICs9IDQ7XHJcbiAgICAgICAgcmVwID0gMTtcclxuICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgLy8gSWYgdGhlIHJvdW5kaW5nIGRpZ2l0cyBhcmUgbnVsbCwgMHswLDR9IG9yIDUwezAsM30sIGNoZWNrIGZvciBhbiBleGFjdCByZXN1bHQuXHJcbiAgICAgICAgLy8gSWYgbm90LCB0aGVuIHRoZXJlIGFyZSBmdXJ0aGVyIGRpZ2l0cyBhbmQgbSB3aWxsIGJlIHRydXRoeS5cclxuICAgICAgICBpZiAoIStuIHx8ICErbi5zbGljZSgxKSAmJiBuLmNoYXJBdCgwKSA9PSAnNScpIHtcclxuXHJcbiAgICAgICAgICAvLyBUcnVuY2F0ZSB0byB0aGUgZmlyc3Qgcm91bmRpbmcgZGlnaXQuXHJcbiAgICAgICAgICBmaW5hbGlzZShyLCBlICsgMSwgMSk7XHJcbiAgICAgICAgICBtID0gIXIudGltZXMocikuZXEoeCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZXh0ZXJuYWwgPSB0cnVlO1xyXG5cclxuICByZXR1cm4gZmluYWxpc2UociwgZSwgQ3Rvci5yb3VuZGluZywgbSk7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIHRhbmdlbnQgb2YgdGhlIHZhbHVlIGluIHJhZGlhbnMgb2YgdGhpcyBEZWNpbWFsLlxyXG4gKlxyXG4gKiBEb21haW46IFstSW5maW5pdHksIEluZmluaXR5XVxyXG4gKiBSYW5nZTogWy1JbmZpbml0eSwgSW5maW5pdHldXHJcbiAqXHJcbiAqIHRhbigwKSAgICAgICAgID0gMFxyXG4gKiB0YW4oLTApICAgICAgICA9IC0wXHJcbiAqIHRhbihJbmZpbml0eSkgID0gTmFOXHJcbiAqIHRhbigtSW5maW5pdHkpID0gTmFOXHJcbiAqIHRhbihOYU4pICAgICAgID0gTmFOXHJcbiAqXHJcbiAqL1xyXG5QLnRhbmdlbnQgPSBQLnRhbiA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgcHIsIHJtLFxyXG4gICAgeCA9IHRoaXMsXHJcbiAgICBDdG9yID0geC5jb25zdHJ1Y3RvcjtcclxuXHJcbiAgaWYgKCF4LmlzRmluaXRlKCkpIHJldHVybiBuZXcgQ3RvcihOYU4pO1xyXG4gIGlmICh4LmlzWmVybygpKSByZXR1cm4gbmV3IEN0b3IoeCk7XHJcblxyXG4gIHByID0gQ3Rvci5wcmVjaXNpb247XHJcbiAgcm0gPSBDdG9yLnJvdW5kaW5nO1xyXG4gIEN0b3IucHJlY2lzaW9uID0gcHIgKyAxMDtcclxuICBDdG9yLnJvdW5kaW5nID0gMTtcclxuXHJcbiAgeCA9IHguc2luKCk7XHJcbiAgeC5zID0gMTtcclxuICB4ID0gZGl2aWRlKHgsIG5ldyBDdG9yKDEpLm1pbnVzKHgudGltZXMoeCkpLnNxcnQoKSwgcHIgKyAxMCwgMCk7XHJcblxyXG4gIEN0b3IucHJlY2lzaW9uID0gcHI7XHJcbiAgQ3Rvci5yb3VuZGluZyA9IHJtO1xyXG5cclxuICByZXR1cm4gZmluYWxpc2UocXVhZHJhbnQgPT0gMiB8fCBxdWFkcmFudCA9PSA0ID8geC5uZWcoKSA6IHgsIHByLCBybSwgdHJ1ZSk7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogIG4gKiAwID0gMFxyXG4gKiAgbiAqIE4gPSBOXHJcbiAqICBuICogSSA9IElcclxuICogIDAgKiBuID0gMFxyXG4gKiAgMCAqIDAgPSAwXHJcbiAqICAwICogTiA9IE5cclxuICogIDAgKiBJID0gTlxyXG4gKiAgTiAqIG4gPSBOXHJcbiAqICBOICogMCA9IE5cclxuICogIE4gKiBOID0gTlxyXG4gKiAgTiAqIEkgPSBOXHJcbiAqICBJICogbiA9IElcclxuICogIEkgKiAwID0gTlxyXG4gKiAgSSAqIE4gPSBOXHJcbiAqICBJICogSSA9IElcclxuICpcclxuICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhpcyBEZWNpbWFsIHRpbWVzIGB5YCwgcm91bmRlZCB0byBgcHJlY2lzaW9uYCBzaWduaWZpY2FudFxyXG4gKiBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSBgcm91bmRpbmdgLlxyXG4gKlxyXG4gKi9cclxuUC50aW1lcyA9IFAubXVsID0gZnVuY3Rpb24gKHkpIHtcclxuICB2YXIgY2FycnksIGUsIGksIGssIHIsIHJMLCB0LCB4ZEwsIHlkTCxcclxuICAgIHggPSB0aGlzLFxyXG4gICAgQ3RvciA9IHguY29uc3RydWN0b3IsXHJcbiAgICB4ZCA9IHguZCxcclxuICAgIHlkID0gKHkgPSBuZXcgQ3Rvcih5KSkuZDtcclxuXHJcbiAgeS5zICo9IHgucztcclxuXHJcbiAgIC8vIElmIGVpdGhlciBpcyBOYU4sIMKxSW5maW5pdHkgb3IgwrEwLi4uXHJcbiAgaWYgKCF4ZCB8fCAheGRbMF0gfHwgIXlkIHx8ICF5ZFswXSkge1xyXG5cclxuICAgIHJldHVybiBuZXcgQ3RvcigheS5zIHx8IHhkICYmICF4ZFswXSAmJiAheWQgfHwgeWQgJiYgIXlkWzBdICYmICF4ZFxyXG5cclxuICAgICAgLy8gUmV0dXJuIE5hTiBpZiBlaXRoZXIgaXMgTmFOLlxyXG4gICAgICAvLyBSZXR1cm4gTmFOIGlmIHggaXMgwrEwIGFuZCB5IGlzIMKxSW5maW5pdHksIG9yIHkgaXMgwrEwIGFuZCB4IGlzIMKxSW5maW5pdHkuXHJcbiAgICAgID8gTmFOXHJcblxyXG4gICAgICAvLyBSZXR1cm4gwrFJbmZpbml0eSBpZiBlaXRoZXIgaXMgwrFJbmZpbml0eS5cclxuICAgICAgLy8gUmV0dXJuIMKxMCBpZiBlaXRoZXIgaXMgwrEwLlxyXG4gICAgICA6ICF4ZCB8fCAheWQgPyB5LnMgLyAwIDogeS5zICogMCk7XHJcbiAgfVxyXG5cclxuICBlID0gbWF0aGZsb29yKHguZSAvIExPR19CQVNFKSArIG1hdGhmbG9vcih5LmUgLyBMT0dfQkFTRSk7XHJcbiAgeGRMID0geGQubGVuZ3RoO1xyXG4gIHlkTCA9IHlkLmxlbmd0aDtcclxuXHJcbiAgLy8gRW5zdXJlIHhkIHBvaW50cyB0byB0aGUgbG9uZ2VyIGFycmF5LlxyXG4gIGlmICh4ZEwgPCB5ZEwpIHtcclxuICAgIHIgPSB4ZDtcclxuICAgIHhkID0geWQ7XHJcbiAgICB5ZCA9IHI7XHJcbiAgICByTCA9IHhkTDtcclxuICAgIHhkTCA9IHlkTDtcclxuICAgIHlkTCA9IHJMO1xyXG4gIH1cclxuXHJcbiAgLy8gSW5pdGlhbGlzZSB0aGUgcmVzdWx0IGFycmF5IHdpdGggemVyb3MuXHJcbiAgciA9IFtdO1xyXG4gIHJMID0geGRMICsgeWRMO1xyXG4gIGZvciAoaSA9IHJMOyBpLS07KSByLnB1c2goMCk7XHJcblxyXG4gIC8vIE11bHRpcGx5IVxyXG4gIGZvciAoaSA9IHlkTDsgLS1pID49IDA7KSB7XHJcbiAgICBjYXJyeSA9IDA7XHJcbiAgICBmb3IgKGsgPSB4ZEwgKyBpOyBrID4gaTspIHtcclxuICAgICAgdCA9IHJba10gKyB5ZFtpXSAqIHhkW2sgLSBpIC0gMV0gKyBjYXJyeTtcclxuICAgICAgcltrLS1dID0gdCAlIEJBU0UgfCAwO1xyXG4gICAgICBjYXJyeSA9IHQgLyBCQVNFIHwgMDtcclxuICAgIH1cclxuXHJcbiAgICByW2tdID0gKHJba10gKyBjYXJyeSkgJSBCQVNFIHwgMDtcclxuICB9XHJcblxyXG4gIC8vIFJlbW92ZSB0cmFpbGluZyB6ZXJvcy5cclxuICBmb3IgKDsgIXJbLS1yTF07KSByLnBvcCgpO1xyXG5cclxuICBpZiAoY2FycnkpICsrZTtcclxuICBlbHNlIHIuc2hpZnQoKTtcclxuXHJcbiAgeS5kID0gcjtcclxuICB5LmUgPSBnZXRCYXNlMTBFeHBvbmVudChyLCBlKTtcclxuXHJcbiAgcmV0dXJuIGV4dGVybmFsID8gZmluYWxpc2UoeSwgQ3Rvci5wcmVjaXNpb24sIEN0b3Iucm91bmRpbmcpIDogeTtcclxufTtcclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwgaW4gYmFzZSAyLCByb3VuZCB0byBgc2RgIHNpZ25pZmljYW50XHJcbiAqIGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIGBybWAuXHJcbiAqXHJcbiAqIElmIHRoZSBvcHRpb25hbCBgc2RgIGFyZ3VtZW50IGlzIHByZXNlbnQgdGhlbiByZXR1cm4gYmluYXJ5IGV4cG9uZW50aWFsIG5vdGF0aW9uLlxyXG4gKlxyXG4gKiBbc2RdIHtudW1iZXJ9IFNpZ25pZmljYW50IGRpZ2l0cy4gSW50ZWdlciwgMSB0byBNQVhfRElHSVRTIGluY2x1c2l2ZS5cclxuICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gKlxyXG4gKi9cclxuUC50b0JpbmFyeSA9IGZ1bmN0aW9uIChzZCwgcm0pIHtcclxuICByZXR1cm4gdG9TdHJpbmdCaW5hcnkodGhpcywgMiwgc2QsIHJtKTtcclxufTtcclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBEZWNpbWFsIHJvdW5kZWQgdG8gYSBtYXhpbXVtIG9mIGBkcGBcclxuICogZGVjaW1hbCBwbGFjZXMgdXNpbmcgcm91bmRpbmcgbW9kZSBgcm1gIG9yIGByb3VuZGluZ2AgaWYgYHJtYCBpcyBvbWl0dGVkLlxyXG4gKlxyXG4gKiBJZiBgZHBgIGlzIG9taXR0ZWQsIHJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwuXHJcbiAqXHJcbiAqIFtkcF0ge251bWJlcn0gRGVjaW1hbCBwbGFjZXMuIEludGVnZXIsIDAgdG8gTUFYX0RJR0lUUyBpbmNsdXNpdmUuXHJcbiAqIFtybV0ge251bWJlcn0gUm91bmRpbmcgbW9kZS4gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICpcclxuICovXHJcblAudG9EZWNpbWFsUGxhY2VzID0gUC50b0RQID0gZnVuY3Rpb24gKGRwLCBybSkge1xyXG4gIHZhciB4ID0gdGhpcyxcclxuICAgIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xyXG5cclxuICB4ID0gbmV3IEN0b3IoeCk7XHJcbiAgaWYgKGRwID09PSB2b2lkIDApIHJldHVybiB4O1xyXG5cclxuICBjaGVja0ludDMyKGRwLCAwLCBNQVhfRElHSVRTKTtcclxuXHJcbiAgaWYgKHJtID09PSB2b2lkIDApIHJtID0gQ3Rvci5yb3VuZGluZztcclxuICBlbHNlIGNoZWNrSW50MzIocm0sIDAsIDgpO1xyXG5cclxuICByZXR1cm4gZmluYWxpc2UoeCwgZHAgKyB4LmUgKyAxLCBybSk7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhpcyBEZWNpbWFsIGluIGV4cG9uZW50aWFsIG5vdGF0aW9uIHJvdW5kZWQgdG9cclxuICogYGRwYCBmaXhlZCBkZWNpbWFsIHBsYWNlcyB1c2luZyByb3VuZGluZyBtb2RlIGByb3VuZGluZ2AuXHJcbiAqXHJcbiAqIFtkcF0ge251bWJlcn0gRGVjaW1hbCBwbGFjZXMuIEludGVnZXIsIDAgdG8gTUFYX0RJR0lUUyBpbmNsdXNpdmUuXHJcbiAqIFtybV0ge251bWJlcn0gUm91bmRpbmcgbW9kZS4gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICpcclxuICovXHJcblAudG9FeHBvbmVudGlhbCA9IGZ1bmN0aW9uIChkcCwgcm0pIHtcclxuICB2YXIgc3RyLFxyXG4gICAgeCA9IHRoaXMsXHJcbiAgICBDdG9yID0geC5jb25zdHJ1Y3RvcjtcclxuXHJcbiAgaWYgKGRwID09PSB2b2lkIDApIHtcclxuICAgIHN0ciA9IGZpbml0ZVRvU3RyaW5nKHgsIHRydWUpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBjaGVja0ludDMyKGRwLCAwLCBNQVhfRElHSVRTKTtcclxuXHJcbiAgICBpZiAocm0gPT09IHZvaWQgMCkgcm0gPSBDdG9yLnJvdW5kaW5nO1xyXG4gICAgZWxzZSBjaGVja0ludDMyKHJtLCAwLCA4KTtcclxuXHJcbiAgICB4ID0gZmluYWxpc2UobmV3IEN0b3IoeCksIGRwICsgMSwgcm0pO1xyXG4gICAgc3RyID0gZmluaXRlVG9TdHJpbmcoeCwgdHJ1ZSwgZHAgKyAxKTtcclxuICB9XHJcblxyXG4gIHJldHVybiB4LmlzTmVnKCkgJiYgIXguaXNaZXJvKCkgPyAnLScgKyBzdHIgOiBzdHI7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhpcyBEZWNpbWFsIGluIG5vcm1hbCAoZml4ZWQtcG9pbnQpIG5vdGF0aW9uIHRvXHJcbiAqIGBkcGAgZml4ZWQgZGVjaW1hbCBwbGFjZXMgYW5kIHJvdW5kZWQgdXNpbmcgcm91bmRpbmcgbW9kZSBgcm1gIG9yIGByb3VuZGluZ2AgaWYgYHJtYCBpc1xyXG4gKiBvbWl0dGVkLlxyXG4gKlxyXG4gKiBBcyB3aXRoIEphdmFTY3JpcHQgbnVtYmVycywgKC0wKS50b0ZpeGVkKDApIGlzICcwJywgYnV0IGUuZy4gKC0wLjAwMDAxKS50b0ZpeGVkKDApIGlzICctMCcuXHJcbiAqXHJcbiAqIFtkcF0ge251bWJlcn0gRGVjaW1hbCBwbGFjZXMuIEludGVnZXIsIDAgdG8gTUFYX0RJR0lUUyBpbmNsdXNpdmUuXHJcbiAqIFtybV0ge251bWJlcn0gUm91bmRpbmcgbW9kZS4gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICpcclxuICogKC0wKS50b0ZpeGVkKDApIGlzICcwJywgYnV0ICgtMC4xKS50b0ZpeGVkKDApIGlzICctMCcuXHJcbiAqICgtMCkudG9GaXhlZCgxKSBpcyAnMC4wJywgYnV0ICgtMC4wMSkudG9GaXhlZCgxKSBpcyAnLTAuMCcuXHJcbiAqICgtMCkudG9GaXhlZCgzKSBpcyAnMC4wMDAnLlxyXG4gKiAoLTAuNSkudG9GaXhlZCgwKSBpcyAnLTAnLlxyXG4gKlxyXG4gKi9cclxuUC50b0ZpeGVkID0gZnVuY3Rpb24gKGRwLCBybSkge1xyXG4gIHZhciBzdHIsIHksXHJcbiAgICB4ID0gdGhpcyxcclxuICAgIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xyXG5cclxuICBpZiAoZHAgPT09IHZvaWQgMCkge1xyXG4gICAgc3RyID0gZmluaXRlVG9TdHJpbmcoeCk7XHJcbiAgfSBlbHNlIHtcclxuICAgIGNoZWNrSW50MzIoZHAsIDAsIE1BWF9ESUdJVFMpO1xyXG5cclxuICAgIGlmIChybSA9PT0gdm9pZCAwKSBybSA9IEN0b3Iucm91bmRpbmc7XHJcbiAgICBlbHNlIGNoZWNrSW50MzIocm0sIDAsIDgpO1xyXG5cclxuICAgIHkgPSBmaW5hbGlzZShuZXcgQ3Rvcih4KSwgZHAgKyB4LmUgKyAxLCBybSk7XHJcbiAgICBzdHIgPSBmaW5pdGVUb1N0cmluZyh5LCBmYWxzZSwgZHAgKyB5LmUgKyAxKTtcclxuICB9XHJcblxyXG4gIC8vIFRvIGRldGVybWluZSB3aGV0aGVyIHRvIGFkZCB0aGUgbWludXMgc2lnbiBsb29rIGF0IHRoZSB2YWx1ZSBiZWZvcmUgaXQgd2FzIHJvdW5kZWQsXHJcbiAgLy8gaS5lLiBsb29rIGF0IGB4YCByYXRoZXIgdGhhbiBgeWAuXHJcbiAgcmV0dXJuIHguaXNOZWcoKSAmJiAheC5pc1plcm8oKSA/ICctJyArIHN0ciA6IHN0cjtcclxufTtcclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYW4gYXJyYXkgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwgYXMgYSBzaW1wbGUgZnJhY3Rpb24gd2l0aCBhbiBpbnRlZ2VyXHJcbiAqIG51bWVyYXRvciBhbmQgYW4gaW50ZWdlciBkZW5vbWluYXRvci5cclxuICpcclxuICogVGhlIGRlbm9taW5hdG9yIHdpbGwgYmUgYSBwb3NpdGl2ZSBub24temVybyB2YWx1ZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHNwZWNpZmllZCBtYXhpbXVtXHJcbiAqIGRlbm9taW5hdG9yLiBJZiBhIG1heGltdW0gZGVub21pbmF0b3IgaXMgbm90IHNwZWNpZmllZCwgdGhlIGRlbm9taW5hdG9yIHdpbGwgYmUgdGhlIGxvd2VzdFxyXG4gKiB2YWx1ZSBuZWNlc3NhcnkgdG8gcmVwcmVzZW50IHRoZSBudW1iZXIgZXhhY3RseS5cclxuICpcclxuICogW21heERdIHtudW1iZXJ8c3RyaW5nfERlY2ltYWx9IE1heGltdW0gZGVub21pbmF0b3IuIEludGVnZXIgPj0gMSBhbmQgPCBJbmZpbml0eS5cclxuICpcclxuICovXHJcblAudG9GcmFjdGlvbiA9IGZ1bmN0aW9uIChtYXhEKSB7XHJcbiAgdmFyIGQsIGQwLCBkMSwgZDIsIGUsIGssIG4sIG4wLCBuMSwgcHIsIHEsIHIsXHJcbiAgICB4ID0gdGhpcyxcclxuICAgIHhkID0geC5kLFxyXG4gICAgQ3RvciA9IHguY29uc3RydWN0b3I7XHJcblxyXG4gIGlmICgheGQpIHJldHVybiBuZXcgQ3Rvcih4KTtcclxuXHJcbiAgbjEgPSBkMCA9IG5ldyBDdG9yKDEpO1xyXG4gIGQxID0gbjAgPSBuZXcgQ3RvcigwKTtcclxuXHJcbiAgZCA9IG5ldyBDdG9yKGQxKTtcclxuICBlID0gZC5lID0gZ2V0UHJlY2lzaW9uKHhkKSAtIHguZSAtIDE7XHJcbiAgayA9IGUgJSBMT0dfQkFTRTtcclxuICBkLmRbMF0gPSBtYXRocG93KDEwLCBrIDwgMCA/IExPR19CQVNFICsgayA6IGspO1xyXG5cclxuICBpZiAobWF4RCA9PSBudWxsKSB7XHJcblxyXG4gICAgLy8gZCBpcyAxMCoqZSwgdGhlIG1pbmltdW0gbWF4LWRlbm9taW5hdG9yIG5lZWRlZC5cclxuICAgIG1heEQgPSBlID4gMCA/IGQgOiBuMTtcclxuICB9IGVsc2Uge1xyXG4gICAgbiA9IG5ldyBDdG9yKG1heEQpO1xyXG4gICAgaWYgKCFuLmlzSW50KCkgfHwgbi5sdChuMSkpIHRocm93IEVycm9yKGludmFsaWRBcmd1bWVudCArIG4pO1xyXG4gICAgbWF4RCA9IG4uZ3QoZCkgPyAoZSA+IDAgPyBkIDogbjEpIDogbjtcclxuICB9XHJcblxyXG4gIGV4dGVybmFsID0gZmFsc2U7XHJcbiAgbiA9IG5ldyBDdG9yKGRpZ2l0c1RvU3RyaW5nKHhkKSk7XHJcbiAgcHIgPSBDdG9yLnByZWNpc2lvbjtcclxuICBDdG9yLnByZWNpc2lvbiA9IGUgPSB4ZC5sZW5ndGggKiBMT0dfQkFTRSAqIDI7XHJcblxyXG4gIGZvciAoOzspICB7XHJcbiAgICBxID0gZGl2aWRlKG4sIGQsIDAsIDEsIDEpO1xyXG4gICAgZDIgPSBkMC5wbHVzKHEudGltZXMoZDEpKTtcclxuICAgIGlmIChkMi5jbXAobWF4RCkgPT0gMSkgYnJlYWs7XHJcbiAgICBkMCA9IGQxO1xyXG4gICAgZDEgPSBkMjtcclxuICAgIGQyID0gbjE7XHJcbiAgICBuMSA9IG4wLnBsdXMocS50aW1lcyhkMikpO1xyXG4gICAgbjAgPSBkMjtcclxuICAgIGQyID0gZDtcclxuICAgIGQgPSBuLm1pbnVzKHEudGltZXMoZDIpKTtcclxuICAgIG4gPSBkMjtcclxuICB9XHJcblxyXG4gIGQyID0gZGl2aWRlKG1heEQubWludXMoZDApLCBkMSwgMCwgMSwgMSk7XHJcbiAgbjAgPSBuMC5wbHVzKGQyLnRpbWVzKG4xKSk7XHJcbiAgZDAgPSBkMC5wbHVzKGQyLnRpbWVzKGQxKSk7XHJcbiAgbjAucyA9IG4xLnMgPSB4LnM7XHJcblxyXG4gIC8vIERldGVybWluZSB3aGljaCBmcmFjdGlvbiBpcyBjbG9zZXIgdG8geCwgbjAvZDAgb3IgbjEvZDE/XHJcbiAgciA9IGRpdmlkZShuMSwgZDEsIGUsIDEpLm1pbnVzKHgpLmFicygpLmNtcChkaXZpZGUobjAsIGQwLCBlLCAxKS5taW51cyh4KS5hYnMoKSkgPCAxXHJcbiAgICAgID8gW24xLCBkMV0gOiBbbjAsIGQwXTtcclxuXHJcbiAgQ3Rvci5wcmVjaXNpb24gPSBwcjtcclxuICBleHRlcm5hbCA9IHRydWU7XHJcblxyXG4gIHJldHVybiByO1xyXG59O1xyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbCBpbiBiYXNlIDE2LCByb3VuZCB0byBgc2RgIHNpZ25pZmljYW50XHJcbiAqIGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIGBybWAuXHJcbiAqXHJcbiAqIElmIHRoZSBvcHRpb25hbCBgc2RgIGFyZ3VtZW50IGlzIHByZXNlbnQgdGhlbiByZXR1cm4gYmluYXJ5IGV4cG9uZW50aWFsIG5vdGF0aW9uLlxyXG4gKlxyXG4gKiBbc2RdIHtudW1iZXJ9IFNpZ25pZmljYW50IGRpZ2l0cy4gSW50ZWdlciwgMSB0byBNQVhfRElHSVRTIGluY2x1c2l2ZS5cclxuICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gKlxyXG4gKi9cclxuUC50b0hleGFkZWNpbWFsID0gUC50b0hleCA9IGZ1bmN0aW9uIChzZCwgcm0pIHtcclxuICByZXR1cm4gdG9TdHJpbmdCaW5hcnkodGhpcywgMTYsIHNkLCBybSk7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogUmV0dXJucyBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSBuZWFyZXN0IG11bHRpcGxlIG9mIGB5YCBpbiB0aGUgZGlyZWN0aW9uIG9mIHJvdW5kaW5nXHJcbiAqIG1vZGUgYHJtYCwgb3IgYERlY2ltYWwucm91bmRpbmdgIGlmIGBybWAgaXMgb21pdHRlZCwgdG8gdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbC5cclxuICpcclxuICogVGhlIHJldHVybiB2YWx1ZSB3aWxsIGFsd2F5cyBoYXZlIHRoZSBzYW1lIHNpZ24gYXMgdGhpcyBEZWNpbWFsLCB1bmxlc3MgZWl0aGVyIHRoaXMgRGVjaW1hbFxyXG4gKiBvciBgeWAgaXMgTmFOLCBpbiB3aGljaCBjYXNlIHRoZSByZXR1cm4gdmFsdWUgd2lsbCBiZSBhbHNvIGJlIE5hTi5cclxuICpcclxuICogVGhlIHJldHVybiB2YWx1ZSBpcyBub3QgYWZmZWN0ZWQgYnkgdGhlIHZhbHVlIG9mIGBwcmVjaXNpb25gLlxyXG4gKlxyXG4gKiB5IHtudW1iZXJ8c3RyaW5nfERlY2ltYWx9IFRoZSBtYWduaXR1ZGUgdG8gcm91bmQgdG8gYSBtdWx0aXBsZSBvZi5cclxuICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gKlxyXG4gKiAndG9OZWFyZXN0KCkgcm91bmRpbmcgbW9kZSBub3QgYW4gaW50ZWdlcjoge3JtfSdcclxuICogJ3RvTmVhcmVzdCgpIHJvdW5kaW5nIG1vZGUgb3V0IG9mIHJhbmdlOiB7cm19J1xyXG4gKlxyXG4gKi9cclxuUC50b05lYXJlc3QgPSBmdW5jdGlvbiAoeSwgcm0pIHtcclxuICB2YXIgeCA9IHRoaXMsXHJcbiAgICBDdG9yID0geC5jb25zdHJ1Y3RvcjtcclxuXHJcbiAgeCA9IG5ldyBDdG9yKHgpO1xyXG5cclxuICBpZiAoeSA9PSBudWxsKSB7XHJcblxyXG4gICAgLy8gSWYgeCBpcyBub3QgZmluaXRlLCByZXR1cm4geC5cclxuICAgIGlmICgheC5kKSByZXR1cm4geDtcclxuXHJcbiAgICB5ID0gbmV3IEN0b3IoMSk7XHJcbiAgICBybSA9IEN0b3Iucm91bmRpbmc7XHJcbiAgfSBlbHNlIHtcclxuICAgIHkgPSBuZXcgQ3Rvcih5KTtcclxuICAgIGlmIChybSA9PT0gdm9pZCAwKSB7XHJcbiAgICAgIHJtID0gQ3Rvci5yb3VuZGluZztcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNoZWNrSW50MzIocm0sIDAsIDgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIElmIHggaXMgbm90IGZpbml0ZSwgcmV0dXJuIHggaWYgeSBpcyBub3QgTmFOLCBlbHNlIE5hTi5cclxuICAgIGlmICgheC5kKSByZXR1cm4geS5zID8geCA6IHk7XHJcblxyXG4gICAgLy8gSWYgeSBpcyBub3QgZmluaXRlLCByZXR1cm4gSW5maW5pdHkgd2l0aCB0aGUgc2lnbiBvZiB4IGlmIHkgaXMgSW5maW5pdHksIGVsc2UgTmFOLlxyXG4gICAgaWYgKCF5LmQpIHtcclxuICAgICAgaWYgKHkucykgeS5zID0geC5zO1xyXG4gICAgICByZXR1cm4geTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIElmIHkgaXMgbm90IHplcm8sIGNhbGN1bGF0ZSB0aGUgbmVhcmVzdCBtdWx0aXBsZSBvZiB5IHRvIHguXHJcbiAgaWYgKHkuZFswXSkge1xyXG4gICAgZXh0ZXJuYWwgPSBmYWxzZTtcclxuICAgIHggPSBkaXZpZGUoeCwgeSwgMCwgcm0sIDEpLnRpbWVzKHkpO1xyXG4gICAgZXh0ZXJuYWwgPSB0cnVlO1xyXG4gICAgZmluYWxpc2UoeCk7XHJcblxyXG4gIC8vIElmIHkgaXMgemVybywgcmV0dXJuIHplcm8gd2l0aCB0aGUgc2lnbiBvZiB4LlxyXG4gIH0gZWxzZSB7XHJcbiAgICB5LnMgPSB4LnM7XHJcbiAgICB4ID0geTtcclxuICB9XHJcblxyXG4gIHJldHVybiB4O1xyXG59O1xyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiB0aGUgdmFsdWUgb2YgdGhpcyBEZWNpbWFsIGNvbnZlcnRlZCB0byBhIG51bWJlciBwcmltaXRpdmUuXHJcbiAqIFplcm8ga2VlcHMgaXRzIHNpZ24uXHJcbiAqXHJcbiAqL1xyXG5QLnRvTnVtYmVyID0gZnVuY3Rpb24gKCkge1xyXG4gIHJldHVybiArdGhpcztcclxufTtcclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwgaW4gYmFzZSA4LCByb3VuZCB0byBgc2RgIHNpZ25pZmljYW50XHJcbiAqIGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIGBybWAuXHJcbiAqXHJcbiAqIElmIHRoZSBvcHRpb25hbCBgc2RgIGFyZ3VtZW50IGlzIHByZXNlbnQgdGhlbiByZXR1cm4gYmluYXJ5IGV4cG9uZW50aWFsIG5vdGF0aW9uLlxyXG4gKlxyXG4gKiBbc2RdIHtudW1iZXJ9IFNpZ25pZmljYW50IGRpZ2l0cy4gSW50ZWdlciwgMSB0byBNQVhfRElHSVRTIGluY2x1c2l2ZS5cclxuICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gKlxyXG4gKi9cclxuUC50b09jdGFsID0gZnVuY3Rpb24gKHNkLCBybSkge1xyXG4gIHJldHVybiB0b1N0cmluZ0JpbmFyeSh0aGlzLCA4LCBzZCwgcm0pO1xyXG59O1xyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwgcmFpc2VkIHRvIHRoZSBwb3dlciBgeWAsIHJvdW5kZWRcclxuICogdG8gYHByZWNpc2lvbmAgc2lnbmlmaWNhbnQgZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJvdW5kaW5nYC5cclxuICpcclxuICogRUNNQVNjcmlwdCBjb21wbGlhbnQuXHJcbiAqXHJcbiAqICAgcG93KHgsIE5hTikgICAgICAgICAgICAgICAgICAgICAgICAgICA9IE5hTlxyXG4gKiAgIHBvdyh4LCDCsTApICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMVxyXG5cclxuICogICBwb3coTmFOLCBub24temVybykgICAgICAgICAgICAgICAgICAgID0gTmFOXHJcbiAqICAgcG93KGFicyh4KSA+IDEsICtJbmZpbml0eSkgICAgICAgICAgICA9ICtJbmZpbml0eVxyXG4gKiAgIHBvdyhhYnMoeCkgPiAxLCAtSW5maW5pdHkpICAgICAgICAgICAgPSArMFxyXG4gKiAgIHBvdyhhYnMoeCkgPT0gMSwgwrFJbmZpbml0eSkgICAgICAgICAgID0gTmFOXHJcbiAqICAgcG93KGFicyh4KSA8IDEsICtJbmZpbml0eSkgICAgICAgICAgICA9ICswXHJcbiAqICAgcG93KGFicyh4KSA8IDEsIC1JbmZpbml0eSkgICAgICAgICAgICA9ICtJbmZpbml0eVxyXG4gKiAgIHBvdygrSW5maW5pdHksIHkgPiAwKSAgICAgICAgICAgICAgICAgPSArSW5maW5pdHlcclxuICogICBwb3coK0luZmluaXR5LCB5IDwgMCkgICAgICAgICAgICAgICAgID0gKzBcclxuICogICBwb3coLUluZmluaXR5LCBvZGQgaW50ZWdlciA+IDApICAgICAgID0gLUluZmluaXR5XHJcbiAqICAgcG93KC1JbmZpbml0eSwgZXZlbiBpbnRlZ2VyID4gMCkgICAgICA9ICtJbmZpbml0eVxyXG4gKiAgIHBvdygtSW5maW5pdHksIG9kZCBpbnRlZ2VyIDwgMCkgICAgICAgPSAtMFxyXG4gKiAgIHBvdygtSW5maW5pdHksIGV2ZW4gaW50ZWdlciA8IDApICAgICAgPSArMFxyXG4gKiAgIHBvdygrMCwgeSA+IDApICAgICAgICAgICAgICAgICAgICAgICAgPSArMFxyXG4gKiAgIHBvdygrMCwgeSA8IDApICAgICAgICAgICAgICAgICAgICAgICAgPSArSW5maW5pdHlcclxuICogICBwb3coLTAsIG9kZCBpbnRlZ2VyID4gMCkgICAgICAgICAgICAgID0gLTBcclxuICogICBwb3coLTAsIGV2ZW4gaW50ZWdlciA+IDApICAgICAgICAgICAgID0gKzBcclxuICogICBwb3coLTAsIG9kZCBpbnRlZ2VyIDwgMCkgICAgICAgICAgICAgID0gLUluZmluaXR5XHJcbiAqICAgcG93KC0wLCBldmVuIGludGVnZXIgPCAwKSAgICAgICAgICAgICA9ICtJbmZpbml0eVxyXG4gKiAgIHBvdyhmaW5pdGUgeCA8IDAsIGZpbml0ZSBub24taW50ZWdlcikgPSBOYU5cclxuICpcclxuICogRm9yIG5vbi1pbnRlZ2VyIG9yIHZlcnkgbGFyZ2UgZXhwb25lbnRzIHBvdyh4LCB5KSBpcyBjYWxjdWxhdGVkIHVzaW5nXHJcbiAqXHJcbiAqICAgeF55ID0gZXhwKHkqbG4oeCkpXHJcbiAqXHJcbiAqIEFzc3VtaW5nIHRoZSBmaXJzdCAxNSByb3VuZGluZyBkaWdpdHMgYXJlIGVhY2ggZXF1YWxseSBsaWtlbHkgdG8gYmUgYW55IGRpZ2l0IDAtOSwgdGhlXHJcbiAqIHByb2JhYmlsaXR5IG9mIGFuIGluY29ycmVjdGx5IHJvdW5kZWQgcmVzdWx0XHJcbiAqIFAoWzQ5XTl7MTR9IHwgWzUwXTB7MTR9KSA9IDIgKiAwLjIgKiAxMF4tMTQgPSA0ZS0xNSA9IDEvMi41ZSsxNFxyXG4gKiBpLmUuIDEgaW4gMjUwLDAwMCwwMDAsMDAwLDAwMFxyXG4gKlxyXG4gKiBJZiBhIHJlc3VsdCBpcyBpbmNvcnJlY3RseSByb3VuZGVkIHRoZSBtYXhpbXVtIGVycm9yIHdpbGwgYmUgMSB1bHAgKHVuaXQgaW4gbGFzdCBwbGFjZSkuXHJcbiAqXHJcbiAqIHkge251bWJlcnxzdHJpbmd8RGVjaW1hbH0gVGhlIHBvd2VyIHRvIHdoaWNoIHRvIHJhaXNlIHRoaXMgRGVjaW1hbC5cclxuICpcclxuICovXHJcblAudG9Qb3dlciA9IFAucG93ID0gZnVuY3Rpb24gKHkpIHtcclxuICB2YXIgZSwgaywgcHIsIHIsIHJtLCBzLFxyXG4gICAgeCA9IHRoaXMsXHJcbiAgICBDdG9yID0geC5jb25zdHJ1Y3RvcixcclxuICAgIHluID0gKyh5ID0gbmV3IEN0b3IoeSkpO1xyXG5cclxuICAvLyBFaXRoZXIgwrFJbmZpbml0eSwgTmFOIG9yIMKxMD9cclxuICBpZiAoIXguZCB8fCAheS5kIHx8ICF4LmRbMF0gfHwgIXkuZFswXSkgcmV0dXJuIG5ldyBDdG9yKG1hdGhwb3coK3gsIHluKSk7XHJcblxyXG4gIHggPSBuZXcgQ3Rvcih4KTtcclxuXHJcbiAgaWYgKHguZXEoMSkpIHJldHVybiB4O1xyXG5cclxuICBwciA9IEN0b3IucHJlY2lzaW9uO1xyXG4gIHJtID0gQ3Rvci5yb3VuZGluZztcclxuXHJcbiAgaWYgKHkuZXEoMSkpIHJldHVybiBmaW5hbGlzZSh4LCBwciwgcm0pO1xyXG5cclxuICAvLyB5IGV4cG9uZW50XHJcbiAgZSA9IG1hdGhmbG9vcih5LmUgLyBMT0dfQkFTRSk7XHJcblxyXG4gIC8vIElmIHkgaXMgYSBzbWFsbCBpbnRlZ2VyIHVzZSB0aGUgJ2V4cG9uZW50aWF0aW9uIGJ5IHNxdWFyaW5nJyBhbGdvcml0aG0uXHJcbiAgaWYgKGUgPj0geS5kLmxlbmd0aCAtIDEgJiYgKGsgPSB5biA8IDAgPyAteW4gOiB5bikgPD0gTUFYX1NBRkVfSU5URUdFUikge1xyXG4gICAgciA9IGludFBvdyhDdG9yLCB4LCBrLCBwcik7XHJcbiAgICByZXR1cm4geS5zIDwgMCA/IG5ldyBDdG9yKDEpLmRpdihyKSA6IGZpbmFsaXNlKHIsIHByLCBybSk7XHJcbiAgfVxyXG5cclxuICBzID0geC5zO1xyXG5cclxuICAvLyBpZiB4IGlzIG5lZ2F0aXZlXHJcbiAgaWYgKHMgPCAwKSB7XHJcblxyXG4gICAgLy8gaWYgeSBpcyBub3QgYW4gaW50ZWdlclxyXG4gICAgaWYgKGUgPCB5LmQubGVuZ3RoIC0gMSkgcmV0dXJuIG5ldyBDdG9yKE5hTik7XHJcblxyXG4gICAgLy8gUmVzdWx0IGlzIHBvc2l0aXZlIGlmIHggaXMgbmVnYXRpdmUgYW5kIHRoZSBsYXN0IGRpZ2l0IG9mIGludGVnZXIgeSBpcyBldmVuLlxyXG4gICAgaWYgKCh5LmRbZV0gJiAxKSA9PSAwKSBzID0gMTtcclxuXHJcbiAgICAvLyBpZiB4LmVxKC0xKVxyXG4gICAgaWYgKHguZSA9PSAwICYmIHguZFswXSA9PSAxICYmIHguZC5sZW5ndGggPT0gMSkge1xyXG4gICAgICB4LnMgPSBzO1xyXG4gICAgICByZXR1cm4geDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIEVzdGltYXRlIHJlc3VsdCBleHBvbmVudC5cclxuICAvLyB4XnkgPSAxMF5lLCAgd2hlcmUgZSA9IHkgKiBsb2cxMCh4KVxyXG4gIC8vIGxvZzEwKHgpID0gbG9nMTAoeF9zaWduaWZpY2FuZCkgKyB4X2V4cG9uZW50XHJcbiAgLy8gbG9nMTAoeF9zaWduaWZpY2FuZCkgPSBsbih4X3NpZ25pZmljYW5kKSAvIGxuKDEwKVxyXG4gIGsgPSBtYXRocG93KCt4LCB5bik7XHJcbiAgZSA9IGsgPT0gMCB8fCAhaXNGaW5pdGUoaylcclxuICAgID8gbWF0aGZsb29yKHluICogKE1hdGgubG9nKCcwLicgKyBkaWdpdHNUb1N0cmluZyh4LmQpKSAvIE1hdGguTE4xMCArIHguZSArIDEpKVxyXG4gICAgOiBuZXcgQ3RvcihrICsgJycpLmU7XHJcblxyXG4gIC8vIEV4cG9uZW50IGVzdGltYXRlIG1heSBiZSBpbmNvcnJlY3QgZS5nLiB4OiAwLjk5OTk5OTk5OTk5OTk5OTk5OSwgeTogMi4yOSwgZTogMCwgci5lOiAtMS5cclxuXHJcbiAgLy8gT3ZlcmZsb3cvdW5kZXJmbG93P1xyXG4gIGlmIChlID4gQ3Rvci5tYXhFICsgMSB8fCBlIDwgQ3Rvci5taW5FIC0gMSkgcmV0dXJuIG5ldyBDdG9yKGUgPiAwID8gcyAvIDAgOiAwKTtcclxuXHJcbiAgZXh0ZXJuYWwgPSBmYWxzZTtcclxuICBDdG9yLnJvdW5kaW5nID0geC5zID0gMTtcclxuXHJcbiAgLy8gRXN0aW1hdGUgdGhlIGV4dHJhIGd1YXJkIGRpZ2l0cyBuZWVkZWQgdG8gZW5zdXJlIGZpdmUgY29ycmVjdCByb3VuZGluZyBkaWdpdHMgZnJvbVxyXG4gIC8vIG5hdHVyYWxMb2dhcml0aG0oeCkuIEV4YW1wbGUgb2YgZmFpbHVyZSB3aXRob3V0IHRoZXNlIGV4dHJhIGRpZ2l0cyAocHJlY2lzaW9uOiAxMCk6XHJcbiAgLy8gbmV3IERlY2ltYWwoMi4zMjQ1NikucG93KCcyMDg3OTg3NDM2NTM0NTY2LjQ2NDExJylcclxuICAvLyBzaG91bGQgYmUgMS4xNjIzNzc4MjNlKzc2NDkxNDkwNTE3MzgxNSwgYnV0IGlzIDEuMTYyMzU1ODIzZSs3NjQ5MTQ5MDUxNzM4MTVcclxuICBrID0gTWF0aC5taW4oMTIsIChlICsgJycpLmxlbmd0aCk7XHJcblxyXG4gIC8vIHIgPSB4XnkgPSBleHAoeSpsbih4KSlcclxuICByID0gbmF0dXJhbEV4cG9uZW50aWFsKHkudGltZXMobmF0dXJhbExvZ2FyaXRobSh4LCBwciArIGspKSwgcHIpO1xyXG5cclxuICAvLyByIG1heSBiZSBJbmZpbml0eSwgZS5nLiAoMC45OTk5OTk5OTk5OTk5OTk5KS5wb3coLTFlKzQwKVxyXG4gIGlmIChyLmQpIHtcclxuXHJcbiAgICAvLyBUcnVuY2F0ZSB0byB0aGUgcmVxdWlyZWQgcHJlY2lzaW9uIHBsdXMgZml2ZSByb3VuZGluZyBkaWdpdHMuXHJcbiAgICByID0gZmluYWxpc2UociwgcHIgKyA1LCAxKTtcclxuXHJcbiAgICAvLyBJZiB0aGUgcm91bmRpbmcgZGlnaXRzIGFyZSBbNDldOTk5OSBvciBbNTBdMDAwMCBpbmNyZWFzZSB0aGUgcHJlY2lzaW9uIGJ5IDEwIGFuZCByZWNhbGN1bGF0ZVxyXG4gICAgLy8gdGhlIHJlc3VsdC5cclxuICAgIGlmIChjaGVja1JvdW5kaW5nRGlnaXRzKHIuZCwgcHIsIHJtKSkge1xyXG4gICAgICBlID0gcHIgKyAxMDtcclxuXHJcbiAgICAgIC8vIFRydW5jYXRlIHRvIHRoZSBpbmNyZWFzZWQgcHJlY2lzaW9uIHBsdXMgZml2ZSByb3VuZGluZyBkaWdpdHMuXHJcbiAgICAgIHIgPSBmaW5hbGlzZShuYXR1cmFsRXhwb25lbnRpYWwoeS50aW1lcyhuYXR1cmFsTG9nYXJpdGhtKHgsIGUgKyBrKSksIGUpLCBlICsgNSwgMSk7XHJcblxyXG4gICAgICAvLyBDaGVjayBmb3IgMTQgbmluZXMgZnJvbSB0aGUgMm5kIHJvdW5kaW5nIGRpZ2l0ICh0aGUgZmlyc3Qgcm91bmRpbmcgZGlnaXQgbWF5IGJlIDQgb3IgOSkuXHJcbiAgICAgIGlmICgrZGlnaXRzVG9TdHJpbmcoci5kKS5zbGljZShwciArIDEsIHByICsgMTUpICsgMSA9PSAxZTE0KSB7XHJcbiAgICAgICAgciA9IGZpbmFsaXNlKHIsIHByICsgMSwgMCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIHIucyA9IHM7XHJcbiAgZXh0ZXJuYWwgPSB0cnVlO1xyXG4gIEN0b3Iucm91bmRpbmcgPSBybTtcclxuXHJcbiAgcmV0dXJuIGZpbmFsaXNlKHIsIHByLCBybSk7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhpcyBEZWNpbWFsIHJvdW5kZWQgdG8gYHNkYCBzaWduaWZpY2FudCBkaWdpdHNcclxuICogdXNpbmcgcm91bmRpbmcgbW9kZSBgcm91bmRpbmdgLlxyXG4gKlxyXG4gKiBSZXR1cm4gZXhwb25lbnRpYWwgbm90YXRpb24gaWYgYHNkYCBpcyBsZXNzIHRoYW4gdGhlIG51bWJlciBvZiBkaWdpdHMgbmVjZXNzYXJ5IHRvIHJlcHJlc2VudFxyXG4gKiB0aGUgaW50ZWdlciBwYXJ0IG9mIHRoZSB2YWx1ZSBpbiBub3JtYWwgbm90YXRpb24uXHJcbiAqXHJcbiAqIFtzZF0ge251bWJlcn0gU2lnbmlmaWNhbnQgZGlnaXRzLiBJbnRlZ2VyLCAxIHRvIE1BWF9ESUdJVFMgaW5jbHVzaXZlLlxyXG4gKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAqXHJcbiAqL1xyXG5QLnRvUHJlY2lzaW9uID0gZnVuY3Rpb24gKHNkLCBybSkge1xyXG4gIHZhciBzdHIsXHJcbiAgICB4ID0gdGhpcyxcclxuICAgIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xyXG5cclxuICBpZiAoc2QgPT09IHZvaWQgMCkge1xyXG4gICAgc3RyID0gZmluaXRlVG9TdHJpbmcoeCwgeC5lIDw9IEN0b3IudG9FeHBOZWcgfHwgeC5lID49IEN0b3IudG9FeHBQb3MpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBjaGVja0ludDMyKHNkLCAxLCBNQVhfRElHSVRTKTtcclxuXHJcbiAgICBpZiAocm0gPT09IHZvaWQgMCkgcm0gPSBDdG9yLnJvdW5kaW5nO1xyXG4gICAgZWxzZSBjaGVja0ludDMyKHJtLCAwLCA4KTtcclxuXHJcbiAgICB4ID0gZmluYWxpc2UobmV3IEN0b3IoeCksIHNkLCBybSk7XHJcbiAgICBzdHIgPSBmaW5pdGVUb1N0cmluZyh4LCBzZCA8PSB4LmUgfHwgeC5lIDw9IEN0b3IudG9FeHBOZWcsIHNkKTtcclxuICB9XHJcblxyXG4gIHJldHVybiB4LmlzTmVnKCkgJiYgIXguaXNaZXJvKCkgPyAnLScgKyBzdHIgOiBzdHI7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbCByb3VuZGVkIHRvIGEgbWF4aW11bSBvZiBgc2RgXHJcbiAqIHNpZ25pZmljYW50IGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIGBybWAsIG9yIHRvIGBwcmVjaXNpb25gIGFuZCBgcm91bmRpbmdgIHJlc3BlY3RpdmVseSBpZlxyXG4gKiBvbWl0dGVkLlxyXG4gKlxyXG4gKiBbc2RdIHtudW1iZXJ9IFNpZ25pZmljYW50IGRpZ2l0cy4gSW50ZWdlciwgMSB0byBNQVhfRElHSVRTIGluY2x1c2l2ZS5cclxuICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gKlxyXG4gKiAndG9TRCgpIGRpZ2l0cyBvdXQgb2YgcmFuZ2U6IHtzZH0nXHJcbiAqICd0b1NEKCkgZGlnaXRzIG5vdCBhbiBpbnRlZ2VyOiB7c2R9J1xyXG4gKiAndG9TRCgpIHJvdW5kaW5nIG1vZGUgbm90IGFuIGludGVnZXI6IHtybX0nXHJcbiAqICd0b1NEKCkgcm91bmRpbmcgbW9kZSBvdXQgb2YgcmFuZ2U6IHtybX0nXHJcbiAqXHJcbiAqL1xyXG5QLnRvU2lnbmlmaWNhbnREaWdpdHMgPSBQLnRvU0QgPSBmdW5jdGlvbiAoc2QsIHJtKSB7XHJcbiAgdmFyIHggPSB0aGlzLFxyXG4gICAgQ3RvciA9IHguY29uc3RydWN0b3I7XHJcblxyXG4gIGlmIChzZCA9PT0gdm9pZCAwKSB7XHJcbiAgICBzZCA9IEN0b3IucHJlY2lzaW9uO1xyXG4gICAgcm0gPSBDdG9yLnJvdW5kaW5nO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBjaGVja0ludDMyKHNkLCAxLCBNQVhfRElHSVRTKTtcclxuXHJcbiAgICBpZiAocm0gPT09IHZvaWQgMCkgcm0gPSBDdG9yLnJvdW5kaW5nO1xyXG4gICAgZWxzZSBjaGVja0ludDMyKHJtLCAwLCA4KTtcclxuICB9XHJcblxyXG4gIHJldHVybiBmaW5hbGlzZShuZXcgQ3Rvcih4KSwgc2QsIHJtKTtcclxufTtcclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwuXHJcbiAqXHJcbiAqIFJldHVybiBleHBvbmVudGlhbCBub3RhdGlvbiBpZiB0aGlzIERlY2ltYWwgaGFzIGEgcG9zaXRpdmUgZXhwb25lbnQgZXF1YWwgdG8gb3IgZ3JlYXRlciB0aGFuXHJcbiAqIGB0b0V4cFBvc2AsIG9yIGEgbmVnYXRpdmUgZXhwb25lbnQgZXF1YWwgdG8gb3IgbGVzcyB0aGFuIGB0b0V4cE5lZ2AuXHJcbiAqXHJcbiAqL1xyXG5QLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xyXG4gIHZhciB4ID0gdGhpcyxcclxuICAgIEN0b3IgPSB4LmNvbnN0cnVjdG9yLFxyXG4gICAgc3RyID0gZmluaXRlVG9TdHJpbmcoeCwgeC5lIDw9IEN0b3IudG9FeHBOZWcgfHwgeC5lID49IEN0b3IudG9FeHBQb3MpO1xyXG5cclxuICByZXR1cm4geC5pc05lZygpICYmICF4LmlzWmVybygpID8gJy0nICsgc3RyIDogc3RyO1xyXG59O1xyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwgdHJ1bmNhdGVkIHRvIGEgd2hvbGUgbnVtYmVyLlxyXG4gKlxyXG4gKi9cclxuUC50cnVuY2F0ZWQgPSBQLnRydW5jID0gZnVuY3Rpb24gKCkge1xyXG4gIHJldHVybiBmaW5hbGlzZShuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzKSwgdGhpcy5lICsgMSwgMSk7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhpcyBEZWNpbWFsLlxyXG4gKiBVbmxpa2UgYHRvU3RyaW5nYCwgbmVnYXRpdmUgemVybyB3aWxsIGluY2x1ZGUgdGhlIG1pbnVzIHNpZ24uXHJcbiAqXHJcbiAqL1xyXG5QLnZhbHVlT2YgPSBQLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgeCA9IHRoaXMsXHJcbiAgICBDdG9yID0geC5jb25zdHJ1Y3RvcixcclxuICAgIHN0ciA9IGZpbml0ZVRvU3RyaW5nKHgsIHguZSA8PSBDdG9yLnRvRXhwTmVnIHx8IHguZSA+PSBDdG9yLnRvRXhwUG9zKTtcclxuXHJcbiAgcmV0dXJuIHguaXNOZWcoKSA/ICctJyArIHN0ciA6IHN0cjtcclxufTtcclxuXHJcblxyXG4vLyBIZWxwZXIgZnVuY3Rpb25zIGZvciBEZWNpbWFsLnByb3RvdHlwZSAoUCkgYW5kL29yIERlY2ltYWwgbWV0aG9kcywgYW5kIHRoZWlyIGNhbGxlcnMuXHJcblxyXG5cclxuLypcclxuICogIGRpZ2l0c1RvU3RyaW5nICAgICAgICAgICBQLmN1YmVSb290LCBQLmxvZ2FyaXRobSwgUC5zcXVhcmVSb290LCBQLnRvRnJhY3Rpb24sIFAudG9Qb3dlcixcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5pdGVUb1N0cmluZywgbmF0dXJhbEV4cG9uZW50aWFsLCBuYXR1cmFsTG9nYXJpdGhtXHJcbiAqICBjaGVja0ludDMyICAgICAgICAgICAgICAgUC50b0RlY2ltYWxQbGFjZXMsIFAudG9FeHBvbmVudGlhbCwgUC50b0ZpeGVkLCBQLnRvTmVhcmVzdCxcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICBQLnRvUHJlY2lzaW9uLCBQLnRvU2lnbmlmaWNhbnREaWdpdHMsIHRvU3RyaW5nQmluYXJ5LCByYW5kb21cclxuICogIGNoZWNrUm91bmRpbmdEaWdpdHMgICAgICBQLmxvZ2FyaXRobSwgUC50b1Bvd2VyLCBuYXR1cmFsRXhwb25lbnRpYWwsIG5hdHVyYWxMb2dhcml0aG1cclxuICogIGNvbnZlcnRCYXNlICAgICAgICAgICAgICB0b1N0cmluZ0JpbmFyeSwgcGFyc2VPdGhlclxyXG4gKiAgY29zICAgICAgICAgICAgICAgICAgICAgIFAuY29zXHJcbiAqICBkaXZpZGUgICAgICAgICAgICAgICAgICAgUC5hdGFuaCwgUC5jdWJlUm9vdCwgUC5kaXZpZGVkQnksIFAuZGl2aWRlZFRvSW50ZWdlckJ5LFxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIFAubG9nYXJpdGhtLCBQLm1vZHVsbywgUC5zcXVhcmVSb290LCBQLnRhbiwgUC50YW5oLCBQLnRvRnJhY3Rpb24sXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgUC50b05lYXJlc3QsIHRvU3RyaW5nQmluYXJ5LCBuYXR1cmFsRXhwb25lbnRpYWwsIG5hdHVyYWxMb2dhcml0aG0sXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgdGF5bG9yU2VyaWVzLCBhdGFuMiwgcGFyc2VPdGhlclxyXG4gKiAgZmluYWxpc2UgICAgICAgICAgICAgICAgIFAuYWJzb2x1dGVWYWx1ZSwgUC5hdGFuLCBQLmF0YW5oLCBQLmNlaWwsIFAuY29zLCBQLmNvc2gsXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgUC5jdWJlUm9vdCwgUC5kaXZpZGVkVG9JbnRlZ2VyQnksIFAuZmxvb3IsIFAubG9nYXJpdGhtLCBQLm1pbnVzLFxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIFAubW9kdWxvLCBQLm5lZ2F0ZWQsIFAucGx1cywgUC5yb3VuZCwgUC5zaW4sIFAuc2luaCwgUC5zcXVhcmVSb290LFxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIFAudGFuLCBQLnRpbWVzLCBQLnRvRGVjaW1hbFBsYWNlcywgUC50b0V4cG9uZW50aWFsLCBQLnRvRml4ZWQsXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgUC50b05lYXJlc3QsIFAudG9Qb3dlciwgUC50b1ByZWNpc2lvbiwgUC50b1NpZ25pZmljYW50RGlnaXRzLFxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIFAudHJ1bmNhdGVkLCBkaXZpZGUsIGdldExuMTAsIGdldFBpLCBuYXR1cmFsRXhwb25lbnRpYWwsXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgbmF0dXJhbExvZ2FyaXRobSwgY2VpbCwgZmxvb3IsIHJvdW5kLCB0cnVuY1xyXG4gKiAgZmluaXRlVG9TdHJpbmcgICAgICAgICAgIFAudG9FeHBvbmVudGlhbCwgUC50b0ZpeGVkLCBQLnRvUHJlY2lzaW9uLCBQLnRvU3RyaW5nLCBQLnZhbHVlT2YsXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9TdHJpbmdCaW5hcnlcclxuICogIGdldEJhc2UxMEV4cG9uZW50ICAgICAgICBQLm1pbnVzLCBQLnBsdXMsIFAudGltZXMsIHBhcnNlT3RoZXJcclxuICogIGdldExuMTAgICAgICAgICAgICAgICAgICBQLmxvZ2FyaXRobSwgbmF0dXJhbExvZ2FyaXRobVxyXG4gKiAgZ2V0UGkgICAgICAgICAgICAgICAgICAgIFAuYWNvcywgUC5hc2luLCBQLmF0YW4sIHRvTGVzc1RoYW5IYWxmUGksIGF0YW4yXHJcbiAqICBnZXRQcmVjaXNpb24gICAgICAgICAgICAgUC5wcmVjaXNpb24sIFAudG9GcmFjdGlvblxyXG4gKiAgZ2V0WmVyb1N0cmluZyAgICAgICAgICAgIGRpZ2l0c1RvU3RyaW5nLCBmaW5pdGVUb1N0cmluZ1xyXG4gKiAgaW50UG93ICAgICAgICAgICAgICAgICAgIFAudG9Qb3dlciwgcGFyc2VPdGhlclxyXG4gKiAgaXNPZGQgICAgICAgICAgICAgICAgICAgIHRvTGVzc1RoYW5IYWxmUGlcclxuICogIG1heE9yTWluICAgICAgICAgICAgICAgICBtYXgsIG1pblxyXG4gKiAgbmF0dXJhbEV4cG9uZW50aWFsICAgICAgIFAubmF0dXJhbEV4cG9uZW50aWFsLCBQLnRvUG93ZXJcclxuICogIG5hdHVyYWxMb2dhcml0aG0gICAgICAgICBQLmFjb3NoLCBQLmFzaW5oLCBQLmF0YW5oLCBQLmxvZ2FyaXRobSwgUC5uYXR1cmFsTG9nYXJpdGhtLFxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIFAudG9Qb3dlciwgbmF0dXJhbEV4cG9uZW50aWFsXHJcbiAqICBub25GaW5pdGVUb1N0cmluZyAgICAgICAgZmluaXRlVG9TdHJpbmcsIHRvU3RyaW5nQmluYXJ5XHJcbiAqICBwYXJzZURlY2ltYWwgICAgICAgICAgICAgRGVjaW1hbFxyXG4gKiAgcGFyc2VPdGhlciAgICAgICAgICAgICAgIERlY2ltYWxcclxuICogIHNpbiAgICAgICAgICAgICAgICAgICAgICBQLnNpblxyXG4gKiAgdGF5bG9yU2VyaWVzICAgICAgICAgICAgIFAuY29zaCwgUC5zaW5oLCBjb3MsIHNpblxyXG4gKiAgdG9MZXNzVGhhbkhhbGZQaSAgICAgICAgIFAuY29zLCBQLnNpblxyXG4gKiAgdG9TdHJpbmdCaW5hcnkgICAgICAgICAgIFAudG9CaW5hcnksIFAudG9IZXhhZGVjaW1hbCwgUC50b09jdGFsXHJcbiAqICB0cnVuY2F0ZSAgICAgICAgICAgICAgICAgaW50UG93XHJcbiAqXHJcbiAqICBUaHJvd3M6ICAgICAgICAgICAgICAgICAgUC5sb2dhcml0aG0sIFAucHJlY2lzaW9uLCBQLnRvRnJhY3Rpb24sIGNoZWNrSW50MzIsIGdldExuMTAsIGdldFBpLFxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hdHVyYWxMb2dhcml0aG0sIGNvbmZpZywgcGFyc2VPdGhlciwgcmFuZG9tLCBEZWNpbWFsXHJcbiAqL1xyXG5cclxuXHJcbmZ1bmN0aW9uIGRpZ2l0c1RvU3RyaW5nKGQpIHtcclxuICB2YXIgaSwgaywgd3MsXHJcbiAgICBpbmRleE9mTGFzdFdvcmQgPSBkLmxlbmd0aCAtIDEsXHJcbiAgICBzdHIgPSAnJyxcclxuICAgIHcgPSBkWzBdO1xyXG5cclxuICBpZiAoaW5kZXhPZkxhc3RXb3JkID4gMCkge1xyXG4gICAgc3RyICs9IHc7XHJcbiAgICBmb3IgKGkgPSAxOyBpIDwgaW5kZXhPZkxhc3RXb3JkOyBpKyspIHtcclxuICAgICAgd3MgPSBkW2ldICsgJyc7XHJcbiAgICAgIGsgPSBMT0dfQkFTRSAtIHdzLmxlbmd0aDtcclxuICAgICAgaWYgKGspIHN0ciArPSBnZXRaZXJvU3RyaW5nKGspO1xyXG4gICAgICBzdHIgKz0gd3M7XHJcbiAgICB9XHJcblxyXG4gICAgdyA9IGRbaV07XHJcbiAgICB3cyA9IHcgKyAnJztcclxuICAgIGsgPSBMT0dfQkFTRSAtIHdzLmxlbmd0aDtcclxuICAgIGlmIChrKSBzdHIgKz0gZ2V0WmVyb1N0cmluZyhrKTtcclxuICB9IGVsc2UgaWYgKHcgPT09IDApIHtcclxuICAgIHJldHVybiAnMCc7XHJcbiAgfVxyXG5cclxuICAvLyBSZW1vdmUgdHJhaWxpbmcgemVyb3Mgb2YgbGFzdCB3LlxyXG4gIGZvciAoOyB3ICUgMTAgPT09IDA7KSB3IC89IDEwO1xyXG5cclxuICByZXR1cm4gc3RyICsgdztcclxufVxyXG5cclxuXHJcbmZ1bmN0aW9uIGNoZWNrSW50MzIoaSwgbWluLCBtYXgpIHtcclxuICBpZiAoaSAhPT0gfn5pIHx8IGkgPCBtaW4gfHwgaSA+IG1heCkge1xyXG4gICAgdGhyb3cgRXJyb3IoaW52YWxpZEFyZ3VtZW50ICsgaSk7XHJcbiAgfVxyXG59XHJcblxyXG5cclxuLypcclxuICogQ2hlY2sgNSByb3VuZGluZyBkaWdpdHMgaWYgYHJlcGVhdGluZ2AgaXMgbnVsbCwgNCBvdGhlcndpc2UuXHJcbiAqIGByZXBlYXRpbmcgPT0gbnVsbGAgaWYgY2FsbGVyIGlzIGBsb2dgIG9yIGBwb3dgLFxyXG4gKiBgcmVwZWF0aW5nICE9IG51bGxgIGlmIGNhbGxlciBpcyBgbmF0dXJhbExvZ2FyaXRobWAgb3IgYG5hdHVyYWxFeHBvbmVudGlhbGAuXHJcbiAqL1xyXG5mdW5jdGlvbiBjaGVja1JvdW5kaW5nRGlnaXRzKGQsIGksIHJtLCByZXBlYXRpbmcpIHtcclxuICB2YXIgZGksIGssIHIsIHJkO1xyXG5cclxuICAvLyBHZXQgdGhlIGxlbmd0aCBvZiB0aGUgZmlyc3Qgd29yZCBvZiB0aGUgYXJyYXkgZC5cclxuICBmb3IgKGsgPSBkWzBdOyBrID49IDEwOyBrIC89IDEwKSAtLWk7XHJcblxyXG4gIC8vIElzIHRoZSByb3VuZGluZyBkaWdpdCBpbiB0aGUgZmlyc3Qgd29yZCBvZiBkP1xyXG4gIGlmICgtLWkgPCAwKSB7XHJcbiAgICBpICs9IExPR19CQVNFO1xyXG4gICAgZGkgPSAwO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBkaSA9IE1hdGguY2VpbCgoaSArIDEpIC8gTE9HX0JBU0UpO1xyXG4gICAgaSAlPSBMT0dfQkFTRTtcclxuICB9XHJcblxyXG4gIC8vIGkgaXMgdGhlIGluZGV4ICgwIC0gNikgb2YgdGhlIHJvdW5kaW5nIGRpZ2l0LlxyXG4gIC8vIEUuZy4gaWYgd2l0aGluIHRoZSB3b3JkIDM0ODc1NjMgdGhlIGZpcnN0IHJvdW5kaW5nIGRpZ2l0IGlzIDUsXHJcbiAgLy8gdGhlbiBpID0gNCwgayA9IDEwMDAsIHJkID0gMzQ4NzU2MyAlIDEwMDAgPSA1NjNcclxuICBrID0gbWF0aHBvdygxMCwgTE9HX0JBU0UgLSBpKTtcclxuICByZCA9IGRbZGldICUgayB8IDA7XHJcblxyXG4gIGlmIChyZXBlYXRpbmcgPT0gbnVsbCkge1xyXG4gICAgaWYgKGkgPCAzKSB7XHJcbiAgICAgIGlmIChpID09IDApIHJkID0gcmQgLyAxMDAgfCAwO1xyXG4gICAgICBlbHNlIGlmIChpID09IDEpIHJkID0gcmQgLyAxMCB8IDA7XHJcbiAgICAgIHIgPSBybSA8IDQgJiYgcmQgPT0gOTk5OTkgfHwgcm0gPiAzICYmIHJkID09IDQ5OTk5IHx8IHJkID09IDUwMDAwIHx8IHJkID09IDA7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByID0gKHJtIDwgNCAmJiByZCArIDEgPT0gayB8fCBybSA+IDMgJiYgcmQgKyAxID09IGsgLyAyKSAmJlxyXG4gICAgICAgIChkW2RpICsgMV0gLyBrIC8gMTAwIHwgMCkgPT0gbWF0aHBvdygxMCwgaSAtIDIpIC0gMSB8fFxyXG4gICAgICAgICAgKHJkID09IGsgLyAyIHx8IHJkID09IDApICYmIChkW2RpICsgMV0gLyBrIC8gMTAwIHwgMCkgPT0gMDtcclxuICAgIH1cclxuICB9IGVsc2Uge1xyXG4gICAgaWYgKGkgPCA0KSB7XHJcbiAgICAgIGlmIChpID09IDApIHJkID0gcmQgLyAxMDAwIHwgMDtcclxuICAgICAgZWxzZSBpZiAoaSA9PSAxKSByZCA9IHJkIC8gMTAwIHwgMDtcclxuICAgICAgZWxzZSBpZiAoaSA9PSAyKSByZCA9IHJkIC8gMTAgfCAwO1xyXG4gICAgICByID0gKHJlcGVhdGluZyB8fCBybSA8IDQpICYmIHJkID09IDk5OTkgfHwgIXJlcGVhdGluZyAmJiBybSA+IDMgJiYgcmQgPT0gNDk5OTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHIgPSAoKHJlcGVhdGluZyB8fCBybSA8IDQpICYmIHJkICsgMSA9PSBrIHx8XHJcbiAgICAgICghcmVwZWF0aW5nICYmIHJtID4gMykgJiYgcmQgKyAxID09IGsgLyAyKSAmJlxyXG4gICAgICAgIChkW2RpICsgMV0gLyBrIC8gMTAwMCB8IDApID09IG1hdGhwb3coMTAsIGkgLSAzKSAtIDE7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gcjtcclxufVxyXG5cclxuXHJcbi8vIENvbnZlcnQgc3RyaW5nIG9mIGBiYXNlSW5gIHRvIGFuIGFycmF5IG9mIG51bWJlcnMgb2YgYGJhc2VPdXRgLlxyXG4vLyBFZy4gY29udmVydEJhc2UoJzI1NScsIDEwLCAxNikgcmV0dXJucyBbMTUsIDE1XS5cclxuLy8gRWcuIGNvbnZlcnRCYXNlKCdmZicsIDE2LCAxMCkgcmV0dXJucyBbMiwgNSwgNV0uXHJcbmZ1bmN0aW9uIGNvbnZlcnRCYXNlKHN0ciwgYmFzZUluLCBiYXNlT3V0KSB7XHJcbiAgdmFyIGosXHJcbiAgICBhcnIgPSBbMF0sXHJcbiAgICBhcnJMLFxyXG4gICAgaSA9IDAsXHJcbiAgICBzdHJMID0gc3RyLmxlbmd0aDtcclxuXHJcbiAgZm9yICg7IGkgPCBzdHJMOykge1xyXG4gICAgZm9yIChhcnJMID0gYXJyLmxlbmd0aDsgYXJyTC0tOykgYXJyW2FyckxdICo9IGJhc2VJbjtcclxuICAgIGFyclswXSArPSBOVU1FUkFMUy5pbmRleE9mKHN0ci5jaGFyQXQoaSsrKSk7XHJcbiAgICBmb3IgKGogPSAwOyBqIDwgYXJyLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgIGlmIChhcnJbal0gPiBiYXNlT3V0IC0gMSkge1xyXG4gICAgICAgIGlmIChhcnJbaiArIDFdID09PSB2b2lkIDApIGFycltqICsgMV0gPSAwO1xyXG4gICAgICAgIGFycltqICsgMV0gKz0gYXJyW2pdIC8gYmFzZU91dCB8IDA7XHJcbiAgICAgICAgYXJyW2pdICU9IGJhc2VPdXQ7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiBhcnIucmV2ZXJzZSgpO1xyXG59XHJcblxyXG5cclxuLypcclxuICogY29zKHgpID0gMSAtIHheMi8yISArIHheNC80ISAtIC4uLlxyXG4gKiB8eHwgPCBwaS8yXHJcbiAqXHJcbiAqL1xyXG5mdW5jdGlvbiBjb3NpbmUoQ3RvciwgeCkge1xyXG4gIHZhciBrLCBsZW4sIHk7XHJcblxyXG4gIGlmICh4LmlzWmVybygpKSByZXR1cm4geDtcclxuXHJcbiAgLy8gQXJndW1lbnQgcmVkdWN0aW9uOiBjb3MoNHgpID0gOCooY29zXjQoeCkgLSBjb3NeMih4KSkgKyAxXHJcbiAgLy8gaS5lLiBjb3MoeCkgPSA4Kihjb3NeNCh4LzQpIC0gY29zXjIoeC80KSkgKyAxXHJcblxyXG4gIC8vIEVzdGltYXRlIHRoZSBvcHRpbXVtIG51bWJlciBvZiB0aW1lcyB0byB1c2UgdGhlIGFyZ3VtZW50IHJlZHVjdGlvbi5cclxuICBsZW4gPSB4LmQubGVuZ3RoO1xyXG4gIGlmIChsZW4gPCAzMikge1xyXG4gICAgayA9IE1hdGguY2VpbChsZW4gLyAzKTtcclxuICAgIHkgPSAoMSAvIHRpbnlQb3coNCwgaykpLnRvU3RyaW5nKCk7XHJcbiAgfSBlbHNlIHtcclxuICAgIGsgPSAxNjtcclxuICAgIHkgPSAnMi4zMjgzMDY0MzY1Mzg2OTYyODkwNjI1ZS0xMCc7XHJcbiAgfVxyXG5cclxuICBDdG9yLnByZWNpc2lvbiArPSBrO1xyXG5cclxuICB4ID0gdGF5bG9yU2VyaWVzKEN0b3IsIDEsIHgudGltZXMoeSksIG5ldyBDdG9yKDEpKTtcclxuXHJcbiAgLy8gUmV2ZXJzZSBhcmd1bWVudCByZWR1Y3Rpb25cclxuICBmb3IgKHZhciBpID0gazsgaS0tOykge1xyXG4gICAgdmFyIGNvczJ4ID0geC50aW1lcyh4KTtcclxuICAgIHggPSBjb3MyeC50aW1lcyhjb3MyeCkubWludXMoY29zMngpLnRpbWVzKDgpLnBsdXMoMSk7XHJcbiAgfVxyXG5cclxuICBDdG9yLnByZWNpc2lvbiAtPSBrO1xyXG5cclxuICByZXR1cm4geDtcclxufVxyXG5cclxuXHJcbi8qXHJcbiAqIFBlcmZvcm0gZGl2aXNpb24gaW4gdGhlIHNwZWNpZmllZCBiYXNlLlxyXG4gKi9cclxudmFyIGRpdmlkZSA9IChmdW5jdGlvbiAoKSB7XHJcblxyXG4gIC8vIEFzc3VtZXMgbm9uLXplcm8geCBhbmQgaywgYW5kIGhlbmNlIG5vbi16ZXJvIHJlc3VsdC5cclxuICBmdW5jdGlvbiBtdWx0aXBseUludGVnZXIoeCwgaywgYmFzZSkge1xyXG4gICAgdmFyIHRlbXAsXHJcbiAgICAgIGNhcnJ5ID0gMCxcclxuICAgICAgaSA9IHgubGVuZ3RoO1xyXG5cclxuICAgIGZvciAoeCA9IHguc2xpY2UoKTsgaS0tOykge1xyXG4gICAgICB0ZW1wID0geFtpXSAqIGsgKyBjYXJyeTtcclxuICAgICAgeFtpXSA9IHRlbXAgJSBiYXNlIHwgMDtcclxuICAgICAgY2FycnkgPSB0ZW1wIC8gYmFzZSB8IDA7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGNhcnJ5KSB4LnVuc2hpZnQoY2FycnkpO1xyXG5cclxuICAgIHJldHVybiB4O1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gY29tcGFyZShhLCBiLCBhTCwgYkwpIHtcclxuICAgIHZhciBpLCByO1xyXG5cclxuICAgIGlmIChhTCAhPSBiTCkge1xyXG4gICAgICByID0gYUwgPiBiTCA/IDEgOiAtMTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGZvciAoaSA9IHIgPSAwOyBpIDwgYUw7IGkrKykge1xyXG4gICAgICAgIGlmIChhW2ldICE9IGJbaV0pIHtcclxuICAgICAgICAgIHIgPSBhW2ldID4gYltpXSA/IDEgOiAtMTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiByO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gc3VidHJhY3QoYSwgYiwgYUwsIGJhc2UpIHtcclxuICAgIHZhciBpID0gMDtcclxuXHJcbiAgICAvLyBTdWJ0cmFjdCBiIGZyb20gYS5cclxuICAgIGZvciAoOyBhTC0tOykge1xyXG4gICAgICBhW2FMXSAtPSBpO1xyXG4gICAgICBpID0gYVthTF0gPCBiW2FMXSA/IDEgOiAwO1xyXG4gICAgICBhW2FMXSA9IGkgKiBiYXNlICsgYVthTF0gLSBiW2FMXTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBSZW1vdmUgbGVhZGluZyB6ZXJvcy5cclxuICAgIGZvciAoOyAhYVswXSAmJiBhLmxlbmd0aCA+IDE7KSBhLnNoaWZ0KCk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gZnVuY3Rpb24gKHgsIHksIHByLCBybSwgZHAsIGJhc2UpIHtcclxuICAgIHZhciBjbXAsIGUsIGksIGssIGxvZ0Jhc2UsIG1vcmUsIHByb2QsIHByb2RMLCBxLCBxZCwgcmVtLCByZW1MLCByZW0wLCBzZCwgdCwgeGksIHhMLCB5ZDAsXHJcbiAgICAgIHlMLCB5eixcclxuICAgICAgQ3RvciA9IHguY29uc3RydWN0b3IsXHJcbiAgICAgIHNpZ24gPSB4LnMgPT0geS5zID8gMSA6IC0xLFxyXG4gICAgICB4ZCA9IHguZCxcclxuICAgICAgeWQgPSB5LmQ7XHJcblxyXG4gICAgLy8gRWl0aGVyIE5hTiwgSW5maW5pdHkgb3IgMD9cclxuICAgIGlmICgheGQgfHwgIXhkWzBdIHx8ICF5ZCB8fCAheWRbMF0pIHtcclxuXHJcbiAgICAgIHJldHVybiBuZXcgQ3RvcigvLyBSZXR1cm4gTmFOIGlmIGVpdGhlciBOYU4sIG9yIGJvdGggSW5maW5pdHkgb3IgMC5cclxuICAgICAgICAheC5zIHx8ICF5LnMgfHwgKHhkID8geWQgJiYgeGRbMF0gPT0geWRbMF0gOiAheWQpID8gTmFOIDpcclxuXHJcbiAgICAgICAgLy8gUmV0dXJuIMKxMCBpZiB4IGlzIDAgb3IgeSBpcyDCsUluZmluaXR5LCBvciByZXR1cm4gwrFJbmZpbml0eSBhcyB5IGlzIDAuXHJcbiAgICAgICAgeGQgJiYgeGRbMF0gPT0gMCB8fCAheWQgPyBzaWduICogMCA6IHNpZ24gLyAwKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoYmFzZSkge1xyXG4gICAgICBsb2dCYXNlID0gMTtcclxuICAgICAgZSA9IHguZSAtIHkuZTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGJhc2UgPSBCQVNFO1xyXG4gICAgICBsb2dCYXNlID0gTE9HX0JBU0U7XHJcbiAgICAgIGUgPSBtYXRoZmxvb3IoeC5lIC8gbG9nQmFzZSkgLSBtYXRoZmxvb3IoeS5lIC8gbG9nQmFzZSk7XHJcbiAgICB9XHJcblxyXG4gICAgeUwgPSB5ZC5sZW5ndGg7XHJcbiAgICB4TCA9IHhkLmxlbmd0aDtcclxuICAgIHEgPSBuZXcgQ3RvcihzaWduKTtcclxuICAgIHFkID0gcS5kID0gW107XHJcblxyXG4gICAgLy8gUmVzdWx0IGV4cG9uZW50IG1heSBiZSBvbmUgbGVzcyB0aGFuIGUuXHJcbiAgICAvLyBUaGUgZGlnaXQgYXJyYXkgb2YgYSBEZWNpbWFsIGZyb20gdG9TdHJpbmdCaW5hcnkgbWF5IGhhdmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgICBmb3IgKGkgPSAwOyB5ZFtpXSA9PSAoeGRbaV0gfHwgMCk7IGkrKyk7XHJcblxyXG4gICAgaWYgKHlkW2ldID4gKHhkW2ldIHx8IDApKSBlLS07XHJcblxyXG4gICAgaWYgKHByID09IG51bGwpIHtcclxuICAgICAgc2QgPSBwciA9IEN0b3IucHJlY2lzaW9uO1xyXG4gICAgICBybSA9IEN0b3Iucm91bmRpbmc7XHJcbiAgICB9IGVsc2UgaWYgKGRwKSB7XHJcbiAgICAgIHNkID0gcHIgKyAoeC5lIC0geS5lKSArIDE7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBzZCA9IHByO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChzZCA8IDApIHtcclxuICAgICAgcWQucHVzaCgxKTtcclxuICAgICAgbW9yZSA9IHRydWU7XHJcbiAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgLy8gQ29udmVydCBwcmVjaXNpb24gaW4gbnVtYmVyIG9mIGJhc2UgMTAgZGlnaXRzIHRvIGJhc2UgMWU3IGRpZ2l0cy5cclxuICAgICAgc2QgPSBzZCAvIGxvZ0Jhc2UgKyAyIHwgMDtcclxuICAgICAgaSA9IDA7XHJcblxyXG4gICAgICAvLyBkaXZpc29yIDwgMWU3XHJcbiAgICAgIGlmICh5TCA9PSAxKSB7XHJcbiAgICAgICAgayA9IDA7XHJcbiAgICAgICAgeWQgPSB5ZFswXTtcclxuICAgICAgICBzZCsrO1xyXG5cclxuICAgICAgICAvLyBrIGlzIHRoZSBjYXJyeS5cclxuICAgICAgICBmb3IgKDsgKGkgPCB4TCB8fCBrKSAmJiBzZC0tOyBpKyspIHtcclxuICAgICAgICAgIHQgPSBrICogYmFzZSArICh4ZFtpXSB8fCAwKTtcclxuICAgICAgICAgIHFkW2ldID0gdCAvIHlkIHwgMDtcclxuICAgICAgICAgIGsgPSB0ICUgeWQgfCAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbW9yZSA9IGsgfHwgaSA8IHhMO1xyXG5cclxuICAgICAgLy8gZGl2aXNvciA+PSAxZTdcclxuICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgLy8gTm9ybWFsaXNlIHhkIGFuZCB5ZCBzbyBoaWdoZXN0IG9yZGVyIGRpZ2l0IG9mIHlkIGlzID49IGJhc2UvMlxyXG4gICAgICAgIGsgPSBiYXNlIC8gKHlkWzBdICsgMSkgfCAwO1xyXG5cclxuICAgICAgICBpZiAoayA+IDEpIHtcclxuICAgICAgICAgIHlkID0gbXVsdGlwbHlJbnRlZ2VyKHlkLCBrLCBiYXNlKTtcclxuICAgICAgICAgIHhkID0gbXVsdGlwbHlJbnRlZ2VyKHhkLCBrLCBiYXNlKTtcclxuICAgICAgICAgIHlMID0geWQubGVuZ3RoO1xyXG4gICAgICAgICAgeEwgPSB4ZC5sZW5ndGg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB4aSA9IHlMO1xyXG4gICAgICAgIHJlbSA9IHhkLnNsaWNlKDAsIHlMKTtcclxuICAgICAgICByZW1MID0gcmVtLmxlbmd0aDtcclxuXHJcbiAgICAgICAgLy8gQWRkIHplcm9zIHRvIG1ha2UgcmVtYWluZGVyIGFzIGxvbmcgYXMgZGl2aXNvci5cclxuICAgICAgICBmb3IgKDsgcmVtTCA8IHlMOykgcmVtW3JlbUwrK10gPSAwO1xyXG5cclxuICAgICAgICB5eiA9IHlkLnNsaWNlKCk7XHJcbiAgICAgICAgeXoudW5zaGlmdCgwKTtcclxuICAgICAgICB5ZDAgPSB5ZFswXTtcclxuXHJcbiAgICAgICAgaWYgKHlkWzFdID49IGJhc2UgLyAyKSArK3lkMDtcclxuXHJcbiAgICAgICAgZG8ge1xyXG4gICAgICAgICAgayA9IDA7XHJcblxyXG4gICAgICAgICAgLy8gQ29tcGFyZSBkaXZpc29yIGFuZCByZW1haW5kZXIuXHJcbiAgICAgICAgICBjbXAgPSBjb21wYXJlKHlkLCByZW0sIHlMLCByZW1MKTtcclxuXHJcbiAgICAgICAgICAvLyBJZiBkaXZpc29yIDwgcmVtYWluZGVyLlxyXG4gICAgICAgICAgaWYgKGNtcCA8IDApIHtcclxuXHJcbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSB0cmlhbCBkaWdpdCwgay5cclxuICAgICAgICAgICAgcmVtMCA9IHJlbVswXTtcclxuICAgICAgICAgICAgaWYgKHlMICE9IHJlbUwpIHJlbTAgPSByZW0wICogYmFzZSArIChyZW1bMV0gfHwgMCk7XHJcblxyXG4gICAgICAgICAgICAvLyBrIHdpbGwgYmUgaG93IG1hbnkgdGltZXMgdGhlIGRpdmlzb3IgZ29lcyBpbnRvIHRoZSBjdXJyZW50IHJlbWFpbmRlci5cclxuICAgICAgICAgICAgayA9IHJlbTAgLyB5ZDAgfCAwO1xyXG5cclxuICAgICAgICAgICAgLy8gIEFsZ29yaXRobTpcclxuICAgICAgICAgICAgLy8gIDEuIHByb2R1Y3QgPSBkaXZpc29yICogdHJpYWwgZGlnaXQgKGspXHJcbiAgICAgICAgICAgIC8vICAyLiBpZiBwcm9kdWN0ID4gcmVtYWluZGVyOiBwcm9kdWN0IC09IGRpdmlzb3IsIGstLVxyXG4gICAgICAgICAgICAvLyAgMy4gcmVtYWluZGVyIC09IHByb2R1Y3RcclxuICAgICAgICAgICAgLy8gIDQuIGlmIHByb2R1Y3Qgd2FzIDwgcmVtYWluZGVyIGF0IDI6XHJcbiAgICAgICAgICAgIC8vICAgIDUuIGNvbXBhcmUgbmV3IHJlbWFpbmRlciBhbmQgZGl2aXNvclxyXG4gICAgICAgICAgICAvLyAgICA2LiBJZiByZW1haW5kZXIgPiBkaXZpc29yOiByZW1haW5kZXIgLT0gZGl2aXNvciwgaysrXHJcblxyXG4gICAgICAgICAgICBpZiAoayA+IDEpIHtcclxuICAgICAgICAgICAgICBpZiAoayA+PSBiYXNlKSBrID0gYmFzZSAtIDE7XHJcblxyXG4gICAgICAgICAgICAgIC8vIHByb2R1Y3QgPSBkaXZpc29yICogdHJpYWwgZGlnaXQuXHJcbiAgICAgICAgICAgICAgcHJvZCA9IG11bHRpcGx5SW50ZWdlcih5ZCwgaywgYmFzZSk7XHJcbiAgICAgICAgICAgICAgcHJvZEwgPSBwcm9kLmxlbmd0aDtcclxuICAgICAgICAgICAgICByZW1MID0gcmVtLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgICAgLy8gQ29tcGFyZSBwcm9kdWN0IGFuZCByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgY21wID0gY29tcGFyZShwcm9kLCByZW0sIHByb2RMLCByZW1MKTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gcHJvZHVjdCA+IHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICBpZiAoY21wID09IDEpIHtcclxuICAgICAgICAgICAgICAgIGstLTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBTdWJ0cmFjdCBkaXZpc29yIGZyb20gcHJvZHVjdC5cclxuICAgICAgICAgICAgICAgIHN1YnRyYWN0KHByb2QsIHlMIDwgcHJvZEwgPyB5eiA6IHlkLCBwcm9kTCwgYmFzZSk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAvLyBjbXAgaXMgLTEuXHJcbiAgICAgICAgICAgICAgLy8gSWYgayBpcyAwLCB0aGVyZSBpcyBubyBuZWVkIHRvIGNvbXBhcmUgeWQgYW5kIHJlbSBhZ2FpbiBiZWxvdywgc28gY2hhbmdlIGNtcCB0byAxXHJcbiAgICAgICAgICAgICAgLy8gdG8gYXZvaWQgaXQuIElmIGsgaXMgMSB0aGVyZSBpcyBhIG5lZWQgdG8gY29tcGFyZSB5ZCBhbmQgcmVtIGFnYWluIGJlbG93LlxyXG4gICAgICAgICAgICAgIGlmIChrID09IDApIGNtcCA9IGsgPSAxO1xyXG4gICAgICAgICAgICAgIHByb2QgPSB5ZC5zbGljZSgpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBwcm9kTCA9IHByb2QubGVuZ3RoO1xyXG4gICAgICAgICAgICBpZiAocHJvZEwgPCByZW1MKSBwcm9kLnVuc2hpZnQoMCk7XHJcblxyXG4gICAgICAgICAgICAvLyBTdWJ0cmFjdCBwcm9kdWN0IGZyb20gcmVtYWluZGVyLlxyXG4gICAgICAgICAgICBzdWJ0cmFjdChyZW0sIHByb2QsIHJlbUwsIGJhc2UpO1xyXG5cclxuICAgICAgICAgICAgLy8gSWYgcHJvZHVjdCB3YXMgPCBwcmV2aW91cyByZW1haW5kZXIuXHJcbiAgICAgICAgICAgIGlmIChjbXAgPT0gLTEpIHtcclxuICAgICAgICAgICAgICByZW1MID0gcmVtLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgICAgLy8gQ29tcGFyZSBkaXZpc29yIGFuZCBuZXcgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgIGNtcCA9IGNvbXBhcmUoeWQsIHJlbSwgeUwsIHJlbUwpO1xyXG5cclxuICAgICAgICAgICAgICAvLyBJZiBkaXZpc29yIDwgbmV3IHJlbWFpbmRlciwgc3VidHJhY3QgZGl2aXNvciBmcm9tIHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICBpZiAoY21wIDwgMSkge1xyXG4gICAgICAgICAgICAgICAgaysrO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFN1YnRyYWN0IGRpdmlzb3IgZnJvbSByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgICBzdWJ0cmFjdChyZW0sIHlMIDwgcmVtTCA/IHl6IDogeWQsIHJlbUwsIGJhc2UpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmVtTCA9IHJlbS5sZW5ndGg7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKGNtcCA9PT0gMCkge1xyXG4gICAgICAgICAgICBrKys7XHJcbiAgICAgICAgICAgIHJlbSA9IFswXTtcclxuICAgICAgICAgIH0gICAgLy8gaWYgY21wID09PSAxLCBrIHdpbGwgYmUgMFxyXG5cclxuICAgICAgICAgIC8vIEFkZCB0aGUgbmV4dCBkaWdpdCwgaywgdG8gdGhlIHJlc3VsdCBhcnJheS5cclxuICAgICAgICAgIHFkW2krK10gPSBrO1xyXG5cclxuICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgcmVtYWluZGVyLlxyXG4gICAgICAgICAgaWYgKGNtcCAmJiByZW1bMF0pIHtcclxuICAgICAgICAgICAgcmVtW3JlbUwrK10gPSB4ZFt4aV0gfHwgMDtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJlbSA9IFt4ZFt4aV1dO1xyXG4gICAgICAgICAgICByZW1MID0gMTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfSB3aGlsZSAoKHhpKysgPCB4TCB8fCByZW1bMF0gIT09IHZvaWQgMCkgJiYgc2QtLSk7XHJcblxyXG4gICAgICAgIG1vcmUgPSByZW1bMF0gIT09IHZvaWQgMDtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gTGVhZGluZyB6ZXJvP1xyXG4gICAgICBpZiAoIXFkWzBdKSBxZC5zaGlmdCgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGxvZ0Jhc2UgaXMgMSB3aGVuIGRpdmlkZSBpcyBiZWluZyB1c2VkIGZvciBiYXNlIGNvbnZlcnNpb24uXHJcbiAgICBpZiAobG9nQmFzZSA9PSAxKSB7XHJcbiAgICAgIHEuZSA9IGU7XHJcbiAgICAgIGluZXhhY3QgPSBtb3JlO1xyXG4gICAgfSBlbHNlIHtcclxuXHJcbiAgICAgIC8vIFRvIGNhbGN1bGF0ZSBxLmUsIGZpcnN0IGdldCB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBvZiBxZFswXS5cclxuICAgICAgZm9yIChpID0gMSwgayA9IHFkWzBdOyBrID49IDEwOyBrIC89IDEwKSBpKys7XHJcbiAgICAgIHEuZSA9IGkgKyBlICogbG9nQmFzZSAtIDE7XHJcblxyXG4gICAgICBmaW5hbGlzZShxLCBkcCA/IHByICsgcS5lICsgMSA6IHByLCBybSwgbW9yZSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHE7XHJcbiAgfTtcclxufSkoKTtcclxuXHJcblxyXG4vKlxyXG4gKiBSb3VuZCBgeGAgdG8gYHNkYCBzaWduaWZpY2FudCBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSBgcm1gLlxyXG4gKiBDaGVjayBmb3Igb3Zlci91bmRlci1mbG93LlxyXG4gKi9cclxuIGZ1bmN0aW9uIGZpbmFsaXNlKHgsIHNkLCBybSwgaXNUcnVuY2F0ZWQpIHtcclxuICB2YXIgZGlnaXRzLCBpLCBqLCBrLCByZCwgcm91bmRVcCwgdywgeGQsIHhkaSxcclxuICAgIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xyXG5cclxuICAvLyBEb24ndCByb3VuZCBpZiBzZCBpcyBudWxsIG9yIHVuZGVmaW5lZC5cclxuICBvdXQ6IGlmIChzZCAhPSBudWxsKSB7XHJcbiAgICB4ZCA9IHguZDtcclxuXHJcbiAgICAvLyBJbmZpbml0eS9OYU4uXHJcbiAgICBpZiAoIXhkKSByZXR1cm4geDtcclxuXHJcbiAgICAvLyByZDogdGhlIHJvdW5kaW5nIGRpZ2l0LCBpLmUuIHRoZSBkaWdpdCBhZnRlciB0aGUgZGlnaXQgdGhhdCBtYXkgYmUgcm91bmRlZCB1cC5cclxuICAgIC8vIHc6IHRoZSB3b3JkIG9mIHhkIGNvbnRhaW5pbmcgcmQsIGEgYmFzZSAxZTcgbnVtYmVyLlxyXG4gICAgLy8geGRpOiB0aGUgaW5kZXggb2YgdyB3aXRoaW4geGQuXHJcbiAgICAvLyBkaWdpdHM6IHRoZSBudW1iZXIgb2YgZGlnaXRzIG9mIHcuXHJcbiAgICAvLyBpOiB3aGF0IHdvdWxkIGJlIHRoZSBpbmRleCBvZiByZCB3aXRoaW4gdyBpZiBhbGwgdGhlIG51bWJlcnMgd2VyZSA3IGRpZ2l0cyBsb25nIChpLmUuIGlmXHJcbiAgICAvLyB0aGV5IGhhZCBsZWFkaW5nIHplcm9zKVxyXG4gICAgLy8gajogaWYgPiAwLCB0aGUgYWN0dWFsIGluZGV4IG9mIHJkIHdpdGhpbiB3IChpZiA8IDAsIHJkIGlzIGEgbGVhZGluZyB6ZXJvKS5cclxuXHJcbiAgICAvLyBHZXQgdGhlIGxlbmd0aCBvZiB0aGUgZmlyc3Qgd29yZCBvZiB0aGUgZGlnaXRzIGFycmF5IHhkLlxyXG4gICAgZm9yIChkaWdpdHMgPSAxLCBrID0geGRbMF07IGsgPj0gMTA7IGsgLz0gMTApIGRpZ2l0cysrO1xyXG4gICAgaSA9IHNkIC0gZGlnaXRzO1xyXG5cclxuICAgIC8vIElzIHRoZSByb3VuZGluZyBkaWdpdCBpbiB0aGUgZmlyc3Qgd29yZCBvZiB4ZD9cclxuICAgIGlmIChpIDwgMCkge1xyXG4gICAgICBpICs9IExPR19CQVNFO1xyXG4gICAgICBqID0gc2Q7XHJcbiAgICAgIHcgPSB4ZFt4ZGkgPSAwXTtcclxuXHJcbiAgICAgIC8vIEdldCB0aGUgcm91bmRpbmcgZGlnaXQgYXQgaW5kZXggaiBvZiB3LlxyXG4gICAgICByZCA9IHcgLyBtYXRocG93KDEwLCBkaWdpdHMgLSBqIC0gMSkgJSAxMCB8IDA7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB4ZGkgPSBNYXRoLmNlaWwoKGkgKyAxKSAvIExPR19CQVNFKTtcclxuICAgICAgayA9IHhkLmxlbmd0aDtcclxuICAgICAgaWYgKHhkaSA+PSBrKSB7XHJcbiAgICAgICAgaWYgKGlzVHJ1bmNhdGVkKSB7XHJcblxyXG4gICAgICAgICAgLy8gTmVlZGVkIGJ5IGBuYXR1cmFsRXhwb25lbnRpYWxgLCBgbmF0dXJhbExvZ2FyaXRobWAgYW5kIGBzcXVhcmVSb290YC5cclxuICAgICAgICAgIGZvciAoOyBrKysgPD0geGRpOykgeGQucHVzaCgwKTtcclxuICAgICAgICAgIHcgPSByZCA9IDA7XHJcbiAgICAgICAgICBkaWdpdHMgPSAxO1xyXG4gICAgICAgICAgaSAlPSBMT0dfQkFTRTtcclxuICAgICAgICAgIGogPSBpIC0gTE9HX0JBU0UgKyAxO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBicmVhayBvdXQ7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHcgPSBrID0geGRbeGRpXTtcclxuXHJcbiAgICAgICAgLy8gR2V0IHRoZSBudW1iZXIgb2YgZGlnaXRzIG9mIHcuXHJcbiAgICAgICAgZm9yIChkaWdpdHMgPSAxOyBrID49IDEwOyBrIC89IDEwKSBkaWdpdHMrKztcclxuXHJcbiAgICAgICAgLy8gR2V0IHRoZSBpbmRleCBvZiByZCB3aXRoaW4gdy5cclxuICAgICAgICBpICU9IExPR19CQVNFO1xyXG5cclxuICAgICAgICAvLyBHZXQgdGhlIGluZGV4IG9mIHJkIHdpdGhpbiB3LCBhZGp1c3RlZCBmb3IgbGVhZGluZyB6ZXJvcy5cclxuICAgICAgICAvLyBUaGUgbnVtYmVyIG9mIGxlYWRpbmcgemVyb3Mgb2YgdyBpcyBnaXZlbiBieSBMT0dfQkFTRSAtIGRpZ2l0cy5cclxuICAgICAgICBqID0gaSAtIExPR19CQVNFICsgZGlnaXRzO1xyXG5cclxuICAgICAgICAvLyBHZXQgdGhlIHJvdW5kaW5nIGRpZ2l0IGF0IGluZGV4IGogb2Ygdy5cclxuICAgICAgICByZCA9IGogPCAwID8gMCA6IHcgLyBtYXRocG93KDEwLCBkaWdpdHMgLSBqIC0gMSkgJSAxMCB8IDA7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBBcmUgdGhlcmUgYW55IG5vbi16ZXJvIGRpZ2l0cyBhZnRlciB0aGUgcm91bmRpbmcgZGlnaXQ/XHJcbiAgICBpc1RydW5jYXRlZCA9IGlzVHJ1bmNhdGVkIHx8IHNkIDwgMCB8fFxyXG4gICAgICB4ZFt4ZGkgKyAxXSAhPT0gdm9pZCAwIHx8IChqIDwgMCA/IHcgOiB3ICUgbWF0aHBvdygxMCwgZGlnaXRzIC0gaiAtIDEpKTtcclxuXHJcbiAgICAvLyBUaGUgZXhwcmVzc2lvbiBgdyAlIG1hdGhwb3coMTAsIGRpZ2l0cyAtIGogLSAxKWAgcmV0dXJucyBhbGwgdGhlIGRpZ2l0cyBvZiB3IHRvIHRoZSByaWdodFxyXG4gICAgLy8gb2YgdGhlIGRpZ2l0IGF0IChsZWZ0LXRvLXJpZ2h0KSBpbmRleCBqLCBlLmcuIGlmIHcgaXMgOTA4NzE0IGFuZCBqIGlzIDIsIHRoZSBleHByZXNzaW9uXHJcbiAgICAvLyB3aWxsIGdpdmUgNzE0LlxyXG5cclxuICAgIHJvdW5kVXAgPSBybSA8IDRcclxuICAgICAgPyAocmQgfHwgaXNUcnVuY2F0ZWQpICYmIChybSA9PSAwIHx8IHJtID09ICh4LnMgPCAwID8gMyA6IDIpKVxyXG4gICAgICA6IHJkID4gNSB8fCByZCA9PSA1ICYmIChybSA9PSA0IHx8IGlzVHJ1bmNhdGVkIHx8IHJtID09IDYgJiZcclxuXHJcbiAgICAgICAgLy8gQ2hlY2sgd2hldGhlciB0aGUgZGlnaXQgdG8gdGhlIGxlZnQgb2YgdGhlIHJvdW5kaW5nIGRpZ2l0IGlzIG9kZC5cclxuICAgICAgICAoKGkgPiAwID8gaiA+IDAgPyB3IC8gbWF0aHBvdygxMCwgZGlnaXRzIC0gaikgOiAwIDogeGRbeGRpIC0gMV0pICUgMTApICYgMSB8fFxyXG4gICAgICAgICAgcm0gPT0gKHgucyA8IDAgPyA4IDogNykpO1xyXG5cclxuICAgIGlmIChzZCA8IDEgfHwgIXhkWzBdKSB7XHJcbiAgICAgIHhkLmxlbmd0aCA9IDA7XHJcbiAgICAgIGlmIChyb3VuZFVwKSB7XHJcblxyXG4gICAgICAgIC8vIENvbnZlcnQgc2QgdG8gZGVjaW1hbCBwbGFjZXMuXHJcbiAgICAgICAgc2QgLT0geC5lICsgMTtcclxuXHJcbiAgICAgICAgLy8gMSwgMC4xLCAwLjAxLCAwLjAwMSwgMC4wMDAxIGV0Yy5cclxuICAgICAgICB4ZFswXSA9IG1hdGhwb3coMTAsIChMT0dfQkFTRSAtIHNkICUgTE9HX0JBU0UpICUgTE9HX0JBU0UpO1xyXG4gICAgICAgIHguZSA9IC1zZCB8fCAwO1xyXG4gICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAvLyBaZXJvLlxyXG4gICAgICAgIHhkWzBdID0geC5lID0gMDtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHg7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUmVtb3ZlIGV4Y2VzcyBkaWdpdHMuXHJcbiAgICBpZiAoaSA9PSAwKSB7XHJcbiAgICAgIHhkLmxlbmd0aCA9IHhkaTtcclxuICAgICAgayA9IDE7XHJcbiAgICAgIHhkaS0tO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgeGQubGVuZ3RoID0geGRpICsgMTtcclxuICAgICAgayA9IG1hdGhwb3coMTAsIExPR19CQVNFIC0gaSk7XHJcblxyXG4gICAgICAvLyBFLmcuIDU2NzAwIGJlY29tZXMgNTYwMDAgaWYgNyBpcyB0aGUgcm91bmRpbmcgZGlnaXQuXHJcbiAgICAgIC8vIGogPiAwIG1lYW5zIGkgPiBudW1iZXIgb2YgbGVhZGluZyB6ZXJvcyBvZiB3LlxyXG4gICAgICB4ZFt4ZGldID0gaiA+IDAgPyAodyAvIG1hdGhwb3coMTAsIGRpZ2l0cyAtIGopICUgbWF0aHBvdygxMCwgaikgfCAwKSAqIGsgOiAwO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChyb3VuZFVwKSB7XHJcbiAgICAgIGZvciAoOzspIHtcclxuXHJcbiAgICAgICAgLy8gSXMgdGhlIGRpZ2l0IHRvIGJlIHJvdW5kZWQgdXAgaW4gdGhlIGZpcnN0IHdvcmQgb2YgeGQ/XHJcbiAgICAgICAgaWYgKHhkaSA9PSAwKSB7XHJcblxyXG4gICAgICAgICAgLy8gaSB3aWxsIGJlIHRoZSBsZW5ndGggb2YgeGRbMF0gYmVmb3JlIGsgaXMgYWRkZWQuXHJcbiAgICAgICAgICBmb3IgKGkgPSAxLCBqID0geGRbMF07IGogPj0gMTA7IGogLz0gMTApIGkrKztcclxuICAgICAgICAgIGogPSB4ZFswXSArPSBrO1xyXG4gICAgICAgICAgZm9yIChrID0gMTsgaiA+PSAxMDsgaiAvPSAxMCkgaysrO1xyXG5cclxuICAgICAgICAgIC8vIGlmIGkgIT0gayB0aGUgbGVuZ3RoIGhhcyBpbmNyZWFzZWQuXHJcbiAgICAgICAgICBpZiAoaSAhPSBrKSB7XHJcbiAgICAgICAgICAgIHguZSsrO1xyXG4gICAgICAgICAgICBpZiAoeGRbMF0gPT0gQkFTRSkgeGRbMF0gPSAxO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB4ZFt4ZGldICs9IGs7XHJcbiAgICAgICAgICBpZiAoeGRbeGRpXSAhPSBCQVNFKSBicmVhaztcclxuICAgICAgICAgIHhkW3hkaS0tXSA9IDA7XHJcbiAgICAgICAgICBrID0gMTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBSZW1vdmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgICBmb3IgKGkgPSB4ZC5sZW5ndGg7IHhkWy0taV0gPT09IDA7KSB4ZC5wb3AoKTtcclxuICB9XHJcblxyXG4gIGlmIChleHRlcm5hbCkge1xyXG5cclxuICAgIC8vIE92ZXJmbG93P1xyXG4gICAgaWYgKHguZSA+IEN0b3IubWF4RSkge1xyXG5cclxuICAgICAgLy8gSW5maW5pdHkuXHJcbiAgICAgIHguZCA9IG51bGw7XHJcbiAgICAgIHguZSA9IE5hTjtcclxuXHJcbiAgICAvLyBVbmRlcmZsb3c/XHJcbiAgICB9IGVsc2UgaWYgKHguZSA8IEN0b3IubWluRSkge1xyXG5cclxuICAgICAgLy8gWmVyby5cclxuICAgICAgeC5lID0gMDtcclxuICAgICAgeC5kID0gWzBdO1xyXG4gICAgICAvLyBDdG9yLnVuZGVyZmxvdyA9IHRydWU7XHJcbiAgICB9IC8vIGVsc2UgQ3Rvci51bmRlcmZsb3cgPSBmYWxzZTtcclxuICB9XHJcblxyXG4gIHJldHVybiB4O1xyXG59XHJcblxyXG5cclxuZnVuY3Rpb24gZmluaXRlVG9TdHJpbmcoeCwgaXNFeHAsIHNkKSB7XHJcbiAgaWYgKCF4LmlzRmluaXRlKCkpIHJldHVybiBub25GaW5pdGVUb1N0cmluZyh4KTtcclxuICB2YXIgayxcclxuICAgIGUgPSB4LmUsXHJcbiAgICBzdHIgPSBkaWdpdHNUb1N0cmluZyh4LmQpLFxyXG4gICAgbGVuID0gc3RyLmxlbmd0aDtcclxuXHJcbiAgaWYgKGlzRXhwKSB7XHJcbiAgICBpZiAoc2QgJiYgKGsgPSBzZCAtIGxlbikgPiAwKSB7XHJcbiAgICAgIHN0ciA9IHN0ci5jaGFyQXQoMCkgKyAnLicgKyBzdHIuc2xpY2UoMSkgKyBnZXRaZXJvU3RyaW5nKGspO1xyXG4gICAgfSBlbHNlIGlmIChsZW4gPiAxKSB7XHJcbiAgICAgIHN0ciA9IHN0ci5jaGFyQXQoMCkgKyAnLicgKyBzdHIuc2xpY2UoMSk7XHJcbiAgICB9XHJcblxyXG4gICAgc3RyID0gc3RyICsgKHguZSA8IDAgPyAnZScgOiAnZSsnKSArIHguZTtcclxuICB9IGVsc2UgaWYgKGUgPCAwKSB7XHJcbiAgICBzdHIgPSAnMC4nICsgZ2V0WmVyb1N0cmluZygtZSAtIDEpICsgc3RyO1xyXG4gICAgaWYgKHNkICYmIChrID0gc2QgLSBsZW4pID4gMCkgc3RyICs9IGdldFplcm9TdHJpbmcoayk7XHJcbiAgfSBlbHNlIGlmIChlID49IGxlbikge1xyXG4gICAgc3RyICs9IGdldFplcm9TdHJpbmcoZSArIDEgLSBsZW4pO1xyXG4gICAgaWYgKHNkICYmIChrID0gc2QgLSBlIC0gMSkgPiAwKSBzdHIgPSBzdHIgKyAnLicgKyBnZXRaZXJvU3RyaW5nKGspO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBpZiAoKGsgPSBlICsgMSkgPCBsZW4pIHN0ciA9IHN0ci5zbGljZSgwLCBrKSArICcuJyArIHN0ci5zbGljZShrKTtcclxuICAgIGlmIChzZCAmJiAoayA9IHNkIC0gbGVuKSA+IDApIHtcclxuICAgICAgaWYgKGUgKyAxID09PSBsZW4pIHN0ciArPSAnLic7XHJcbiAgICAgIHN0ciArPSBnZXRaZXJvU3RyaW5nKGspO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHN0cjtcclxufVxyXG5cclxuXHJcbi8vIENhbGN1bGF0ZSB0aGUgYmFzZSAxMCBleHBvbmVudCBmcm9tIHRoZSBiYXNlIDFlNyBleHBvbmVudC5cclxuZnVuY3Rpb24gZ2V0QmFzZTEwRXhwb25lbnQoZGlnaXRzLCBlKSB7XHJcbiAgdmFyIHcgPSBkaWdpdHNbMF07XHJcblxyXG4gIC8vIEFkZCB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBvZiB0aGUgZmlyc3Qgd29yZCBvZiB0aGUgZGlnaXRzIGFycmF5LlxyXG4gIGZvciAoIGUgKj0gTE9HX0JBU0U7IHcgPj0gMTA7IHcgLz0gMTApIGUrKztcclxuICByZXR1cm4gZTtcclxufVxyXG5cclxuXHJcbmZ1bmN0aW9uIGdldExuMTAoQ3Rvciwgc2QsIHByKSB7XHJcbiAgaWYgKHNkID4gTE4xMF9QUkVDSVNJT04pIHtcclxuXHJcbiAgICAvLyBSZXNldCBnbG9iYWwgc3RhdGUgaW4gY2FzZSB0aGUgZXhjZXB0aW9uIGlzIGNhdWdodC5cclxuICAgIGV4dGVybmFsID0gdHJ1ZTtcclxuICAgIGlmIChwcikgQ3Rvci5wcmVjaXNpb24gPSBwcjtcclxuICAgIHRocm93IEVycm9yKHByZWNpc2lvbkxpbWl0RXhjZWVkZWQpO1xyXG4gIH1cclxuICByZXR1cm4gZmluYWxpc2UobmV3IEN0b3IoTE4xMCksIHNkLCAxLCB0cnVlKTtcclxufVxyXG5cclxuXHJcbmZ1bmN0aW9uIGdldFBpKEN0b3IsIHNkLCBybSkge1xyXG4gIGlmIChzZCA+IFBJX1BSRUNJU0lPTikgdGhyb3cgRXJyb3IocHJlY2lzaW9uTGltaXRFeGNlZWRlZCk7XHJcbiAgcmV0dXJuIGZpbmFsaXNlKG5ldyBDdG9yKFBJKSwgc2QsIHJtLCB0cnVlKTtcclxufVxyXG5cclxuXHJcbmZ1bmN0aW9uIGdldFByZWNpc2lvbihkaWdpdHMpIHtcclxuICB2YXIgdyA9IGRpZ2l0cy5sZW5ndGggLSAxLFxyXG4gICAgbGVuID0gdyAqIExPR19CQVNFICsgMTtcclxuXHJcbiAgdyA9IGRpZ2l0c1t3XTtcclxuXHJcbiAgLy8gSWYgbm9uLXplcm8uLi5cclxuICBpZiAodykge1xyXG5cclxuICAgIC8vIFN1YnRyYWN0IHRoZSBudW1iZXIgb2YgdHJhaWxpbmcgemVyb3Mgb2YgdGhlIGxhc3Qgd29yZC5cclxuICAgIGZvciAoOyB3ICUgMTAgPT0gMDsgdyAvPSAxMCkgbGVuLS07XHJcblxyXG4gICAgLy8gQWRkIHRoZSBudW1iZXIgb2YgZGlnaXRzIG9mIHRoZSBmaXJzdCB3b3JkLlxyXG4gICAgZm9yICh3ID0gZGlnaXRzWzBdOyB3ID49IDEwOyB3IC89IDEwKSBsZW4rKztcclxuICB9XHJcblxyXG4gIHJldHVybiBsZW47XHJcbn1cclxuXHJcblxyXG5mdW5jdGlvbiBnZXRaZXJvU3RyaW5nKGspIHtcclxuICB2YXIgenMgPSAnJztcclxuICBmb3IgKDsgay0tOykgenMgKz0gJzAnO1xyXG4gIHJldHVybiB6cztcclxufVxyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiBEZWNpbWFsIGB4YCB0byB0aGUgcG93ZXIgYG5gLCB3aGVyZSBgbmAgaXMgYW5cclxuICogaW50ZWdlciBvZiB0eXBlIG51bWJlci5cclxuICpcclxuICogSW1wbGVtZW50cyAnZXhwb25lbnRpYXRpb24gYnkgc3F1YXJpbmcnLiBDYWxsZWQgYnkgYHBvd2AgYW5kIGBwYXJzZU90aGVyYC5cclxuICpcclxuICovXHJcbmZ1bmN0aW9uIGludFBvdyhDdG9yLCB4LCBuLCBwcikge1xyXG4gIHZhciBpc1RydW5jYXRlZCxcclxuICAgIHIgPSBuZXcgQ3RvcigxKSxcclxuXHJcbiAgICAvLyBNYXggbiBvZiA5MDA3MTk5MjU0NzQwOTkxIHRha2VzIDUzIGxvb3AgaXRlcmF0aW9ucy5cclxuICAgIC8vIE1heGltdW0gZGlnaXRzIGFycmF5IGxlbmd0aDsgbGVhdmVzIFsyOCwgMzRdIGd1YXJkIGRpZ2l0cy5cclxuICAgIGsgPSBNYXRoLmNlaWwocHIgLyBMT0dfQkFTRSArIDQpO1xyXG5cclxuICBleHRlcm5hbCA9IGZhbHNlO1xyXG5cclxuICBmb3IgKDs7KSB7XHJcbiAgICBpZiAobiAlIDIpIHtcclxuICAgICAgciA9IHIudGltZXMoeCk7XHJcbiAgICAgIGlmICh0cnVuY2F0ZShyLmQsIGspKSBpc1RydW5jYXRlZCA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgbiA9IG1hdGhmbG9vcihuIC8gMik7XHJcbiAgICBpZiAobiA9PT0gMCkge1xyXG5cclxuICAgICAgLy8gVG8gZW5zdXJlIGNvcnJlY3Qgcm91bmRpbmcgd2hlbiByLmQgaXMgdHJ1bmNhdGVkLCBpbmNyZW1lbnQgdGhlIGxhc3Qgd29yZCBpZiBpdCBpcyB6ZXJvLlxyXG4gICAgICBuID0gci5kLmxlbmd0aCAtIDE7XHJcbiAgICAgIGlmIChpc1RydW5jYXRlZCAmJiByLmRbbl0gPT09IDApICsrci5kW25dO1xyXG4gICAgICBicmVhaztcclxuICAgIH1cclxuXHJcbiAgICB4ID0geC50aW1lcyh4KTtcclxuICAgIHRydW5jYXRlKHguZCwgayk7XHJcbiAgfVxyXG5cclxuICBleHRlcm5hbCA9IHRydWU7XHJcblxyXG4gIHJldHVybiByO1xyXG59XHJcblxyXG5cclxuZnVuY3Rpb24gaXNPZGQobikge1xyXG4gIHJldHVybiBuLmRbbi5kLmxlbmd0aCAtIDFdICYgMTtcclxufVxyXG5cclxuXHJcbi8qXHJcbiAqIEhhbmRsZSBgbWF4YCBhbmQgYG1pbmAuIGBsdGd0YCBpcyAnbHQnIG9yICdndCcuXHJcbiAqL1xyXG5mdW5jdGlvbiBtYXhPck1pbihDdG9yLCBhcmdzLCBsdGd0KSB7XHJcbiAgdmFyIHksXHJcbiAgICB4ID0gbmV3IEN0b3IoYXJnc1swXSksXHJcbiAgICBpID0gMDtcclxuXHJcbiAgZm9yICg7ICsraSA8IGFyZ3MubGVuZ3RoOykge1xyXG4gICAgeSA9IG5ldyBDdG9yKGFyZ3NbaV0pO1xyXG4gICAgaWYgKCF5LnMpIHtcclxuICAgICAgeCA9IHk7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgfSBlbHNlIGlmICh4W2x0Z3RdKHkpKSB7XHJcbiAgICAgIHggPSB5O1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHg7XHJcbn1cclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgbmF0dXJhbCBleHBvbmVudGlhbCBvZiBgeGAgcm91bmRlZCB0byBgc2RgIHNpZ25pZmljYW50XHJcbiAqIGRpZ2l0cy5cclxuICpcclxuICogVGF5bG9yL01hY2xhdXJpbiBzZXJpZXMuXHJcbiAqXHJcbiAqIGV4cCh4KSA9IHheMC8wISArIHheMS8xISArIHheMi8yISArIHheMy8zISArIC4uLlxyXG4gKlxyXG4gKiBBcmd1bWVudCByZWR1Y3Rpb246XHJcbiAqICAgUmVwZWF0IHggPSB4IC8gMzIsIGsgKz0gNSwgdW50aWwgfHh8IDwgMC4xXHJcbiAqICAgZXhwKHgpID0gZXhwKHggLyAyXmspXigyXmspXHJcbiAqXHJcbiAqIFByZXZpb3VzbHksIHRoZSBhcmd1bWVudCB3YXMgaW5pdGlhbGx5IHJlZHVjZWQgYnlcclxuICogZXhwKHgpID0gZXhwKHIpICogMTBeayAgd2hlcmUgciA9IHggLSBrICogbG4xMCwgayA9IGZsb29yKHggLyBsbjEwKVxyXG4gKiB0byBmaXJzdCBwdXQgciBpbiB0aGUgcmFuZ2UgWzAsIGxuMTBdLCBiZWZvcmUgZGl2aWRpbmcgYnkgMzIgdW50aWwgfHh8IDwgMC4xLCBidXQgdGhpcyB3YXNcclxuICogZm91bmQgdG8gYmUgc2xvd2VyIHRoYW4ganVzdCBkaXZpZGluZyByZXBlYXRlZGx5IGJ5IDMyIGFzIGFib3ZlLlxyXG4gKlxyXG4gKiBNYXggaW50ZWdlciBhcmd1bWVudDogZXhwKCcyMDcyMzI2NTgzNjk0NjQxMycpID0gNi4zZSs5MDAwMDAwMDAwMDAwMDAwXHJcbiAqIE1pbiBpbnRlZ2VyIGFyZ3VtZW50OiBleHAoJy0yMDcyMzI2NTgzNjk0NjQxMScpID0gMS4yZS05MDAwMDAwMDAwMDAwMDAwXHJcbiAqIChNYXRoIG9iamVjdCBpbnRlZ2VyIG1pbi9tYXg6IE1hdGguZXhwKDcwOSkgPSA4LjJlKzMwNywgTWF0aC5leHAoLTc0NSkgPSA1ZS0zMjQpXHJcbiAqXHJcbiAqICBleHAoSW5maW5pdHkpICA9IEluZmluaXR5XHJcbiAqICBleHAoLUluZmluaXR5KSA9IDBcclxuICogIGV4cChOYU4pICAgICAgID0gTmFOXHJcbiAqICBleHAowrEwKSAgICAgICAgPSAxXHJcbiAqXHJcbiAqICBleHAoeCkgaXMgbm9uLXRlcm1pbmF0aW5nIGZvciBhbnkgZmluaXRlLCBub24temVybyB4LlxyXG4gKlxyXG4gKiAgVGhlIHJlc3VsdCB3aWxsIGFsd2F5cyBiZSBjb3JyZWN0bHkgcm91bmRlZC5cclxuICpcclxuICovXHJcbmZ1bmN0aW9uIG5hdHVyYWxFeHBvbmVudGlhbCh4LCBzZCkge1xyXG4gIHZhciBkZW5vbWluYXRvciwgZ3VhcmQsIGosIHBvdywgc3VtLCB0LCB3cHIsXHJcbiAgICByZXAgPSAwLFxyXG4gICAgaSA9IDAsXHJcbiAgICBrID0gMCxcclxuICAgIEN0b3IgPSB4LmNvbnN0cnVjdG9yLFxyXG4gICAgcm0gPSBDdG9yLnJvdW5kaW5nLFxyXG4gICAgcHIgPSBDdG9yLnByZWNpc2lvbjtcclxuXHJcbiAgLy8gMC9OYU4vSW5maW5pdHk/XHJcbiAgaWYgKCF4LmQgfHwgIXguZFswXSB8fCB4LmUgPiAxNykge1xyXG5cclxuICAgIHJldHVybiBuZXcgQ3Rvcih4LmRcclxuICAgICAgPyAheC5kWzBdID8gMSA6IHgucyA8IDAgPyAwIDogMSAvIDBcclxuICAgICAgOiB4LnMgPyB4LnMgPCAwID8gMCA6IHggOiAwIC8gMCk7XHJcbiAgfVxyXG5cclxuICBpZiAoc2QgPT0gbnVsbCkge1xyXG4gICAgZXh0ZXJuYWwgPSBmYWxzZTtcclxuICAgIHdwciA9IHByO1xyXG4gIH0gZWxzZSB7XHJcbiAgICB3cHIgPSBzZDtcclxuICB9XHJcblxyXG4gIHQgPSBuZXcgQ3RvcigwLjAzMTI1KTtcclxuXHJcbiAgLy8gd2hpbGUgYWJzKHgpID49IDAuMVxyXG4gIHdoaWxlICh4LmUgPiAtMikge1xyXG5cclxuICAgIC8vIHggPSB4IC8gMl41XHJcbiAgICB4ID0geC50aW1lcyh0KTtcclxuICAgIGsgKz0gNTtcclxuICB9XHJcblxyXG4gIC8vIFVzZSAyICogbG9nMTAoMl5rKSArIDUgKGVtcGlyaWNhbGx5IGRlcml2ZWQpIHRvIGVzdGltYXRlIHRoZSBpbmNyZWFzZSBpbiBwcmVjaXNpb25cclxuICAvLyBuZWNlc3NhcnkgdG8gZW5zdXJlIHRoZSBmaXJzdCA0IHJvdW5kaW5nIGRpZ2l0cyBhcmUgY29ycmVjdC5cclxuICBndWFyZCA9IE1hdGgubG9nKG1hdGhwb3coMiwgaykpIC8gTWF0aC5MTjEwICogMiArIDUgfCAwO1xyXG4gIHdwciArPSBndWFyZDtcclxuICBkZW5vbWluYXRvciA9IHBvdyA9IHN1bSA9IG5ldyBDdG9yKDEpO1xyXG4gIEN0b3IucHJlY2lzaW9uID0gd3ByO1xyXG5cclxuICBmb3IgKDs7KSB7XHJcbiAgICBwb3cgPSBmaW5hbGlzZShwb3cudGltZXMoeCksIHdwciwgMSk7XHJcbiAgICBkZW5vbWluYXRvciA9IGRlbm9taW5hdG9yLnRpbWVzKCsraSk7XHJcbiAgICB0ID0gc3VtLnBsdXMoZGl2aWRlKHBvdywgZGVub21pbmF0b3IsIHdwciwgMSkpO1xyXG5cclxuICAgIGlmIChkaWdpdHNUb1N0cmluZyh0LmQpLnNsaWNlKDAsIHdwcikgPT09IGRpZ2l0c1RvU3RyaW5nKHN1bS5kKS5zbGljZSgwLCB3cHIpKSB7XHJcbiAgICAgIGogPSBrO1xyXG4gICAgICB3aGlsZSAoai0tKSBzdW0gPSBmaW5hbGlzZShzdW0udGltZXMoc3VtKSwgd3ByLCAxKTtcclxuXHJcbiAgICAgIC8vIENoZWNrIHRvIHNlZSBpZiB0aGUgZmlyc3QgNCByb3VuZGluZyBkaWdpdHMgYXJlIFs0OV05OTkuXHJcbiAgICAgIC8vIElmIHNvLCByZXBlYXQgdGhlIHN1bW1hdGlvbiB3aXRoIGEgaGlnaGVyIHByZWNpc2lvbiwgb3RoZXJ3aXNlXHJcbiAgICAgIC8vIGUuZy4gd2l0aCBwcmVjaXNpb246IDE4LCByb3VuZGluZzogMVxyXG4gICAgICAvLyBleHAoMTguNDA0MjcyNDYyNTk1MDM0MDgzNTY3NzkzOTE5ODQzNzYxKSA9IDk4MzcyNTYwLjEyMjk5OTk5OTkgKHNob3VsZCBiZSA5ODM3MjU2MC4xMjMpXHJcbiAgICAgIC8vIGB3cHIgLSBndWFyZGAgaXMgdGhlIGluZGV4IG9mIGZpcnN0IHJvdW5kaW5nIGRpZ2l0LlxyXG4gICAgICBpZiAoc2QgPT0gbnVsbCkge1xyXG5cclxuICAgICAgICBpZiAocmVwIDwgMyAmJiBjaGVja1JvdW5kaW5nRGlnaXRzKHN1bS5kLCB3cHIgLSBndWFyZCwgcm0sIHJlcCkpIHtcclxuICAgICAgICAgIEN0b3IucHJlY2lzaW9uID0gd3ByICs9IDEwO1xyXG4gICAgICAgICAgZGVub21pbmF0b3IgPSBwb3cgPSB0ID0gbmV3IEN0b3IoMSk7XHJcbiAgICAgICAgICBpID0gMDtcclxuICAgICAgICAgIHJlcCsrO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICByZXR1cm4gZmluYWxpc2Uoc3VtLCBDdG9yLnByZWNpc2lvbiA9IHByLCBybSwgZXh0ZXJuYWwgPSB0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgQ3Rvci5wcmVjaXNpb24gPSBwcjtcclxuICAgICAgICByZXR1cm4gc3VtO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgc3VtID0gdDtcclxuICB9XHJcbn1cclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgbmF0dXJhbCBsb2dhcml0aG0gb2YgYHhgIHJvdW5kZWQgdG8gYHNkYCBzaWduaWZpY2FudFxyXG4gKiBkaWdpdHMuXHJcbiAqXHJcbiAqICBsbigtbikgICAgICAgID0gTmFOXHJcbiAqICBsbigwKSAgICAgICAgID0gLUluZmluaXR5XHJcbiAqICBsbigtMCkgICAgICAgID0gLUluZmluaXR5XHJcbiAqICBsbigxKSAgICAgICAgID0gMFxyXG4gKiAgbG4oSW5maW5pdHkpICA9IEluZmluaXR5XHJcbiAqICBsbigtSW5maW5pdHkpID0gTmFOXHJcbiAqICBsbihOYU4pICAgICAgID0gTmFOXHJcbiAqXHJcbiAqICBsbihuKSAobiAhPSAxKSBpcyBub24tdGVybWluYXRpbmcuXHJcbiAqXHJcbiAqL1xyXG5mdW5jdGlvbiBuYXR1cmFsTG9nYXJpdGhtKHksIHNkKSB7XHJcbiAgdmFyIGMsIGMwLCBkZW5vbWluYXRvciwgZSwgbnVtZXJhdG9yLCByZXAsIHN1bSwgdCwgd3ByLCB4MSwgeDIsXHJcbiAgICBuID0gMSxcclxuICAgIGd1YXJkID0gMTAsXHJcbiAgICB4ID0geSxcclxuICAgIHhkID0geC5kLFxyXG4gICAgQ3RvciA9IHguY29uc3RydWN0b3IsXHJcbiAgICBybSA9IEN0b3Iucm91bmRpbmcsXHJcbiAgICBwciA9IEN0b3IucHJlY2lzaW9uO1xyXG5cclxuICAvLyBJcyB4IG5lZ2F0aXZlIG9yIEluZmluaXR5LCBOYU4sIDAgb3IgMT9cclxuICBpZiAoeC5zIDwgMCB8fCAheGQgfHwgIXhkWzBdIHx8ICF4LmUgJiYgeGRbMF0gPT0gMSAmJiB4ZC5sZW5ndGggPT0gMSkge1xyXG4gICAgcmV0dXJuIG5ldyBDdG9yKHhkICYmICF4ZFswXSA/IC0xIC8gMCA6IHgucyAhPSAxID8gTmFOIDogeGQgPyAwIDogeCk7XHJcbiAgfVxyXG5cclxuICBpZiAoc2QgPT0gbnVsbCkge1xyXG4gICAgZXh0ZXJuYWwgPSBmYWxzZTtcclxuICAgIHdwciA9IHByO1xyXG4gIH0gZWxzZSB7XHJcbiAgICB3cHIgPSBzZDtcclxuICB9XHJcblxyXG4gIEN0b3IucHJlY2lzaW9uID0gd3ByICs9IGd1YXJkO1xyXG4gIGMgPSBkaWdpdHNUb1N0cmluZyh4ZCk7XHJcbiAgYzAgPSBjLmNoYXJBdCgwKTtcclxuXHJcbiAgaWYgKE1hdGguYWJzKGUgPSB4LmUpIDwgMS41ZTE1KSB7XHJcblxyXG4gICAgLy8gQXJndW1lbnQgcmVkdWN0aW9uLlxyXG4gICAgLy8gVGhlIHNlcmllcyBjb252ZXJnZXMgZmFzdGVyIHRoZSBjbG9zZXIgdGhlIGFyZ3VtZW50IGlzIHRvIDEsIHNvIHVzaW5nXHJcbiAgICAvLyBsbihhXmIpID0gYiAqIGxuKGEpLCAgIGxuKGEpID0gbG4oYV5iKSAvIGJcclxuICAgIC8vIG11bHRpcGx5IHRoZSBhcmd1bWVudCBieSBpdHNlbGYgdW50aWwgdGhlIGxlYWRpbmcgZGlnaXRzIG9mIHRoZSBzaWduaWZpY2FuZCBhcmUgNywgOCwgOSxcclxuICAgIC8vIDEwLCAxMSwgMTIgb3IgMTMsIHJlY29yZGluZyB0aGUgbnVtYmVyIG9mIG11bHRpcGxpY2F0aW9ucyBzbyB0aGUgc3VtIG9mIHRoZSBzZXJpZXMgY2FuXHJcbiAgICAvLyBsYXRlciBiZSBkaXZpZGVkIGJ5IHRoaXMgbnVtYmVyLCB0aGVuIHNlcGFyYXRlIG91dCB0aGUgcG93ZXIgb2YgMTAgdXNpbmdcclxuICAgIC8vIGxuKGEqMTBeYikgPSBsbihhKSArIGIqbG4oMTApLlxyXG5cclxuICAgIC8vIG1heCBuIGlzIDIxIChnaXZlcyAwLjksIDEuMCBvciAxLjEpICg5ZTE1IC8gMjEgPSA0LjJlMTQpLlxyXG4gICAgLy93aGlsZSAoYzAgPCA5ICYmIGMwICE9IDEgfHwgYzAgPT0gMSAmJiBjLmNoYXJBdCgxKSA+IDEpIHtcclxuICAgIC8vIG1heCBuIGlzIDYgKGdpdmVzIDAuNyAtIDEuMylcclxuICAgIHdoaWxlIChjMCA8IDcgJiYgYzAgIT0gMSB8fCBjMCA9PSAxICYmIGMuY2hhckF0KDEpID4gMykge1xyXG4gICAgICB4ID0geC50aW1lcyh5KTtcclxuICAgICAgYyA9IGRpZ2l0c1RvU3RyaW5nKHguZCk7XHJcbiAgICAgIGMwID0gYy5jaGFyQXQoMCk7XHJcbiAgICAgIG4rKztcclxuICAgIH1cclxuXHJcbiAgICBlID0geC5lO1xyXG5cclxuICAgIGlmIChjMCA+IDEpIHtcclxuICAgICAgeCA9IG5ldyBDdG9yKCcwLicgKyBjKTtcclxuICAgICAgZSsrO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgeCA9IG5ldyBDdG9yKGMwICsgJy4nICsgYy5zbGljZSgxKSk7XHJcbiAgICB9XHJcbiAgfSBlbHNlIHtcclxuXHJcbiAgICAvLyBUaGUgYXJndW1lbnQgcmVkdWN0aW9uIG1ldGhvZCBhYm92ZSBtYXkgcmVzdWx0IGluIG92ZXJmbG93IGlmIHRoZSBhcmd1bWVudCB5IGlzIGEgbWFzc2l2ZVxyXG4gICAgLy8gbnVtYmVyIHdpdGggZXhwb25lbnQgPj0gMTUwMDAwMDAwMDAwMDAwMCAoOWUxNSAvIDYgPSAxLjVlMTUpLCBzbyBpbnN0ZWFkIHJlY2FsbCB0aGlzXHJcbiAgICAvLyBmdW5jdGlvbiB1c2luZyBsbih4KjEwXmUpID0gbG4oeCkgKyBlKmxuKDEwKS5cclxuICAgIHQgPSBnZXRMbjEwKEN0b3IsIHdwciArIDIsIHByKS50aW1lcyhlICsgJycpO1xyXG4gICAgeCA9IG5hdHVyYWxMb2dhcml0aG0obmV3IEN0b3IoYzAgKyAnLicgKyBjLnNsaWNlKDEpKSwgd3ByIC0gZ3VhcmQpLnBsdXModCk7XHJcbiAgICBDdG9yLnByZWNpc2lvbiA9IHByO1xyXG5cclxuICAgIHJldHVybiBzZCA9PSBudWxsID8gZmluYWxpc2UoeCwgcHIsIHJtLCBleHRlcm5hbCA9IHRydWUpIDogeDtcclxuICB9XHJcblxyXG4gIC8vIHgxIGlzIHggcmVkdWNlZCB0byBhIHZhbHVlIG5lYXIgMS5cclxuICB4MSA9IHg7XHJcblxyXG4gIC8vIFRheWxvciBzZXJpZXMuXHJcbiAgLy8gbG4oeSkgPSBsbigoMSArIHgpLygxIC0geCkpID0gMih4ICsgeF4zLzMgKyB4XjUvNSArIHheNy83ICsgLi4uKVxyXG4gIC8vIHdoZXJlIHggPSAoeSAtIDEpLyh5ICsgMSkgICAgKHx4fCA8IDEpXHJcbiAgc3VtID0gbnVtZXJhdG9yID0geCA9IGRpdmlkZSh4Lm1pbnVzKDEpLCB4LnBsdXMoMSksIHdwciwgMSk7XHJcbiAgeDIgPSBmaW5hbGlzZSh4LnRpbWVzKHgpLCB3cHIsIDEpO1xyXG4gIGRlbm9taW5hdG9yID0gMztcclxuXHJcbiAgZm9yICg7Oykge1xyXG4gICAgbnVtZXJhdG9yID0gZmluYWxpc2UobnVtZXJhdG9yLnRpbWVzKHgyKSwgd3ByLCAxKTtcclxuICAgIHQgPSBzdW0ucGx1cyhkaXZpZGUobnVtZXJhdG9yLCBuZXcgQ3RvcihkZW5vbWluYXRvciksIHdwciwgMSkpO1xyXG5cclxuICAgIGlmIChkaWdpdHNUb1N0cmluZyh0LmQpLnNsaWNlKDAsIHdwcikgPT09IGRpZ2l0c1RvU3RyaW5nKHN1bS5kKS5zbGljZSgwLCB3cHIpKSB7XHJcbiAgICAgIHN1bSA9IHN1bS50aW1lcygyKTtcclxuXHJcbiAgICAgIC8vIFJldmVyc2UgdGhlIGFyZ3VtZW50IHJlZHVjdGlvbi4gQ2hlY2sgdGhhdCBlIGlzIG5vdCAwIGJlY2F1c2UsIGJlc2lkZXMgcHJldmVudGluZyBhblxyXG4gICAgICAvLyB1bm5lY2Vzc2FyeSBjYWxjdWxhdGlvbiwgLTAgKyAwID0gKzAgYW5kIHRvIGVuc3VyZSBjb3JyZWN0IHJvdW5kaW5nIC0wIG5lZWRzIHRvIHN0YXkgLTAuXHJcbiAgICAgIGlmIChlICE9PSAwKSBzdW0gPSBzdW0ucGx1cyhnZXRMbjEwKEN0b3IsIHdwciArIDIsIHByKS50aW1lcyhlICsgJycpKTtcclxuICAgICAgc3VtID0gZGl2aWRlKHN1bSwgbmV3IEN0b3IobiksIHdwciwgMSk7XHJcblxyXG4gICAgICAvLyBJcyBybSA+IDMgYW5kIHRoZSBmaXJzdCA0IHJvdW5kaW5nIGRpZ2l0cyA0OTk5LCBvciBybSA8IDQgKG9yIHRoZSBzdW1tYXRpb24gaGFzXHJcbiAgICAgIC8vIGJlZW4gcmVwZWF0ZWQgcHJldmlvdXNseSkgYW5kIHRoZSBmaXJzdCA0IHJvdW5kaW5nIGRpZ2l0cyA5OTk5P1xyXG4gICAgICAvLyBJZiBzbywgcmVzdGFydCB0aGUgc3VtbWF0aW9uIHdpdGggYSBoaWdoZXIgcHJlY2lzaW9uLCBvdGhlcndpc2VcclxuICAgICAgLy8gZS5nLiB3aXRoIHByZWNpc2lvbjogMTIsIHJvdW5kaW5nOiAxXHJcbiAgICAgIC8vIGxuKDEzNTUyMDAyOC42MTI2MDkxNzE0MjY1MzgxNTMzKSA9IDE4LjcyNDYyOTk5OTkgd2hlbiBpdCBzaG91bGQgYmUgMTguNzI0NjMuXHJcbiAgICAgIC8vIGB3cHIgLSBndWFyZGAgaXMgdGhlIGluZGV4IG9mIGZpcnN0IHJvdW5kaW5nIGRpZ2l0LlxyXG4gICAgICBpZiAoc2QgPT0gbnVsbCkge1xyXG4gICAgICAgIGlmIChjaGVja1JvdW5kaW5nRGlnaXRzKHN1bS5kLCB3cHIgLSBndWFyZCwgcm0sIHJlcCkpIHtcclxuICAgICAgICAgIEN0b3IucHJlY2lzaW9uID0gd3ByICs9IGd1YXJkO1xyXG4gICAgICAgICAgdCA9IG51bWVyYXRvciA9IHggPSBkaXZpZGUoeDEubWludXMoMSksIHgxLnBsdXMoMSksIHdwciwgMSk7XHJcbiAgICAgICAgICB4MiA9IGZpbmFsaXNlKHgudGltZXMoeCksIHdwciwgMSk7XHJcbiAgICAgICAgICBkZW5vbWluYXRvciA9IHJlcCA9IDE7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHJldHVybiBmaW5hbGlzZShzdW0sIEN0b3IucHJlY2lzaW9uID0gcHIsIHJtLCBleHRlcm5hbCA9IHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBDdG9yLnByZWNpc2lvbiA9IHByO1xyXG4gICAgICAgIHJldHVybiBzdW07XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBzdW0gPSB0O1xyXG4gICAgZGVub21pbmF0b3IgKz0gMjtcclxuICB9XHJcbn1cclxuXHJcblxyXG4vLyDCsUluZmluaXR5LCBOYU4uXHJcbmZ1bmN0aW9uIG5vbkZpbml0ZVRvU3RyaW5nKHgpIHtcclxuICAvLyBVbnNpZ25lZC5cclxuICByZXR1cm4gU3RyaW5nKHgucyAqIHgucyAvIDApO1xyXG59XHJcblxyXG5cclxuLypcclxuICogUGFyc2UgdGhlIHZhbHVlIG9mIGEgbmV3IERlY2ltYWwgYHhgIGZyb20gc3RyaW5nIGBzdHJgLlxyXG4gKi9cclxuZnVuY3Rpb24gcGFyc2VEZWNpbWFsKHgsIHN0cikge1xyXG4gIHZhciBlLCBpLCBsZW47XHJcblxyXG4gIC8vIERlY2ltYWwgcG9pbnQ/XHJcbiAgaWYgKChlID0gc3RyLmluZGV4T2YoJy4nKSkgPiAtMSkgc3RyID0gc3RyLnJlcGxhY2UoJy4nLCAnJyk7XHJcblxyXG4gIC8vIEV4cG9uZW50aWFsIGZvcm0/XHJcbiAgaWYgKChpID0gc3RyLnNlYXJjaCgvZS9pKSkgPiAwKSB7XHJcblxyXG4gICAgLy8gRGV0ZXJtaW5lIGV4cG9uZW50LlxyXG4gICAgaWYgKGUgPCAwKSBlID0gaTtcclxuICAgIGUgKz0gK3N0ci5zbGljZShpICsgMSk7XHJcbiAgICBzdHIgPSBzdHIuc3Vic3RyaW5nKDAsIGkpO1xyXG4gIH0gZWxzZSBpZiAoZSA8IDApIHtcclxuXHJcbiAgICAvLyBJbnRlZ2VyLlxyXG4gICAgZSA9IHN0ci5sZW5ndGg7XHJcbiAgfVxyXG5cclxuICAvLyBEZXRlcm1pbmUgbGVhZGluZyB6ZXJvcy5cclxuICBmb3IgKGkgPSAwOyBzdHIuY2hhckNvZGVBdChpKSA9PT0gNDg7IGkrKyk7XHJcblxyXG4gIC8vIERldGVybWluZSB0cmFpbGluZyB6ZXJvcy5cclxuICBmb3IgKGxlbiA9IHN0ci5sZW5ndGg7IHN0ci5jaGFyQ29kZUF0KGxlbiAtIDEpID09PSA0ODsgLS1sZW4pO1xyXG4gIHN0ciA9IHN0ci5zbGljZShpLCBsZW4pO1xyXG5cclxuICBpZiAoc3RyKSB7XHJcbiAgICBsZW4gLT0gaTtcclxuICAgIHguZSA9IGUgPSBlIC0gaSAtIDE7XHJcbiAgICB4LmQgPSBbXTtcclxuXHJcbiAgICAvLyBUcmFuc2Zvcm0gYmFzZVxyXG5cclxuICAgIC8vIGUgaXMgdGhlIGJhc2UgMTAgZXhwb25lbnQuXHJcbiAgICAvLyBpIGlzIHdoZXJlIHRvIHNsaWNlIHN0ciB0byBnZXQgdGhlIGZpcnN0IHdvcmQgb2YgdGhlIGRpZ2l0cyBhcnJheS5cclxuICAgIGkgPSAoZSArIDEpICUgTE9HX0JBU0U7XHJcbiAgICBpZiAoZSA8IDApIGkgKz0gTE9HX0JBU0U7XHJcblxyXG4gICAgaWYgKGkgPCBsZW4pIHtcclxuICAgICAgaWYgKGkpIHguZC5wdXNoKCtzdHIuc2xpY2UoMCwgaSkpO1xyXG4gICAgICBmb3IgKGxlbiAtPSBMT0dfQkFTRTsgaSA8IGxlbjspIHguZC5wdXNoKCtzdHIuc2xpY2UoaSwgaSArPSBMT0dfQkFTRSkpO1xyXG4gICAgICBzdHIgPSBzdHIuc2xpY2UoaSk7XHJcbiAgICAgIGkgPSBMT0dfQkFTRSAtIHN0ci5sZW5ndGg7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBpIC09IGxlbjtcclxuICAgIH1cclxuXHJcbiAgICBmb3IgKDsgaS0tOykgc3RyICs9ICcwJztcclxuICAgIHguZC5wdXNoKCtzdHIpO1xyXG5cclxuICAgIGlmIChleHRlcm5hbCkge1xyXG5cclxuICAgICAgLy8gT3ZlcmZsb3c/XHJcbiAgICAgIGlmICh4LmUgPiB4LmNvbnN0cnVjdG9yLm1heEUpIHtcclxuXHJcbiAgICAgICAgLy8gSW5maW5pdHkuXHJcbiAgICAgICAgeC5kID0gbnVsbDtcclxuICAgICAgICB4LmUgPSBOYU47XHJcblxyXG4gICAgICAvLyBVbmRlcmZsb3c/XHJcbiAgICAgIH0gZWxzZSBpZiAoeC5lIDwgeC5jb25zdHJ1Y3Rvci5taW5FKSB7XHJcblxyXG4gICAgICAgIC8vIFplcm8uXHJcbiAgICAgICAgeC5lID0gMDtcclxuICAgICAgICB4LmQgPSBbMF07XHJcbiAgICAgICAgLy8geC5jb25zdHJ1Y3Rvci51bmRlcmZsb3cgPSB0cnVlO1xyXG4gICAgICB9IC8vIGVsc2UgeC5jb25zdHJ1Y3Rvci51bmRlcmZsb3cgPSBmYWxzZTtcclxuICAgIH1cclxuICB9IGVsc2Uge1xyXG5cclxuICAgIC8vIFplcm8uXHJcbiAgICB4LmUgPSAwO1xyXG4gICAgeC5kID0gWzBdO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHg7XHJcbn1cclxuXHJcblxyXG4vKlxyXG4gKiBQYXJzZSB0aGUgdmFsdWUgb2YgYSBuZXcgRGVjaW1hbCBgeGAgZnJvbSBhIHN0cmluZyBgc3RyYCwgd2hpY2ggaXMgbm90IGEgZGVjaW1hbCB2YWx1ZS5cclxuICovXHJcbmZ1bmN0aW9uIHBhcnNlT3RoZXIoeCwgc3RyKSB7XHJcbiAgdmFyIGJhc2UsIEN0b3IsIGRpdmlzb3IsIGksIGlzRmxvYXQsIGxlbiwgcCwgeGQsIHhlO1xyXG5cclxuICBpZiAoc3RyLmluZGV4T2YoJ18nKSA+IC0xKSB7XHJcbiAgICBzdHIgPSBzdHIucmVwbGFjZSgvKFxcZClfKD89XFxkKS9nLCAnJDEnKTtcclxuICAgIGlmIChpc0RlY2ltYWwudGVzdChzdHIpKSByZXR1cm4gcGFyc2VEZWNpbWFsKHgsIHN0cik7XHJcbiAgfSBlbHNlIGlmIChzdHIgPT09ICdJbmZpbml0eScgfHwgc3RyID09PSAnTmFOJykge1xyXG4gICAgaWYgKCErc3RyKSB4LnMgPSBOYU47XHJcbiAgICB4LmUgPSBOYU47XHJcbiAgICB4LmQgPSBudWxsO1xyXG4gICAgcmV0dXJuIHg7XHJcbiAgfVxyXG5cclxuICBpZiAoaXNIZXgudGVzdChzdHIpKSAge1xyXG4gICAgYmFzZSA9IDE2O1xyXG4gICAgc3RyID0gc3RyLnRvTG93ZXJDYXNlKCk7XHJcbiAgfSBlbHNlIGlmIChpc0JpbmFyeS50ZXN0KHN0cikpICB7XHJcbiAgICBiYXNlID0gMjtcclxuICB9IGVsc2UgaWYgKGlzT2N0YWwudGVzdChzdHIpKSAge1xyXG4gICAgYmFzZSA9IDg7XHJcbiAgfSBlbHNlIHtcclxuICAgIHRocm93IEVycm9yKGludmFsaWRBcmd1bWVudCArIHN0cik7XHJcbiAgfVxyXG5cclxuICAvLyBJcyB0aGVyZSBhIGJpbmFyeSBleHBvbmVudCBwYXJ0P1xyXG4gIGkgPSBzdHIuc2VhcmNoKC9wL2kpO1xyXG5cclxuICBpZiAoaSA+IDApIHtcclxuICAgIHAgPSArc3RyLnNsaWNlKGkgKyAxKTtcclxuICAgIHN0ciA9IHN0ci5zdWJzdHJpbmcoMiwgaSk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHN0ciA9IHN0ci5zbGljZSgyKTtcclxuICB9XHJcblxyXG4gIC8vIENvbnZlcnQgYHN0cmAgYXMgYW4gaW50ZWdlciB0aGVuIGRpdmlkZSB0aGUgcmVzdWx0IGJ5IGBiYXNlYCByYWlzZWQgdG8gYSBwb3dlciBzdWNoIHRoYXQgdGhlXHJcbiAgLy8gZnJhY3Rpb24gcGFydCB3aWxsIGJlIHJlc3RvcmVkLlxyXG4gIGkgPSBzdHIuaW5kZXhPZignLicpO1xyXG4gIGlzRmxvYXQgPSBpID49IDA7XHJcbiAgQ3RvciA9IHguY29uc3RydWN0b3I7XHJcblxyXG4gIGlmIChpc0Zsb2F0KSB7XHJcbiAgICBzdHIgPSBzdHIucmVwbGFjZSgnLicsICcnKTtcclxuICAgIGxlbiA9IHN0ci5sZW5ndGg7XHJcbiAgICBpID0gbGVuIC0gaTtcclxuXHJcbiAgICAvLyBsb2dbMTBdKDE2KSA9IDEuMjA0MS4uLiAsIGxvZ1sxMF0oODgpID0gMS45NDQ0Li4uLlxyXG4gICAgZGl2aXNvciA9IGludFBvdyhDdG9yLCBuZXcgQ3RvcihiYXNlKSwgaSwgaSAqIDIpO1xyXG4gIH1cclxuXHJcbiAgeGQgPSBjb252ZXJ0QmFzZShzdHIsIGJhc2UsIEJBU0UpO1xyXG4gIHhlID0geGQubGVuZ3RoIC0gMTtcclxuXHJcbiAgLy8gUmVtb3ZlIHRyYWlsaW5nIHplcm9zLlxyXG4gIGZvciAoaSA9IHhlOyB4ZFtpXSA9PT0gMDsgLS1pKSB4ZC5wb3AoKTtcclxuICBpZiAoaSA8IDApIHJldHVybiBuZXcgQ3Rvcih4LnMgKiAwKTtcclxuICB4LmUgPSBnZXRCYXNlMTBFeHBvbmVudCh4ZCwgeGUpO1xyXG4gIHguZCA9IHhkO1xyXG4gIGV4dGVybmFsID0gZmFsc2U7XHJcblxyXG4gIC8vIEF0IHdoYXQgcHJlY2lzaW9uIHRvIHBlcmZvcm0gdGhlIGRpdmlzaW9uIHRvIGVuc3VyZSBleGFjdCBjb252ZXJzaW9uP1xyXG4gIC8vIG1heERlY2ltYWxJbnRlZ2VyUGFydERpZ2l0Q291bnQgPSBjZWlsKGxvZ1sxMF0oYikgKiBvdGhlckJhc2VJbnRlZ2VyUGFydERpZ2l0Q291bnQpXHJcbiAgLy8gbG9nWzEwXSgyKSA9IDAuMzAxMDMsIGxvZ1sxMF0oOCkgPSAwLjkwMzA5LCBsb2dbMTBdKDE2KSA9IDEuMjA0MTJcclxuICAvLyBFLmcuIGNlaWwoMS4yICogMykgPSA0LCBzbyB1cCB0byA0IGRlY2ltYWwgZGlnaXRzIGFyZSBuZWVkZWQgdG8gcmVwcmVzZW50IDMgaGV4IGludCBkaWdpdHMuXHJcbiAgLy8gbWF4RGVjaW1hbEZyYWN0aW9uUGFydERpZ2l0Q291bnQgPSB7SGV4OjR8T2N0OjN8QmluOjF9ICogb3RoZXJCYXNlRnJhY3Rpb25QYXJ0RGlnaXRDb3VudFxyXG4gIC8vIFRoZXJlZm9yZSB1c2luZyA0ICogdGhlIG51bWJlciBvZiBkaWdpdHMgb2Ygc3RyIHdpbGwgYWx3YXlzIGJlIGVub3VnaC5cclxuICBpZiAoaXNGbG9hdCkgeCA9IGRpdmlkZSh4LCBkaXZpc29yLCBsZW4gKiA0KTtcclxuXHJcbiAgLy8gTXVsdGlwbHkgYnkgdGhlIGJpbmFyeSBleHBvbmVudCBwYXJ0IGlmIHByZXNlbnQuXHJcbiAgaWYgKHApIHggPSB4LnRpbWVzKE1hdGguYWJzKHApIDwgNTQgPyBtYXRocG93KDIsIHApIDogRGVjaW1hbC5wb3coMiwgcCkpO1xyXG4gIGV4dGVybmFsID0gdHJ1ZTtcclxuXHJcbiAgcmV0dXJuIHg7XHJcbn1cclxuXHJcblxyXG4vKlxyXG4gKiBzaW4oeCkgPSB4IC0geF4zLzMhICsgeF41LzUhIC0gLi4uXHJcbiAqIHx4fCA8IHBpLzJcclxuICpcclxuICovXHJcbmZ1bmN0aW9uIHNpbmUoQ3RvciwgeCkge1xyXG4gIHZhciBrLFxyXG4gICAgbGVuID0geC5kLmxlbmd0aDtcclxuXHJcbiAgaWYgKGxlbiA8IDMpIHtcclxuICAgIHJldHVybiB4LmlzWmVybygpID8geCA6IHRheWxvclNlcmllcyhDdG9yLCAyLCB4LCB4KTtcclxuICB9XHJcblxyXG4gIC8vIEFyZ3VtZW50IHJlZHVjdGlvbjogc2luKDV4KSA9IDE2KnNpbl41KHgpIC0gMjAqc2luXjMoeCkgKyA1KnNpbih4KVxyXG4gIC8vIGkuZS4gc2luKHgpID0gMTYqc2luXjUoeC81KSAtIDIwKnNpbl4zKHgvNSkgKyA1KnNpbih4LzUpXHJcbiAgLy8gYW5kICBzaW4oeCkgPSBzaW4oeC81KSg1ICsgc2luXjIoeC81KSgxNnNpbl4yKHgvNSkgLSAyMCkpXHJcblxyXG4gIC8vIEVzdGltYXRlIHRoZSBvcHRpbXVtIG51bWJlciBvZiB0aW1lcyB0byB1c2UgdGhlIGFyZ3VtZW50IHJlZHVjdGlvbi5cclxuICBrID0gMS40ICogTWF0aC5zcXJ0KGxlbik7XHJcbiAgayA9IGsgPiAxNiA/IDE2IDogayB8IDA7XHJcblxyXG4gIHggPSB4LnRpbWVzKDEgLyB0aW55UG93KDUsIGspKTtcclxuICB4ID0gdGF5bG9yU2VyaWVzKEN0b3IsIDIsIHgsIHgpO1xyXG5cclxuICAvLyBSZXZlcnNlIGFyZ3VtZW50IHJlZHVjdGlvblxyXG4gIHZhciBzaW4yX3gsXHJcbiAgICBkNSA9IG5ldyBDdG9yKDUpLFxyXG4gICAgZDE2ID0gbmV3IEN0b3IoMTYpLFxyXG4gICAgZDIwID0gbmV3IEN0b3IoMjApO1xyXG4gIGZvciAoOyBrLS07KSB7XHJcbiAgICBzaW4yX3ggPSB4LnRpbWVzKHgpO1xyXG4gICAgeCA9IHgudGltZXMoZDUucGx1cyhzaW4yX3gudGltZXMoZDE2LnRpbWVzKHNpbjJfeCkubWludXMoZDIwKSkpKTtcclxuICB9XHJcblxyXG4gIHJldHVybiB4O1xyXG59XHJcblxyXG5cclxuLy8gQ2FsY3VsYXRlIFRheWxvciBzZXJpZXMgZm9yIGBjb3NgLCBgY29zaGAsIGBzaW5gIGFuZCBgc2luaGAuXHJcbmZ1bmN0aW9uIHRheWxvclNlcmllcyhDdG9yLCBuLCB4LCB5LCBpc0h5cGVyYm9saWMpIHtcclxuICB2YXIgaiwgdCwgdSwgeDIsXHJcbiAgICBpID0gMSxcclxuICAgIHByID0gQ3Rvci5wcmVjaXNpb24sXHJcbiAgICBrID0gTWF0aC5jZWlsKHByIC8gTE9HX0JBU0UpO1xyXG5cclxuICBleHRlcm5hbCA9IGZhbHNlO1xyXG4gIHgyID0geC50aW1lcyh4KTtcclxuICB1ID0gbmV3IEN0b3IoeSk7XHJcblxyXG4gIGZvciAoOzspIHtcclxuICAgIHQgPSBkaXZpZGUodS50aW1lcyh4MiksIG5ldyBDdG9yKG4rKyAqIG4rKyksIHByLCAxKTtcclxuICAgIHUgPSBpc0h5cGVyYm9saWMgPyB5LnBsdXModCkgOiB5Lm1pbnVzKHQpO1xyXG4gICAgeSA9IGRpdmlkZSh0LnRpbWVzKHgyKSwgbmV3IEN0b3IobisrICogbisrKSwgcHIsIDEpO1xyXG4gICAgdCA9IHUucGx1cyh5KTtcclxuXHJcbiAgICBpZiAodC5kW2tdICE9PSB2b2lkIDApIHtcclxuICAgICAgZm9yIChqID0gazsgdC5kW2pdID09PSB1LmRbal0gJiYgai0tOyk7XHJcbiAgICAgIGlmIChqID09IC0xKSBicmVhaztcclxuICAgIH1cclxuXHJcbiAgICBqID0gdTtcclxuICAgIHUgPSB5O1xyXG4gICAgeSA9IHQ7XHJcbiAgICB0ID0gajtcclxuICAgIGkrKztcclxuICB9XHJcblxyXG4gIGV4dGVybmFsID0gdHJ1ZTtcclxuICB0LmQubGVuZ3RoID0gayArIDE7XHJcblxyXG4gIHJldHVybiB0O1xyXG59XHJcblxyXG5cclxuLy8gRXhwb25lbnQgZSBtdXN0IGJlIHBvc2l0aXZlIGFuZCBub24temVyby5cclxuZnVuY3Rpb24gdGlueVBvdyhiLCBlKSB7XHJcbiAgdmFyIG4gPSBiO1xyXG4gIHdoaWxlICgtLWUpIG4gKj0gYjtcclxuICByZXR1cm4gbjtcclxufVxyXG5cclxuXHJcbi8vIFJldHVybiB0aGUgYWJzb2x1dGUgdmFsdWUgb2YgYHhgIHJlZHVjZWQgdG8gbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGhhbGYgcGkuXHJcbmZ1bmN0aW9uIHRvTGVzc1RoYW5IYWxmUGkoQ3RvciwgeCkge1xyXG4gIHZhciB0LFxyXG4gICAgaXNOZWcgPSB4LnMgPCAwLFxyXG4gICAgcGkgPSBnZXRQaShDdG9yLCBDdG9yLnByZWNpc2lvbiwgMSksXHJcbiAgICBoYWxmUGkgPSBwaS50aW1lcygwLjUpO1xyXG5cclxuICB4ID0geC5hYnMoKTtcclxuXHJcbiAgaWYgKHgubHRlKGhhbGZQaSkpIHtcclxuICAgIHF1YWRyYW50ID0gaXNOZWcgPyA0IDogMTtcclxuICAgIHJldHVybiB4O1xyXG4gIH1cclxuXHJcbiAgdCA9IHguZGl2VG9JbnQocGkpO1xyXG5cclxuICBpZiAodC5pc1plcm8oKSkge1xyXG4gICAgcXVhZHJhbnQgPSBpc05lZyA/IDMgOiAyO1xyXG4gIH0gZWxzZSB7XHJcbiAgICB4ID0geC5taW51cyh0LnRpbWVzKHBpKSk7XHJcblxyXG4gICAgLy8gMCA8PSB4IDwgcGlcclxuICAgIGlmICh4Lmx0ZShoYWxmUGkpKSB7XHJcbiAgICAgIHF1YWRyYW50ID0gaXNPZGQodCkgPyAoaXNOZWcgPyAyIDogMykgOiAoaXNOZWcgPyA0IDogMSk7XHJcbiAgICAgIHJldHVybiB4O1xyXG4gICAgfVxyXG5cclxuICAgIHF1YWRyYW50ID0gaXNPZGQodCkgPyAoaXNOZWcgPyAxIDogNCkgOiAoaXNOZWcgPyAzIDogMik7XHJcbiAgfVxyXG5cclxuICByZXR1cm4geC5taW51cyhwaSkuYWJzKCk7XHJcbn1cclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gdGhlIHZhbHVlIG9mIERlY2ltYWwgYHhgIGFzIGEgc3RyaW5nIGluIGJhc2UgYGJhc2VPdXRgLlxyXG4gKlxyXG4gKiBJZiB0aGUgb3B0aW9uYWwgYHNkYCBhcmd1bWVudCBpcyBwcmVzZW50IGluY2x1ZGUgYSBiaW5hcnkgZXhwb25lbnQgc3VmZml4LlxyXG4gKi9cclxuZnVuY3Rpb24gdG9TdHJpbmdCaW5hcnkoeCwgYmFzZU91dCwgc2QsIHJtKSB7XHJcbiAgdmFyIGJhc2UsIGUsIGksIGssIGxlbiwgcm91bmRVcCwgc3RyLCB4ZCwgeSxcclxuICAgIEN0b3IgPSB4LmNvbnN0cnVjdG9yLFxyXG4gICAgaXNFeHAgPSBzZCAhPT0gdm9pZCAwO1xyXG5cclxuICBpZiAoaXNFeHApIHtcclxuICAgIGNoZWNrSW50MzIoc2QsIDEsIE1BWF9ESUdJVFMpO1xyXG4gICAgaWYgKHJtID09PSB2b2lkIDApIHJtID0gQ3Rvci5yb3VuZGluZztcclxuICAgIGVsc2UgY2hlY2tJbnQzMihybSwgMCwgOCk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHNkID0gQ3Rvci5wcmVjaXNpb247XHJcbiAgICBybSA9IEN0b3Iucm91bmRpbmc7XHJcbiAgfVxyXG5cclxuICBpZiAoIXguaXNGaW5pdGUoKSkge1xyXG4gICAgc3RyID0gbm9uRmluaXRlVG9TdHJpbmcoeCk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHN0ciA9IGZpbml0ZVRvU3RyaW5nKHgpO1xyXG4gICAgaSA9IHN0ci5pbmRleE9mKCcuJyk7XHJcblxyXG4gICAgLy8gVXNlIGV4cG9uZW50aWFsIG5vdGF0aW9uIGFjY29yZGluZyB0byBgdG9FeHBQb3NgIGFuZCBgdG9FeHBOZWdgPyBObywgYnV0IGlmIHJlcXVpcmVkOlxyXG4gICAgLy8gbWF4QmluYXJ5RXhwb25lbnQgPSBmbG9vcigoZGVjaW1hbEV4cG9uZW50ICsgMSkgKiBsb2dbMl0oMTApKVxyXG4gICAgLy8gbWluQmluYXJ5RXhwb25lbnQgPSBmbG9vcihkZWNpbWFsRXhwb25lbnQgKiBsb2dbMl0oMTApKVxyXG4gICAgLy8gbG9nWzJdKDEwKSA9IDMuMzIxOTI4MDk0ODg3MzYyMzQ3ODcwMzE5NDI5NDg5MzkwMTc1ODY0XHJcblxyXG4gICAgaWYgKGlzRXhwKSB7XHJcbiAgICAgIGJhc2UgPSAyO1xyXG4gICAgICBpZiAoYmFzZU91dCA9PSAxNikge1xyXG4gICAgICAgIHNkID0gc2QgKiA0IC0gMztcclxuICAgICAgfSBlbHNlIGlmIChiYXNlT3V0ID09IDgpIHtcclxuICAgICAgICBzZCA9IHNkICogMyAtIDI7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGJhc2UgPSBiYXNlT3V0O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIENvbnZlcnQgdGhlIG51bWJlciBhcyBhbiBpbnRlZ2VyIHRoZW4gZGl2aWRlIHRoZSByZXN1bHQgYnkgaXRzIGJhc2UgcmFpc2VkIHRvIGEgcG93ZXIgc3VjaFxyXG4gICAgLy8gdGhhdCB0aGUgZnJhY3Rpb24gcGFydCB3aWxsIGJlIHJlc3RvcmVkLlxyXG5cclxuICAgIC8vIE5vbi1pbnRlZ2VyLlxyXG4gICAgaWYgKGkgPj0gMCkge1xyXG4gICAgICBzdHIgPSBzdHIucmVwbGFjZSgnLicsICcnKTtcclxuICAgICAgeSA9IG5ldyBDdG9yKDEpO1xyXG4gICAgICB5LmUgPSBzdHIubGVuZ3RoIC0gaTtcclxuICAgICAgeS5kID0gY29udmVydEJhc2UoZmluaXRlVG9TdHJpbmcoeSksIDEwLCBiYXNlKTtcclxuICAgICAgeS5lID0geS5kLmxlbmd0aDtcclxuICAgIH1cclxuXHJcbiAgICB4ZCA9IGNvbnZlcnRCYXNlKHN0ciwgMTAsIGJhc2UpO1xyXG4gICAgZSA9IGxlbiA9IHhkLmxlbmd0aDtcclxuXHJcbiAgICAvLyBSZW1vdmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgICBmb3IgKDsgeGRbLS1sZW5dID09IDA7KSB4ZC5wb3AoKTtcclxuXHJcbiAgICBpZiAoIXhkWzBdKSB7XHJcbiAgICAgIHN0ciA9IGlzRXhwID8gJzBwKzAnIDogJzAnO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaWYgKGkgPCAwKSB7XHJcbiAgICAgICAgZS0tO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHggPSBuZXcgQ3Rvcih4KTtcclxuICAgICAgICB4LmQgPSB4ZDtcclxuICAgICAgICB4LmUgPSBlO1xyXG4gICAgICAgIHggPSBkaXZpZGUoeCwgeSwgc2QsIHJtLCAwLCBiYXNlKTtcclxuICAgICAgICB4ZCA9IHguZDtcclxuICAgICAgICBlID0geC5lO1xyXG4gICAgICAgIHJvdW5kVXAgPSBpbmV4YWN0O1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBUaGUgcm91bmRpbmcgZGlnaXQsIGkuZS4gdGhlIGRpZ2l0IGFmdGVyIHRoZSBkaWdpdCB0aGF0IG1heSBiZSByb3VuZGVkIHVwLlxyXG4gICAgICBpID0geGRbc2RdO1xyXG4gICAgICBrID0gYmFzZSAvIDI7XHJcbiAgICAgIHJvdW5kVXAgPSByb3VuZFVwIHx8IHhkW3NkICsgMV0gIT09IHZvaWQgMDtcclxuXHJcbiAgICAgIHJvdW5kVXAgPSBybSA8IDRcclxuICAgICAgICA/IChpICE9PSB2b2lkIDAgfHwgcm91bmRVcCkgJiYgKHJtID09PSAwIHx8IHJtID09PSAoeC5zIDwgMCA/IDMgOiAyKSlcclxuICAgICAgICA6IGkgPiBrIHx8IGkgPT09IGsgJiYgKHJtID09PSA0IHx8IHJvdW5kVXAgfHwgcm0gPT09IDYgJiYgeGRbc2QgLSAxXSAmIDEgfHxcclxuICAgICAgICAgIHJtID09PSAoeC5zIDwgMCA/IDggOiA3KSk7XHJcblxyXG4gICAgICB4ZC5sZW5ndGggPSBzZDtcclxuXHJcbiAgICAgIGlmIChyb3VuZFVwKSB7XHJcblxyXG4gICAgICAgIC8vIFJvdW5kaW5nIHVwIG1heSBtZWFuIHRoZSBwcmV2aW91cyBkaWdpdCBoYXMgdG8gYmUgcm91bmRlZCB1cCBhbmQgc28gb24uXHJcbiAgICAgICAgZm9yICg7ICsreGRbLS1zZF0gPiBiYXNlIC0gMTspIHtcclxuICAgICAgICAgIHhkW3NkXSA9IDA7XHJcbiAgICAgICAgICBpZiAoIXNkKSB7XHJcbiAgICAgICAgICAgICsrZTtcclxuICAgICAgICAgICAgeGQudW5zaGlmdCgxKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIERldGVybWluZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgICAgZm9yIChsZW4gPSB4ZC5sZW5ndGg7ICF4ZFtsZW4gLSAxXTsgLS1sZW4pO1xyXG5cclxuICAgICAgLy8gRS5nLiBbNCwgMTEsIDE1XSBiZWNvbWVzIDRiZi5cclxuICAgICAgZm9yIChpID0gMCwgc3RyID0gJyc7IGkgPCBsZW47IGkrKykgc3RyICs9IE5VTUVSQUxTLmNoYXJBdCh4ZFtpXSk7XHJcblxyXG4gICAgICAvLyBBZGQgYmluYXJ5IGV4cG9uZW50IHN1ZmZpeD9cclxuICAgICAgaWYgKGlzRXhwKSB7XHJcbiAgICAgICAgaWYgKGxlbiA+IDEpIHtcclxuICAgICAgICAgIGlmIChiYXNlT3V0ID09IDE2IHx8IGJhc2VPdXQgPT0gOCkge1xyXG4gICAgICAgICAgICBpID0gYmFzZU91dCA9PSAxNiA/IDQgOiAzO1xyXG4gICAgICAgICAgICBmb3IgKC0tbGVuOyBsZW4gJSBpOyBsZW4rKykgc3RyICs9ICcwJztcclxuICAgICAgICAgICAgeGQgPSBjb252ZXJ0QmFzZShzdHIsIGJhc2UsIGJhc2VPdXQpO1xyXG4gICAgICAgICAgICBmb3IgKGxlbiA9IHhkLmxlbmd0aDsgIXhkW2xlbiAtIDFdOyAtLWxlbik7XHJcblxyXG4gICAgICAgICAgICAvLyB4ZFswXSB3aWxsIGFsd2F5cyBiZSBiZSAxXHJcbiAgICAgICAgICAgIGZvciAoaSA9IDEsIHN0ciA9ICcxLic7IGkgPCBsZW47IGkrKykgc3RyICs9IE5VTUVSQUxTLmNoYXJBdCh4ZFtpXSk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBzdHIgPSBzdHIuY2hhckF0KDApICsgJy4nICsgc3RyLnNsaWNlKDEpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc3RyID0gIHN0ciArIChlIDwgMCA/ICdwJyA6ICdwKycpICsgZTtcclxuICAgICAgfSBlbHNlIGlmIChlIDwgMCkge1xyXG4gICAgICAgIGZvciAoOyArK2U7KSBzdHIgPSAnMCcgKyBzdHI7XHJcbiAgICAgICAgc3RyID0gJzAuJyArIHN0cjtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpZiAoKytlID4gbGVuKSBmb3IgKGUgLT0gbGVuOyBlLS0gOykgc3RyICs9ICcwJztcclxuICAgICAgICBlbHNlIGlmIChlIDwgbGVuKSBzdHIgPSBzdHIuc2xpY2UoMCwgZSkgKyAnLicgKyBzdHIuc2xpY2UoZSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBzdHIgPSAoYmFzZU91dCA9PSAxNiA/ICcweCcgOiBiYXNlT3V0ID09IDIgPyAnMGInIDogYmFzZU91dCA9PSA4ID8gJzBvJyA6ICcnKSArIHN0cjtcclxuICB9XHJcblxyXG4gIHJldHVybiB4LnMgPCAwID8gJy0nICsgc3RyIDogc3RyO1xyXG59XHJcblxyXG5cclxuLy8gRG9lcyBub3Qgc3RyaXAgdHJhaWxpbmcgemVyb3MuXHJcbmZ1bmN0aW9uIHRydW5jYXRlKGFyciwgbGVuKSB7XHJcbiAgaWYgKGFyci5sZW5ndGggPiBsZW4pIHtcclxuICAgIGFyci5sZW5ndGggPSBsZW47XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcbn1cclxuXHJcblxyXG4vLyBEZWNpbWFsIG1ldGhvZHNcclxuXHJcblxyXG4vKlxyXG4gKiAgYWJzXHJcbiAqICBhY29zXHJcbiAqICBhY29zaFxyXG4gKiAgYWRkXHJcbiAqICBhc2luXHJcbiAqICBhc2luaFxyXG4gKiAgYXRhblxyXG4gKiAgYXRhbmhcclxuICogIGF0YW4yXHJcbiAqICBjYnJ0XHJcbiAqICBjZWlsXHJcbiAqICBjbGFtcFxyXG4gKiAgY2xvbmVcclxuICogIGNvbmZpZ1xyXG4gKiAgY29zXHJcbiAqICBjb3NoXHJcbiAqICBkaXZcclxuICogIGV4cFxyXG4gKiAgZmxvb3JcclxuICogIGh5cG90XHJcbiAqICBsblxyXG4gKiAgbG9nXHJcbiAqICBsb2cyXHJcbiAqICBsb2cxMFxyXG4gKiAgbWF4XHJcbiAqICBtaW5cclxuICogIG1vZFxyXG4gKiAgbXVsXHJcbiAqICBwb3dcclxuICogIHJhbmRvbVxyXG4gKiAgcm91bmRcclxuICogIHNldFxyXG4gKiAgc2lnblxyXG4gKiAgc2luXHJcbiAqICBzaW5oXHJcbiAqICBzcXJ0XHJcbiAqICBzdWJcclxuICogIHN1bVxyXG4gKiAgdGFuXHJcbiAqICB0YW5oXHJcbiAqICB0cnVuY1xyXG4gKi9cclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgYWJzb2x1dGUgdmFsdWUgb2YgYHhgLlxyXG4gKlxyXG4gKiB4IHtudW1iZXJ8c3RyaW5nfERlY2ltYWx9XHJcbiAqXHJcbiAqL1xyXG5mdW5jdGlvbiBhYnMoeCkge1xyXG4gIHJldHVybiBuZXcgdGhpcyh4KS5hYnMoKTtcclxufVxyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSBhcmNjb3NpbmUgaW4gcmFkaWFucyBvZiBgeGAuXHJcbiAqXHJcbiAqIHgge251bWJlcnxzdHJpbmd8RGVjaW1hbH1cclxuICpcclxuICovXHJcbmZ1bmN0aW9uIGFjb3MoeCkge1xyXG4gIHJldHVybiBuZXcgdGhpcyh4KS5hY29zKCk7XHJcbn1cclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgaW52ZXJzZSBvZiB0aGUgaHlwZXJib2xpYyBjb3NpbmUgb2YgYHhgLCByb3VuZGVkIHRvXHJcbiAqIGBwcmVjaXNpb25gIHNpZ25pZmljYW50IGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIGByb3VuZGluZ2AuXHJcbiAqXHJcbiAqIHgge251bWJlcnxzdHJpbmd8RGVjaW1hbH0gQSB2YWx1ZSBpbiByYWRpYW5zLlxyXG4gKlxyXG4gKi9cclxuZnVuY3Rpb24gYWNvc2goeCkge1xyXG4gIHJldHVybiBuZXcgdGhpcyh4KS5hY29zaCgpO1xyXG59XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIHN1bSBvZiBgeGAgYW5kIGB5YCwgcm91bmRlZCB0byBgcHJlY2lzaW9uYCBzaWduaWZpY2FudFxyXG4gKiBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSBgcm91bmRpbmdgLlxyXG4gKlxyXG4gKiB4IHtudW1iZXJ8c3RyaW5nfERlY2ltYWx9XHJcbiAqIHkge251bWJlcnxzdHJpbmd8RGVjaW1hbH1cclxuICpcclxuICovXHJcbmZ1bmN0aW9uIGFkZCh4LCB5KSB7XHJcbiAgcmV0dXJuIG5ldyB0aGlzKHgpLnBsdXMoeSk7XHJcbn1cclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgYXJjc2luZSBpbiByYWRpYW5zIG9mIGB4YCwgcm91bmRlZCB0byBgcHJlY2lzaW9uYFxyXG4gKiBzaWduaWZpY2FudCBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSBgcm91bmRpbmdgLlxyXG4gKlxyXG4gKiB4IHtudW1iZXJ8c3RyaW5nfERlY2ltYWx9XHJcbiAqXHJcbiAqL1xyXG5mdW5jdGlvbiBhc2luKHgpIHtcclxuICByZXR1cm4gbmV3IHRoaXMoeCkuYXNpbigpO1xyXG59XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIGludmVyc2Ugb2YgdGhlIGh5cGVyYm9saWMgc2luZSBvZiBgeGAsIHJvdW5kZWQgdG9cclxuICogYHByZWNpc2lvbmAgc2lnbmlmaWNhbnQgZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJvdW5kaW5nYC5cclxuICpcclxuICogeCB7bnVtYmVyfHN0cmluZ3xEZWNpbWFsfSBBIHZhbHVlIGluIHJhZGlhbnMuXHJcbiAqXHJcbiAqL1xyXG5mdW5jdGlvbiBhc2luaCh4KSB7XHJcbiAgcmV0dXJuIG5ldyB0aGlzKHgpLmFzaW5oKCk7XHJcbn1cclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgYXJjdGFuZ2VudCBpbiByYWRpYW5zIG9mIGB4YCwgcm91bmRlZCB0byBgcHJlY2lzaW9uYFxyXG4gKiBzaWduaWZpY2FudCBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSBgcm91bmRpbmdgLlxyXG4gKlxyXG4gKiB4IHtudW1iZXJ8c3RyaW5nfERlY2ltYWx9XHJcbiAqXHJcbiAqL1xyXG5mdW5jdGlvbiBhdGFuKHgpIHtcclxuICByZXR1cm4gbmV3IHRoaXMoeCkuYXRhbigpO1xyXG59XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIGludmVyc2Ugb2YgdGhlIGh5cGVyYm9saWMgdGFuZ2VudCBvZiBgeGAsIHJvdW5kZWQgdG9cclxuICogYHByZWNpc2lvbmAgc2lnbmlmaWNhbnQgZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJvdW5kaW5nYC5cclxuICpcclxuICogeCB7bnVtYmVyfHN0cmluZ3xEZWNpbWFsfSBBIHZhbHVlIGluIHJhZGlhbnMuXHJcbiAqXHJcbiAqL1xyXG5mdW5jdGlvbiBhdGFuaCh4KSB7XHJcbiAgcmV0dXJuIG5ldyB0aGlzKHgpLmF0YW5oKCk7XHJcbn1cclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgYXJjdGFuZ2VudCBpbiByYWRpYW5zIG9mIGB5L3hgIGluIHRoZSByYW5nZSAtcGkgdG8gcGlcclxuICogKGluY2x1c2l2ZSksIHJvdW5kZWQgdG8gYHByZWNpc2lvbmAgc2lnbmlmaWNhbnQgZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJvdW5kaW5nYC5cclxuICpcclxuICogRG9tYWluOiBbLUluZmluaXR5LCBJbmZpbml0eV1cclxuICogUmFuZ2U6IFstcGksIHBpXVxyXG4gKlxyXG4gKiB5IHtudW1iZXJ8c3RyaW5nfERlY2ltYWx9IFRoZSB5LWNvb3JkaW5hdGUuXHJcbiAqIHgge251bWJlcnxzdHJpbmd8RGVjaW1hbH0gVGhlIHgtY29vcmRpbmF0ZS5cclxuICpcclxuICogYXRhbjIowrEwLCAtMCkgICAgICAgICAgICAgICA9IMKxcGlcclxuICogYXRhbjIowrEwLCArMCkgICAgICAgICAgICAgICA9IMKxMFxyXG4gKiBhdGFuMijCsTAsIC14KSAgICAgICAgICAgICAgID0gwrFwaSBmb3IgeCA+IDBcclxuICogYXRhbjIowrEwLCB4KSAgICAgICAgICAgICAgICA9IMKxMCBmb3IgeCA+IDBcclxuICogYXRhbjIoLXksIMKxMCkgICAgICAgICAgICAgICA9IC1waS8yIGZvciB5ID4gMFxyXG4gKiBhdGFuMih5LCDCsTApICAgICAgICAgICAgICAgID0gcGkvMiBmb3IgeSA+IDBcclxuICogYXRhbjIowrF5LCAtSW5maW5pdHkpICAgICAgICA9IMKxcGkgZm9yIGZpbml0ZSB5ID4gMFxyXG4gKiBhdGFuMijCsXksICtJbmZpbml0eSkgICAgICAgID0gwrEwIGZvciBmaW5pdGUgeSA+IDBcclxuICogYXRhbjIowrFJbmZpbml0eSwgeCkgICAgICAgICA9IMKxcGkvMiBmb3IgZmluaXRlIHhcclxuICogYXRhbjIowrFJbmZpbml0eSwgLUluZmluaXR5KSA9IMKxMypwaS80XHJcbiAqIGF0YW4yKMKxSW5maW5pdHksICtJbmZpbml0eSkgPSDCsXBpLzRcclxuICogYXRhbjIoTmFOLCB4KSA9IE5hTlxyXG4gKiBhdGFuMih5LCBOYU4pID0gTmFOXHJcbiAqXHJcbiAqL1xyXG5mdW5jdGlvbiBhdGFuMih5LCB4KSB7XHJcbiAgeSA9IG5ldyB0aGlzKHkpO1xyXG4gIHggPSBuZXcgdGhpcyh4KTtcclxuICB2YXIgcixcclxuICAgIHByID0gdGhpcy5wcmVjaXNpb24sXHJcbiAgICBybSA9IHRoaXMucm91bmRpbmcsXHJcbiAgICB3cHIgPSBwciArIDQ7XHJcblxyXG4gIC8vIEVpdGhlciBOYU5cclxuICBpZiAoIXkucyB8fCAheC5zKSB7XHJcbiAgICByID0gbmV3IHRoaXMoTmFOKTtcclxuXHJcbiAgLy8gQm90aCDCsUluZmluaXR5XHJcbiAgfSBlbHNlIGlmICgheS5kICYmICF4LmQpIHtcclxuICAgIHIgPSBnZXRQaSh0aGlzLCB3cHIsIDEpLnRpbWVzKHgucyA+IDAgPyAwLjI1IDogMC43NSk7XHJcbiAgICByLnMgPSB5LnM7XHJcblxyXG4gIC8vIHggaXMgwrFJbmZpbml0eSBvciB5IGlzIMKxMFxyXG4gIH0gZWxzZSBpZiAoIXguZCB8fCB5LmlzWmVybygpKSB7XHJcbiAgICByID0geC5zIDwgMCA/IGdldFBpKHRoaXMsIHByLCBybSkgOiBuZXcgdGhpcygwKTtcclxuICAgIHIucyA9IHkucztcclxuXHJcbiAgLy8geSBpcyDCsUluZmluaXR5IG9yIHggaXMgwrEwXHJcbiAgfSBlbHNlIGlmICgheS5kIHx8IHguaXNaZXJvKCkpIHtcclxuICAgIHIgPSBnZXRQaSh0aGlzLCB3cHIsIDEpLnRpbWVzKDAuNSk7XHJcbiAgICByLnMgPSB5LnM7XHJcblxyXG4gIC8vIEJvdGggbm9uLXplcm8gYW5kIGZpbml0ZVxyXG4gIH0gZWxzZSBpZiAoeC5zIDwgMCkge1xyXG4gICAgdGhpcy5wcmVjaXNpb24gPSB3cHI7XHJcbiAgICB0aGlzLnJvdW5kaW5nID0gMTtcclxuICAgIHIgPSB0aGlzLmF0YW4oZGl2aWRlKHksIHgsIHdwciwgMSkpO1xyXG4gICAgeCA9IGdldFBpKHRoaXMsIHdwciwgMSk7XHJcbiAgICB0aGlzLnByZWNpc2lvbiA9IHByO1xyXG4gICAgdGhpcy5yb3VuZGluZyA9IHJtO1xyXG4gICAgciA9IHkucyA8IDAgPyByLm1pbnVzKHgpIDogci5wbHVzKHgpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICByID0gdGhpcy5hdGFuKGRpdmlkZSh5LCB4LCB3cHIsIDEpKTtcclxuICB9XHJcblxyXG4gIHJldHVybiByO1xyXG59XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIGN1YmUgcm9vdCBvZiBgeGAsIHJvdW5kZWQgdG8gYHByZWNpc2lvbmAgc2lnbmlmaWNhbnRcclxuICogZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJvdW5kaW5nYC5cclxuICpcclxuICogeCB7bnVtYmVyfHN0cmluZ3xEZWNpbWFsfVxyXG4gKlxyXG4gKi9cclxuZnVuY3Rpb24gY2JydCh4KSB7XHJcbiAgcmV0dXJuIG5ldyB0aGlzKHgpLmNicnQoKTtcclxufVxyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIGB4YCByb3VuZGVkIHRvIGFuIGludGVnZXIgdXNpbmcgYFJPVU5EX0NFSUxgLlxyXG4gKlxyXG4gKiB4IHtudW1iZXJ8c3RyaW5nfERlY2ltYWx9XHJcbiAqXHJcbiAqL1xyXG5mdW5jdGlvbiBjZWlsKHgpIHtcclxuICByZXR1cm4gZmluYWxpc2UoeCA9IG5ldyB0aGlzKHgpLCB4LmUgKyAxLCAyKTtcclxufVxyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIGB4YCBjbGFtcGVkIHRvIHRoZSByYW5nZSBkZWxpbmVhdGVkIGJ5IGBtaW5gIGFuZCBgbWF4YC5cclxuICpcclxuICogeCB7bnVtYmVyfHN0cmluZ3xEZWNpbWFsfVxyXG4gKiBtaW4ge251bWJlcnxzdHJpbmd8RGVjaW1hbH1cclxuICogbWF4IHtudW1iZXJ8c3RyaW5nfERlY2ltYWx9XHJcbiAqXHJcbiAqL1xyXG5mdW5jdGlvbiBjbGFtcCh4LCBtaW4sIG1heCkge1xyXG4gIHJldHVybiBuZXcgdGhpcyh4KS5jbGFtcChtaW4sIG1heCk7XHJcbn1cclxuXHJcblxyXG4vKlxyXG4gKiBDb25maWd1cmUgZ2xvYmFsIHNldHRpbmdzIGZvciBhIERlY2ltYWwgY29uc3RydWN0b3IuXHJcbiAqXHJcbiAqIGBvYmpgIGlzIGFuIG9iamVjdCB3aXRoIG9uZSBvciBtb3JlIG9mIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllcyxcclxuICpcclxuICogICBwcmVjaXNpb24gIHtudW1iZXJ9XHJcbiAqICAgcm91bmRpbmcgICB7bnVtYmVyfVxyXG4gKiAgIHRvRXhwTmVnICAge251bWJlcn1cclxuICogICB0b0V4cFBvcyAgIHtudW1iZXJ9XHJcbiAqICAgbWF4RSAgICAgICB7bnVtYmVyfVxyXG4gKiAgIG1pbkUgICAgICAge251bWJlcn1cclxuICogICBtb2R1bG8gICAgIHtudW1iZXJ9XHJcbiAqICAgY3J5cHRvICAgICB7Ym9vbGVhbnxudW1iZXJ9XHJcbiAqICAgZGVmYXVsdHMgICB7dHJ1ZX1cclxuICpcclxuICogRS5nLiBEZWNpbWFsLmNvbmZpZyh7IHByZWNpc2lvbjogMjAsIHJvdW5kaW5nOiA0IH0pXHJcbiAqXHJcbiAqL1xyXG5mdW5jdGlvbiBjb25maWcob2JqKSB7XHJcbiAgaWYgKCFvYmogfHwgdHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpIHRocm93IEVycm9yKGRlY2ltYWxFcnJvciArICdPYmplY3QgZXhwZWN0ZWQnKTtcclxuICB2YXIgaSwgcCwgdixcclxuICAgIHVzZURlZmF1bHRzID0gb2JqLmRlZmF1bHRzID09PSB0cnVlLFxyXG4gICAgcHMgPSBbXHJcbiAgICAgICdwcmVjaXNpb24nLCAxLCBNQVhfRElHSVRTLFxyXG4gICAgICAncm91bmRpbmcnLCAwLCA4LFxyXG4gICAgICAndG9FeHBOZWcnLCAtRVhQX0xJTUlULCAwLFxyXG4gICAgICAndG9FeHBQb3MnLCAwLCBFWFBfTElNSVQsXHJcbiAgICAgICdtYXhFJywgMCwgRVhQX0xJTUlULFxyXG4gICAgICAnbWluRScsIC1FWFBfTElNSVQsIDAsXHJcbiAgICAgICdtb2R1bG8nLCAwLCA5XHJcbiAgICBdO1xyXG5cclxuICBmb3IgKGkgPSAwOyBpIDwgcHMubGVuZ3RoOyBpICs9IDMpIHtcclxuICAgIGlmIChwID0gcHNbaV0sIHVzZURlZmF1bHRzKSB0aGlzW3BdID0gREVGQVVMVFNbcF07XHJcbiAgICBpZiAoKHYgPSBvYmpbcF0pICE9PSB2b2lkIDApIHtcclxuICAgICAgaWYgKG1hdGhmbG9vcih2KSA9PT0gdiAmJiB2ID49IHBzW2kgKyAxXSAmJiB2IDw9IHBzW2kgKyAyXSkgdGhpc1twXSA9IHY7XHJcbiAgICAgIGVsc2UgdGhyb3cgRXJyb3IoaW52YWxpZEFyZ3VtZW50ICsgcCArICc6ICcgKyB2KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGlmIChwID0gJ2NyeXB0bycsIHVzZURlZmF1bHRzKSB0aGlzW3BdID0gREVGQVVMVFNbcF07XHJcbiAgaWYgKCh2ID0gb2JqW3BdKSAhPT0gdm9pZCAwKSB7XHJcbiAgICBpZiAodiA9PT0gdHJ1ZSB8fCB2ID09PSBmYWxzZSB8fCB2ID09PSAwIHx8IHYgPT09IDEpIHtcclxuICAgICAgaWYgKHYpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGNyeXB0byAhPSAndW5kZWZpbmVkJyAmJiBjcnlwdG8gJiZcclxuICAgICAgICAgIChjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzIHx8IGNyeXB0by5yYW5kb21CeXRlcykpIHtcclxuICAgICAgICAgIHRoaXNbcF0gPSB0cnVlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB0aHJvdyBFcnJvcihjcnlwdG9VbmF2YWlsYWJsZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXNbcF0gPSBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhyb3cgRXJyb3IoaW52YWxpZEFyZ3VtZW50ICsgcCArICc6ICcgKyB2KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiB0aGlzO1xyXG59XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIGNvc2luZSBvZiBgeGAsIHJvdW5kZWQgdG8gYHByZWNpc2lvbmAgc2lnbmlmaWNhbnRcclxuICogZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJvdW5kaW5nYC5cclxuICpcclxuICogeCB7bnVtYmVyfHN0cmluZ3xEZWNpbWFsfSBBIHZhbHVlIGluIHJhZGlhbnMuXHJcbiAqXHJcbiAqL1xyXG5mdW5jdGlvbiBjb3MoeCkge1xyXG4gIHJldHVybiBuZXcgdGhpcyh4KS5jb3MoKTtcclxufVxyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSBoeXBlcmJvbGljIGNvc2luZSBvZiBgeGAsIHJvdW5kZWQgdG8gcHJlY2lzaW9uXHJcbiAqIHNpZ25pZmljYW50IGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIGByb3VuZGluZ2AuXHJcbiAqXHJcbiAqIHgge251bWJlcnxzdHJpbmd8RGVjaW1hbH0gQSB2YWx1ZSBpbiByYWRpYW5zLlxyXG4gKlxyXG4gKi9cclxuZnVuY3Rpb24gY29zaCh4KSB7XHJcbiAgcmV0dXJuIG5ldyB0aGlzKHgpLmNvc2goKTtcclxufVxyXG5cclxuXHJcbi8qXHJcbiAqIENyZWF0ZSBhbmQgcmV0dXJuIGEgRGVjaW1hbCBjb25zdHJ1Y3RvciB3aXRoIHRoZSBzYW1lIGNvbmZpZ3VyYXRpb24gcHJvcGVydGllcyBhcyB0aGlzIERlY2ltYWxcclxuICogY29uc3RydWN0b3IuXHJcbiAqXHJcbiAqL1xyXG5mdW5jdGlvbiBjbG9uZShvYmopIHtcclxuICB2YXIgaSwgcCwgcHM7XHJcblxyXG4gIC8qXHJcbiAgICogVGhlIERlY2ltYWwgY29uc3RydWN0b3IgYW5kIGV4cG9ydGVkIGZ1bmN0aW9uLlxyXG4gICAqIFJldHVybiBhIG5ldyBEZWNpbWFsIGluc3RhbmNlLlxyXG4gICAqXHJcbiAgICogdiB7bnVtYmVyfHN0cmluZ3xEZWNpbWFsfSBBIG51bWVyaWMgdmFsdWUuXHJcbiAgICpcclxuICAgKi9cclxuICBmdW5jdGlvbiBEZWNpbWFsKHYpIHtcclxuICAgIHZhciBlLCBpLCB0LFxyXG4gICAgICB4ID0gdGhpcztcclxuXHJcbiAgICAvLyBEZWNpbWFsIGNhbGxlZCB3aXRob3V0IG5ldy5cclxuICAgIGlmICghKHggaW5zdGFuY2VvZiBEZWNpbWFsKSkgcmV0dXJuIG5ldyBEZWNpbWFsKHYpO1xyXG5cclxuICAgIC8vIFJldGFpbiBhIHJlZmVyZW5jZSB0byB0aGlzIERlY2ltYWwgY29uc3RydWN0b3IsIGFuZCBzaGFkb3cgRGVjaW1hbC5wcm90b3R5cGUuY29uc3RydWN0b3JcclxuICAgIC8vIHdoaWNoIHBvaW50cyB0byBPYmplY3QuXHJcbiAgICB4LmNvbnN0cnVjdG9yID0gRGVjaW1hbDtcclxuXHJcbiAgICAvLyBEdXBsaWNhdGUuXHJcbiAgICBpZiAoaXNEZWNpbWFsSW5zdGFuY2UodikpIHtcclxuICAgICAgeC5zID0gdi5zO1xyXG5cclxuICAgICAgaWYgKGV4dGVybmFsKSB7XHJcbiAgICAgICAgaWYgKCF2LmQgfHwgdi5lID4gRGVjaW1hbC5tYXhFKSB7XHJcblxyXG4gICAgICAgICAgLy8gSW5maW5pdHkuXHJcbiAgICAgICAgICB4LmUgPSBOYU47XHJcbiAgICAgICAgICB4LmQgPSBudWxsO1xyXG4gICAgICAgIH0gZWxzZSBpZiAodi5lIDwgRGVjaW1hbC5taW5FKSB7XHJcblxyXG4gICAgICAgICAgLy8gWmVyby5cclxuICAgICAgICAgIHguZSA9IDA7XHJcbiAgICAgICAgICB4LmQgPSBbMF07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHguZSA9IHYuZTtcclxuICAgICAgICAgIHguZCA9IHYuZC5zbGljZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB4LmUgPSB2LmU7XHJcbiAgICAgICAgeC5kID0gdi5kID8gdi5kLnNsaWNlKCkgOiB2LmQ7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB0ID0gdHlwZW9mIHY7XHJcblxyXG4gICAgaWYgKHQgPT09ICdudW1iZXInKSB7XHJcbiAgICAgIGlmICh2ID09PSAwKSB7XHJcbiAgICAgICAgeC5zID0gMSAvIHYgPCAwID8gLTEgOiAxO1xyXG4gICAgICAgIHguZSA9IDA7XHJcbiAgICAgICAgeC5kID0gWzBdO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHYgPCAwKSB7XHJcbiAgICAgICAgdiA9IC12O1xyXG4gICAgICAgIHgucyA9IC0xO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHgucyA9IDE7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEZhc3QgcGF0aCBmb3Igc21hbGwgaW50ZWdlcnMuXHJcbiAgICAgIGlmICh2ID09PSB+fnYgJiYgdiA8IDFlNykge1xyXG4gICAgICAgIGZvciAoZSA9IDAsIGkgPSB2OyBpID49IDEwOyBpIC89IDEwKSBlKys7XHJcblxyXG4gICAgICAgIGlmIChleHRlcm5hbCkge1xyXG4gICAgICAgICAgaWYgKGUgPiBEZWNpbWFsLm1heEUpIHtcclxuICAgICAgICAgICAgeC5lID0gTmFOO1xyXG4gICAgICAgICAgICB4LmQgPSBudWxsO1xyXG4gICAgICAgICAgfSBlbHNlIGlmIChlIDwgRGVjaW1hbC5taW5FKSB7XHJcbiAgICAgICAgICAgIHguZSA9IDA7XHJcbiAgICAgICAgICAgIHguZCA9IFswXTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHguZSA9IGU7XHJcbiAgICAgICAgICAgIHguZCA9IFt2XTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgeC5lID0gZTtcclxuICAgICAgICAgIHguZCA9IFt2XTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgIC8vIEluZmluaXR5LCBOYU4uXHJcbiAgICAgIH0gZWxzZSBpZiAodiAqIDAgIT09IDApIHtcclxuICAgICAgICBpZiAoIXYpIHgucyA9IE5hTjtcclxuICAgICAgICB4LmUgPSBOYU47XHJcbiAgICAgICAgeC5kID0gbnVsbDtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBwYXJzZURlY2ltYWwoeCwgdi50b1N0cmluZygpKTtcclxuXHJcbiAgICB9IGVsc2UgaWYgKHQgIT09ICdzdHJpbmcnKSB7XHJcbiAgICAgIHRocm93IEVycm9yKGludmFsaWRBcmd1bWVudCArIHYpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIE1pbnVzIHNpZ24/XHJcbiAgICBpZiAoKGkgPSB2LmNoYXJDb2RlQXQoMCkpID09PSA0NSkge1xyXG4gICAgICB2ID0gdi5zbGljZSgxKTtcclxuICAgICAgeC5zID0gLTE7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBQbHVzIHNpZ24/XHJcbiAgICAgIGlmIChpID09PSA0MykgdiA9IHYuc2xpY2UoMSk7XHJcbiAgICAgIHgucyA9IDE7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGlzRGVjaW1hbC50ZXN0KHYpID8gcGFyc2VEZWNpbWFsKHgsIHYpIDogcGFyc2VPdGhlcih4LCB2KTtcclxuICB9XHJcblxyXG4gIERlY2ltYWwucHJvdG90eXBlID0gUDtcclxuXHJcbiAgRGVjaW1hbC5ST1VORF9VUCA9IDA7XHJcbiAgRGVjaW1hbC5ST1VORF9ET1dOID0gMTtcclxuICBEZWNpbWFsLlJPVU5EX0NFSUwgPSAyO1xyXG4gIERlY2ltYWwuUk9VTkRfRkxPT1IgPSAzO1xyXG4gIERlY2ltYWwuUk9VTkRfSEFMRl9VUCA9IDQ7XHJcbiAgRGVjaW1hbC5ST1VORF9IQUxGX0RPV04gPSA1O1xyXG4gIERlY2ltYWwuUk9VTkRfSEFMRl9FVkVOID0gNjtcclxuICBEZWNpbWFsLlJPVU5EX0hBTEZfQ0VJTCA9IDc7XHJcbiAgRGVjaW1hbC5ST1VORF9IQUxGX0ZMT09SID0gODtcclxuICBEZWNpbWFsLkVVQ0xJRCA9IDk7XHJcblxyXG4gIERlY2ltYWwuY29uZmlnID0gRGVjaW1hbC5zZXQgPSBjb25maWc7XHJcbiAgRGVjaW1hbC5jbG9uZSA9IGNsb25lO1xyXG4gIERlY2ltYWwuaXNEZWNpbWFsID0gaXNEZWNpbWFsSW5zdGFuY2U7XHJcblxyXG4gIERlY2ltYWwuYWJzID0gYWJzO1xyXG4gIERlY2ltYWwuYWNvcyA9IGFjb3M7XHJcbiAgRGVjaW1hbC5hY29zaCA9IGFjb3NoOyAgICAgICAgLy8gRVM2XHJcbiAgRGVjaW1hbC5hZGQgPSBhZGQ7XHJcbiAgRGVjaW1hbC5hc2luID0gYXNpbjtcclxuICBEZWNpbWFsLmFzaW5oID0gYXNpbmg7ICAgICAgICAvLyBFUzZcclxuICBEZWNpbWFsLmF0YW4gPSBhdGFuO1xyXG4gIERlY2ltYWwuYXRhbmggPSBhdGFuaDsgICAgICAgIC8vIEVTNlxyXG4gIERlY2ltYWwuYXRhbjIgPSBhdGFuMjtcclxuICBEZWNpbWFsLmNicnQgPSBjYnJ0OyAgICAgICAgICAvLyBFUzZcclxuICBEZWNpbWFsLmNlaWwgPSBjZWlsO1xyXG4gIERlY2ltYWwuY2xhbXAgPSBjbGFtcDtcclxuICBEZWNpbWFsLmNvcyA9IGNvcztcclxuICBEZWNpbWFsLmNvc2ggPSBjb3NoOyAgICAgICAgICAvLyBFUzZcclxuICBEZWNpbWFsLmRpdiA9IGRpdjtcclxuICBEZWNpbWFsLmV4cCA9IGV4cDtcclxuICBEZWNpbWFsLmZsb29yID0gZmxvb3I7XHJcbiAgRGVjaW1hbC5oeXBvdCA9IGh5cG90OyAgICAgICAgLy8gRVM2XHJcbiAgRGVjaW1hbC5sbiA9IGxuO1xyXG4gIERlY2ltYWwubG9nID0gbG9nO1xyXG4gIERlY2ltYWwubG9nMTAgPSBsb2cxMDsgICAgICAgIC8vIEVTNlxyXG4gIERlY2ltYWwubG9nMiA9IGxvZzI7ICAgICAgICAgIC8vIEVTNlxyXG4gIERlY2ltYWwubWF4ID0gbWF4O1xyXG4gIERlY2ltYWwubWluID0gbWluO1xyXG4gIERlY2ltYWwubW9kID0gbW9kO1xyXG4gIERlY2ltYWwubXVsID0gbXVsO1xyXG4gIERlY2ltYWwucG93ID0gcG93O1xyXG4gIERlY2ltYWwucmFuZG9tID0gcmFuZG9tO1xyXG4gIERlY2ltYWwucm91bmQgPSByb3VuZDtcclxuICBEZWNpbWFsLnNpZ24gPSBzaWduOyAgICAgICAgICAvLyBFUzZcclxuICBEZWNpbWFsLnNpbiA9IHNpbjtcclxuICBEZWNpbWFsLnNpbmggPSBzaW5oOyAgICAgICAgICAvLyBFUzZcclxuICBEZWNpbWFsLnNxcnQgPSBzcXJ0O1xyXG4gIERlY2ltYWwuc3ViID0gc3ViO1xyXG4gIERlY2ltYWwuc3VtID0gc3VtO1xyXG4gIERlY2ltYWwudGFuID0gdGFuO1xyXG4gIERlY2ltYWwudGFuaCA9IHRhbmg7ICAgICAgICAgIC8vIEVTNlxyXG4gIERlY2ltYWwudHJ1bmMgPSB0cnVuYzsgICAgICAgIC8vIEVTNlxyXG5cclxuICBpZiAob2JqID09PSB2b2lkIDApIG9iaiA9IHt9O1xyXG4gIGlmIChvYmopIHtcclxuICAgIGlmIChvYmouZGVmYXVsdHMgIT09IHRydWUpIHtcclxuICAgICAgcHMgPSBbJ3ByZWNpc2lvbicsICdyb3VuZGluZycsICd0b0V4cE5lZycsICd0b0V4cFBvcycsICdtYXhFJywgJ21pbkUnLCAnbW9kdWxvJywgJ2NyeXB0byddO1xyXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgcHMubGVuZ3RoOykgaWYgKCFvYmouaGFzT3duUHJvcGVydHkocCA9IHBzW2krK10pKSBvYmpbcF0gPSB0aGlzW3BdO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgRGVjaW1hbC5jb25maWcob2JqKTtcclxuXHJcbiAgcmV0dXJuIERlY2ltYWw7XHJcbn1cclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyBgeGAgZGl2aWRlZCBieSBgeWAsIHJvdW5kZWQgdG8gYHByZWNpc2lvbmAgc2lnbmlmaWNhbnRcclxuICogZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJvdW5kaW5nYC5cclxuICpcclxuICogeCB7bnVtYmVyfHN0cmluZ3xEZWNpbWFsfVxyXG4gKiB5IHtudW1iZXJ8c3RyaW5nfERlY2ltYWx9XHJcbiAqXHJcbiAqL1xyXG5mdW5jdGlvbiBkaXYoeCwgeSkge1xyXG4gIHJldHVybiBuZXcgdGhpcyh4KS5kaXYoeSk7XHJcbn1cclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgbmF0dXJhbCBleHBvbmVudGlhbCBvZiBgeGAsIHJvdW5kZWQgdG8gYHByZWNpc2lvbmBcclxuICogc2lnbmlmaWNhbnQgZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJvdW5kaW5nYC5cclxuICpcclxuICogeCB7bnVtYmVyfHN0cmluZ3xEZWNpbWFsfSBUaGUgcG93ZXIgdG8gd2hpY2ggdG8gcmFpc2UgdGhlIGJhc2Ugb2YgdGhlIG5hdHVyYWwgbG9nLlxyXG4gKlxyXG4gKi9cclxuZnVuY3Rpb24gZXhwKHgpIHtcclxuICByZXR1cm4gbmV3IHRoaXMoeCkuZXhwKCk7XHJcbn1cclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyBgeGAgcm91bmQgdG8gYW4gaW50ZWdlciB1c2luZyBgUk9VTkRfRkxPT1JgLlxyXG4gKlxyXG4gKiB4IHtudW1iZXJ8c3RyaW5nfERlY2ltYWx9XHJcbiAqXHJcbiAqL1xyXG5mdW5jdGlvbiBmbG9vcih4KSB7XHJcbiAgcmV0dXJuIGZpbmFsaXNlKHggPSBuZXcgdGhpcyh4KSwgeC5lICsgMSwgMyk7XHJcbn1cclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgc3F1YXJlIHJvb3Qgb2YgdGhlIHN1bSBvZiB0aGUgc3F1YXJlcyBvZiB0aGUgYXJndW1lbnRzLFxyXG4gKiByb3VuZGVkIHRvIGBwcmVjaXNpb25gIHNpZ25pZmljYW50IGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIGByb3VuZGluZ2AuXHJcbiAqXHJcbiAqIGh5cG90KGEsIGIsIC4uLikgPSBzcXJ0KGFeMiArIGJeMiArIC4uLilcclxuICpcclxuICogYXJndW1lbnRzIHtudW1iZXJ8c3RyaW5nfERlY2ltYWx9XHJcbiAqXHJcbiAqL1xyXG5mdW5jdGlvbiBoeXBvdCgpIHtcclxuICB2YXIgaSwgbixcclxuICAgIHQgPSBuZXcgdGhpcygwKTtcclxuXHJcbiAgZXh0ZXJuYWwgPSBmYWxzZTtcclxuXHJcbiAgZm9yIChpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7KSB7XHJcbiAgICBuID0gbmV3IHRoaXMoYXJndW1lbnRzW2krK10pO1xyXG4gICAgaWYgKCFuLmQpIHtcclxuICAgICAgaWYgKG4ucykge1xyXG4gICAgICAgIGV4dGVybmFsID0gdHJ1ZTtcclxuICAgICAgICByZXR1cm4gbmV3IHRoaXMoMSAvIDApO1xyXG4gICAgICB9XHJcbiAgICAgIHQgPSBuO1xyXG4gICAgfSBlbHNlIGlmICh0LmQpIHtcclxuICAgICAgdCA9IHQucGx1cyhuLnRpbWVzKG4pKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGV4dGVybmFsID0gdHJ1ZTtcclxuXHJcbiAgcmV0dXJuIHQuc3FydCgpO1xyXG59XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIHRydWUgaWYgb2JqZWN0IGlzIGEgRGVjaW1hbCBpbnN0YW5jZSAod2hlcmUgRGVjaW1hbCBpcyBhbnkgRGVjaW1hbCBjb25zdHJ1Y3RvciksXHJcbiAqIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAqXHJcbiAqL1xyXG5mdW5jdGlvbiBpc0RlY2ltYWxJbnN0YW5jZShvYmopIHtcclxuICByZXR1cm4gb2JqIGluc3RhbmNlb2YgRGVjaW1hbCB8fCBvYmogJiYgb2JqLnRvU3RyaW5nVGFnID09PSB0YWcgfHwgZmFsc2U7XHJcbn1cclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgbmF0dXJhbCBsb2dhcml0aG0gb2YgYHhgLCByb3VuZGVkIHRvIGBwcmVjaXNpb25gXHJcbiAqIHNpZ25pZmljYW50IGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIGByb3VuZGluZ2AuXHJcbiAqXHJcbiAqIHgge251bWJlcnxzdHJpbmd8RGVjaW1hbH1cclxuICpcclxuICovXHJcbmZ1bmN0aW9uIGxuKHgpIHtcclxuICByZXR1cm4gbmV3IHRoaXMoeCkubG4oKTtcclxufVxyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSBsb2cgb2YgYHhgIHRvIHRoZSBiYXNlIGB5YCwgb3IgdG8gYmFzZSAxMCBpZiBubyBiYXNlXHJcbiAqIGlzIHNwZWNpZmllZCwgcm91bmRlZCB0byBgcHJlY2lzaW9uYCBzaWduaWZpY2FudCBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSBgcm91bmRpbmdgLlxyXG4gKlxyXG4gKiBsb2dbeV0oeClcclxuICpcclxuICogeCB7bnVtYmVyfHN0cmluZ3xEZWNpbWFsfSBUaGUgYXJndW1lbnQgb2YgdGhlIGxvZ2FyaXRobS5cclxuICogeSB7bnVtYmVyfHN0cmluZ3xEZWNpbWFsfSBUaGUgYmFzZSBvZiB0aGUgbG9nYXJpdGhtLlxyXG4gKlxyXG4gKi9cclxuZnVuY3Rpb24gbG9nKHgsIHkpIHtcclxuICByZXR1cm4gbmV3IHRoaXMoeCkubG9nKHkpO1xyXG59XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIGJhc2UgMiBsb2dhcml0aG0gb2YgYHhgLCByb3VuZGVkIHRvIGBwcmVjaXNpb25gXHJcbiAqIHNpZ25pZmljYW50IGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIGByb3VuZGluZ2AuXHJcbiAqXHJcbiAqIHgge251bWJlcnxzdHJpbmd8RGVjaW1hbH1cclxuICpcclxuICovXHJcbmZ1bmN0aW9uIGxvZzIoeCkge1xyXG4gIHJldHVybiBuZXcgdGhpcyh4KS5sb2coMik7XHJcbn1cclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgYmFzZSAxMCBsb2dhcml0aG0gb2YgYHhgLCByb3VuZGVkIHRvIGBwcmVjaXNpb25gXHJcbiAqIHNpZ25pZmljYW50IGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIGByb3VuZGluZ2AuXHJcbiAqXHJcbiAqIHgge251bWJlcnxzdHJpbmd8RGVjaW1hbH1cclxuICpcclxuICovXHJcbmZ1bmN0aW9uIGxvZzEwKHgpIHtcclxuICByZXR1cm4gbmV3IHRoaXMoeCkubG9nKDEwKTtcclxufVxyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSBtYXhpbXVtIG9mIHRoZSBhcmd1bWVudHMuXHJcbiAqXHJcbiAqIGFyZ3VtZW50cyB7bnVtYmVyfHN0cmluZ3xEZWNpbWFsfVxyXG4gKlxyXG4gKi9cclxuZnVuY3Rpb24gbWF4KCkge1xyXG4gIHJldHVybiBtYXhPck1pbih0aGlzLCBhcmd1bWVudHMsICdsdCcpO1xyXG59XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIG1pbmltdW0gb2YgdGhlIGFyZ3VtZW50cy5cclxuICpcclxuICogYXJndW1lbnRzIHtudW1iZXJ8c3RyaW5nfERlY2ltYWx9XHJcbiAqXHJcbiAqL1xyXG5mdW5jdGlvbiBtaW4oKSB7XHJcbiAgcmV0dXJuIG1heE9yTWluKHRoaXMsIGFyZ3VtZW50cywgJ2d0Jyk7XHJcbn1cclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyBgeGAgbW9kdWxvIGB5YCwgcm91bmRlZCB0byBgcHJlY2lzaW9uYCBzaWduaWZpY2FudCBkaWdpdHNcclxuICogdXNpbmcgcm91bmRpbmcgbW9kZSBgcm91bmRpbmdgLlxyXG4gKlxyXG4gKiB4IHtudW1iZXJ8c3RyaW5nfERlY2ltYWx9XHJcbiAqIHkge251bWJlcnxzdHJpbmd8RGVjaW1hbH1cclxuICpcclxuICovXHJcbmZ1bmN0aW9uIG1vZCh4LCB5KSB7XHJcbiAgcmV0dXJuIG5ldyB0aGlzKHgpLm1vZCh5KTtcclxufVxyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIGB4YCBtdWx0aXBsaWVkIGJ5IGB5YCwgcm91bmRlZCB0byBgcHJlY2lzaW9uYCBzaWduaWZpY2FudFxyXG4gKiBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSBgcm91bmRpbmdgLlxyXG4gKlxyXG4gKiB4IHtudW1iZXJ8c3RyaW5nfERlY2ltYWx9XHJcbiAqIHkge251bWJlcnxzdHJpbmd8RGVjaW1hbH1cclxuICpcclxuICovXHJcbmZ1bmN0aW9uIG11bCh4LCB5KSB7XHJcbiAgcmV0dXJuIG5ldyB0aGlzKHgpLm11bCh5KTtcclxufVxyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIGB4YCByYWlzZWQgdG8gdGhlIHBvd2VyIGB5YCwgcm91bmRlZCB0byBwcmVjaXNpb25cclxuICogc2lnbmlmaWNhbnQgZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJvdW5kaW5nYC5cclxuICpcclxuICogeCB7bnVtYmVyfHN0cmluZ3xEZWNpbWFsfSBUaGUgYmFzZS5cclxuICogeSB7bnVtYmVyfHN0cmluZ3xEZWNpbWFsfSBUaGUgZXhwb25lbnQuXHJcbiAqXHJcbiAqL1xyXG5mdW5jdGlvbiBwb3coeCwgeSkge1xyXG4gIHJldHVybiBuZXcgdGhpcyh4KS5wb3coeSk7XHJcbn1cclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm5zIGEgbmV3IERlY2ltYWwgd2l0aCBhIHJhbmRvbSB2YWx1ZSBlcXVhbCB0byBvciBncmVhdGVyIHRoYW4gMCBhbmQgbGVzcyB0aGFuIDEsIGFuZCB3aXRoXHJcbiAqIGBzZGAsIG9yIGBEZWNpbWFsLnByZWNpc2lvbmAgaWYgYHNkYCBpcyBvbWl0dGVkLCBzaWduaWZpY2FudCBkaWdpdHMgKG9yIGxlc3MgaWYgdHJhaWxpbmcgemVyb3NcclxuICogYXJlIHByb2R1Y2VkKS5cclxuICpcclxuICogW3NkXSB7bnVtYmVyfSBTaWduaWZpY2FudCBkaWdpdHMuIEludGVnZXIsIDAgdG8gTUFYX0RJR0lUUyBpbmNsdXNpdmUuXHJcbiAqXHJcbiAqL1xyXG5mdW5jdGlvbiByYW5kb20oc2QpIHtcclxuICB2YXIgZCwgZSwgaywgbixcclxuICAgIGkgPSAwLFxyXG4gICAgciA9IG5ldyB0aGlzKDEpLFxyXG4gICAgcmQgPSBbXTtcclxuXHJcbiAgaWYgKHNkID09PSB2b2lkIDApIHNkID0gdGhpcy5wcmVjaXNpb247XHJcbiAgZWxzZSBjaGVja0ludDMyKHNkLCAxLCBNQVhfRElHSVRTKTtcclxuXHJcbiAgayA9IE1hdGguY2VpbChzZCAvIExPR19CQVNFKTtcclxuXHJcbiAgaWYgKCF0aGlzLmNyeXB0bykge1xyXG4gICAgZm9yICg7IGkgPCBrOykgcmRbaSsrXSA9IE1hdGgucmFuZG9tKCkgKiAxZTcgfCAwO1xyXG5cclxuICAvLyBCcm93c2VycyBzdXBwb3J0aW5nIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMuXHJcbiAgfSBlbHNlIGlmIChjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKSB7XHJcbiAgICBkID0gY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDMyQXJyYXkoaykpO1xyXG5cclxuICAgIGZvciAoOyBpIDwgazspIHtcclxuICAgICAgbiA9IGRbaV07XHJcblxyXG4gICAgICAvLyAwIDw9IG4gPCA0Mjk0OTY3Mjk2XHJcbiAgICAgIC8vIFByb2JhYmlsaXR5IG4gPj0gNC4yOWU5LCBpcyA0OTY3Mjk2IC8gNDI5NDk2NzI5NiA9IDAuMDAxMTYgKDEgaW4gODY1KS5cclxuICAgICAgaWYgKG4gPj0gNC4yOWU5KSB7XHJcbiAgICAgICAgZFtpXSA9IGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQzMkFycmF5KDEpKVswXTtcclxuICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgLy8gMCA8PSBuIDw9IDQyODk5OTk5OTlcclxuICAgICAgICAvLyAwIDw9IChuICUgMWU3KSA8PSA5OTk5OTk5XHJcbiAgICAgICAgcmRbaSsrXSA9IG4gJSAxZTc7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgLy8gTm9kZS5qcyBzdXBwb3J0aW5nIGNyeXB0by5yYW5kb21CeXRlcy5cclxuICB9IGVsc2UgaWYgKGNyeXB0by5yYW5kb21CeXRlcykge1xyXG5cclxuICAgIC8vIGJ1ZmZlclxyXG4gICAgZCA9IGNyeXB0by5yYW5kb21CeXRlcyhrICo9IDQpO1xyXG5cclxuICAgIGZvciAoOyBpIDwgazspIHtcclxuXHJcbiAgICAgIC8vIDAgPD0gbiA8IDIxNDc0ODM2NDhcclxuICAgICAgbiA9IGRbaV0gKyAoZFtpICsgMV0gPDwgOCkgKyAoZFtpICsgMl0gPDwgMTYpICsgKChkW2kgKyAzXSAmIDB4N2YpIDw8IDI0KTtcclxuXHJcbiAgICAgIC8vIFByb2JhYmlsaXR5IG4gPj0gMi4xNGU5LCBpcyA3NDgzNjQ4IC8gMjE0NzQ4MzY0OCA9IDAuMDAzNSAoMSBpbiAyODYpLlxyXG4gICAgICBpZiAobiA+PSAyLjE0ZTkpIHtcclxuICAgICAgICBjcnlwdG8ucmFuZG9tQnl0ZXMoNCkuY29weShkLCBpKTtcclxuICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgLy8gMCA8PSBuIDw9IDIxMzk5OTk5OTlcclxuICAgICAgICAvLyAwIDw9IChuICUgMWU3KSA8PSA5OTk5OTk5XHJcbiAgICAgICAgcmQucHVzaChuICUgMWU3KTtcclxuICAgICAgICBpICs9IDQ7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpID0gayAvIDQ7XHJcbiAgfSBlbHNlIHtcclxuICAgIHRocm93IEVycm9yKGNyeXB0b1VuYXZhaWxhYmxlKTtcclxuICB9XHJcblxyXG4gIGsgPSByZFstLWldO1xyXG4gIHNkICU9IExPR19CQVNFO1xyXG5cclxuICAvLyBDb252ZXJ0IHRyYWlsaW5nIGRpZ2l0cyB0byB6ZXJvcyBhY2NvcmRpbmcgdG8gc2QuXHJcbiAgaWYgKGsgJiYgc2QpIHtcclxuICAgIG4gPSBtYXRocG93KDEwLCBMT0dfQkFTRSAtIHNkKTtcclxuICAgIHJkW2ldID0gKGsgLyBuIHwgMCkgKiBuO1xyXG4gIH1cclxuXHJcbiAgLy8gUmVtb3ZlIHRyYWlsaW5nIHdvcmRzIHdoaWNoIGFyZSB6ZXJvLlxyXG4gIGZvciAoOyByZFtpXSA9PT0gMDsgaS0tKSByZC5wb3AoKTtcclxuXHJcbiAgLy8gWmVybz9cclxuICBpZiAoaSA8IDApIHtcclxuICAgIGUgPSAwO1xyXG4gICAgcmQgPSBbMF07XHJcbiAgfSBlbHNlIHtcclxuICAgIGUgPSAtMTtcclxuXHJcbiAgICAvLyBSZW1vdmUgbGVhZGluZyB3b3JkcyB3aGljaCBhcmUgemVybyBhbmQgYWRqdXN0IGV4cG9uZW50IGFjY29yZGluZ2x5LlxyXG4gICAgZm9yICg7IHJkWzBdID09PSAwOyBlIC09IExPR19CQVNFKSByZC5zaGlmdCgpO1xyXG5cclxuICAgIC8vIENvdW50IHRoZSBkaWdpdHMgb2YgdGhlIGZpcnN0IHdvcmQgb2YgcmQgdG8gZGV0ZXJtaW5lIGxlYWRpbmcgemVyb3MuXHJcbiAgICBmb3IgKGsgPSAxLCBuID0gcmRbMF07IG4gPj0gMTA7IG4gLz0gMTApIGsrKztcclxuXHJcbiAgICAvLyBBZGp1c3QgdGhlIGV4cG9uZW50IGZvciBsZWFkaW5nIHplcm9zIG9mIHRoZSBmaXJzdCB3b3JkIG9mIHJkLlxyXG4gICAgaWYgKGsgPCBMT0dfQkFTRSkgZSAtPSBMT0dfQkFTRSAtIGs7XHJcbiAgfVxyXG5cclxuICByLmUgPSBlO1xyXG4gIHIuZCA9IHJkO1xyXG5cclxuICByZXR1cm4gcjtcclxufVxyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIGB4YCByb3VuZGVkIHRvIGFuIGludGVnZXIgdXNpbmcgcm91bmRpbmcgbW9kZSBgcm91bmRpbmdgLlxyXG4gKlxyXG4gKiBUbyBlbXVsYXRlIGBNYXRoLnJvdW5kYCwgc2V0IHJvdW5kaW5nIHRvIDcgKFJPVU5EX0hBTEZfQ0VJTCkuXHJcbiAqXHJcbiAqIHgge251bWJlcnxzdHJpbmd8RGVjaW1hbH1cclxuICpcclxuICovXHJcbmZ1bmN0aW9uIHJvdW5kKHgpIHtcclxuICByZXR1cm4gZmluYWxpc2UoeCA9IG5ldyB0aGlzKHgpLCB4LmUgKyAxLCB0aGlzLnJvdW5kaW5nKTtcclxufVxyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVyblxyXG4gKiAgIDEgICAgaWYgeCA+IDAsXHJcbiAqICAtMSAgICBpZiB4IDwgMCxcclxuICogICAwICAgIGlmIHggaXMgMCxcclxuICogIC0wICAgIGlmIHggaXMgLTAsXHJcbiAqICAgTmFOICBvdGhlcndpc2VcclxuICpcclxuICogeCB7bnVtYmVyfHN0cmluZ3xEZWNpbWFsfVxyXG4gKlxyXG4gKi9cclxuZnVuY3Rpb24gc2lnbih4KSB7XHJcbiAgeCA9IG5ldyB0aGlzKHgpO1xyXG4gIHJldHVybiB4LmQgPyAoeC5kWzBdID8geC5zIDogMCAqIHgucykgOiB4LnMgfHwgTmFOO1xyXG59XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIHNpbmUgb2YgYHhgLCByb3VuZGVkIHRvIGBwcmVjaXNpb25gIHNpZ25pZmljYW50IGRpZ2l0c1xyXG4gKiB1c2luZyByb3VuZGluZyBtb2RlIGByb3VuZGluZ2AuXHJcbiAqXHJcbiAqIHgge251bWJlcnxzdHJpbmd8RGVjaW1hbH0gQSB2YWx1ZSBpbiByYWRpYW5zLlxyXG4gKlxyXG4gKi9cclxuZnVuY3Rpb24gc2luKHgpIHtcclxuICByZXR1cm4gbmV3IHRoaXMoeCkuc2luKCk7XHJcbn1cclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgaHlwZXJib2xpYyBzaW5lIG9mIGB4YCwgcm91bmRlZCB0byBgcHJlY2lzaW9uYFxyXG4gKiBzaWduaWZpY2FudCBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSBgcm91bmRpbmdgLlxyXG4gKlxyXG4gKiB4IHtudW1iZXJ8c3RyaW5nfERlY2ltYWx9IEEgdmFsdWUgaW4gcmFkaWFucy5cclxuICpcclxuICovXHJcbmZ1bmN0aW9uIHNpbmgoeCkge1xyXG4gIHJldHVybiBuZXcgdGhpcyh4KS5zaW5oKCk7XHJcbn1cclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgc3F1YXJlIHJvb3Qgb2YgYHhgLCByb3VuZGVkIHRvIGBwcmVjaXNpb25gIHNpZ25pZmljYW50XHJcbiAqIGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIGByb3VuZGluZ2AuXHJcbiAqXHJcbiAqIHgge251bWJlcnxzdHJpbmd8RGVjaW1hbH1cclxuICpcclxuICovXHJcbmZ1bmN0aW9uIHNxcnQoeCkge1xyXG4gIHJldHVybiBuZXcgdGhpcyh4KS5zcXJ0KCk7XHJcbn1cclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyBgeGAgbWludXMgYHlgLCByb3VuZGVkIHRvIGBwcmVjaXNpb25gIHNpZ25pZmljYW50IGRpZ2l0c1xyXG4gKiB1c2luZyByb3VuZGluZyBtb2RlIGByb3VuZGluZ2AuXHJcbiAqXHJcbiAqIHgge251bWJlcnxzdHJpbmd8RGVjaW1hbH1cclxuICogeSB7bnVtYmVyfHN0cmluZ3xEZWNpbWFsfVxyXG4gKlxyXG4gKi9cclxuZnVuY3Rpb24gc3ViKHgsIHkpIHtcclxuICByZXR1cm4gbmV3IHRoaXMoeCkuc3ViKHkpO1xyXG59XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIHN1bSBvZiB0aGUgYXJndW1lbnRzLCByb3VuZGVkIHRvIGBwcmVjaXNpb25gXHJcbiAqIHNpZ25pZmljYW50IGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIGByb3VuZGluZ2AuXHJcbiAqXHJcbiAqIE9ubHkgdGhlIHJlc3VsdCBpcyByb3VuZGVkLCBub3QgdGhlIGludGVybWVkaWF0ZSBjYWxjdWxhdGlvbnMuXHJcbiAqXHJcbiAqIGFyZ3VtZW50cyB7bnVtYmVyfHN0cmluZ3xEZWNpbWFsfVxyXG4gKlxyXG4gKi9cclxuZnVuY3Rpb24gc3VtKCkge1xyXG4gIHZhciBpID0gMCxcclxuICAgIGFyZ3MgPSBhcmd1bWVudHMsXHJcbiAgICB4ID0gbmV3IHRoaXMoYXJnc1tpXSk7XHJcblxyXG4gIGV4dGVybmFsID0gZmFsc2U7XHJcbiAgZm9yICg7IHgucyAmJiArK2kgPCBhcmdzLmxlbmd0aDspIHggPSB4LnBsdXMoYXJnc1tpXSk7XHJcbiAgZXh0ZXJuYWwgPSB0cnVlO1xyXG5cclxuICByZXR1cm4gZmluYWxpc2UoeCwgdGhpcy5wcmVjaXNpb24sIHRoaXMucm91bmRpbmcpO1xyXG59XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIHRhbmdlbnQgb2YgYHhgLCByb3VuZGVkIHRvIGBwcmVjaXNpb25gIHNpZ25pZmljYW50XHJcbiAqIGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIGByb3VuZGluZ2AuXHJcbiAqXHJcbiAqIHgge251bWJlcnxzdHJpbmd8RGVjaW1hbH0gQSB2YWx1ZSBpbiByYWRpYW5zLlxyXG4gKlxyXG4gKi9cclxuZnVuY3Rpb24gdGFuKHgpIHtcclxuICByZXR1cm4gbmV3IHRoaXMoeCkudGFuKCk7XHJcbn1cclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgaHlwZXJib2xpYyB0YW5nZW50IG9mIGB4YCwgcm91bmRlZCB0byBgcHJlY2lzaW9uYFxyXG4gKiBzaWduaWZpY2FudCBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSBgcm91bmRpbmdgLlxyXG4gKlxyXG4gKiB4IHtudW1iZXJ8c3RyaW5nfERlY2ltYWx9IEEgdmFsdWUgaW4gcmFkaWFucy5cclxuICpcclxuICovXHJcbmZ1bmN0aW9uIHRhbmgoeCkge1xyXG4gIHJldHVybiBuZXcgdGhpcyh4KS50YW5oKCk7XHJcbn1cclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyBgeGAgdHJ1bmNhdGVkIHRvIGFuIGludGVnZXIuXHJcbiAqXHJcbiAqIHgge251bWJlcnxzdHJpbmd8RGVjaW1hbH1cclxuICpcclxuICovXHJcbmZ1bmN0aW9uIHRydW5jKHgpIHtcclxuICByZXR1cm4gZmluYWxpc2UoeCA9IG5ldyB0aGlzKHgpLCB4LmUgKyAxLCAxKTtcclxufVxyXG5cclxuXHJcblBbU3ltYm9sLmZvcignbm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b20nKV0gPSBQLnRvU3RyaW5nO1xyXG5QW1N5bWJvbC50b1N0cmluZ1RhZ10gPSAnRGVjaW1hbCc7XHJcblxyXG4vLyBDcmVhdGUgYW5kIGNvbmZpZ3VyZSBpbml0aWFsIERlY2ltYWwgY29uc3RydWN0b3IuXHJcbmV4cG9ydCB2YXIgRGVjaW1hbCA9IFAuY29uc3RydWN0b3IgPSBjbG9uZShERUZBVUxUUyk7XHJcblxyXG4vLyBDcmVhdGUgdGhlIGludGVybmFsIGNvbnN0YW50cyBmcm9tIHRoZWlyIHN0cmluZyB2YWx1ZXMuXHJcbkxOMTAgPSBuZXcgRGVjaW1hbChMTjEwKTtcclxuUEkgPSBuZXcgRGVjaW1hbChQSSk7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBEZWNpbWFsO1xyXG4iXSwibmFtZXMiOlsiRVhQX0xJTUlUIiwiTUFYX0RJR0lUUyIsIk5VTUVSQUxTIiwiTE4xMCIsIlBJIiwiREVGQVVMVFMiLCJwcmVjaXNpb24iLCJyb3VuZGluZyIsIm1vZHVsbyIsInRvRXhwTmVnIiwidG9FeHBQb3MiLCJtaW5FIiwibWF4RSIsImNyeXB0byIsImluZXhhY3QiLCJxdWFkcmFudCIsImV4dGVybmFsIiwiZGVjaW1hbEVycm9yIiwiaW52YWxpZEFyZ3VtZW50IiwicHJlY2lzaW9uTGltaXRFeGNlZWRlZCIsImNyeXB0b1VuYXZhaWxhYmxlIiwidGFnIiwibWF0aGZsb29yIiwiTWF0aCIsImZsb29yIiwibWF0aHBvdyIsInBvdyIsImlzQmluYXJ5IiwiaXNIZXgiLCJpc09jdGFsIiwiaXNEZWNpbWFsIiwiQkFTRSIsIkxPR19CQVNFIiwiTUFYX1NBRkVfSU5URUdFUiIsIkxOMTBfUFJFQ0lTSU9OIiwibGVuZ3RoIiwiUElfUFJFQ0lTSU9OIiwiUCIsInRvU3RyaW5nVGFnIiwiYWJzb2x1dGVWYWx1ZSIsImFicyIsIngiLCJjb25zdHJ1Y3RvciIsInMiLCJmaW5hbGlzZSIsImNlaWwiLCJlIiwiY2xhbXBlZFRvIiwiY2xhbXAiLCJtaW4iLCJtYXgiLCJrIiwiQ3RvciIsIk5hTiIsImd0IiwiRXJyb3IiLCJjbXAiLCJjb21wYXJlZFRvIiwieSIsImkiLCJqIiwieGRMIiwieWRMIiwieGQiLCJkIiwieWQiLCJ4cyIsInlzIiwiY29zaW5lIiwiY29zIiwicHIiLCJybSIsInNkIiwidG9MZXNzVGhhbkhhbGZQaSIsIm5lZyIsImN1YmVSb290IiwiY2JydCIsIm0iLCJuIiwiciIsInJlcCIsInQiLCJ0MyIsInQzcGx1c3giLCJpc0Zpbml0ZSIsImlzWmVybyIsImRpZ2l0c1RvU3RyaW5nIiwidG9FeHBvbmVudGlhbCIsInNsaWNlIiwiaW5kZXhPZiIsInRvU3RyaW5nIiwidGltZXMiLCJwbHVzIiwiZGl2aWRlIiwiZXEiLCJjaGFyQXQiLCJkZWNpbWFsUGxhY2VzIiwiZHAiLCJ3IiwiZGl2aWRlZEJ5IiwiZGl2IiwiZGl2aWRlZFRvSW50ZWdlckJ5IiwiZGl2VG9JbnQiLCJlcXVhbHMiLCJncmVhdGVyVGhhbiIsImdyZWF0ZXJUaGFuT3JFcXVhbFRvIiwiZ3RlIiwiaHlwZXJib2xpY0Nvc2luZSIsImNvc2giLCJsZW4iLCJvbmUiLCJ0aW55UG93IiwidGF5bG9yU2VyaWVzIiwiY29zaDJfeCIsImQ4IiwibWludXMiLCJoeXBlcmJvbGljU2luZSIsInNpbmgiLCJzcXJ0Iiwic2luaDJfeCIsImQ1IiwiZDE2IiwiZDIwIiwiaHlwZXJib2xpY1RhbmdlbnQiLCJ0YW5oIiwiaW52ZXJzZUNvc2luZSIsImFjb3MiLCJoYWxmUGkiLCJpc05lZyIsImdldFBpIiwiYXNpbiIsImludmVyc2VIeXBlcmJvbGljQ29zaW5lIiwiYWNvc2giLCJsdGUiLCJsbiIsImludmVyc2VIeXBlcmJvbGljU2luZSIsImFzaW5oIiwiaW52ZXJzZUh5cGVyYm9saWNUYW5nZW50IiwiYXRhbmgiLCJ3cHIiLCJ4c2QiLCJpbnZlcnNlU2luZSIsImF0YW4iLCJpbnZlcnNlVGFuZ2VudCIsInB4IiwieDIiLCJpc0ludGVnZXIiLCJpc0ludCIsImlzTmFOIiwiaXNOZWdhdGl2ZSIsImlzUG9zaXRpdmUiLCJpc1BvcyIsImxlc3NUaGFuIiwibHQiLCJsZXNzVGhhbk9yRXF1YWxUbyIsImxvZ2FyaXRobSIsImxvZyIsImJhc2UiLCJpc0Jhc2UxMCIsImRlbm9taW5hdG9yIiwiaW5mIiwibnVtIiwiYXJnIiwiZ3VhcmQiLCJuYXR1cmFsTG9nYXJpdGhtIiwiZ2V0TG4xMCIsImNoZWNrUm91bmRpbmdEaWdpdHMiLCJzdWIiLCJ4ZSIsInhMVHkiLCJyZXZlcnNlIiwicHVzaCIsInBvcCIsInNoaWZ0IiwiZ2V0QmFzZTEwRXhwb25lbnQiLCJtb2QiLCJxIiwibmF0dXJhbEV4cG9uZW50aWFsIiwiZXhwIiwibmVnYXRlZCIsImFkZCIsImNhcnJ5IiwidW5zaGlmdCIsInoiLCJnZXRQcmVjaXNpb24iLCJyb3VuZCIsInNpbmUiLCJzaW4iLCJzcXVhcmVSb290IiwidGFuZ2VudCIsInRhbiIsIm11bCIsInJMIiwidG9CaW5hcnkiLCJ0b1N0cmluZ0JpbmFyeSIsInRvRGVjaW1hbFBsYWNlcyIsInRvRFAiLCJjaGVja0ludDMyIiwic3RyIiwiZmluaXRlVG9TdHJpbmciLCJ0b0ZpeGVkIiwidG9GcmFjdGlvbiIsIm1heEQiLCJkMCIsImQxIiwiZDIiLCJuMCIsIm4xIiwidG9IZXhhZGVjaW1hbCIsInRvSGV4IiwidG9OZWFyZXN0IiwidG9OdW1iZXIiLCJ0b09jdGFsIiwidG9Qb3dlciIsInluIiwiaW50UG93IiwidG9QcmVjaXNpb24iLCJ0b1NpZ25pZmljYW50RGlnaXRzIiwidG9TRCIsInRydW5jYXRlZCIsInRydW5jIiwidmFsdWVPZiIsInRvSlNPTiIsIndzIiwiaW5kZXhPZkxhc3RXb3JkIiwiZ2V0WmVyb1N0cmluZyIsInJlcGVhdGluZyIsImRpIiwicmQiLCJjb252ZXJ0QmFzZSIsImJhc2VJbiIsImJhc2VPdXQiLCJhcnIiLCJhcnJMIiwic3RyTCIsImNvczJ4IiwibXVsdGlwbHlJbnRlZ2VyIiwidGVtcCIsImNvbXBhcmUiLCJhIiwiYiIsImFMIiwiYkwiLCJzdWJ0cmFjdCIsImxvZ0Jhc2UiLCJtb3JlIiwicHJvZCIsInByb2RMIiwicWQiLCJyZW0iLCJyZW1MIiwicmVtMCIsInhpIiwieEwiLCJ5ZDAiLCJ5TCIsInl6Iiwic2lnbiIsImlzVHJ1bmNhdGVkIiwiZGlnaXRzIiwicm91bmRVcCIsInhkaSIsIm91dCIsImlzRXhwIiwibm9uRmluaXRlVG9TdHJpbmciLCJ6cyIsInRydW5jYXRlIiwiaXNPZGQiLCJtYXhPck1pbiIsImFyZ3MiLCJsdGd0Iiwic3VtIiwiYyIsImMwIiwibnVtZXJhdG9yIiwieDEiLCJTdHJpbmciLCJwYXJzZURlY2ltYWwiLCJyZXBsYWNlIiwic2VhcmNoIiwic3Vic3RyaW5nIiwiY2hhckNvZGVBdCIsInBhcnNlT3RoZXIiLCJkaXZpc29yIiwiaXNGbG9hdCIsInAiLCJ0ZXN0IiwidG9Mb3dlckNhc2UiLCJEZWNpbWFsIiwic2luMl94IiwiaXNIeXBlcmJvbGljIiwidSIsInBpIiwiYXRhbjIiLCJjb25maWciLCJvYmoiLCJ2IiwidXNlRGVmYXVsdHMiLCJkZWZhdWx0cyIsInBzIiwiZ2V0UmFuZG9tVmFsdWVzIiwicmFuZG9tQnl0ZXMiLCJjbG9uZSIsImlzRGVjaW1hbEluc3RhbmNlIiwicHJvdG90eXBlIiwiUk9VTkRfVVAiLCJST1VORF9ET1dOIiwiUk9VTkRfQ0VJTCIsIlJPVU5EX0ZMT09SIiwiUk9VTkRfSEFMRl9VUCIsIlJPVU5EX0hBTEZfRE9XTiIsIlJPVU5EX0hBTEZfRVZFTiIsIlJPVU5EX0hBTEZfQ0VJTCIsIlJPVU5EX0hBTEZfRkxPT1IiLCJFVUNMSUQiLCJzZXQiLCJoeXBvdCIsImxvZzEwIiwibG9nMiIsInJhbmRvbSIsImhhc093blByb3BlcnR5IiwiYXJndW1lbnRzIiwiVWludDMyQXJyYXkiLCJjb3B5IiwiU3ltYm9sIiwiZm9yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/decimal.js@10.4.3/node_modules/decimal.js/decimal.mjs\n");

/***/ })

};
;