/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ip@2.0.0";
exports.ids = ["vendor-chunks/ip@2.0.0"];
exports.modules = {

/***/ "(rsc)/../../node_modules/.pnpm/ip@2.0.0/node_modules/ip/lib/ip.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/.pnpm/ip@2.0.0/node_modules/ip/lib/ip.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("const ip = exports;\nconst { Buffer } = __webpack_require__(/*! buffer */ \"buffer\");\nconst os = __webpack_require__(/*! os */ \"os\");\nip.toBuffer = function(ip, buff, offset) {\n    offset = ~~offset;\n    let result;\n    if (this.isV4Format(ip)) {\n        result = buff || Buffer.alloc(offset + 4);\n        ip.split(/\\./g).map((byte)=>{\n            result[offset++] = parseInt(byte, 10) & 0xff;\n        });\n    } else if (this.isV6Format(ip)) {\n        const sections = ip.split(\":\", 8);\n        let i;\n        for(i = 0; i < sections.length; i++){\n            const isv4 = this.isV4Format(sections[i]);\n            let v4Buffer;\n            if (isv4) {\n                v4Buffer = this.toBuffer(sections[i]);\n                sections[i] = v4Buffer.slice(0, 2).toString(\"hex\");\n            }\n            if (v4Buffer && ++i < 8) {\n                sections.splice(i, 0, v4Buffer.slice(2, 4).toString(\"hex\"));\n            }\n        }\n        if (sections[0] === \"\") {\n            while(sections.length < 8)sections.unshift(\"0\");\n        } else if (sections[sections.length - 1] === \"\") {\n            while(sections.length < 8)sections.push(\"0\");\n        } else if (sections.length < 8) {\n            for(i = 0; i < sections.length && sections[i] !== \"\"; i++);\n            const argv = [\n                i,\n                1\n            ];\n            for(i = 9 - sections.length; i > 0; i--){\n                argv.push(\"0\");\n            }\n            sections.splice(...argv);\n        }\n        result = buff || Buffer.alloc(offset + 16);\n        for(i = 0; i < sections.length; i++){\n            const word = parseInt(sections[i], 16);\n            result[offset++] = word >> 8 & 0xff;\n            result[offset++] = word & 0xff;\n        }\n    }\n    if (!result) {\n        throw Error(`Invalid ip address: ${ip}`);\n    }\n    return result;\n};\nip.toString = function(buff, offset, length) {\n    offset = ~~offset;\n    length = length || buff.length - offset;\n    let result = [];\n    if (length === 4) {\n        // IPv4\n        for(let i = 0; i < length; i++){\n            result.push(buff[offset + i]);\n        }\n        result = result.join(\".\");\n    } else if (length === 16) {\n        // IPv6\n        for(let i = 0; i < length; i += 2){\n            result.push(buff.readUInt16BE(offset + i).toString(16));\n        }\n        result = result.join(\":\");\n        result = result.replace(/(^|:)0(:0)*:0(:|$)/, \"$1::$3\");\n        result = result.replace(/:{3,4}/, \"::\");\n    }\n    return result;\n};\nconst ipv4Regex = /^(\\d{1,3}\\.){3,3}\\d{1,3}$/;\nconst ipv6Regex = /^(::)?(((\\d{1,3}\\.){3}(\\d{1,3}){1})?([0-9a-f]){0,4}:{0,2}){1,8}(::)?$/i;\nip.isV4Format = function(ip) {\n    return ipv4Regex.test(ip);\n};\nip.isV6Format = function(ip) {\n    return ipv6Regex.test(ip);\n};\nfunction _normalizeFamily(family) {\n    if (family === 4) {\n        return \"ipv4\";\n    }\n    if (family === 6) {\n        return \"ipv6\";\n    }\n    return family ? family.toLowerCase() : \"ipv4\";\n}\nip.fromPrefixLen = function(prefixlen, family) {\n    if (prefixlen > 32) {\n        family = \"ipv6\";\n    } else {\n        family = _normalizeFamily(family);\n    }\n    let len = 4;\n    if (family === \"ipv6\") {\n        len = 16;\n    }\n    const buff = Buffer.alloc(len);\n    for(let i = 0, n = buff.length; i < n; ++i){\n        let bits = 8;\n        if (prefixlen < 8) {\n            bits = prefixlen;\n        }\n        prefixlen -= bits;\n        buff[i] = ~(0xff >> bits) & 0xff;\n    }\n    return ip.toString(buff);\n};\nip.mask = function(addr, mask) {\n    addr = ip.toBuffer(addr);\n    mask = ip.toBuffer(mask);\n    const result = Buffer.alloc(Math.max(addr.length, mask.length));\n    // Same protocol - do bitwise and\n    let i;\n    if (addr.length === mask.length) {\n        for(i = 0; i < addr.length; i++){\n            result[i] = addr[i] & mask[i];\n        }\n    } else if (mask.length === 4) {\n        // IPv6 address and IPv4 mask\n        // (Mask low bits)\n        for(i = 0; i < mask.length; i++){\n            result[i] = addr[addr.length - 4 + i] & mask[i];\n        }\n    } else {\n        // IPv6 mask and IPv4 addr\n        for(i = 0; i < result.length - 6; i++){\n            result[i] = 0;\n        }\n        // ::ffff:ipv4\n        result[10] = 0xff;\n        result[11] = 0xff;\n        for(i = 0; i < addr.length; i++){\n            result[i + 12] = addr[i] & mask[i + 12];\n        }\n        i += 12;\n    }\n    for(; i < result.length; i++){\n        result[i] = 0;\n    }\n    return ip.toString(result);\n};\nip.cidr = function(cidrString) {\n    const cidrParts = cidrString.split(\"/\");\n    const addr = cidrParts[0];\n    if (cidrParts.length !== 2) {\n        throw new Error(`invalid CIDR subnet: ${addr}`);\n    }\n    const mask = ip.fromPrefixLen(parseInt(cidrParts[1], 10));\n    return ip.mask(addr, mask);\n};\nip.subnet = function(addr, mask) {\n    const networkAddress = ip.toLong(ip.mask(addr, mask));\n    // Calculate the mask's length.\n    const maskBuffer = ip.toBuffer(mask);\n    let maskLength = 0;\n    for(let i = 0; i < maskBuffer.length; i++){\n        if (maskBuffer[i] === 0xff) {\n            maskLength += 8;\n        } else {\n            let octet = maskBuffer[i] & 0xff;\n            while(octet){\n                octet = octet << 1 & 0xff;\n                maskLength++;\n            }\n        }\n    }\n    const numberOfAddresses = 2 ** (32 - maskLength);\n    return {\n        networkAddress: ip.fromLong(networkAddress),\n        firstAddress: numberOfAddresses <= 2 ? ip.fromLong(networkAddress) : ip.fromLong(networkAddress + 1),\n        lastAddress: numberOfAddresses <= 2 ? ip.fromLong(networkAddress + numberOfAddresses - 1) : ip.fromLong(networkAddress + numberOfAddresses - 2),\n        broadcastAddress: ip.fromLong(networkAddress + numberOfAddresses - 1),\n        subnetMask: mask,\n        subnetMaskLength: maskLength,\n        numHosts: numberOfAddresses <= 2 ? numberOfAddresses : numberOfAddresses - 2,\n        length: numberOfAddresses,\n        contains (other) {\n            return networkAddress === ip.toLong(ip.mask(other, mask));\n        }\n    };\n};\nip.cidrSubnet = function(cidrString) {\n    const cidrParts = cidrString.split(\"/\");\n    const addr = cidrParts[0];\n    if (cidrParts.length !== 2) {\n        throw new Error(`invalid CIDR subnet: ${addr}`);\n    }\n    const mask = ip.fromPrefixLen(parseInt(cidrParts[1], 10));\n    return ip.subnet(addr, mask);\n};\nip.not = function(addr) {\n    const buff = ip.toBuffer(addr);\n    for(let i = 0; i < buff.length; i++){\n        buff[i] = 0xff ^ buff[i];\n    }\n    return ip.toString(buff);\n};\nip.or = function(a, b) {\n    a = ip.toBuffer(a);\n    b = ip.toBuffer(b);\n    // same protocol\n    if (a.length === b.length) {\n        for(let i = 0; i < a.length; ++i){\n            a[i] |= b[i];\n        }\n        return ip.toString(a);\n    // mixed protocols\n    }\n    let buff = a;\n    let other = b;\n    if (b.length > a.length) {\n        buff = b;\n        other = a;\n    }\n    const offset = buff.length - other.length;\n    for(let i = offset; i < buff.length; ++i){\n        buff[i] |= other[i - offset];\n    }\n    return ip.toString(buff);\n};\nip.isEqual = function(a, b) {\n    a = ip.toBuffer(a);\n    b = ip.toBuffer(b);\n    // Same protocol\n    if (a.length === b.length) {\n        for(let i = 0; i < a.length; i++){\n            if (a[i] !== b[i]) return false;\n        }\n        return true;\n    }\n    // Swap\n    if (b.length === 4) {\n        const t = b;\n        b = a;\n        a = t;\n    }\n    // a - IPv4, b - IPv6\n    for(let i = 0; i < 10; i++){\n        if (b[i] !== 0) return false;\n    }\n    const word = b.readUInt16BE(10);\n    if (word !== 0 && word !== 0xffff) return false;\n    for(let i = 0; i < 4; i++){\n        if (a[i] !== b[i + 12]) return false;\n    }\n    return true;\n};\nip.isPrivate = function(addr) {\n    return /^(::f{4}:)?10\\.([0-9]{1,3})\\.([0-9]{1,3})\\.([0-9]{1,3})$/i.test(addr) || /^(::f{4}:)?192\\.168\\.([0-9]{1,3})\\.([0-9]{1,3})$/i.test(addr) || /^(::f{4}:)?172\\.(1[6-9]|2\\d|30|31)\\.([0-9]{1,3})\\.([0-9]{1,3})$/i.test(addr) || /^(::f{4}:)?127\\.([0-9]{1,3})\\.([0-9]{1,3})\\.([0-9]{1,3})$/i.test(addr) || /^(::f{4}:)?169\\.254\\.([0-9]{1,3})\\.([0-9]{1,3})$/i.test(addr) || /^f[cd][0-9a-f]{2}:/i.test(addr) || /^fe80:/i.test(addr) || /^::1$/.test(addr) || /^::$/.test(addr);\n};\nip.isPublic = function(addr) {\n    return !ip.isPrivate(addr);\n};\nip.isLoopback = function(addr) {\n    return /^(::f{4}:)?127\\.([0-9]{1,3})\\.([0-9]{1,3})\\.([0-9]{1,3})/.test(addr) || /^fe80::1$/.test(addr) || /^::1$/.test(addr) || /^::$/.test(addr);\n};\nip.loopback = function(family) {\n    //\n    // Default to `ipv4`\n    //\n    family = _normalizeFamily(family);\n    if (family !== \"ipv4\" && family !== \"ipv6\") {\n        throw new Error(\"family must be ipv4 or ipv6\");\n    }\n    return family === \"ipv4\" ? \"127.0.0.1\" : \"fe80::1\";\n};\n//\n// ### function address (name, family)\n// #### @name {string|'public'|'private'} **Optional** Name or security\n//      of the network interface.\n// #### @family {ipv4|ipv6} **Optional** IP family of the address (defaults\n//      to ipv4).\n//\n// Returns the address for the network interface on the current system with\n// the specified `name`:\n//   * String: First `family` address of the interface.\n//             If not found see `undefined`.\n//   * 'public': the first public ip address of family.\n//   * 'private': the first private ip address of family.\n//   * undefined: First address with `ipv4` or loopback address `127.0.0.1`.\n//\nip.address = function(name, family) {\n    const interfaces = os.networkInterfaces();\n    //\n    // Default to `ipv4`\n    //\n    family = _normalizeFamily(family);\n    //\n    // If a specific network interface has been named,\n    // return the address.\n    //\n    if (name && name !== \"private\" && name !== \"public\") {\n        const res = interfaces[name].filter((details)=>{\n            const itemFamily = _normalizeFamily(details.family);\n            return itemFamily === family;\n        });\n        if (res.length === 0) {\n            return undefined;\n        }\n        return res[0].address;\n    }\n    const all = Object.keys(interfaces).map((nic)=>{\n        //\n        // Note: name will only be `public` or `private`\n        // when this is called.\n        //\n        const addresses = interfaces[nic].filter((details)=>{\n            details.family = _normalizeFamily(details.family);\n            if (details.family !== family || ip.isLoopback(details.address)) {\n                return false;\n            }\n            if (!name) {\n                return true;\n            }\n            return name === \"public\" ? ip.isPrivate(details.address) : ip.isPublic(details.address);\n        });\n        return addresses.length ? addresses[0].address : undefined;\n    }).filter(Boolean);\n    return !all.length ? ip.loopback(family) : all[0];\n};\nip.toLong = function(ip) {\n    let ipl = 0;\n    ip.split(\".\").forEach((octet)=>{\n        ipl <<= 8;\n        ipl += parseInt(octet);\n    });\n    return ipl >>> 0;\n};\nip.fromLong = function(ipl) {\n    return `${ipl >>> 24}.${ipl >> 16 & 255}.${ipl >> 8 & 255}.${ipl & 255}`;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2lwQDIuMC4wL25vZGVfbW9kdWxlcy9pcC9saWIvaXAuanMiLCJtYXBwaW5ncyI6IkFBQUEsTUFBTUEsS0FBS0M7QUFDWCxNQUFNLEVBQUVDLE1BQU0sRUFBRSxHQUFHQyxtQkFBT0EsQ0FBQztBQUMzQixNQUFNQyxLQUFLRCxtQkFBT0EsQ0FBQztBQUVuQkgsR0FBR0ssUUFBUSxHQUFHLFNBQVVMLEVBQUUsRUFBRU0sSUFBSSxFQUFFQyxNQUFNO0lBQ3RDQSxTQUFTLENBQUMsQ0FBQ0E7SUFFWCxJQUFJQztJQUVKLElBQUksSUFBSSxDQUFDQyxVQUFVLENBQUNULEtBQUs7UUFDdkJRLFNBQVNGLFFBQVFKLE9BQU9RLEtBQUssQ0FBQ0gsU0FBUztRQUN2Q1AsR0FBR1csS0FBSyxDQUFDLE9BQU9DLEdBQUcsQ0FBQyxDQUFDQztZQUNuQkwsTUFBTSxDQUFDRCxTQUFTLEdBQUdPLFNBQVNELE1BQU0sTUFBTTtRQUMxQztJQUNGLE9BQU8sSUFBSSxJQUFJLENBQUNFLFVBQVUsQ0FBQ2YsS0FBSztRQUM5QixNQUFNZ0IsV0FBV2hCLEdBQUdXLEtBQUssQ0FBQyxLQUFLO1FBRS9CLElBQUlNO1FBQ0osSUFBS0EsSUFBSSxHQUFHQSxJQUFJRCxTQUFTRSxNQUFNLEVBQUVELElBQUs7WUFDcEMsTUFBTUUsT0FBTyxJQUFJLENBQUNWLFVBQVUsQ0FBQ08sUUFBUSxDQUFDQyxFQUFFO1lBQ3hDLElBQUlHO1lBRUosSUFBSUQsTUFBTTtnQkFDUkMsV0FBVyxJQUFJLENBQUNmLFFBQVEsQ0FBQ1csUUFBUSxDQUFDQyxFQUFFO2dCQUNwQ0QsUUFBUSxDQUFDQyxFQUFFLEdBQUdHLFNBQVNDLEtBQUssQ0FBQyxHQUFHLEdBQUdDLFFBQVEsQ0FBQztZQUM5QztZQUVBLElBQUlGLFlBQVksRUFBRUgsSUFBSSxHQUFHO2dCQUN2QkQsU0FBU08sTUFBTSxDQUFDTixHQUFHLEdBQUdHLFNBQVNDLEtBQUssQ0FBQyxHQUFHLEdBQUdD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QU0sR0FBR2xCLEdBQUc0RSxRQUFRLENBQUN4QyxVQUFVa0QsR0FBRyxDQUFDLEVBQUU7QUFDbkQ7QUFFQXRGLEdBQUdvRCxNQUFNLEdBQUcsU0FBVXBELEVBQUU7SUFDdEIsSUFBSTRGLE1BQU07SUFDVjVGLEdBQUdXLEtBQUssQ0FBQyxLQUFLa0YsT0FBTyxDQUFDLENBQUN0QztRQUNyQnFDLFFBQVE7UUFDUkEsT0FBTzlFLFNBQVN5QztJQUNsQjtJQUNBLE9BQVFxQyxRQUFRO0FBQ2xCO0FBRUE1RixHQUFHeUQsUUFBUSxHQUFHLFNBQVVtQyxHQUFHO0lBQ3pCLE9BQVEsQ0FBQyxFQUFFQSxRQUFRLEdBQUcsQ0FBQyxFQUNyQkEsT0FBTyxLQUFLLElBQUksQ0FBQyxFQUNqQkEsT0FBTyxJQUFJLElBQUksQ0FBQyxFQUNoQkEsTUFBTSxJQUFJLENBQUM7QUFDZiIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vaXBAMi4wLjAvbm9kZV9tb2R1bGVzL2lwL2xpYi9pcC5qcz8wZWQ4Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGlwID0gZXhwb3J0cztcbmNvbnN0IHsgQnVmZmVyIH0gPSByZXF1aXJlKCdidWZmZXInKTtcbmNvbnN0IG9zID0gcmVxdWlyZSgnb3MnKTtcblxuaXAudG9CdWZmZXIgPSBmdW5jdGlvbiAoaXAsIGJ1ZmYsIG9mZnNldCkge1xuICBvZmZzZXQgPSB+fm9mZnNldDtcblxuICBsZXQgcmVzdWx0O1xuXG4gIGlmICh0aGlzLmlzVjRGb3JtYXQoaXApKSB7XG4gICAgcmVzdWx0ID0gYnVmZiB8fCBCdWZmZXIuYWxsb2Mob2Zmc2V0ICsgNCk7XG4gICAgaXAuc3BsaXQoL1xcLi9nKS5tYXAoKGJ5dGUpID0+IHtcbiAgICAgIHJlc3VsdFtvZmZzZXQrK10gPSBwYXJzZUludChieXRlLCAxMCkgJiAweGZmO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKHRoaXMuaXNWNkZvcm1hdChpcCkpIHtcbiAgICBjb25zdCBzZWN0aW9ucyA9IGlwLnNwbGl0KCc6JywgOCk7XG5cbiAgICBsZXQgaTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgc2VjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGlzdjQgPSB0aGlzLmlzVjRGb3JtYXQoc2VjdGlvbnNbaV0pO1xuICAgICAgbGV0IHY0QnVmZmVyO1xuXG4gICAgICBpZiAoaXN2NCkge1xuICAgICAgICB2NEJ1ZmZlciA9IHRoaXMudG9CdWZmZXIoc2VjdGlvbnNbaV0pO1xuICAgICAgICBzZWN0aW9uc1tpXSA9IHY0QnVmZmVyLnNsaWNlKDAsIDIpLnRvU3RyaW5nKCdoZXgnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHY0QnVmZmVyICYmICsraSA8IDgpIHtcbiAgICAgICAgc2VjdGlvbnMuc3BsaWNlKGksIDAsIHY0QnVmZmVyLnNsaWNlKDIsIDQpLnRvU3RyaW5nKCdoZXgnKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHNlY3Rpb25zWzBdID09PSAnJykge1xuICAgICAgd2hpbGUgKHNlY3Rpb25zLmxlbmd0aCA8IDgpIHNlY3Rpb25zLnVuc2hpZnQoJzAnKTtcbiAgICB9IGVsc2UgaWYgKHNlY3Rpb25zW3NlY3Rpb25zLmxlbmd0aCAtIDFdID09PSAnJykge1xuICAgICAgd2hpbGUgKHNlY3Rpb25zLmxlbmd0aCA8IDgpIHNlY3Rpb25zLnB1c2goJzAnKTtcbiAgICB9IGVsc2UgaWYgKHNlY3Rpb25zLmxlbmd0aCA8IDgpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBzZWN0aW9ucy5sZW5ndGggJiYgc2VjdGlvbnNbaV0gIT09ICcnOyBpKyspO1xuICAgICAgY29uc3QgYXJndiA9IFtpLCAxXTtcbiAgICAgIGZvciAoaSA9IDkgLSBzZWN0aW9ucy5sZW5ndGg7IGkgPiAwOyBpLS0pIHtcbiAgICAgICAgYXJndi5wdXNoKCcwJyk7XG4gICAgICB9XG4gICAgICBzZWN0aW9ucy5zcGxpY2UoLi4uYXJndik7XG4gICAgfVxuXG4gICAgcmVzdWx0ID0gYnVmZiB8fCBCdWZmZXIuYWxsb2Mob2Zmc2V0ICsgMTYpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBzZWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgd29yZCA9IHBhcnNlSW50KHNlY3Rpb25zW2ldLCAxNik7XG4gICAgICByZXN1bHRbb2Zmc2V0KytdID0gKHdvcmQgPj4gOCkgJiAweGZmO1xuICAgICAgcmVzdWx0W29mZnNldCsrXSA9IHdvcmQgJiAweGZmO1xuICAgIH1cbiAgfVxuXG4gIGlmICghcmVzdWx0KSB7XG4gICAgdGhyb3cgRXJyb3IoYEludmFsaWQgaXAgYWRkcmVzczogJHtpcH1gKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5pcC50b1N0cmluZyA9IGZ1bmN0aW9uIChidWZmLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSB+fm9mZnNldDtcbiAgbGVuZ3RoID0gbGVuZ3RoIHx8IChidWZmLmxlbmd0aCAtIG9mZnNldCk7XG5cbiAgbGV0IHJlc3VsdCA9IFtdO1xuICBpZiAobGVuZ3RoID09PSA0KSB7XG4gICAgLy8gSVB2NFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHJlc3VsdC5wdXNoKGJ1ZmZbb2Zmc2V0ICsgaV0pO1xuICAgIH1cbiAgICByZXN1bHQgPSByZXN1bHQuam9pbignLicpO1xuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gMTYpIHtcbiAgICAvLyBJUHY2XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMikge1xuICAgICAgcmVzdWx0LnB1c2goYnVmZi5yZWFkVUludDE2QkUob2Zmc2V0ICsgaSkudG9TdHJpbmcoMTYpKTtcbiAgICB9XG4gICAgcmVzdWx0ID0gcmVzdWx0LmpvaW4oJzonKTtcbiAgICByZXN1bHQgPSByZXN1bHQucmVwbGFjZSgvKF58OikwKDowKSo6MCg6fCQpLywgJyQxOjokMycpO1xuICAgIHJlc3VsdCA9IHJlc3VsdC5yZXBsYWNlKC86ezMsNH0vLCAnOjonKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5jb25zdCBpcHY0UmVnZXggPSAvXihcXGR7MSwzfVxcLil7MywzfVxcZHsxLDN9JC87XG5jb25zdCBpcHY2UmVnZXggPSAvXig6Oik/KCgoXFxkezEsM31cXC4pezN9KFxcZHsxLDN9KXsxfSk/KFswLTlhLWZdKXswLDR9OnswLDJ9KXsxLDh9KDo6KT8kL2k7XG5cbmlwLmlzVjRGb3JtYXQgPSBmdW5jdGlvbiAoaXApIHtcbiAgcmV0dXJuIGlwdjRSZWdleC50ZXN0KGlwKTtcbn07XG5cbmlwLmlzVjZGb3JtYXQgPSBmdW5jdGlvbiAoaXApIHtcbiAgcmV0dXJuIGlwdjZSZWdleC50ZXN0KGlwKTtcbn07XG5cbmZ1bmN0aW9uIF9ub3JtYWxpemVGYW1pbHkoZmFtaWx5KSB7XG4gIGlmIChmYW1pbHkgPT09IDQpIHtcbiAgICByZXR1cm4gJ2lwdjQnO1xuICB9XG4gIGlmIChmYW1pbHkgPT09IDYpIHtcbiAgICByZXR1cm4gJ2lwdjYnO1xuICB9XG4gIHJldHVybiBmYW1pbHkgPyBmYW1pbHkudG9Mb3dlckNhc2UoKSA6ICdpcHY0Jztcbn1cblxuaXAuZnJvbVByZWZpeExlbiA9IGZ1bmN0aW9uIChwcmVmaXhsZW4sIGZhbWlseSkge1xuICBpZiAocHJlZml4bGVuID4gMzIpIHtcbiAgICBmYW1pbHkgPSAnaXB2Nic7XG4gIH0gZWxzZSB7XG4gICAgZmFtaWx5ID0gX25vcm1hbGl6ZUZhbWlseShmYW1pbHkpO1xuICB9XG5cbiAgbGV0IGxlbiA9IDQ7XG4gIGlmIChmYW1pbHkgPT09ICdpcHY2Jykge1xuICAgIGxlbiA9IDE2O1xuICB9XG4gIGNvbnN0IGJ1ZmYgPSBCdWZmZXIuYWxsb2MobGVuKTtcblxuICBmb3IgKGxldCBpID0gMCwgbiA9IGJ1ZmYubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgbGV0IGJpdHMgPSA4O1xuICAgIGlmIChwcmVmaXhsZW4gPCA4KSB7XG4gICAgICBiaXRzID0gcHJlZml4bGVuO1xuICAgIH1cbiAgICBwcmVmaXhsZW4gLT0gYml0cztcblxuICAgIGJ1ZmZbaV0gPSB+KDB4ZmYgPj4gYml0cykgJiAweGZmO1xuICB9XG5cbiAgcmV0dXJuIGlwLnRvU3RyaW5nKGJ1ZmYpO1xufTtcblxuaXAubWFzayA9IGZ1bmN0aW9uIChhZGRyLCBtYXNrKSB7XG4gIGFkZHIgPSBpcC50b0J1ZmZlcihhZGRyKTtcbiAgbWFzayA9IGlwLnRvQnVmZmVyKG1hc2spO1xuXG4gIGNvbnN0IHJlc3VsdCA9IEJ1ZmZlci5hbGxvYyhNYXRoLm1heChhZGRyLmxlbmd0aCwgbWFzay5sZW5ndGgpKTtcblxuICAvLyBTYW1lIHByb3RvY29sIC0gZG8gYml0d2lzZSBhbmRcbiAgbGV0IGk7XG4gIGlmIChhZGRyLmxlbmd0aCA9PT0gbWFzay5sZW5ndGgpIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgYWRkci5sZW5ndGg7IGkrKykge1xuICAgICAgcmVzdWx0W2ldID0gYWRkcltpXSAmIG1hc2tbaV07XG4gICAgfVxuICB9IGVsc2UgaWYgKG1hc2subGVuZ3RoID09PSA0KSB7XG4gICAgLy8gSVB2NiBhZGRyZXNzIGFuZCBJUHY0IG1hc2tcbiAgICAvLyAoTWFzayBsb3cgYml0cylcbiAgICBmb3IgKGkgPSAwOyBpIDwgbWFzay5sZW5ndGg7IGkrKykge1xuICAgICAgcmVzdWx0W2ldID0gYWRkclthZGRyLmxlbmd0aCAtIDQgKyBpXSAmIG1hc2tbaV07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIElQdjYgbWFzayBhbmQgSVB2NCBhZGRyXG4gICAgZm9yIChpID0gMDsgaSA8IHJlc3VsdC5sZW5ndGggLSA2OyBpKyspIHtcbiAgICAgIHJlc3VsdFtpXSA9IDA7XG4gICAgfVxuXG4gICAgLy8gOjpmZmZmOmlwdjRcbiAgICByZXN1bHRbMTBdID0gMHhmZjtcbiAgICByZXN1bHRbMTFdID0gMHhmZjtcbiAgICBmb3IgKGkgPSAwOyBpIDwgYWRkci5sZW5ndGg7IGkrKykge1xuICAgICAgcmVzdWx0W2kgKyAxMl0gPSBhZGRyW2ldICYgbWFza1tpICsgMTJdO1xuICAgIH1cbiAgICBpICs9IDEyO1xuICB9XG4gIGZvciAoOyBpIDwgcmVzdWx0Lmxlbmd0aDsgaSsrKSB7XG4gICAgcmVzdWx0W2ldID0gMDtcbiAgfVxuXG4gIHJldHVybiBpcC50b1N0cmluZyhyZXN1bHQpO1xufTtcblxuaXAuY2lkciA9IGZ1bmN0aW9uIChjaWRyU3RyaW5nKSB7XG4gIGNvbnN0IGNpZHJQYXJ0cyA9IGNpZHJTdHJpbmcuc3BsaXQoJy8nKTtcblxuICBjb25zdCBhZGRyID0gY2lkclBhcnRzWzBdO1xuICBpZiAoY2lkclBhcnRzLmxlbmd0aCAhPT0gMikge1xuICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBDSURSIHN1Ym5ldDogJHthZGRyfWApO1xuICB9XG5cbiAgY29uc3QgbWFzayA9IGlwLmZyb21QcmVmaXhMZW4ocGFyc2VJbnQoY2lkclBhcnRzWzFdLCAxMCkpO1xuXG4gIHJldHVybiBpcC5tYXNrKGFkZHIsIG1hc2spO1xufTtcblxuaXAuc3VibmV0ID0gZnVuY3Rpb24gKGFkZHIsIG1hc2spIHtcbiAgY29uc3QgbmV0d29ya0FkZHJlc3MgPSBpcC50b0xvbmcoaXAubWFzayhhZGRyLCBtYXNrKSk7XG5cbiAgLy8gQ2FsY3VsYXRlIHRoZSBtYXNrJ3MgbGVuZ3RoLlxuICBjb25zdCBtYXNrQnVmZmVyID0gaXAudG9CdWZmZXIobWFzayk7XG4gIGxldCBtYXNrTGVuZ3RoID0gMDtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IG1hc2tCdWZmZXIubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAobWFza0J1ZmZlcltpXSA9PT0gMHhmZikge1xuICAgICAgbWFza0xlbmd0aCArPSA4O1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgb2N0ZXQgPSBtYXNrQnVmZmVyW2ldICYgMHhmZjtcbiAgICAgIHdoaWxlIChvY3RldCkge1xuICAgICAgICBvY3RldCA9IChvY3RldCA8PCAxKSAmIDB4ZmY7XG4gICAgICAgIG1hc2tMZW5ndGgrKztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjb25zdCBudW1iZXJPZkFkZHJlc3NlcyA9IDIgKiogKDMyIC0gbWFza0xlbmd0aCk7XG5cbiAgcmV0dXJuIHtcbiAgICBuZXR3b3JrQWRkcmVzczogaXAuZnJvbUxvbmcobmV0d29ya0FkZHJlc3MpLFxuICAgIGZpcnN0QWRkcmVzczogbnVtYmVyT2ZBZGRyZXNzZXMgPD0gMlxuICAgICAgPyBpcC5mcm9tTG9uZyhuZXR3b3JrQWRkcmVzcylcbiAgICAgIDogaXAuZnJvbUxvbmcobmV0d29ya0FkZHJlc3MgKyAxKSxcbiAgICBsYXN0QWRkcmVzczogbnVtYmVyT2ZBZGRyZXNzZXMgPD0gMlxuICAgICAgPyBpcC5mcm9tTG9uZyhuZXR3b3JrQWRkcmVzcyArIG51bWJlck9mQWRkcmVzc2VzIC0gMSlcbiAgICAgIDogaXAuZnJvbUxvbmcobmV0d29ya0FkZHJlc3MgKyBudW1iZXJPZkFkZHJlc3NlcyAtIDIpLFxuICAgIGJyb2FkY2FzdEFkZHJlc3M6IGlwLmZyb21Mb25nKG5ldHdvcmtBZGRyZXNzICsgbnVtYmVyT2ZBZGRyZXNzZXMgLSAxKSxcbiAgICBzdWJuZXRNYXNrOiBtYXNrLFxuICAgIHN1Ym5ldE1hc2tMZW5ndGg6IG1hc2tMZW5ndGgsXG4gICAgbnVtSG9zdHM6IG51bWJlck9mQWRkcmVzc2VzIDw9IDJcbiAgICAgID8gbnVtYmVyT2ZBZGRyZXNzZXMgOiBudW1iZXJPZkFkZHJlc3NlcyAtIDIsXG4gICAgbGVuZ3RoOiBudW1iZXJPZkFkZHJlc3NlcyxcbiAgICBjb250YWlucyhvdGhlcikge1xuICAgICAgcmV0dXJuIG5ldHdvcmtBZGRyZXNzID09PSBpcC50b0xvbmcoaXAubWFzayhvdGhlciwgbWFzaykpO1xuICAgIH0sXG4gIH07XG59O1xuXG5pcC5jaWRyU3VibmV0ID0gZnVuY3Rpb24gKGNpZHJTdHJpbmcpIHtcbiAgY29uc3QgY2lkclBhcnRzID0gY2lkclN0cmluZy5zcGxpdCgnLycpO1xuXG4gIGNvbnN0IGFkZHIgPSBjaWRyUGFydHNbMF07XG4gIGlmIChjaWRyUGFydHMubGVuZ3RoICE9PSAyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIENJRFIgc3VibmV0OiAke2FkZHJ9YCk7XG4gIH1cblxuICBjb25zdCBtYXNrID0gaXAuZnJvbVByZWZpeExlbihwYXJzZUludChjaWRyUGFydHNbMV0sIDEwKSk7XG5cbiAgcmV0dXJuIGlwLnN1Ym5ldChhZGRyLCBtYXNrKTtcbn07XG5cbmlwLm5vdCA9IGZ1bmN0aW9uIChhZGRyKSB7XG4gIGNvbnN0IGJ1ZmYgPSBpcC50b0J1ZmZlcihhZGRyKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBidWZmLmxlbmd0aDsgaSsrKSB7XG4gICAgYnVmZltpXSA9IDB4ZmYgXiBidWZmW2ldO1xuICB9XG4gIHJldHVybiBpcC50b1N0cmluZyhidWZmKTtcbn07XG5cbmlwLm9yID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgYSA9IGlwLnRvQnVmZmVyKGEpO1xuICBiID0gaXAudG9CdWZmZXIoYik7XG5cbiAgLy8gc2FtZSBwcm90b2NvbFxuICBpZiAoYS5sZW5ndGggPT09IGIubGVuZ3RoKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgKytpKSB7XG4gICAgICBhW2ldIHw9IGJbaV07XG4gICAgfVxuICAgIHJldHVybiBpcC50b1N0cmluZyhhKTtcblxuICAvLyBtaXhlZCBwcm90b2NvbHNcbiAgfVxuICBsZXQgYnVmZiA9IGE7XG4gIGxldCBvdGhlciA9IGI7XG4gIGlmIChiLmxlbmd0aCA+IGEubGVuZ3RoKSB7XG4gICAgYnVmZiA9IGI7XG4gICAgb3RoZXIgPSBhO1xuICB9XG5cbiAgY29uc3Qgb2Zmc2V0ID0gYnVmZi5sZW5ndGggLSBvdGhlci5sZW5ndGg7XG4gIGZvciAobGV0IGkgPSBvZmZzZXQ7IGkgPCBidWZmLmxlbmd0aDsgKytpKSB7XG4gICAgYnVmZltpXSB8PSBvdGhlcltpIC0gb2Zmc2V0XTtcbiAgfVxuXG4gIHJldHVybiBpcC50b1N0cmluZyhidWZmKTtcbn07XG5cbmlwLmlzRXF1YWwgPSBmdW5jdGlvbiAoYSwgYikge1xuICBhID0gaXAudG9CdWZmZXIoYSk7XG4gIGIgPSBpcC50b0J1ZmZlcihiKTtcblxuICAvLyBTYW1lIHByb3RvY29sXG4gIGlmIChhLmxlbmd0aCA9PT0gYi5sZW5ndGgpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChhW2ldICE9PSBiW2ldKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gU3dhcFxuICBpZiAoYi5sZW5ndGggPT09IDQpIHtcbiAgICBjb25zdCB0ID0gYjtcbiAgICBiID0gYTtcbiAgICBhID0gdDtcbiAgfVxuXG4gIC8vIGEgLSBJUHY0LCBiIC0gSVB2NlxuICBmb3IgKGxldCBpID0gMDsgaSA8IDEwOyBpKyspIHtcbiAgICBpZiAoYltpXSAhPT0gMCkgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY29uc3Qgd29yZCA9IGIucmVhZFVJbnQxNkJFKDEwKTtcbiAgaWYgKHdvcmQgIT09IDAgJiYgd29yZCAhPT0gMHhmZmZmKSByZXR1cm4gZmFsc2U7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpICsgMTJdKSByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbmlwLmlzUHJpdmF0ZSA9IGZ1bmN0aW9uIChhZGRyKSB7XG4gIHJldHVybiAvXig6OmZ7NH06KT8xMFxcLihbMC05XXsxLDN9KVxcLihbMC05XXsxLDN9KVxcLihbMC05XXsxLDN9KSQvaVxuICAgIC50ZXN0KGFkZHIpXG4gICAgfHwgL14oOjpmezR9Oik/MTkyXFwuMTY4XFwuKFswLTldezEsM30pXFwuKFswLTldezEsM30pJC9pLnRlc3QoYWRkcilcbiAgICB8fCAvXig6OmZ7NH06KT8xNzJcXC4oMVs2LTldfDJcXGR8MzB8MzEpXFwuKFswLTldezEsM30pXFwuKFswLTldezEsM30pJC9pXG4gICAgICAudGVzdChhZGRyKVxuICAgIHx8IC9eKDo6Zns0fTopPzEyN1xcLihbMC05XXsxLDN9KVxcLihbMC05XXsxLDN9KVxcLihbMC05XXsxLDN9KSQvaS50ZXN0KGFkZHIpXG4gICAgfHwgL14oOjpmezR9Oik/MTY5XFwuMjU0XFwuKFswLTldezEsM30pXFwuKFswLTldezEsM30pJC9pLnRlc3QoYWRkcilcbiAgICB8fCAvXmZbY2RdWzAtOWEtZl17Mn06L2kudGVzdChhZGRyKVxuICAgIHx8IC9eZmU4MDovaS50ZXN0KGFkZHIpXG4gICAgfHwgL146OjEkLy50ZXN0KGFkZHIpXG4gICAgfHwgL146OiQvLnRlc3QoYWRkcik7XG59O1xuXG5pcC5pc1B1YmxpYyA9IGZ1bmN0aW9uIChhZGRyKSB7XG4gIHJldHVybiAhaXAuaXNQcml2YXRlKGFkZHIpO1xufTtcblxuaXAuaXNMb29wYmFjayA9IGZ1bmN0aW9uIChhZGRyKSB7XG4gIHJldHVybiAvXig6OmZ7NH06KT8xMjdcXC4oWzAtOV17MSwzfSlcXC4oWzAtOV17MSwzfSlcXC4oWzAtOV17MSwzfSkvXG4gICAgLnRlc3QoYWRkcilcbiAgICB8fCAvXmZlODA6OjEkLy50ZXN0KGFkZHIpXG4gICAgfHwgL146OjEkLy50ZXN0KGFkZHIpXG4gICAgfHwgL146OiQvLnRlc3QoYWRkcik7XG59O1xuXG5pcC5sb29wYmFjayA9IGZ1bmN0aW9uIChmYW1pbHkpIHtcbiAgLy9cbiAgLy8gRGVmYXVsdCB0byBgaXB2NGBcbiAgLy9cbiAgZmFtaWx5ID0gX25vcm1hbGl6ZUZhbWlseShmYW1pbHkpO1xuXG4gIGlmIChmYW1pbHkgIT09ICdpcHY0JyAmJiBmYW1pbHkgIT09ICdpcHY2Jykge1xuICAgIHRocm93IG5ldyBFcnJvcignZmFtaWx5IG11c3QgYmUgaXB2NCBvciBpcHY2Jyk7XG4gIH1cblxuICByZXR1cm4gZmFtaWx5ID09PSAnaXB2NCcgPyAnMTI3LjAuMC4xJyA6ICdmZTgwOjoxJztcbn07XG5cbi8vXG4vLyAjIyMgZnVuY3Rpb24gYWRkcmVzcyAobmFtZSwgZmFtaWx5KVxuLy8gIyMjIyBAbmFtZSB7c3RyaW5nfCdwdWJsaWMnfCdwcml2YXRlJ30gKipPcHRpb25hbCoqIE5hbWUgb3Igc2VjdXJpdHlcbi8vICAgICAgb2YgdGhlIG5ldHdvcmsgaW50ZXJmYWNlLlxuLy8gIyMjIyBAZmFtaWx5IHtpcHY0fGlwdjZ9ICoqT3B0aW9uYWwqKiBJUCBmYW1pbHkgb2YgdGhlIGFkZHJlc3MgKGRlZmF1bHRzXG4vLyAgICAgIHRvIGlwdjQpLlxuLy9cbi8vIFJldHVybnMgdGhlIGFkZHJlc3MgZm9yIHRoZSBuZXR3b3JrIGludGVyZmFjZSBvbiB0aGUgY3VycmVudCBzeXN0ZW0gd2l0aFxuLy8gdGhlIHNwZWNpZmllZCBgbmFtZWA6XG4vLyAgICogU3RyaW5nOiBGaXJzdCBgZmFtaWx5YCBhZGRyZXNzIG9mIHRoZSBpbnRlcmZhY2UuXG4vLyAgICAgICAgICAgICBJZiBub3QgZm91bmQgc2VlIGB1bmRlZmluZWRgLlxuLy8gICAqICdwdWJsaWMnOiB0aGUgZmlyc3QgcHVibGljIGlwIGFkZHJlc3Mgb2YgZmFtaWx5LlxuLy8gICAqICdwcml2YXRlJzogdGhlIGZpcnN0IHByaXZhdGUgaXAgYWRkcmVzcyBvZiBmYW1pbHkuXG4vLyAgICogdW5kZWZpbmVkOiBGaXJzdCBhZGRyZXNzIHdpdGggYGlwdjRgIG9yIGxvb3BiYWNrIGFkZHJlc3MgYDEyNy4wLjAuMWAuXG4vL1xuaXAuYWRkcmVzcyA9IGZ1bmN0aW9uIChuYW1lLCBmYW1pbHkpIHtcbiAgY29uc3QgaW50ZXJmYWNlcyA9IG9zLm5ldHdvcmtJbnRlcmZhY2VzKCk7XG5cbiAgLy9cbiAgLy8gRGVmYXVsdCB0byBgaXB2NGBcbiAgLy9cbiAgZmFtaWx5ID0gX25vcm1hbGl6ZUZhbWlseShmYW1pbHkpO1xuXG4gIC8vXG4gIC8vIElmIGEgc3BlY2lmaWMgbmV0d29yayBpbnRlcmZhY2UgaGFzIGJlZW4gbmFtZWQsXG4gIC8vIHJldHVybiB0aGUgYWRkcmVzcy5cbiAgLy9cbiAgaWYgKG5hbWUgJiYgbmFtZSAhPT0gJ3ByaXZhdGUnICYmIG5hbWUgIT09ICdwdWJsaWMnKSB7XG4gICAgY29uc3QgcmVzID0gaW50ZXJmYWNlc1tuYW1lXS5maWx0ZXIoKGRldGFpbHMpID0+IHtcbiAgICAgIGNvbnN0IGl0ZW1GYW1pbHkgPSBfbm9ybWFsaXplRmFtaWx5KGRldGFpbHMuZmFtaWx5KTtcbiAgICAgIHJldHVybiBpdGVtRmFtaWx5ID09PSBmYW1pbHk7XG4gICAgfSk7XG4gICAgaWYgKHJlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiByZXNbMF0uYWRkcmVzcztcbiAgfVxuXG4gIGNvbnN0IGFsbCA9IE9iamVjdC5rZXlzKGludGVyZmFjZXMpLm1hcCgobmljKSA9PiB7XG4gICAgLy9cbiAgICAvLyBOb3RlOiBuYW1lIHdpbGwgb25seSBiZSBgcHVibGljYCBvciBgcHJpdmF0ZWBcbiAgICAvLyB3aGVuIHRoaXMgaXMgY2FsbGVkLlxuICAgIC8vXG4gICAgY29uc3QgYWRkcmVzc2VzID0gaW50ZXJmYWNlc1tuaWNdLmZpbHRlcigoZGV0YWlscykgPT4ge1xuICAgICAgZGV0YWlscy5mYW1pbHkgPSBfbm9ybWFsaXplRmFtaWx5KGRldGFpbHMuZmFtaWx5KTtcbiAgICAgIGlmIChkZXRhaWxzLmZhbWlseSAhPT0gZmFtaWx5IHx8IGlwLmlzTG9vcGJhY2soZGV0YWlscy5hZGRyZXNzKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGlmICghbmFtZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5hbWUgPT09ICdwdWJsaWMnID8gaXAuaXNQcml2YXRlKGRldGFpbHMuYWRkcmVzcylcbiAgICAgICAgOiBpcC5pc1B1YmxpYyhkZXRhaWxzLmFkZHJlc3MpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGFkZHJlc3Nlcy5sZW5ndGggPyBhZGRyZXNzZXNbMF0uYWRkcmVzcyA6IHVuZGVmaW5lZDtcbiAgfSkuZmlsdGVyKEJvb2xlYW4pO1xuXG4gIHJldHVybiAhYWxsLmxlbmd0aCA/IGlwLmxvb3BiYWNrKGZhbWlseSkgOiBhbGxbMF07XG59O1xuXG5pcC50b0xvbmcgPSBmdW5jdGlvbiAoaXApIHtcbiAgbGV0IGlwbCA9IDA7XG4gIGlwLnNwbGl0KCcuJykuZm9yRWFjaCgob2N0ZXQpID0+IHtcbiAgICBpcGwgPDw9IDg7XG4gICAgaXBsICs9IHBhcnNlSW50KG9jdGV0KTtcbiAgfSk7XG4gIHJldHVybiAoaXBsID4+PiAwKTtcbn07XG5cbmlwLmZyb21Mb25nID0gZnVuY3Rpb24gKGlwbCkge1xuICByZXR1cm4gKGAke2lwbCA+Pj4gMjR9LiR7XG4gICAgaXBsID4+IDE2ICYgMjU1fS4ke1xuICAgIGlwbCA+PiA4ICYgMjU1fS4ke1xuICAgIGlwbCAmIDI1NX1gKTtcbn07XG4iXSwibmFtZXMiOlsiaXAiLCJleHBvcnRzIiwiQnVmZmVyIiwicmVxdWlyZSIsIm9zIiwidG9CdWZmZXIiLCJidWZmIiwib2Zmc2V0IiwicmVzdWx0IiwiaXNWNEZvcm1hdCIsImFsbG9jIiwic3BsaXQiLCJtYXAiLCJieXRlIiwicGFyc2VJbnQiLCJpc1Y2Rm9ybWF0Iiwic2VjdGlvbnMiLCJpIiwibGVuZ3RoIiwiaXN2NCIsInY0QnVmZmVyIiwic2xpY2UiLCJ0b1N0cmluZyIsInNwbGljZSIsInVuc2hpZnQiLCJwdXNoIiwiYXJndiIsIndvcmQiLCJFcnJvciIsImpvaW4iLCJyZWFkVUludDE2QkUiLCJyZXBsYWNlIiwiaXB2NFJlZ2V4IiwiaXB2NlJlZ2V4IiwidGVzdCIsIl9ub3JtYWxpemVGYW1pbHkiLCJmYW1pbHkiLCJ0b0xvd2VyQ2FzZSIsImZyb21QcmVmaXhMZW4iLCJwcmVmaXhsZW4iLCJsZW4iLCJuIiwiYml0cyIsIm1hc2siLCJhZGRyIiwiTWF0aCIsIm1heCIsImNpZHIiLCJjaWRyU3RyaW5nIiwiY2lkclBhcnRzIiwic3VibmV0IiwibmV0d29ya0FkZHJlc3MiLCJ0b0xvbmciLCJtYXNrQnVmZmVyIiwibWFza0xlbmd0aCIsIm9jdGV0IiwibnVtYmVyT2ZBZGRyZXNzZXMiLCJmcm9tTG9uZyIsImZpcnN0QWRkcmVzcyIsImxhc3RBZGRyZXNzIiwiYnJvYWRjYXN0QWRkcmVzcyIsInN1Ym5ldE1hc2siLCJzdWJuZXRNYXNrTGVuZ3RoIiwibnVtSG9zdHMiLCJjb250YWlucyIsIm90aGVyIiwiY2lkclN1Ym5ldCIsIm5vdCIsIm9yIiwiYSIsImIiLCJpc0VxdWFsIiwidCIsImlzUHJpdmF0ZSIsImlzUHVibGljIiwiaXNMb29wYmFjayIsImxvb3BiYWNrIiwiYWRkcmVzcyIsIm5hbWUiLCJpbnRlcmZhY2VzIiwibmV0d29ya0ludGVyZmFjZXMiLCJyZXMiLCJmaWx0ZXIiLCJkZXRhaWxzIiwiaXRlbUZhbWlseSIsInVuZGVmaW5lZCIsImFsbCIsIk9iamVjdCIsImtleXMiLCJuaWMiLCJhZGRyZXNzZXMiLCJCb29sZWFuIiwiaXBsIiwiZm9yRWFjaCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/ip@2.0.0/node_modules/ip/lib/ip.js\n");

/***/ })

};
;