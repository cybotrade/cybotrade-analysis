"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@sinclair+typebox@0.28.20";
exports.ids = ["vendor-chunks/@sinclair+typebox@0.28.20"];
exports.modules = {

/***/ "(ssr)/../../node_modules/.pnpm/@sinclair+typebox@0.28.20/node_modules/@sinclair/typebox/compiler/compiler.js":
/*!**************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@sinclair+typebox@0.28.20/node_modules/@sinclair/typebox/compiler/compiler.js ***!
  \**************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*--------------------------------------------------------------------------\n\n@sinclair/typebox/compiler\n\nThe MIT License (MIT)\n\nCopyright (c) 2017-2023 Haydn Paterson (sinclair) <haydn.developer@gmail.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n---------------------------------------------------------------------------*/ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.TypeCompiler = exports.TypeCompilerTypeGuardError = exports.TypeCompilerDereferenceError = exports.TypeCompilerUnknownTypeError = exports.TypeCheck = void 0;\nconst Types = __webpack_require__(/*! ../typebox */ \"(ssr)/../../node_modules/.pnpm/@sinclair+typebox@0.28.20/node_modules/@sinclair/typebox/typebox.js\");\nconst index_1 = __webpack_require__(/*! ../errors/index */ \"(ssr)/../../node_modules/.pnpm/@sinclair+typebox@0.28.20/node_modules/@sinclair/typebox/errors/index.js\");\nconst index_2 = __webpack_require__(/*! ../system/index */ \"(ssr)/../../node_modules/.pnpm/@sinclair+typebox@0.28.20/node_modules/@sinclair/typebox/system/index.js\");\nconst hash_1 = __webpack_require__(/*! ../value/hash */ \"(ssr)/../../node_modules/.pnpm/@sinclair+typebox@0.28.20/node_modules/@sinclair/typebox/value/hash.js\");\n// -------------------------------------------------------------------\n// TypeCheck\n// -------------------------------------------------------------------\nclass TypeCheck {\n    constructor(schema, references, checkFunc, code){\n        this.schema = schema;\n        this.references = references;\n        this.checkFunc = checkFunc;\n        this.code = code;\n    }\n    /** Returns the generated assertion code used to validate this type. */ Code() {\n        return this.code;\n    }\n    /** Returns an iterator for each error in this value. */ Errors(value) {\n        return index_1.ValueErrors.Errors(this.schema, this.references, value);\n    }\n    /** Returns true if the value matches the compiled type. */ Check(value) {\n        return this.checkFunc(value);\n    }\n}\nexports.TypeCheck = TypeCheck;\n// -------------------------------------------------------------------\n// Character\n// -------------------------------------------------------------------\nvar Character;\n(function(Character) {\n    function DollarSign(code) {\n        return code === 36;\n    }\n    Character.DollarSign = DollarSign;\n    function IsUnderscore(code) {\n        return code === 95;\n    }\n    Character.IsUnderscore = IsUnderscore;\n    function IsAlpha(code) {\n        return code >= 65 && code <= 90 || code >= 97 && code <= 122;\n    }\n    Character.IsAlpha = IsAlpha;\n    function IsNumeric(code) {\n        return code >= 48 && code <= 57;\n    }\n    Character.IsNumeric = IsNumeric;\n})(Character || (Character = {}));\n// -------------------------------------------------------------------\n// MemberExpression\n// -------------------------------------------------------------------\nvar MemberExpression;\n(function(MemberExpression) {\n    function IsFirstCharacterNumeric(value) {\n        if (value.length === 0) return false;\n        return Character.IsNumeric(value.charCodeAt(0));\n    }\n    function IsAccessor(value) {\n        if (IsFirstCharacterNumeric(value)) return false;\n        for(let i = 0; i < value.length; i++){\n            const code = value.charCodeAt(i);\n            const check = Character.IsAlpha(code) || Character.IsNumeric(code) || Character.DollarSign(code) || Character.IsUnderscore(code);\n            if (!check) return false;\n        }\n        return true;\n    }\n    function EscapeHyphen(key) {\n        return key.replace(/'/g, \"\\\\'\");\n    }\n    function Encode(object, key) {\n        return IsAccessor(key) ? `${object}.${key}` : `${object}['${EscapeHyphen(key)}']`;\n    }\n    MemberExpression.Encode = Encode;\n})(MemberExpression || (MemberExpression = {}));\n// -------------------------------------------------------------------\n// Identifier\n// -------------------------------------------------------------------\nvar Identifier;\n(function(Identifier) {\n    function Encode($id) {\n        const buffer = [];\n        for(let i = 0; i < $id.length; i++){\n            const code = $id.charCodeAt(i);\n            if (Character.IsNumeric(code) || Character.IsAlpha(code)) {\n                buffer.push($id.charAt(i));\n            } else {\n                buffer.push(`_${code}_`);\n            }\n        }\n        return buffer.join(\"\").replace(/__/g, \"_\");\n    }\n    Identifier.Encode = Encode;\n})(Identifier || (Identifier = {}));\n// -------------------------------------------------------------------\n// TypeCompiler\n// -------------------------------------------------------------------\nclass TypeCompilerUnknownTypeError extends Error {\n    constructor(schema){\n        super(\"TypeCompiler: Unknown type\");\n        this.schema = schema;\n    }\n}\nexports.TypeCompilerUnknownTypeError = TypeCompilerUnknownTypeError;\nclass TypeCompilerDereferenceError extends Error {\n    constructor(schema){\n        super(`TypeCompiler: Unable to dereference schema with $id '${schema.$ref}'`);\n        this.schema = schema;\n    }\n}\nexports.TypeCompilerDereferenceError = TypeCompilerDereferenceError;\nclass TypeCompilerTypeGuardError extends Error {\n    constructor(schema){\n        super(\"TypeCompiler: Preflight validation check failed to guard for the given schema\");\n        this.schema = schema;\n    }\n}\nexports.TypeCompilerTypeGuardError = TypeCompilerTypeGuardError;\n/** Compiles Types for Runtime Type Checking */ var TypeCompiler;\n(function(TypeCompiler) {\n    // -------------------------------------------------------------------\n    // Guards\n    // -------------------------------------------------------------------\n    function IsBigInt(value) {\n        return typeof value === \"bigint\";\n    }\n    function IsNumber(value) {\n        return typeof value === \"number\" && globalThis.Number.isFinite(value);\n    }\n    function IsString(value) {\n        return typeof value === \"string\";\n    }\n    // ----------------------------------------------------------------------\n    // SchemaGuards\n    // ----------------------------------------------------------------------\n    function IsAnyOrUnknown(schema) {\n        return schema[Types.Kind] === \"Any\" || schema[Types.Kind] === \"Unknown\";\n    }\n    // -------------------------------------------------------------------\n    // Polices\n    // -------------------------------------------------------------------\n    function IsExactOptionalProperty(value, key, expression) {\n        return index_2.TypeSystem.ExactOptionalPropertyTypes ? `('${key}' in ${value} ? ${expression} : true)` : `(${MemberExpression.Encode(value, key)} !== undefined ? ${expression} : true)`;\n    }\n    function IsObjectCheck(value) {\n        return !index_2.TypeSystem.AllowArrayObjects ? `(typeof ${value} === 'object' && ${value} !== null && !Array.isArray(${value}))` : `(typeof ${value} === 'object' && ${value} !== null)`;\n    }\n    function IsRecordCheck(value) {\n        return !index_2.TypeSystem.AllowArrayObjects ? `(typeof ${value} === 'object' && ${value} !== null && !Array.isArray(${value}) && !(${value} instanceof Date) && !(${value} instanceof Uint8Array))` : `(typeof ${value} === 'object' && ${value} !== null && !(${value} instanceof Date) && !(${value} instanceof Uint8Array))`;\n    }\n    function IsNumberCheck(value) {\n        return !index_2.TypeSystem.AllowNaN ? `(typeof ${value} === 'number' && Number.isFinite(${value}))` : `typeof ${value} === 'number'`;\n    }\n    function IsVoidCheck(value) {\n        return index_2.TypeSystem.AllowVoidNull ? `(${value} === undefined || ${value} === null)` : `${value} === undefined`;\n    }\n    // -------------------------------------------------------------------\n    // Types\n    // -------------------------------------------------------------------\n    function* Any(schema, references, value) {\n        yield \"true\";\n    }\n    function* Array(schema, references, value) {\n        yield `Array.isArray(${value})`;\n        if (IsNumber(schema.minItems)) yield `${value}.length >= ${schema.minItems}`;\n        if (IsNumber(schema.maxItems)) yield `${value}.length <= ${schema.maxItems}`;\n        if (schema.uniqueItems === true) yield `((function() { const set = new Set(); for(const element of ${value}) { const hashed = hash(element); if(set.has(hashed)) { return false } else { set.add(hashed) } } return true })())`;\n        const expression = CreateExpression(schema.items, references, \"value\");\n        const parameter = CreateParameter(\"value\", \"any\");\n        yield `${value}.every((${parameter}) => ${expression})`;\n    }\n    function* BigInt(schema, references, value) {\n        yield `(typeof ${value} === 'bigint')`;\n        if (IsBigInt(schema.multipleOf)) yield `(${value} % BigInt(${schema.multipleOf})) === 0`;\n        if (IsBigInt(schema.exclusiveMinimum)) yield `${value} > BigInt(${schema.exclusiveMinimum})`;\n        if (IsBigInt(schema.exclusiveMaximum)) yield `${value} < BigInt(${schema.exclusiveMaximum})`;\n        if (IsBigInt(schema.minimum)) yield `${value} >= BigInt(${schema.minimum})`;\n        if (IsBigInt(schema.maximum)) yield `${value} <= BigInt(${schema.maximum})`;\n    }\n    function* Boolean(schema, references, value) {\n        yield `(typeof ${value} === 'boolean')`;\n    }\n    function* Constructor(schema, references, value) {\n        yield* Visit(schema.returns, references, `${value}.prototype`);\n    }\n    function* Date(schema, references, value) {\n        yield `(${value} instanceof Date) && Number.isFinite(${value}.getTime())`;\n        if (IsNumber(schema.exclusiveMinimumTimestamp)) yield `${value}.getTime() > ${schema.exclusiveMinimumTimestamp}`;\n        if (IsNumber(schema.exclusiveMaximumTimestamp)) yield `${value}.getTime() < ${schema.exclusiveMaximumTimestamp}`;\n        if (IsNumber(schema.minimumTimestamp)) yield `${value}.getTime() >= ${schema.minimumTimestamp}`;\n        if (IsNumber(schema.maximumTimestamp)) yield `${value}.getTime() <= ${schema.maximumTimestamp}`;\n    }\n    function* Function(schema, references, value) {\n        yield `(typeof ${value} === 'function')`;\n    }\n    function* Integer(schema, references, value) {\n        yield `(typeof ${value} === 'number' && Number.isInteger(${value}))`;\n        if (IsNumber(schema.multipleOf)) yield `(${value} % ${schema.multipleOf}) === 0`;\n        if (IsNumber(schema.exclusiveMinimum)) yield `${value} > ${schema.exclusiveMinimum}`;\n        if (IsNumber(schema.exclusiveMaximum)) yield `${value} < ${schema.exclusiveMaximum}`;\n        if (IsNumber(schema.minimum)) yield `${value} >= ${schema.minimum}`;\n        if (IsNumber(schema.maximum)) yield `${value} <= ${schema.maximum}`;\n    }\n    function* Intersect(schema, references, value) {\n        const check1 = schema.allOf.map((schema)=>CreateExpression(schema, references, value)).join(\" && \");\n        if (schema.unevaluatedProperties === false) {\n            const keyCheck = PushLocal(`${new RegExp(Types.KeyResolver.ResolvePattern(schema))};`);\n            const check2 = `Object.getOwnPropertyNames(${value}).every(key => ${keyCheck}.test(key))`;\n            yield `(${check1} && ${check2})`;\n        } else if (Types.TypeGuard.TSchema(schema.unevaluatedProperties)) {\n            const keyCheck = PushLocal(`${new RegExp(Types.KeyResolver.ResolvePattern(schema))};`);\n            const check2 = `Object.getOwnPropertyNames(${value}).every(key => ${keyCheck}.test(key) || ${CreateExpression(schema.unevaluatedProperties, references, `${value}[key]`)})`;\n            yield `(${check1} && ${check2})`;\n        } else {\n            yield `(${check1})`;\n        }\n    }\n    function* Literal(schema, references, value) {\n        if (typeof schema.const === \"number\" || typeof schema.const === \"boolean\") {\n            yield `(${value} === ${schema.const})`;\n        } else {\n            yield `(${value} === '${schema.const}')`;\n        }\n    }\n    function* Never(schema, references, value) {\n        yield `false`;\n    }\n    function* Not(schema, references, value) {\n        const left = CreateExpression(schema.allOf[0].not, references, value);\n        const right = CreateExpression(schema.allOf[1], references, value);\n        yield `!${left} && ${right}`;\n    }\n    function* Null(schema, references, value) {\n        yield `(${value} === null)`;\n    }\n    function* Number(schema, references, value) {\n        yield IsNumberCheck(value);\n        if (IsNumber(schema.multipleOf)) yield `(${value} % ${schema.multipleOf}) === 0`;\n        if (IsNumber(schema.exclusiveMinimum)) yield `${value} > ${schema.exclusiveMinimum}`;\n        if (IsNumber(schema.exclusiveMaximum)) yield `${value} < ${schema.exclusiveMaximum}`;\n        if (IsNumber(schema.minimum)) yield `${value} >= ${schema.minimum}`;\n        if (IsNumber(schema.maximum)) yield `${value} <= ${schema.maximum}`;\n    }\n    function* Object1(schema, references, value) {\n        yield IsObjectCheck(value);\n        if (IsNumber(schema.minProperties)) yield `Object.getOwnPropertyNames(${value}).length >= ${schema.minProperties}`;\n        if (IsNumber(schema.maxProperties)) yield `Object.getOwnPropertyNames(${value}).length <= ${schema.maxProperties}`;\n        const knownKeys = globalThis.Object.getOwnPropertyNames(schema.properties);\n        for (const knownKey of knownKeys){\n            const memberExpression = MemberExpression.Encode(value, knownKey);\n            const property = schema.properties[knownKey];\n            if (schema.required && schema.required.includes(knownKey)) {\n                yield* Visit(property, references, memberExpression);\n                if (Types.ExtendsUndefined.Check(property) || IsAnyOrUnknown(property)) yield `('${knownKey}' in ${value})`;\n            } else {\n                const expression = CreateExpression(property, references, memberExpression);\n                yield IsExactOptionalProperty(value, knownKey, expression);\n            }\n        }\n        if (schema.additionalProperties === false) {\n            if (schema.required && schema.required.length === knownKeys.length) {\n                yield `Object.getOwnPropertyNames(${value}).length === ${knownKeys.length}`;\n            } else {\n                const keys = `[${knownKeys.map((key)=>`'${key}'`).join(\", \")}]`;\n                yield `Object.getOwnPropertyNames(${value}).every(key => ${keys}.includes(key))`;\n            }\n        }\n        if (typeof schema.additionalProperties === \"object\") {\n            const expression = CreateExpression(schema.additionalProperties, references, `${value}[key]`);\n            const keys = `[${knownKeys.map((key)=>`'${key}'`).join(\", \")}]`;\n            yield `(Object.getOwnPropertyNames(${value}).every(key => ${keys}.includes(key) || ${expression}))`;\n        }\n    }\n    function* Promise(schema, references, value) {\n        yield `(typeof value === 'object' && typeof ${value}.then === 'function')`;\n    }\n    function* Record(schema, references, value) {\n        yield IsRecordCheck(value);\n        if (IsNumber(schema.minProperties)) yield `Object.getOwnPropertyNames(${value}).length >= ${schema.minProperties}`;\n        if (IsNumber(schema.maxProperties)) yield `Object.getOwnPropertyNames(${value}).length <= ${schema.maxProperties}`;\n        const [patternKey, patternSchema] = globalThis.Object.entries(schema.patternProperties)[0];\n        const local = PushLocal(`new RegExp(/${patternKey}/)`);\n        const check1 = CreateExpression(patternSchema, references, \"value\");\n        const check2 = Types.TypeGuard.TSchema(schema.additionalProperties) ? CreateExpression(schema.additionalProperties, references, value) : schema.additionalProperties === false ? \"false\" : \"true\";\n        const expression = `(${local}.test(key) ? ${check1} : ${check2})`;\n        yield `(Object.entries(${value}).every(([key, value]) => ${expression}))`;\n    }\n    function* Ref(schema, references, value) {\n        const index = references.findIndex((foreign)=>foreign.$id === schema.$ref);\n        if (index === -1) throw new TypeCompilerDereferenceError(schema);\n        const target = references[index];\n        // Reference: If we have seen this reference before we can just yield and\n        // return the function call. If this isn't the case we defer to visit to\n        // generate and set the function for subsequent passes.\n        if (state.functions.has(schema.$ref)) return yield `${CreateFunctionName(schema.$ref)}(${value})`;\n        yield* Visit(target, references, value);\n    }\n    function* String(schema, references, value) {\n        yield `(typeof ${value} === 'string')`;\n        if (IsNumber(schema.minLength)) yield `${value}.length >= ${schema.minLength}`;\n        if (IsNumber(schema.maxLength)) yield `${value}.length <= ${schema.maxLength}`;\n        if (schema.pattern !== undefined) {\n            const local = PushLocal(`${new RegExp(schema.pattern)};`);\n            yield `${local}.test(${value})`;\n        }\n        if (schema.format !== undefined) {\n            yield `format('${schema.format}', ${value})`;\n        }\n    }\n    function* Symbol(schema, references, value) {\n        yield `(typeof ${value} === 'symbol')`;\n    }\n    function* TemplateLiteral(schema, references, value) {\n        yield `(typeof ${value} === 'string')`;\n        const local = PushLocal(`${new RegExp(schema.pattern)};`);\n        yield `${local}.test(${value})`;\n    }\n    function* This(schema, references, value) {\n        const func = CreateFunctionName(schema.$ref);\n        yield `${func}(${value})`;\n    }\n    function* Tuple(schema, references, value) {\n        yield `Array.isArray(${value})`;\n        if (schema.items === undefined) return yield `${value}.length === 0`;\n        yield `(${value}.length === ${schema.maxItems})`;\n        for(let i = 0; i < schema.items.length; i++){\n            const expression = CreateExpression(schema.items[i], references, `${value}[${i}]`);\n            yield `${expression}`;\n        }\n    }\n    function* Undefined(schema, references, value) {\n        yield `${value} === undefined`;\n    }\n    function* Union(schema, references, value) {\n        const expressions = schema.anyOf.map((schema)=>CreateExpression(schema, references, value));\n        yield `(${expressions.join(\" || \")})`;\n    }\n    function* Uint8Array(schema, references, value) {\n        yield `${value} instanceof Uint8Array`;\n        if (IsNumber(schema.maxByteLength)) yield `(${value}.length <= ${schema.maxByteLength})`;\n        if (IsNumber(schema.minByteLength)) yield `(${value}.length >= ${schema.minByteLength})`;\n    }\n    function* Unknown(schema, references, value) {\n        yield \"true\";\n    }\n    function* Void(schema, references, value) {\n        yield IsVoidCheck(value);\n    }\n    function* UserDefined(schema, references, value) {\n        const schema_key = `schema_key_${state.customs.size}`;\n        state.customs.set(schema_key, schema);\n        yield `custom('${schema[Types.Kind]}', '${schema_key}', ${value})`;\n    }\n    function* Visit(schema, references, value, root = false) {\n        const references_ = IsString(schema.$id) ? [\n            ...references,\n            schema\n        ] : references;\n        const schema_ = schema;\n        // Rule: Types with identifiers are hoisted into their own functions.\n        // The following will generate a function for the schema and yield the\n        // call to that function. This call is only made if NOT the root type\n        // which allows the generated function to yield its expression. The\n        // root argument is only true when making calls via CreateFunction().\n        // Note there is potential to omit the root argument and conditional\n        // by refactoring the logic below. Consider for review.\n        if (IsString(schema.$id)) {\n            const name = CreateFunctionName(schema.$id);\n            if (!state.functions.has(schema.$id)) {\n                state.functions.add(schema.$id);\n                const body = CreateFunction(name, schema, references, \"value\");\n                PushFunction(body);\n            }\n            if (!root) return yield `${name}(${value})`;\n        }\n        switch(schema_[Types.Kind]){\n            case \"Any\":\n                return yield* Any(schema_, references_, value);\n            case \"Array\":\n                return yield* Array(schema_, references_, value);\n            case \"BigInt\":\n                return yield* BigInt(schema_, references_, value);\n            case \"Boolean\":\n                return yield* Boolean(schema_, references_, value);\n            case \"Constructor\":\n                return yield* Constructor(schema_, references_, value);\n            case \"Date\":\n                return yield* Date(schema_, references_, value);\n            case \"Function\":\n                return yield* Function(schema_, references_, value);\n            case \"Integer\":\n                return yield* Integer(schema_, references_, value);\n            case \"Intersect\":\n                return yield* Intersect(schema_, references_, value);\n            case \"Literal\":\n                return yield* Literal(schema_, references_, value);\n            case \"Never\":\n                return yield* Never(schema_, references_, value);\n            case \"Not\":\n                return yield* Not(schema_, references_, value);\n            case \"Null\":\n                return yield* Null(schema_, references_, value);\n            case \"Number\":\n                return yield* Number(schema_, references_, value);\n            case \"Object\":\n                return yield* Object1(schema_, references_, value);\n            case \"Promise\":\n                return yield* Promise(schema_, references_, value);\n            case \"Record\":\n                return yield* Record(schema_, references_, value);\n            case \"Ref\":\n                return yield* Ref(schema_, references_, value);\n            case \"String\":\n                return yield* String(schema_, references_, value);\n            case \"Symbol\":\n                return yield* Symbol(schema_, references_, value);\n            case \"TemplateLiteral\":\n                return yield* TemplateLiteral(schema_, references_, value);\n            case \"This\":\n                return yield* This(schema_, references_, value);\n            case \"Tuple\":\n                return yield* Tuple(schema_, references_, value);\n            case \"Undefined\":\n                return yield* Undefined(schema_, references_, value);\n            case \"Union\":\n                return yield* Union(schema_, references_, value);\n            case \"Uint8Array\":\n                return yield* Uint8Array(schema_, references_, value);\n            case \"Unknown\":\n                return yield* Unknown(schema_, references_, value);\n            case \"Void\":\n                return yield* Void(schema_, references_, value);\n            default:\n                if (!Types.TypeRegistry.Has(schema_[Types.Kind])) throw new TypeCompilerUnknownTypeError(schema);\n                return yield* UserDefined(schema_, references_, value);\n        }\n    }\n    // -------------------------------------------------------------------\n    // Compiler State\n    // -------------------------------------------------------------------\n    // prettier-ignore\n    const state = {\n        language: \"javascript\",\n        variables: new Set(),\n        functions: new Set(),\n        customs: new Map()\n    };\n    function CreateFunctionName($id) {\n        return `check_${Identifier.Encode($id)}`;\n    }\n    function CreateExpression(schema, references, value) {\n        return `(${[\n            ...Visit(schema, references, value)\n        ].join(\" && \")})`;\n    }\n    function CreateParameter(name, type) {\n        const annotation = state.language === \"typescript\" ? `: ${type}` : \"\";\n        return `${name}${annotation}`;\n    }\n    function CreateReturns(type) {\n        return state.language === \"typescript\" ? `: ${type}` : \"\";\n    }\n    function CreateFunction(name, schema, references, value) {\n        const expression = [\n            ...Visit(schema, references, value, true)\n        ].map((condition)=>`    ${condition}`).join(\" &&\\n\");\n        const parameter = CreateParameter(\"value\", \"any\");\n        const returns = CreateReturns(\"boolean\");\n        return `function ${name}(${parameter})${returns} {\\n  return (\\n${expression}\\n )\\n}`;\n    }\n    function PushFunction(functionBody) {\n        state.variables.add(functionBody);\n    }\n    function PushLocal(expression) {\n        const local = `local_${state.variables.size}`;\n        state.variables.add(`const ${local} = ${expression}`);\n        return local;\n    }\n    function GetLocals() {\n        return [\n            ...state.variables.values()\n        ];\n    }\n    // -------------------------------------------------------------------\n    // Compile\n    // -------------------------------------------------------------------\n    function Build(schema, references) {\n        const check = CreateFunction(\"check\", schema, references, \"value\"); // interior visit\n        const locals = GetLocals();\n        const parameter = CreateParameter(\"value\", \"any\");\n        const returns = CreateReturns(\"boolean\");\n        // prettier-ignore\n        return IsString(schema.$id) // ensure top level schemas with $id's are hoisted\n         ? `${locals.join(\"\\n\")}\\nreturn function check(${parameter})${returns} {\\n  return ${CreateFunctionName(schema.$id)}(value)\\n}` : `${locals.join(\"\\n\")}\\nreturn ${check}`;\n    }\n    /** Returns the generated assertion code used to validate this type. */ function Code(schema, references = [], options = {\n        language: \"javascript\"\n    }) {\n        // compiler-reset\n        state.language = options.language;\n        state.variables.clear();\n        state.functions.clear();\n        state.customs.clear();\n        if (!Types.TypeGuard.TSchema(schema)) throw new TypeCompilerTypeGuardError(schema);\n        for (const schema of references)if (!Types.TypeGuard.TSchema(schema)) throw new TypeCompilerTypeGuardError(schema);\n        return Build(schema, references);\n    }\n    TypeCompiler.Code = Code;\n    /** Compiles the given type for runtime type checking. This compiler only accepts known TypeBox types non-inclusive of unsafe types. */ function Compile(schema, references = []) {\n        const code = Code(schema, references, {\n            language: \"javascript\"\n        });\n        const customs = new Map(state.customs);\n        const compiledFunction = globalThis.Function(\"custom\", \"format\", \"hash\", code);\n        const checkFunction = compiledFunction((kind, schema_key, value)=>{\n            if (!Types.TypeRegistry.Has(kind) || !customs.has(schema_key)) return false;\n            const schema = customs.get(schema_key);\n            const func = Types.TypeRegistry.Get(kind);\n            return func(schema, value);\n        }, (format, value)=>{\n            if (!Types.FormatRegistry.Has(format)) return false;\n            const func = Types.FormatRegistry.Get(format);\n            return func(value);\n        }, (value)=>{\n            return hash_1.ValueHash.Create(value);\n        });\n        return new TypeCheck(schema, references, checkFunction, code);\n    }\n    TypeCompiler.Compile = Compile;\n})(TypeCompiler || (exports.TypeCompiler = TypeCompiler = {}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BzaW5jbGFpcit0eXBlYm94QDAuMjguMjAvbm9kZV9tb2R1bGVzL0BzaW5jbGFpci90eXBlYm94L2NvbXBpbGVyL2NvbXBpbGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzJFQTBCMkUsR0FDM0VBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxvQkFBb0IsR0FBR0Esa0NBQWtDLEdBQUdBLG9DQUFvQyxHQUFHQSxvQ0FBb0MsR0FBR0EsaUJBQWlCLEdBQUcsS0FBSztBQUNuSyxNQUFNTyxRQUFRQyxtQkFBT0EsQ0FBQyxzSEFBWTtBQUNsQyxNQUFNQyxVQUFVRCxtQkFBT0EsQ0FBQyxnSUFBaUI7QUFDekMsTUFBTUUsVUFBVUYsbUJBQU9BLENBQUMsZ0lBQWlCO0FBQ3pDLE1BQU1HLFNBQVNILG1CQUFPQSxDQUFDLDRIQUFlO0FBQ3RDLHNFQUFzRTtBQUN0RSxZQUFZO0FBQ1osc0VBQXNFO0FBQ3RFLE1BQU1GO0lBQ0ZNLFlBQVlDLE1BQU0sRUFBRUMsVUFBVSxFQUFFQyxTQUFTLEVBQUVDLElBQUksQ0FBRTtRQUM3QyxJQUFJLENBQUNILE1BQU0sR0FBR0E7UUFDZCxJQUFJLENBQUNDLFVBQVUsR0FBR0E7UUFDbEIsSUFBSSxDQUFDQyxTQUFTLEdBQUdBO1FBQ2pCLElBQUksQ0FBQ0MsSUFBSSxHQUFHQTtJQUNoQjtJQUNBLHFFQUFxRSxHQUNyRUMsT0FBTztRQUNILE9BQU8sSUFBSSxDQUFDRCxJQUFJO0lBQ3BCO0lBQ0Esc0RBQXNELEdBQ3RERSxPQUFPakIsS0FBSyxFQUFFO1FBQ1YsT0FBT1EsUUFBUVUsV0FBVyxDQUFDRCxNQUFNLENBQUMsSUFBSSxDQUFDTCxNQUFNLEVBQUUsSUFBSSxDQUFDQyxVQUFVLEVBQUViO0lBQ3BFO0lBQ0EseURBQXlELEdBQ3pEbUIsTUFBTW5CLEtBQUssRUFBRTtRQUNULE9BQU8sSUFBSSxD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QU1iLFVBQVUsSUFBSWdCLElBQUkxQyxNQUFNMEIsT0FBTztRQUNyQyxNQUFNNkIsbUJBQW1CaEosV0FBV3lDLFFBQVEsQ0FBQyxVQUFVLFVBQVUsUUFBUXpFO1FBQ3pFLE1BQU1pTCxnQkFBZ0JELGlCQUFpQixDQUFDRSxNQUFNaEMsWUFBWWpLO1lBQ3RELElBQUksQ0FBQ00sTUFBTXVLLFlBQVksQ0FBQ0MsR0FBRyxDQUFDbUIsU0FBUyxDQUFDL0IsUUFBUXhCLEdBQUcsQ0FBQ3VCLGFBQzlDLE9BQU87WUFDWCxNQUFNckosU0FBU3NKLFFBQVFnQyxHQUFHLENBQUNqQztZQUMzQixNQUFNWixPQUFPL0ksTUFBTXVLLFlBQVksQ0FBQ3NCLEdBQUcsQ0FBQ0Y7WUFDcEMsT0FBTzVDLEtBQUt6SSxRQUFRWjtRQUN4QixHQUFHLENBQUNpSixRQUFRako7WUFDUixJQUFJLENBQUNNLE1BQU04TCxjQUFjLENBQUN0QixHQUFHLENBQUM3QixTQUMxQixPQUFPO1lBQ1gsTUFBTUksT0FBTy9JLE1BQU04TCxjQUFjLENBQUNELEdBQUcsQ0FBQ2xEO1lBQ3RDLE9BQU9JLEtBQUtySjtRQUNoQixHQUFHLENBQUNBO1lBQ0EsT0FBT1UsT0FBTzJMLFNBQVMsQ0FBQ0MsTUFBTSxDQUFDdE07UUFDbkM7UUFDQSxPQUFPLElBQUlLLFVBQVVPLFFBQVFDLFlBQVltTCxlQUFlakw7SUFDNUQ7SUFDQWQsYUFBYTZMLE9BQU8sR0FBR0E7QUFDM0IsR0FBRzdMLGdCQUFpQkYsQ0FBQUEsb0JBQW9CLEdBQUdFLGVBQWUsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHNpbmNsYWlyK3R5cGVib3hAMC4yOC4yMC9ub2RlX21vZHVsZXMvQHNpbmNsYWlyL3R5cGVib3gvY29tcGlsZXIvY29tcGlsZXIuanM/NTRjYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuQHNpbmNsYWlyL3R5cGVib3gvY29tcGlsZXJcblxuVGhlIE1JVCBMaWNlbnNlIChNSVQpXG5cbkNvcHlyaWdodCAoYykgMjAxNy0yMDIzIEhheWRuIFBhdGVyc29uIChzaW5jbGFpcikgPGhheWRuLmRldmVsb3BlckBnbWFpbC5jb20+XG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbm9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbmluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbnRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbmNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbmFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG5JTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbkZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbk9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cblRIRSBTT0ZUV0FSRS5cblxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVHlwZUNvbXBpbGVyID0gZXhwb3J0cy5UeXBlQ29tcGlsZXJUeXBlR3VhcmRFcnJvciA9IGV4cG9ydHMuVHlwZUNvbXBpbGVyRGVyZWZlcmVuY2VFcnJvciA9IGV4cG9ydHMuVHlwZUNvbXBpbGVyVW5rbm93blR5cGVFcnJvciA9IGV4cG9ydHMuVHlwZUNoZWNrID0gdm9pZCAwO1xuY29uc3QgVHlwZXMgPSByZXF1aXJlKFwiLi4vdHlwZWJveFwiKTtcbmNvbnN0IGluZGV4XzEgPSByZXF1aXJlKFwiLi4vZXJyb3JzL2luZGV4XCIpO1xuY29uc3QgaW5kZXhfMiA9IHJlcXVpcmUoXCIuLi9zeXN0ZW0vaW5kZXhcIik7XG5jb25zdCBoYXNoXzEgPSByZXF1aXJlKFwiLi4vdmFsdWUvaGFzaFwiKTtcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFR5cGVDaGVja1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuY2xhc3MgVHlwZUNoZWNrIHtcbiAgICBjb25zdHJ1Y3RvcihzY2hlbWEsIHJlZmVyZW5jZXMsIGNoZWNrRnVuYywgY29kZSkge1xuICAgICAgICB0aGlzLnNjaGVtYSA9IHNjaGVtYTtcbiAgICAgICAgdGhpcy5yZWZlcmVuY2VzID0gcmVmZXJlbmNlcztcbiAgICAgICAgdGhpcy5jaGVja0Z1bmMgPSBjaGVja0Z1bmM7XG4gICAgICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgfVxuICAgIC8qKiBSZXR1cm5zIHRoZSBnZW5lcmF0ZWQgYXNzZXJ0aW9uIGNvZGUgdXNlZCB0byB2YWxpZGF0ZSB0aGlzIHR5cGUuICovXG4gICAgQ29kZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29kZTtcbiAgICB9XG4gICAgLyoqIFJldHVybnMgYW4gaXRlcmF0b3IgZm9yIGVhY2ggZXJyb3IgaW4gdGhpcyB2YWx1ZS4gKi9cbiAgICBFcnJvcnModmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGluZGV4XzEuVmFsdWVFcnJvcnMuRXJyb3JzKHRoaXMuc2NoZW1hLCB0aGlzLnJlZmVyZW5jZXMsIHZhbHVlKTtcbiAgICB9XG4gICAgLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGUgdmFsdWUgbWF0Y2hlcyB0aGUgY29tcGlsZWQgdHlwZS4gKi9cbiAgICBDaGVjayh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGVja0Z1bmModmFsdWUpO1xuICAgIH1cbn1cbmV4cG9ydHMuVHlwZUNoZWNrID0gVHlwZUNoZWNrO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gQ2hhcmFjdGVyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG52YXIgQ2hhcmFjdGVyO1xuKGZ1bmN0aW9uIChDaGFyYWN0ZXIpIHtcbiAgICBmdW5jdGlvbiBEb2xsYXJTaWduKGNvZGUpIHtcbiAgICAgICAgcmV0dXJuIGNvZGUgPT09IDM2O1xuICAgIH1cbiAgICBDaGFyYWN0ZXIuRG9sbGFyU2lnbiA9IERvbGxhclNpZ247XG4gICAgZnVuY3Rpb24gSXNVbmRlcnNjb3JlKGNvZGUpIHtcbiAgICAgICAgcmV0dXJuIGNvZGUgPT09IDk1O1xuICAgIH1cbiAgICBDaGFyYWN0ZXIuSXNVbmRlcnNjb3JlID0gSXNVbmRlcnNjb3JlO1xuICAgIGZ1bmN0aW9uIElzQWxwaGEoY29kZSkge1xuICAgICAgICByZXR1cm4gKGNvZGUgPj0gNjUgJiYgY29kZSA8PSA5MCkgfHwgKGNvZGUgPj0gOTcgJiYgY29kZSA8PSAxMjIpO1xuICAgIH1cbiAgICBDaGFyYWN0ZXIuSXNBbHBoYSA9IElzQWxwaGE7XG4gICAgZnVuY3Rpb24gSXNOdW1lcmljKGNvZGUpIHtcbiAgICAgICAgcmV0dXJuIGNvZGUgPj0gNDggJiYgY29kZSA8PSA1NztcbiAgICB9XG4gICAgQ2hhcmFjdGVyLklzTnVtZXJpYyA9IElzTnVtZXJpYztcbn0pKENoYXJhY3RlciB8fCAoQ2hhcmFjdGVyID0ge30pKTtcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIE1lbWJlckV4cHJlc3Npb25cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbnZhciBNZW1iZXJFeHByZXNzaW9uO1xuKGZ1bmN0aW9uIChNZW1iZXJFeHByZXNzaW9uKSB7XG4gICAgZnVuY3Rpb24gSXNGaXJzdENoYXJhY3Rlck51bWVyaWModmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIENoYXJhY3Rlci5Jc051bWVyaWModmFsdWUuY2hhckNvZGVBdCgwKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIElzQWNjZXNzb3IodmFsdWUpIHtcbiAgICAgICAgaWYgKElzRmlyc3RDaGFyYWN0ZXJOdW1lcmljKHZhbHVlKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgY29kZSA9IHZhbHVlLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICBjb25zdCBjaGVjayA9IENoYXJhY3Rlci5Jc0FscGhhKGNvZGUpIHx8IENoYXJhY3Rlci5Jc051bWVyaWMoY29kZSkgfHwgQ2hhcmFjdGVyLkRvbGxhclNpZ24oY29kZSkgfHwgQ2hhcmFjdGVyLklzVW5kZXJzY29yZShjb2RlKTtcbiAgICAgICAgICAgIGlmICghY2hlY2spXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBFc2NhcGVIeXBoZW4oa2V5KSB7XG4gICAgICAgIHJldHVybiBrZXkucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBFbmNvZGUob2JqZWN0LCBrZXkpIHtcbiAgICAgICAgcmV0dXJuIElzQWNjZXNzb3Ioa2V5KSA/IGAke29iamVjdH0uJHtrZXl9YCA6IGAke29iamVjdH1bJyR7RXNjYXBlSHlwaGVuKGtleSl9J11gO1xuICAgIH1cbiAgICBNZW1iZXJFeHByZXNzaW9uLkVuY29kZSA9IEVuY29kZTtcbn0pKE1lbWJlckV4cHJlc3Npb24gfHwgKE1lbWJlckV4cHJlc3Npb24gPSB7fSkpO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gSWRlbnRpZmllclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxudmFyIElkZW50aWZpZXI7XG4oZnVuY3Rpb24gKElkZW50aWZpZXIpIHtcbiAgICBmdW5jdGlvbiBFbmNvZGUoJGlkKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8ICRpZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgY29kZSA9ICRpZC5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAgICAgaWYgKENoYXJhY3Rlci5Jc051bWVyaWMoY29kZSkgfHwgQ2hhcmFjdGVyLklzQWxwaGEoY29kZSkpIHtcbiAgICAgICAgICAgICAgICBidWZmZXIucHVzaCgkaWQuY2hhckF0KGkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJ1ZmZlci5wdXNoKGBfJHtjb2RlfV9gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnVmZmVyLmpvaW4oJycpLnJlcGxhY2UoL19fL2csICdfJyk7XG4gICAgfVxuICAgIElkZW50aWZpZXIuRW5jb2RlID0gRW5jb2RlO1xufSkoSWRlbnRpZmllciB8fCAoSWRlbnRpZmllciA9IHt9KSk7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBUeXBlQ29tcGlsZXJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmNsYXNzIFR5cGVDb21waWxlclVua25vd25UeXBlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3Ioc2NoZW1hKSB7XG4gICAgICAgIHN1cGVyKCdUeXBlQ29tcGlsZXI6IFVua25vd24gdHlwZScpO1xuICAgICAgICB0aGlzLnNjaGVtYSA9IHNjaGVtYTtcbiAgICB9XG59XG5leHBvcnRzLlR5cGVDb21waWxlclVua25vd25UeXBlRXJyb3IgPSBUeXBlQ29tcGlsZXJVbmtub3duVHlwZUVycm9yO1xuY2xhc3MgVHlwZUNvbXBpbGVyRGVyZWZlcmVuY2VFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihzY2hlbWEpIHtcbiAgICAgICAgc3VwZXIoYFR5cGVDb21waWxlcjogVW5hYmxlIHRvIGRlcmVmZXJlbmNlIHNjaGVtYSB3aXRoICRpZCAnJHtzY2hlbWEuJHJlZn0nYCk7XG4gICAgICAgIHRoaXMuc2NoZW1hID0gc2NoZW1hO1xuICAgIH1cbn1cbmV4cG9ydHMuVHlwZUNvbXBpbGVyRGVyZWZlcmVuY2VFcnJvciA9IFR5cGVDb21waWxlckRlcmVmZXJlbmNlRXJyb3I7XG5jbGFzcyBUeXBlQ29tcGlsZXJUeXBlR3VhcmRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihzY2hlbWEpIHtcbiAgICAgICAgc3VwZXIoJ1R5cGVDb21waWxlcjogUHJlZmxpZ2h0IHZhbGlkYXRpb24gY2hlY2sgZmFpbGVkIHRvIGd1YXJkIGZvciB0aGUgZ2l2ZW4gc2NoZW1hJyk7XG4gICAgICAgIHRoaXMuc2NoZW1hID0gc2NoZW1hO1xuICAgIH1cbn1cbmV4cG9ydHMuVHlwZUNvbXBpbGVyVHlwZUd1YXJkRXJyb3IgPSBUeXBlQ29tcGlsZXJUeXBlR3VhcmRFcnJvcjtcbi8qKiBDb21waWxlcyBUeXBlcyBmb3IgUnVudGltZSBUeXBlIENoZWNraW5nICovXG52YXIgVHlwZUNvbXBpbGVyO1xuKGZ1bmN0aW9uIChUeXBlQ29tcGlsZXIpIHtcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gR3VhcmRzXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGZ1bmN0aW9uIElzQmlnSW50KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdiaWdpbnQnO1xuICAgIH1cbiAgICBmdW5jdGlvbiBJc051bWJlcih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiBnbG9iYWxUaGlzLk51bWJlci5pc0Zpbml0ZSh2YWx1ZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIElzU3RyaW5nKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnO1xuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gU2NoZW1hR3VhcmRzXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGZ1bmN0aW9uIElzQW55T3JVbmtub3duKHNjaGVtYSkge1xuICAgICAgICByZXR1cm4gc2NoZW1hW1R5cGVzLktpbmRdID09PSAnQW55JyB8fCBzY2hlbWFbVHlwZXMuS2luZF0gPT09ICdVbmtub3duJztcbiAgICB9XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIFBvbGljZXNcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZnVuY3Rpb24gSXNFeGFjdE9wdGlvbmFsUHJvcGVydHkodmFsdWUsIGtleSwgZXhwcmVzc2lvbikge1xuICAgICAgICByZXR1cm4gaW5kZXhfMi5UeXBlU3lzdGVtLkV4YWN0T3B0aW9uYWxQcm9wZXJ0eVR5cGVzID8gYCgnJHtrZXl9JyBpbiAke3ZhbHVlfSA/ICR7ZXhwcmVzc2lvbn0gOiB0cnVlKWAgOiBgKCR7TWVtYmVyRXhwcmVzc2lvbi5FbmNvZGUodmFsdWUsIGtleSl9ICE9PSB1bmRlZmluZWQgPyAke2V4cHJlc3Npb259IDogdHJ1ZSlgO1xuICAgIH1cbiAgICBmdW5jdGlvbiBJc09iamVjdENoZWNrKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAhaW5kZXhfMi5UeXBlU3lzdGVtLkFsbG93QXJyYXlPYmplY3RzID8gYCh0eXBlb2YgJHt2YWx1ZX0gPT09ICdvYmplY3QnICYmICR7dmFsdWV9ICE9PSBudWxsICYmICFBcnJheS5pc0FycmF5KCR7dmFsdWV9KSlgIDogYCh0eXBlb2YgJHt2YWx1ZX0gPT09ICdvYmplY3QnICYmICR7dmFsdWV9ICE9PSBudWxsKWA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIElzUmVjb3JkQ2hlY2sodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICFpbmRleF8yLlR5cGVTeXN0ZW0uQWxsb3dBcnJheU9iamVjdHNcbiAgICAgICAgICAgID8gYCh0eXBlb2YgJHt2YWx1ZX0gPT09ICdvYmplY3QnICYmICR7dmFsdWV9ICE9PSBudWxsICYmICFBcnJheS5pc0FycmF5KCR7dmFsdWV9KSAmJiAhKCR7dmFsdWV9IGluc3RhbmNlb2YgRGF0ZSkgJiYgISgke3ZhbHVlfSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKWBcbiAgICAgICAgICAgIDogYCh0eXBlb2YgJHt2YWx1ZX0gPT09ICdvYmplY3QnICYmICR7dmFsdWV9ICE9PSBudWxsICYmICEoJHt2YWx1ZX0gaW5zdGFuY2VvZiBEYXRlKSAmJiAhKCR7dmFsdWV9IGluc3RhbmNlb2YgVWludDhBcnJheSkpYDtcbiAgICB9XG4gICAgZnVuY3Rpb24gSXNOdW1iZXJDaGVjayh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gIWluZGV4XzIuVHlwZVN5c3RlbS5BbGxvd05hTiA/IGAodHlwZW9mICR7dmFsdWV9ID09PSAnbnVtYmVyJyAmJiBOdW1iZXIuaXNGaW5pdGUoJHt2YWx1ZX0pKWAgOiBgdHlwZW9mICR7dmFsdWV9ID09PSAnbnVtYmVyJ2A7XG4gICAgfVxuICAgIGZ1bmN0aW9uIElzVm9pZENoZWNrKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBpbmRleF8yLlR5cGVTeXN0ZW0uQWxsb3dWb2lkTnVsbCA/IGAoJHt2YWx1ZX0gPT09IHVuZGVmaW5lZCB8fCAke3ZhbHVlfSA9PT0gbnVsbClgIDogYCR7dmFsdWV9ID09PSB1bmRlZmluZWRgO1xuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gVHlwZXNcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZnVuY3Rpb24qIEFueShzY2hlbWEsIHJlZmVyZW5jZXMsIHZhbHVlKSB7XG4gICAgICAgIHlpZWxkICd0cnVlJztcbiAgICB9XG4gICAgZnVuY3Rpb24qIEFycmF5KHNjaGVtYSwgcmVmZXJlbmNlcywgdmFsdWUpIHtcbiAgICAgICAgeWllbGQgYEFycmF5LmlzQXJyYXkoJHt2YWx1ZX0pYDtcbiAgICAgICAgaWYgKElzTnVtYmVyKHNjaGVtYS5taW5JdGVtcykpXG4gICAgICAgICAgICB5aWVsZCBgJHt2YWx1ZX0ubGVuZ3RoID49ICR7c2NoZW1hLm1pbkl0ZW1zfWA7XG4gICAgICAgIGlmIChJc051bWJlcihzY2hlbWEubWF4SXRlbXMpKVxuICAgICAgICAgICAgeWllbGQgYCR7dmFsdWV9Lmxlbmd0aCA8PSAke3NjaGVtYS5tYXhJdGVtc31gO1xuICAgICAgICBpZiAoc2NoZW1hLnVuaXF1ZUl0ZW1zID09PSB0cnVlKVxuICAgICAgICAgICAgeWllbGQgYCgoZnVuY3Rpb24oKSB7IGNvbnN0IHNldCA9IG5ldyBTZXQoKTsgZm9yKGNvbnN0IGVsZW1lbnQgb2YgJHt2YWx1ZX0pIHsgY29uc3QgaGFzaGVkID0gaGFzaChlbGVtZW50KTsgaWYoc2V0LmhhcyhoYXNoZWQpKSB7IHJldHVybiBmYWxzZSB9IGVsc2UgeyBzZXQuYWRkKGhhc2hlZCkgfSB9IHJldHVybiB0cnVlIH0pKCkpYDtcbiAgICAgICAgY29uc3QgZXhwcmVzc2lvbiA9IENyZWF0ZUV4cHJlc3Npb24oc2NoZW1hLml0ZW1zLCByZWZlcmVuY2VzLCAndmFsdWUnKTtcbiAgICAgICAgY29uc3QgcGFyYW1ldGVyID0gQ3JlYXRlUGFyYW1ldGVyKCd2YWx1ZScsICdhbnknKTtcbiAgICAgICAgeWllbGQgYCR7dmFsdWV9LmV2ZXJ5KCgke3BhcmFtZXRlcn0pID0+ICR7ZXhwcmVzc2lvbn0pYDtcbiAgICB9XG4gICAgZnVuY3Rpb24qIEJpZ0ludChzY2hlbWEsIHJlZmVyZW5jZXMsIHZhbHVlKSB7XG4gICAgICAgIHlpZWxkIGAodHlwZW9mICR7dmFsdWV9ID09PSAnYmlnaW50JylgO1xuICAgICAgICBpZiAoSXNCaWdJbnQoc2NoZW1hLm11bHRpcGxlT2YpKVxuICAgICAgICAgICAgeWllbGQgYCgke3ZhbHVlfSAlIEJpZ0ludCgke3NjaGVtYS5tdWx0aXBsZU9mfSkpID09PSAwYDtcbiAgICAgICAgaWYgKElzQmlnSW50KHNjaGVtYS5leGNsdXNpdmVNaW5pbXVtKSlcbiAgICAgICAgICAgIHlpZWxkIGAke3ZhbHVlfSA+IEJpZ0ludCgke3NjaGVtYS5leGNsdXNpdmVNaW5pbXVtfSlgO1xuICAgICAgICBpZiAoSXNCaWdJbnQoc2NoZW1hLmV4Y2x1c2l2ZU1heGltdW0pKVxuICAgICAgICAgICAgeWllbGQgYCR7dmFsdWV9IDwgQmlnSW50KCR7c2NoZW1hLmV4Y2x1c2l2ZU1heGltdW19KWA7XG4gICAgICAgIGlmIChJc0JpZ0ludChzY2hlbWEubWluaW11bSkpXG4gICAgICAgICAgICB5aWVsZCBgJHt2YWx1ZX0gPj0gQmlnSW50KCR7c2NoZW1hLm1pbmltdW19KWA7XG4gICAgICAgIGlmIChJc0JpZ0ludChzY2hlbWEubWF4aW11bSkpXG4gICAgICAgICAgICB5aWVsZCBgJHt2YWx1ZX0gPD0gQmlnSW50KCR7c2NoZW1hLm1heGltdW19KWA7XG4gICAgfVxuICAgIGZ1bmN0aW9uKiBCb29sZWFuKHNjaGVtYSwgcmVmZXJlbmNlcywgdmFsdWUpIHtcbiAgICAgICAgeWllbGQgYCh0eXBlb2YgJHt2YWx1ZX0gPT09ICdib29sZWFuJylgO1xuICAgIH1cbiAgICBmdW5jdGlvbiogQ29uc3RydWN0b3Ioc2NoZW1hLCByZWZlcmVuY2VzLCB2YWx1ZSkge1xuICAgICAgICB5aWVsZCogVmlzaXQoc2NoZW1hLnJldHVybnMsIHJlZmVyZW5jZXMsIGAke3ZhbHVlfS5wcm90b3R5cGVgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24qIERhdGUoc2NoZW1hLCByZWZlcmVuY2VzLCB2YWx1ZSkge1xuICAgICAgICB5aWVsZCBgKCR7dmFsdWV9IGluc3RhbmNlb2YgRGF0ZSkgJiYgTnVtYmVyLmlzRmluaXRlKCR7dmFsdWV9LmdldFRpbWUoKSlgO1xuICAgICAgICBpZiAoSXNOdW1iZXIoc2NoZW1hLmV4Y2x1c2l2ZU1pbmltdW1UaW1lc3RhbXApKVxuICAgICAgICAgICAgeWllbGQgYCR7dmFsdWV9LmdldFRpbWUoKSA+ICR7c2NoZW1hLmV4Y2x1c2l2ZU1pbmltdW1UaW1lc3RhbXB9YDtcbiAgICAgICAgaWYgKElzTnVtYmVyKHNjaGVtYS5leGNsdXNpdmVNYXhpbXVtVGltZXN0YW1wKSlcbiAgICAgICAgICAgIHlpZWxkIGAke3ZhbHVlfS5nZXRUaW1lKCkgPCAke3NjaGVtYS5leGNsdXNpdmVNYXhpbXVtVGltZXN0YW1wfWA7XG4gICAgICAgIGlmIChJc051bWJlcihzY2hlbWEubWluaW11bVRpbWVzdGFtcCkpXG4gICAgICAgICAgICB5aWVsZCBgJHt2YWx1ZX0uZ2V0VGltZSgpID49ICR7c2NoZW1hLm1pbmltdW1UaW1lc3RhbXB9YDtcbiAgICAgICAgaWYgKElzTnVtYmVyKHNjaGVtYS5tYXhpbXVtVGltZXN0YW1wKSlcbiAgICAgICAgICAgIHlpZWxkIGAke3ZhbHVlfS5nZXRUaW1lKCkgPD0gJHtzY2hlbWEubWF4aW11bVRpbWVzdGFtcH1gO1xuICAgIH1cbiAgICBmdW5jdGlvbiogRnVuY3Rpb24oc2NoZW1hLCByZWZlcmVuY2VzLCB2YWx1ZSkge1xuICAgICAgICB5aWVsZCBgKHR5cGVvZiAke3ZhbHVlfSA9PT0gJ2Z1bmN0aW9uJylgO1xuICAgIH1cbiAgICBmdW5jdGlvbiogSW50ZWdlcihzY2hlbWEsIHJlZmVyZW5jZXMsIHZhbHVlKSB7XG4gICAgICAgIHlpZWxkIGAodHlwZW9mICR7dmFsdWV9ID09PSAnbnVtYmVyJyAmJiBOdW1iZXIuaXNJbnRlZ2VyKCR7dmFsdWV9KSlgO1xuICAgICAgICBpZiAoSXNOdW1iZXIoc2NoZW1hLm11bHRpcGxlT2YpKVxuICAgICAgICAgICAgeWllbGQgYCgke3ZhbHVlfSAlICR7c2NoZW1hLm11bHRpcGxlT2Z9KSA9PT0gMGA7XG4gICAgICAgIGlmIChJc051bWJlcihzY2hlbWEuZXhjbHVzaXZlTWluaW11bSkpXG4gICAgICAgICAgICB5aWVsZCBgJHt2YWx1ZX0gPiAke3NjaGVtYS5leGNsdXNpdmVNaW5pbXVtfWA7XG4gICAgICAgIGlmIChJc051bWJlcihzY2hlbWEuZXhjbHVzaXZlTWF4aW11bSkpXG4gICAgICAgICAgICB5aWVsZCBgJHt2YWx1ZX0gPCAke3NjaGVtYS5leGNsdXNpdmVNYXhpbXVtfWA7XG4gICAgICAgIGlmIChJc051bWJlcihzY2hlbWEubWluaW11bSkpXG4gICAgICAgICAgICB5aWVsZCBgJHt2YWx1ZX0gPj0gJHtzY2hlbWEubWluaW11bX1gO1xuICAgICAgICBpZiAoSXNOdW1iZXIoc2NoZW1hLm1heGltdW0pKVxuICAgICAgICAgICAgeWllbGQgYCR7dmFsdWV9IDw9ICR7c2NoZW1hLm1heGltdW19YDtcbiAgICB9XG4gICAgZnVuY3Rpb24qIEludGVyc2VjdChzY2hlbWEsIHJlZmVyZW5jZXMsIHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNoZWNrMSA9IHNjaGVtYS5hbGxPZi5tYXAoKHNjaGVtYSkgPT4gQ3JlYXRlRXhwcmVzc2lvbihzY2hlbWEsIHJlZmVyZW5jZXMsIHZhbHVlKSkuam9pbignICYmICcpO1xuICAgICAgICBpZiAoc2NoZW1hLnVuZXZhbHVhdGVkUHJvcGVydGllcyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleUNoZWNrID0gUHVzaExvY2FsKGAke25ldyBSZWdFeHAoVHlwZXMuS2V5UmVzb2x2ZXIuUmVzb2x2ZVBhdHRlcm4oc2NoZW1hKSl9O2ApO1xuICAgICAgICAgICAgY29uc3QgY2hlY2syID0gYE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKCR7dmFsdWV9KS5ldmVyeShrZXkgPT4gJHtrZXlDaGVja30udGVzdChrZXkpKWA7XG4gICAgICAgICAgICB5aWVsZCBgKCR7Y2hlY2sxfSAmJiAke2NoZWNrMn0pYDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChUeXBlcy5UeXBlR3VhcmQuVFNjaGVtYShzY2hlbWEudW5ldmFsdWF0ZWRQcm9wZXJ0aWVzKSkge1xuICAgICAgICAgICAgY29uc3Qga2V5Q2hlY2sgPSBQdXNoTG9jYWwoYCR7bmV3IFJlZ0V4cChUeXBlcy5LZXlSZXNvbHZlci5SZXNvbHZlUGF0dGVybihzY2hlbWEpKX07YCk7XG4gICAgICAgICAgICBjb25zdCBjaGVjazIgPSBgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoJHt2YWx1ZX0pLmV2ZXJ5KGtleSA9PiAke2tleUNoZWNrfS50ZXN0KGtleSkgfHwgJHtDcmVhdGVFeHByZXNzaW9uKHNjaGVtYS51bmV2YWx1YXRlZFByb3BlcnRpZXMsIHJlZmVyZW5jZXMsIGAke3ZhbHVlfVtrZXldYCl9KWA7XG4gICAgICAgICAgICB5aWVsZCBgKCR7Y2hlY2sxfSAmJiAke2NoZWNrMn0pYDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHlpZWxkIGAoJHtjaGVjazF9KWA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24qIExpdGVyYWwoc2NoZW1hLCByZWZlcmVuY2VzLCB2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHNjaGVtYS5jb25zdCA9PT0gJ251bWJlcicgfHwgdHlwZW9mIHNjaGVtYS5jb25zdCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICB5aWVsZCBgKCR7dmFsdWV9ID09PSAke3NjaGVtYS5jb25zdH0pYDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHlpZWxkIGAoJHt2YWx1ZX0gPT09ICcke3NjaGVtYS5jb25zdH0nKWA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24qIE5ldmVyKHNjaGVtYSwgcmVmZXJlbmNlcywgdmFsdWUpIHtcbiAgICAgICAgeWllbGQgYGZhbHNlYDtcbiAgICB9XG4gICAgZnVuY3Rpb24qIE5vdChzY2hlbWEsIHJlZmVyZW5jZXMsIHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGxlZnQgPSBDcmVhdGVFeHByZXNzaW9uKHNjaGVtYS5hbGxPZlswXS5ub3QsIHJlZmVyZW5jZXMsIHZhbHVlKTtcbiAgICAgICAgY29uc3QgcmlnaHQgPSBDcmVhdGVFeHByZXNzaW9uKHNjaGVtYS5hbGxPZlsxXSwgcmVmZXJlbmNlcywgdmFsdWUpO1xuICAgICAgICB5aWVsZCBgISR7bGVmdH0gJiYgJHtyaWdodH1gO1xuICAgIH1cbiAgICBmdW5jdGlvbiogTnVsbChzY2hlbWEsIHJlZmVyZW5jZXMsIHZhbHVlKSB7XG4gICAgICAgIHlpZWxkIGAoJHt2YWx1ZX0gPT09IG51bGwpYDtcbiAgICB9XG4gICAgZnVuY3Rpb24qIE51bWJlcihzY2hlbWEsIHJlZmVyZW5jZXMsIHZhbHVlKSB7XG4gICAgICAgIHlpZWxkIElzTnVtYmVyQ2hlY2sodmFsdWUpO1xuICAgICAgICBpZiAoSXNOdW1iZXIoc2NoZW1hLm11bHRpcGxlT2YpKVxuICAgICAgICAgICAgeWllbGQgYCgke3ZhbHVlfSAlICR7c2NoZW1hLm11bHRpcGxlT2Z9KSA9PT0gMGA7XG4gICAgICAgIGlmIChJc051bWJlcihzY2hlbWEuZXhjbHVzaXZlTWluaW11bSkpXG4gICAgICAgICAgICB5aWVsZCBgJHt2YWx1ZX0gPiAke3NjaGVtYS5leGNsdXNpdmVNaW5pbXVtfWA7XG4gICAgICAgIGlmIChJc051bWJlcihzY2hlbWEuZXhjbHVzaXZlTWF4aW11bSkpXG4gICAgICAgICAgICB5aWVsZCBgJHt2YWx1ZX0gPCAke3NjaGVtYS5leGNsdXNpdmVNYXhpbXVtfWA7XG4gICAgICAgIGlmIChJc051bWJlcihzY2hlbWEubWluaW11bSkpXG4gICAgICAgICAgICB5aWVsZCBgJHt2YWx1ZX0gPj0gJHtzY2hlbWEubWluaW11bX1gO1xuICAgICAgICBpZiAoSXNOdW1iZXIoc2NoZW1hLm1heGltdW0pKVxuICAgICAgICAgICAgeWllbGQgYCR7dmFsdWV9IDw9ICR7c2NoZW1hLm1heGltdW19YDtcbiAgICB9XG4gICAgZnVuY3Rpb24qIE9iamVjdChzY2hlbWEsIHJlZmVyZW5jZXMsIHZhbHVlKSB7XG4gICAgICAgIHlpZWxkIElzT2JqZWN0Q2hlY2sodmFsdWUpO1xuICAgICAgICBpZiAoSXNOdW1iZXIoc2NoZW1hLm1pblByb3BlcnRpZXMpKVxuICAgICAgICAgICAgeWllbGQgYE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKCR7dmFsdWV9KS5sZW5ndGggPj0gJHtzY2hlbWEubWluUHJvcGVydGllc31gO1xuICAgICAgICBpZiAoSXNOdW1iZXIoc2NoZW1hLm1heFByb3BlcnRpZXMpKVxuICAgICAgICAgICAgeWllbGQgYE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKCR7dmFsdWV9KS5sZW5ndGggPD0gJHtzY2hlbWEubWF4UHJvcGVydGllc31gO1xuICAgICAgICBjb25zdCBrbm93bktleXMgPSBnbG9iYWxUaGlzLk9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHNjaGVtYS5wcm9wZXJ0aWVzKTtcbiAgICAgICAgZm9yIChjb25zdCBrbm93bktleSBvZiBrbm93bktleXMpIHtcbiAgICAgICAgICAgIGNvbnN0IG1lbWJlckV4cHJlc3Npb24gPSBNZW1iZXJFeHByZXNzaW9uLkVuY29kZSh2YWx1ZSwga25vd25LZXkpO1xuICAgICAgICAgICAgY29uc3QgcHJvcGVydHkgPSBzY2hlbWEucHJvcGVydGllc1trbm93bktleV07XG4gICAgICAgICAgICBpZiAoc2NoZW1hLnJlcXVpcmVkICYmIHNjaGVtYS5yZXF1aXJlZC5pbmNsdWRlcyhrbm93bktleSkpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCogVmlzaXQocHJvcGVydHksIHJlZmVyZW5jZXMsIG1lbWJlckV4cHJlc3Npb24pO1xuICAgICAgICAgICAgICAgIGlmIChUeXBlcy5FeHRlbmRzVW5kZWZpbmVkLkNoZWNrKHByb3BlcnR5KSB8fCBJc0FueU9yVW5rbm93bihwcm9wZXJ0eSkpXG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIGAoJyR7a25vd25LZXl9JyBpbiAke3ZhbHVlfSlgO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXhwcmVzc2lvbiA9IENyZWF0ZUV4cHJlc3Npb24ocHJvcGVydHksIHJlZmVyZW5jZXMsIG1lbWJlckV4cHJlc3Npb24pO1xuICAgICAgICAgICAgICAgIHlpZWxkIElzRXhhY3RPcHRpb25hbFByb3BlcnR5KHZhbHVlLCBrbm93bktleSwgZXhwcmVzc2lvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNjaGVtYS5hZGRpdGlvbmFsUHJvcGVydGllcyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGlmIChzY2hlbWEucmVxdWlyZWQgJiYgc2NoZW1hLnJlcXVpcmVkLmxlbmd0aCA9PT0ga25vd25LZXlzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHlpZWxkIGBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcygke3ZhbHVlfSkubGVuZ3RoID09PSAke2tub3duS2V5cy5sZW5ndGh9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleXMgPSBgWyR7a25vd25LZXlzLm1hcCgoa2V5KSA9PiBgJyR7a2V5fSdgKS5qb2luKCcsICcpfV1gO1xuICAgICAgICAgICAgICAgIHlpZWxkIGBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcygke3ZhbHVlfSkuZXZlcnkoa2V5ID0+ICR7a2V5c30uaW5jbHVkZXMoa2V5KSlgO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hLmFkZGl0aW9uYWxQcm9wZXJ0aWVzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgY29uc3QgZXhwcmVzc2lvbiA9IENyZWF0ZUV4cHJlc3Npb24oc2NoZW1hLmFkZGl0aW9uYWxQcm9wZXJ0aWVzLCByZWZlcmVuY2VzLCBgJHt2YWx1ZX1ba2V5XWApO1xuICAgICAgICAgICAgY29uc3Qga2V5cyA9IGBbJHtrbm93bktleXMubWFwKChrZXkpID0+IGAnJHtrZXl9J2ApLmpvaW4oJywgJyl9XWA7XG4gICAgICAgICAgICB5aWVsZCBgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKCR7dmFsdWV9KS5ldmVyeShrZXkgPT4gJHtrZXlzfS5pbmNsdWRlcyhrZXkpIHx8ICR7ZXhwcmVzc2lvbn0pKWA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24qIFByb21pc2Uoc2NoZW1hLCByZWZlcmVuY2VzLCB2YWx1ZSkge1xuICAgICAgICB5aWVsZCBgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mICR7dmFsdWV9LnRoZW4gPT09ICdmdW5jdGlvbicpYDtcbiAgICB9XG4gICAgZnVuY3Rpb24qIFJlY29yZChzY2hlbWEsIHJlZmVyZW5jZXMsIHZhbHVlKSB7XG4gICAgICAgIHlpZWxkIElzUmVjb3JkQ2hlY2sodmFsdWUpO1xuICAgICAgICBpZiAoSXNOdW1iZXIoc2NoZW1hLm1pblByb3BlcnRpZXMpKVxuICAgICAgICAgICAgeWllbGQgYE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKCR7dmFsdWV9KS5sZW5ndGggPj0gJHtzY2hlbWEubWluUHJvcGVydGllc31gO1xuICAgICAgICBpZiAoSXNOdW1iZXIoc2NoZW1hLm1heFByb3BlcnRpZXMpKVxuICAgICAgICAgICAgeWllbGQgYE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKCR7dmFsdWV9KS5sZW5ndGggPD0gJHtzY2hlbWEubWF4UHJvcGVydGllc31gO1xuICAgICAgICBjb25zdCBbcGF0dGVybktleSwgcGF0dGVyblNjaGVtYV0gPSBnbG9iYWxUaGlzLk9iamVjdC5lbnRyaWVzKHNjaGVtYS5wYXR0ZXJuUHJvcGVydGllcylbMF07XG4gICAgICAgIGNvbnN0IGxvY2FsID0gUHVzaExvY2FsKGBuZXcgUmVnRXhwKC8ke3BhdHRlcm5LZXl9LylgKTtcbiAgICAgICAgY29uc3QgY2hlY2sxID0gQ3JlYXRlRXhwcmVzc2lvbihwYXR0ZXJuU2NoZW1hLCByZWZlcmVuY2VzLCAndmFsdWUnKTtcbiAgICAgICAgY29uc3QgY2hlY2syID0gVHlwZXMuVHlwZUd1YXJkLlRTY2hlbWEoc2NoZW1hLmFkZGl0aW9uYWxQcm9wZXJ0aWVzKSA/IENyZWF0ZUV4cHJlc3Npb24oc2NoZW1hLmFkZGl0aW9uYWxQcm9wZXJ0aWVzLCByZWZlcmVuY2VzLCB2YWx1ZSkgOiBzY2hlbWEuYWRkaXRpb25hbFByb3BlcnRpZXMgPT09IGZhbHNlID8gJ2ZhbHNlJyA6ICd0cnVlJztcbiAgICAgICAgY29uc3QgZXhwcmVzc2lvbiA9IGAoJHtsb2NhbH0udGVzdChrZXkpID8gJHtjaGVjazF9IDogJHtjaGVjazJ9KWA7XG4gICAgICAgIHlpZWxkIGAoT2JqZWN0LmVudHJpZXMoJHt2YWx1ZX0pLmV2ZXJ5KChba2V5LCB2YWx1ZV0pID0+ICR7ZXhwcmVzc2lvbn0pKWA7XG4gICAgfVxuICAgIGZ1bmN0aW9uKiBSZWYoc2NoZW1hLCByZWZlcmVuY2VzLCB2YWx1ZSkge1xuICAgICAgICBjb25zdCBpbmRleCA9IHJlZmVyZW5jZXMuZmluZEluZGV4KChmb3JlaWduKSA9PiBmb3JlaWduLiRpZCA9PT0gc2NoZW1hLiRyZWYpO1xuICAgICAgICBpZiAoaW5kZXggPT09IC0xKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVDb21waWxlckRlcmVmZXJlbmNlRXJyb3Ioc2NoZW1hKTtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gcmVmZXJlbmNlc1tpbmRleF07XG4gICAgICAgIC8vIFJlZmVyZW5jZTogSWYgd2UgaGF2ZSBzZWVuIHRoaXMgcmVmZXJlbmNlIGJlZm9yZSB3ZSBjYW4ganVzdCB5aWVsZCBhbmRcbiAgICAgICAgLy8gcmV0dXJuIHRoZSBmdW5jdGlvbiBjYWxsLiBJZiB0aGlzIGlzbid0IHRoZSBjYXNlIHdlIGRlZmVyIHRvIHZpc2l0IHRvXG4gICAgICAgIC8vIGdlbmVyYXRlIGFuZCBzZXQgdGhlIGZ1bmN0aW9uIGZvciBzdWJzZXF1ZW50IHBhc3Nlcy5cbiAgICAgICAgaWYgKHN0YXRlLmZ1bmN0aW9ucy5oYXMoc2NoZW1hLiRyZWYpKVxuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIGAke0NyZWF0ZUZ1bmN0aW9uTmFtZShzY2hlbWEuJHJlZil9KCR7dmFsdWV9KWA7XG4gICAgICAgIHlpZWxkKiBWaXNpdCh0YXJnZXQsIHJlZmVyZW5jZXMsIHZhbHVlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24qIFN0cmluZyhzY2hlbWEsIHJlZmVyZW5jZXMsIHZhbHVlKSB7XG4gICAgICAgIHlpZWxkIGAodHlwZW9mICR7dmFsdWV9ID09PSAnc3RyaW5nJylgO1xuICAgICAgICBpZiAoSXNOdW1iZXIoc2NoZW1hLm1pbkxlbmd0aCkpXG4gICAgICAgICAgICB5aWVsZCBgJHt2YWx1ZX0ubGVuZ3RoID49ICR7c2NoZW1hLm1pbkxlbmd0aH1gO1xuICAgICAgICBpZiAoSXNOdW1iZXIoc2NoZW1hLm1heExlbmd0aCkpXG4gICAgICAgICAgICB5aWVsZCBgJHt2YWx1ZX0ubGVuZ3RoIDw9ICR7c2NoZW1hLm1heExlbmd0aH1gO1xuICAgICAgICBpZiAoc2NoZW1hLnBhdHRlcm4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgbG9jYWwgPSBQdXNoTG9jYWwoYCR7bmV3IFJlZ0V4cChzY2hlbWEucGF0dGVybil9O2ApO1xuICAgICAgICAgICAgeWllbGQgYCR7bG9jYWx9LnRlc3QoJHt2YWx1ZX0pYDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2NoZW1hLmZvcm1hdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB5aWVsZCBgZm9ybWF0KCcke3NjaGVtYS5mb3JtYXR9JywgJHt2YWx1ZX0pYDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiogU3ltYm9sKHNjaGVtYSwgcmVmZXJlbmNlcywgdmFsdWUpIHtcbiAgICAgICAgeWllbGQgYCh0eXBlb2YgJHt2YWx1ZX0gPT09ICdzeW1ib2wnKWA7XG4gICAgfVxuICAgIGZ1bmN0aW9uKiBUZW1wbGF0ZUxpdGVyYWwoc2NoZW1hLCByZWZlcmVuY2VzLCB2YWx1ZSkge1xuICAgICAgICB5aWVsZCBgKHR5cGVvZiAke3ZhbHVlfSA9PT0gJ3N0cmluZycpYDtcbiAgICAgICAgY29uc3QgbG9jYWwgPSBQdXNoTG9jYWwoYCR7bmV3IFJlZ0V4cChzY2hlbWEucGF0dGVybil9O2ApO1xuICAgICAgICB5aWVsZCBgJHtsb2NhbH0udGVzdCgke3ZhbHVlfSlgO1xuICAgIH1cbiAgICBmdW5jdGlvbiogVGhpcyhzY2hlbWEsIHJlZmVyZW5jZXMsIHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGZ1bmMgPSBDcmVhdGVGdW5jdGlvbk5hbWUoc2NoZW1hLiRyZWYpO1xuICAgICAgICB5aWVsZCBgJHtmdW5jfSgke3ZhbHVlfSlgO1xuICAgIH1cbiAgICBmdW5jdGlvbiogVHVwbGUoc2NoZW1hLCByZWZlcmVuY2VzLCB2YWx1ZSkge1xuICAgICAgICB5aWVsZCBgQXJyYXkuaXNBcnJheSgke3ZhbHVlfSlgO1xuICAgICAgICBpZiAoc2NoZW1hLml0ZW1zID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4geWllbGQgYCR7dmFsdWV9Lmxlbmd0aCA9PT0gMGA7XG4gICAgICAgIHlpZWxkIGAoJHt2YWx1ZX0ubGVuZ3RoID09PSAke3NjaGVtYS5tYXhJdGVtc30pYDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzY2hlbWEuaXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSBDcmVhdGVFeHByZXNzaW9uKHNjaGVtYS5pdGVtc1tpXSwgcmVmZXJlbmNlcywgYCR7dmFsdWV9WyR7aX1dYCk7XG4gICAgICAgICAgICB5aWVsZCBgJHtleHByZXNzaW9ufWA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24qIFVuZGVmaW5lZChzY2hlbWEsIHJlZmVyZW5jZXMsIHZhbHVlKSB7XG4gICAgICAgIHlpZWxkIGAke3ZhbHVlfSA9PT0gdW5kZWZpbmVkYDtcbiAgICB9XG4gICAgZnVuY3Rpb24qIFVuaW9uKHNjaGVtYSwgcmVmZXJlbmNlcywgdmFsdWUpIHtcbiAgICAgICAgY29uc3QgZXhwcmVzc2lvbnMgPSBzY2hlbWEuYW55T2YubWFwKChzY2hlbWEpID0+IENyZWF0ZUV4cHJlc3Npb24oc2NoZW1hLCByZWZlcmVuY2VzLCB2YWx1ZSkpO1xuICAgICAgICB5aWVsZCBgKCR7ZXhwcmVzc2lvbnMuam9pbignIHx8ICcpfSlgO1xuICAgIH1cbiAgICBmdW5jdGlvbiogVWludDhBcnJheShzY2hlbWEsIHJlZmVyZW5jZXMsIHZhbHVlKSB7XG4gICAgICAgIHlpZWxkIGAke3ZhbHVlfSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXlgO1xuICAgICAgICBpZiAoSXNOdW1iZXIoc2NoZW1hLm1heEJ5dGVMZW5ndGgpKVxuICAgICAgICAgICAgeWllbGQgYCgke3ZhbHVlfS5sZW5ndGggPD0gJHtzY2hlbWEubWF4Qnl0ZUxlbmd0aH0pYDtcbiAgICAgICAgaWYgKElzTnVtYmVyKHNjaGVtYS5taW5CeXRlTGVuZ3RoKSlcbiAgICAgICAgICAgIHlpZWxkIGAoJHt2YWx1ZX0ubGVuZ3RoID49ICR7c2NoZW1hLm1pbkJ5dGVMZW5ndGh9KWA7XG4gICAgfVxuICAgIGZ1bmN0aW9uKiBVbmtub3duKHNjaGVtYSwgcmVmZXJlbmNlcywgdmFsdWUpIHtcbiAgICAgICAgeWllbGQgJ3RydWUnO1xuICAgIH1cbiAgICBmdW5jdGlvbiogVm9pZChzY2hlbWEsIHJlZmVyZW5jZXMsIHZhbHVlKSB7XG4gICAgICAgIHlpZWxkIElzVm9pZENoZWNrKHZhbHVlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24qIFVzZXJEZWZpbmVkKHNjaGVtYSwgcmVmZXJlbmNlcywgdmFsdWUpIHtcbiAgICAgICAgY29uc3Qgc2NoZW1hX2tleSA9IGBzY2hlbWFfa2V5XyR7c3RhdGUuY3VzdG9tcy5zaXplfWA7XG4gICAgICAgIHN0YXRlLmN1c3RvbXMuc2V0KHNjaGVtYV9rZXksIHNjaGVtYSk7XG4gICAgICAgIHlpZWxkIGBjdXN0b20oJyR7c2NoZW1hW1R5cGVzLktpbmRdfScsICcke3NjaGVtYV9rZXl9JywgJHt2YWx1ZX0pYDtcbiAgICB9XG4gICAgZnVuY3Rpb24qIFZpc2l0KHNjaGVtYSwgcmVmZXJlbmNlcywgdmFsdWUsIHJvb3QgPSBmYWxzZSkge1xuICAgICAgICBjb25zdCByZWZlcmVuY2VzXyA9IElzU3RyaW5nKHNjaGVtYS4kaWQpID8gWy4uLnJlZmVyZW5jZXMsIHNjaGVtYV0gOiByZWZlcmVuY2VzO1xuICAgICAgICBjb25zdCBzY2hlbWFfID0gc2NoZW1hO1xuICAgICAgICAvLyBSdWxlOiBUeXBlcyB3aXRoIGlkZW50aWZpZXJzIGFyZSBob2lzdGVkIGludG8gdGhlaXIgb3duIGZ1bmN0aW9ucy5cbiAgICAgICAgLy8gVGhlIGZvbGxvd2luZyB3aWxsIGdlbmVyYXRlIGEgZnVuY3Rpb24gZm9yIHRoZSBzY2hlbWEgYW5kIHlpZWxkIHRoZVxuICAgICAgICAvLyBjYWxsIHRvIHRoYXQgZnVuY3Rpb24uIFRoaXMgY2FsbCBpcyBvbmx5IG1hZGUgaWYgTk9UIHRoZSByb290IHR5cGVcbiAgICAgICAgLy8gd2hpY2ggYWxsb3dzIHRoZSBnZW5lcmF0ZWQgZnVuY3Rpb24gdG8geWllbGQgaXRzIGV4cHJlc3Npb24uIFRoZVxuICAgICAgICAvLyByb290IGFyZ3VtZW50IGlzIG9ubHkgdHJ1ZSB3aGVuIG1ha2luZyBjYWxscyB2aWEgQ3JlYXRlRnVuY3Rpb24oKS5cbiAgICAgICAgLy8gTm90ZSB0aGVyZSBpcyBwb3RlbnRpYWwgdG8gb21pdCB0aGUgcm9vdCBhcmd1bWVudCBhbmQgY29uZGl0aW9uYWxcbiAgICAgICAgLy8gYnkgcmVmYWN0b3JpbmcgdGhlIGxvZ2ljIGJlbG93LiBDb25zaWRlciBmb3IgcmV2aWV3LlxuICAgICAgICBpZiAoSXNTdHJpbmcoc2NoZW1hLiRpZCkpIHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBDcmVhdGVGdW5jdGlvbk5hbWUoc2NoZW1hLiRpZCk7XG4gICAgICAgICAgICBpZiAoIXN0YXRlLmZ1bmN0aW9ucy5oYXMoc2NoZW1hLiRpZCkpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS5mdW5jdGlvbnMuYWRkKHNjaGVtYS4kaWQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBDcmVhdGVGdW5jdGlvbihuYW1lLCBzY2hlbWEsIHJlZmVyZW5jZXMsICd2YWx1ZScpO1xuICAgICAgICAgICAgICAgIFB1c2hGdW5jdGlvbihib2R5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcm9vdClcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgYCR7bmFtZX0oJHt2YWx1ZX0pYDtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKHNjaGVtYV9bVHlwZXMuS2luZF0pIHtcbiAgICAgICAgICAgIGNhc2UgJ0FueSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiBBbnkoc2NoZW1hXywgcmVmZXJlbmNlc18sIHZhbHVlKTtcbiAgICAgICAgICAgIGNhc2UgJ0FycmF5JzpcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQqIEFycmF5KHNjaGVtYV8sIHJlZmVyZW5jZXNfLCB2YWx1ZSk7XG4gICAgICAgICAgICBjYXNlICdCaWdJbnQnOlxuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCogQmlnSW50KHNjaGVtYV8sIHJlZmVyZW5jZXNfLCB2YWx1ZSk7XG4gICAgICAgICAgICBjYXNlICdCb29sZWFuJzpcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQqIEJvb2xlYW4oc2NoZW1hXywgcmVmZXJlbmNlc18sIHZhbHVlKTtcbiAgICAgICAgICAgIGNhc2UgJ0NvbnN0cnVjdG9yJzpcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQqIENvbnN0cnVjdG9yKHNjaGVtYV8sIHJlZmVyZW5jZXNfLCB2YWx1ZSk7XG4gICAgICAgICAgICBjYXNlICdEYXRlJzpcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQqIERhdGUoc2NoZW1hXywgcmVmZXJlbmNlc18sIHZhbHVlKTtcbiAgICAgICAgICAgIGNhc2UgJ0Z1bmN0aW9uJzpcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQqIEZ1bmN0aW9uKHNjaGVtYV8sIHJlZmVyZW5jZXNfLCB2YWx1ZSk7XG4gICAgICAgICAgICBjYXNlICdJbnRlZ2VyJzpcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQqIEludGVnZXIoc2NoZW1hXywgcmVmZXJlbmNlc18sIHZhbHVlKTtcbiAgICAgICAgICAgIGNhc2UgJ0ludGVyc2VjdCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiBJbnRlcnNlY3Qoc2NoZW1hXywgcmVmZXJlbmNlc18sIHZhbHVlKTtcbiAgICAgICAgICAgIGNhc2UgJ0xpdGVyYWwnOlxuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCogTGl0ZXJhbChzY2hlbWFfLCByZWZlcmVuY2VzXywgdmFsdWUpO1xuICAgICAgICAgICAgY2FzZSAnTmV2ZXInOlxuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCogTmV2ZXIoc2NoZW1hXywgcmVmZXJlbmNlc18sIHZhbHVlKTtcbiAgICAgICAgICAgIGNhc2UgJ05vdCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiBOb3Qoc2NoZW1hXywgcmVmZXJlbmNlc18sIHZhbHVlKTtcbiAgICAgICAgICAgIGNhc2UgJ051bGwnOlxuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCogTnVsbChzY2hlbWFfLCByZWZlcmVuY2VzXywgdmFsdWUpO1xuICAgICAgICAgICAgY2FzZSAnTnVtYmVyJzpcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQqIE51bWJlcihzY2hlbWFfLCByZWZlcmVuY2VzXywgdmFsdWUpO1xuICAgICAgICAgICAgY2FzZSAnT2JqZWN0JzpcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQqIE9iamVjdChzY2hlbWFfLCByZWZlcmVuY2VzXywgdmFsdWUpO1xuICAgICAgICAgICAgY2FzZSAnUHJvbWlzZSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiBQcm9taXNlKHNjaGVtYV8sIHJlZmVyZW5jZXNfLCB2YWx1ZSk7XG4gICAgICAgICAgICBjYXNlICdSZWNvcmQnOlxuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCogUmVjb3JkKHNjaGVtYV8sIHJlZmVyZW5jZXNfLCB2YWx1ZSk7XG4gICAgICAgICAgICBjYXNlICdSZWYnOlxuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCogUmVmKHNjaGVtYV8sIHJlZmVyZW5jZXNfLCB2YWx1ZSk7XG4gICAgICAgICAgICBjYXNlICdTdHJpbmcnOlxuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCogU3RyaW5nKHNjaGVtYV8sIHJlZmVyZW5jZXNfLCB2YWx1ZSk7XG4gICAgICAgICAgICBjYXNlICdTeW1ib2wnOlxuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCogU3ltYm9sKHNjaGVtYV8sIHJlZmVyZW5jZXNfLCB2YWx1ZSk7XG4gICAgICAgICAgICBjYXNlICdUZW1wbGF0ZUxpdGVyYWwnOlxuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCogVGVtcGxhdGVMaXRlcmFsKHNjaGVtYV8sIHJlZmVyZW5jZXNfLCB2YWx1ZSk7XG4gICAgICAgICAgICBjYXNlICdUaGlzJzpcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQqIFRoaXMoc2NoZW1hXywgcmVmZXJlbmNlc18sIHZhbHVlKTtcbiAgICAgICAgICAgIGNhc2UgJ1R1cGxlJzpcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQqIFR1cGxlKHNjaGVtYV8sIHJlZmVyZW5jZXNfLCB2YWx1ZSk7XG4gICAgICAgICAgICBjYXNlICdVbmRlZmluZWQnOlxuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCogVW5kZWZpbmVkKHNjaGVtYV8sIHJlZmVyZW5jZXNfLCB2YWx1ZSk7XG4gICAgICAgICAgICBjYXNlICdVbmlvbic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiBVbmlvbihzY2hlbWFfLCByZWZlcmVuY2VzXywgdmFsdWUpO1xuICAgICAgICAgICAgY2FzZSAnVWludDhBcnJheSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiBVaW50OEFycmF5KHNjaGVtYV8sIHJlZmVyZW5jZXNfLCB2YWx1ZSk7XG4gICAgICAgICAgICBjYXNlICdVbmtub3duJzpcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQqIFVua25vd24oc2NoZW1hXywgcmVmZXJlbmNlc18sIHZhbHVlKTtcbiAgICAgICAgICAgIGNhc2UgJ1ZvaWQnOlxuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCogVm9pZChzY2hlbWFfLCByZWZlcmVuY2VzXywgdmFsdWUpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBpZiAoIVR5cGVzLlR5cGVSZWdpc3RyeS5IYXMoc2NoZW1hX1tUeXBlcy5LaW5kXSkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlQ29tcGlsZXJVbmtub3duVHlwZUVycm9yKHNjaGVtYSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiBVc2VyRGVmaW5lZChzY2hlbWFfLCByZWZlcmVuY2VzXywgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBDb21waWxlciBTdGF0ZVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBjb25zdCBzdGF0ZSA9IHtcbiAgICAgICAgbGFuZ3VhZ2U6ICdqYXZhc2NyaXB0JyxcbiAgICAgICAgdmFyaWFibGVzOiBuZXcgU2V0KCksXG4gICAgICAgIGZ1bmN0aW9uczogbmV3IFNldCgpLFxuICAgICAgICBjdXN0b21zOiBuZXcgTWFwKCksIC8vIGN1c3RvbSB0eXBlIGRhdGFcbiAgICB9O1xuICAgIGZ1bmN0aW9uIENyZWF0ZUZ1bmN0aW9uTmFtZSgkaWQpIHtcbiAgICAgICAgcmV0dXJuIGBjaGVja18ke0lkZW50aWZpZXIuRW5jb2RlKCRpZCl9YDtcbiAgICB9XG4gICAgZnVuY3Rpb24gQ3JlYXRlRXhwcmVzc2lvbihzY2hlbWEsIHJlZmVyZW5jZXMsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBgKCR7Wy4uLlZpc2l0KHNjaGVtYSwgcmVmZXJlbmNlcywgdmFsdWUpXS5qb2luKCcgJiYgJyl9KWA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIENyZWF0ZVBhcmFtZXRlcihuYW1lLCB0eXBlKSB7XG4gICAgICAgIGNvbnN0IGFubm90YXRpb24gPSBzdGF0ZS5sYW5ndWFnZSA9PT0gJ3R5cGVzY3JpcHQnID8gYDogJHt0eXBlfWAgOiAnJztcbiAgICAgICAgcmV0dXJuIGAke25hbWV9JHthbm5vdGF0aW9ufWA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIENyZWF0ZVJldHVybnModHlwZSkge1xuICAgICAgICByZXR1cm4gc3RhdGUubGFuZ3VhZ2UgPT09ICd0eXBlc2NyaXB0JyA/IGA6ICR7dHlwZX1gIDogJyc7XG4gICAgfVxuICAgIGZ1bmN0aW9uIENyZWF0ZUZ1bmN0aW9uKG5hbWUsIHNjaGVtYSwgcmVmZXJlbmNlcywgdmFsdWUpIHtcbiAgICAgICAgY29uc3QgZXhwcmVzc2lvbiA9IFsuLi5WaXNpdChzY2hlbWEsIHJlZmVyZW5jZXMsIHZhbHVlLCB0cnVlKV0ubWFwKChjb25kaXRpb24pID0+IGAgICAgJHtjb25kaXRpb259YCkuam9pbignICYmXFxuJyk7XG4gICAgICAgIGNvbnN0IHBhcmFtZXRlciA9IENyZWF0ZVBhcmFtZXRlcigndmFsdWUnLCAnYW55Jyk7XG4gICAgICAgIGNvbnN0IHJldHVybnMgPSBDcmVhdGVSZXR1cm5zKCdib29sZWFuJyk7XG4gICAgICAgIHJldHVybiBgZnVuY3Rpb24gJHtuYW1lfSgke3BhcmFtZXRlcn0pJHtyZXR1cm5zfSB7XFxuICByZXR1cm4gKFxcbiR7ZXhwcmVzc2lvbn1cXG4gKVxcbn1gO1xuICAgIH1cbiAgICBmdW5jdGlvbiBQdXNoRnVuY3Rpb24oZnVuY3Rpb25Cb2R5KSB7XG4gICAgICAgIHN0YXRlLnZhcmlhYmxlcy5hZGQoZnVuY3Rpb25Cb2R5KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gUHVzaExvY2FsKGV4cHJlc3Npb24pIHtcbiAgICAgICAgY29uc3QgbG9jYWwgPSBgbG9jYWxfJHtzdGF0ZS52YXJpYWJsZXMuc2l6ZX1gO1xuICAgICAgICBzdGF0ZS52YXJpYWJsZXMuYWRkKGBjb25zdCAke2xvY2FsfSA9ICR7ZXhwcmVzc2lvbn1gKTtcbiAgICAgICAgcmV0dXJuIGxvY2FsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBHZXRMb2NhbHMoKSB7XG4gICAgICAgIHJldHVybiBbLi4uc3RhdGUudmFyaWFibGVzLnZhbHVlcygpXTtcbiAgICB9XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIENvbXBpbGVcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZnVuY3Rpb24gQnVpbGQoc2NoZW1hLCByZWZlcmVuY2VzKSB7XG4gICAgICAgIGNvbnN0IGNoZWNrID0gQ3JlYXRlRnVuY3Rpb24oJ2NoZWNrJywgc2NoZW1hLCByZWZlcmVuY2VzLCAndmFsdWUnKTsgLy8gaW50ZXJpb3IgdmlzaXRcbiAgICAgICAgY29uc3QgbG9jYWxzID0gR2V0TG9jYWxzKCk7XG4gICAgICAgIGNvbnN0IHBhcmFtZXRlciA9IENyZWF0ZVBhcmFtZXRlcigndmFsdWUnLCAnYW55Jyk7XG4gICAgICAgIGNvbnN0IHJldHVybnMgPSBDcmVhdGVSZXR1cm5zKCdib29sZWFuJyk7XG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICByZXR1cm4gSXNTdHJpbmcoc2NoZW1hLiRpZCkgLy8gZW5zdXJlIHRvcCBsZXZlbCBzY2hlbWFzIHdpdGggJGlkJ3MgYXJlIGhvaXN0ZWRcbiAgICAgICAgICAgID8gYCR7bG9jYWxzLmpvaW4oJ1xcbicpfVxcbnJldHVybiBmdW5jdGlvbiBjaGVjaygke3BhcmFtZXRlcn0pJHtyZXR1cm5zfSB7XFxuICByZXR1cm4gJHtDcmVhdGVGdW5jdGlvbk5hbWUoc2NoZW1hLiRpZCl9KHZhbHVlKVxcbn1gXG4gICAgICAgICAgICA6IGAke2xvY2Fscy5qb2luKCdcXG4nKX1cXG5yZXR1cm4gJHtjaGVja31gO1xuICAgIH1cbiAgICAvKiogUmV0dXJucyB0aGUgZ2VuZXJhdGVkIGFzc2VydGlvbiBjb2RlIHVzZWQgdG8gdmFsaWRhdGUgdGhpcyB0eXBlLiAqL1xuICAgIGZ1bmN0aW9uIENvZGUoc2NoZW1hLCByZWZlcmVuY2VzID0gW10sIG9wdGlvbnMgPSB7IGxhbmd1YWdlOiAnamF2YXNjcmlwdCcgfSkge1xuICAgICAgICAvLyBjb21waWxlci1yZXNldFxuICAgICAgICBzdGF0ZS5sYW5ndWFnZSA9IG9wdGlvbnMubGFuZ3VhZ2U7XG4gICAgICAgIHN0YXRlLnZhcmlhYmxlcy5jbGVhcigpO1xuICAgICAgICBzdGF0ZS5mdW5jdGlvbnMuY2xlYXIoKTtcbiAgICAgICAgc3RhdGUuY3VzdG9tcy5jbGVhcigpO1xuICAgICAgICBpZiAoIVR5cGVzLlR5cGVHdWFyZC5UU2NoZW1hKHNjaGVtYSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUNvbXBpbGVyVHlwZUd1YXJkRXJyb3Ioc2NoZW1hKTtcbiAgICAgICAgZm9yIChjb25zdCBzY2hlbWEgb2YgcmVmZXJlbmNlcylcbiAgICAgICAgICAgIGlmICghVHlwZXMuVHlwZUd1YXJkLlRTY2hlbWEoc2NoZW1hKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUNvbXBpbGVyVHlwZUd1YXJkRXJyb3Ioc2NoZW1hKTtcbiAgICAgICAgcmV0dXJuIEJ1aWxkKHNjaGVtYSwgcmVmZXJlbmNlcyk7XG4gICAgfVxuICAgIFR5cGVDb21waWxlci5Db2RlID0gQ29kZTtcbiAgICAvKiogQ29tcGlsZXMgdGhlIGdpdmVuIHR5cGUgZm9yIHJ1bnRpbWUgdHlwZSBjaGVja2luZy4gVGhpcyBjb21waWxlciBvbmx5IGFjY2VwdHMga25vd24gVHlwZUJveCB0eXBlcyBub24taW5jbHVzaXZlIG9mIHVuc2FmZSB0eXBlcy4gKi9cbiAgICBmdW5jdGlvbiBDb21waWxlKHNjaGVtYSwgcmVmZXJlbmNlcyA9IFtdKSB7XG4gICAgICAgIGNvbnN0IGNvZGUgPSBDb2RlKHNjaGVtYSwgcmVmZXJlbmNlcywgeyBsYW5ndWFnZTogJ2phdmFzY3JpcHQnIH0pO1xuICAgICAgICBjb25zdCBjdXN0b21zID0gbmV3IE1hcChzdGF0ZS5jdXN0b21zKTtcbiAgICAgICAgY29uc3QgY29tcGlsZWRGdW5jdGlvbiA9IGdsb2JhbFRoaXMuRnVuY3Rpb24oJ2N1c3RvbScsICdmb3JtYXQnLCAnaGFzaCcsIGNvZGUpO1xuICAgICAgICBjb25zdCBjaGVja0Z1bmN0aW9uID0gY29tcGlsZWRGdW5jdGlvbigoa2luZCwgc2NoZW1hX2tleSwgdmFsdWUpID0+IHtcbiAgICAgICAgICAgIGlmICghVHlwZXMuVHlwZVJlZ2lzdHJ5LkhhcyhraW5kKSB8fCAhY3VzdG9tcy5oYXMoc2NoZW1hX2tleSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgY29uc3Qgc2NoZW1hID0gY3VzdG9tcy5nZXQoc2NoZW1hX2tleSk7XG4gICAgICAgICAgICBjb25zdCBmdW5jID0gVHlwZXMuVHlwZVJlZ2lzdHJ5LkdldChraW5kKTtcbiAgICAgICAgICAgIHJldHVybiBmdW5jKHNjaGVtYSwgdmFsdWUpO1xuICAgICAgICB9LCAoZm9ybWF0LCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgaWYgKCFUeXBlcy5Gb3JtYXRSZWdpc3RyeS5IYXMoZm9ybWF0KSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBjb25zdCBmdW5jID0gVHlwZXMuRm9ybWF0UmVnaXN0cnkuR2V0KGZvcm1hdCk7XG4gICAgICAgICAgICByZXR1cm4gZnVuYyh2YWx1ZSk7XG4gICAgICAgIH0sICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGhhc2hfMS5WYWx1ZUhhc2guQ3JlYXRlKHZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuZXcgVHlwZUNoZWNrKHNjaGVtYSwgcmVmZXJlbmNlcywgY2hlY2tGdW5jdGlvbiwgY29kZSk7XG4gICAgfVxuICAgIFR5cGVDb21waWxlci5Db21waWxlID0gQ29tcGlsZTtcbn0pKFR5cGVDb21waWxlciB8fCAoZXhwb3J0cy5UeXBlQ29tcGlsZXIgPSBUeXBlQ29tcGlsZXIgPSB7fSkpO1xuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiVHlwZUNvbXBpbGVyIiwiVHlwZUNvbXBpbGVyVHlwZUd1YXJkRXJyb3IiLCJUeXBlQ29tcGlsZXJEZXJlZmVyZW5jZUVycm9yIiwiVHlwZUNvbXBpbGVyVW5rbm93blR5cGVFcnJvciIsIlR5cGVDaGVjayIsIlR5cGVzIiwicmVxdWlyZSIsImluZGV4XzEiLCJpbmRleF8yIiwiaGFzaF8xIiwiY29uc3RydWN0b3IiLCJzY2hlbWEiLCJyZWZlcmVuY2VzIiwiY2hlY2tGdW5jIiwiY29kZSIsIkNvZGUiLCJFcnJvcnMiLCJWYWx1ZUVycm9ycyIsIkNoZWNrIiwiQ2hhcmFjdGVyIiwiRG9sbGFyU2lnbiIsIklzVW5kZXJzY29yZSIsIklzQWxwaGEiLCJJc051bWVyaWMiLCJNZW1iZXJFeHByZXNzaW9uIiwiSXNGaXJzdENoYXJhY3Rlck51bWVyaWMiLCJsZW5ndGgiLCJjaGFyQ29kZUF0IiwiSXNBY2Nlc3NvciIsImkiLCJjaGVjayIsIkVzY2FwZUh5cGhlbiIsImtleSIsInJlcGxhY2UiLCJFbmNvZGUiLCJvYmplY3QiLCJJZGVudGlmaWVyIiwiJGlkIiwiYnVmZmVyIiwicHVzaCIsImNoYXJBdCIsImpvaW4iLCJFcnJvciIsIiRyZWYiLCJJc0JpZ0ludCIsIklzTnVtYmVyIiwiZ2xvYmFsVGhpcyIsIk51bWJlciIsImlzRmluaXRlIiwiSXNTdHJpbmciLCJJc0FueU9yVW5rbm93biIsIktpbmQiLCJJc0V4YWN0T3B0aW9uYWxQcm9wZXJ0eSIsImV4cHJlc3Npb24iLCJUeXBlU3lzdGVtIiwiRXhhY3RPcHRpb25hbFByb3BlcnR5VHlwZXMiLCJJc09iamVjdENoZWNrIiwiQWxsb3dBcnJheU9iamVjdHMiLCJJc1JlY29yZENoZWNrIiwiSXNOdW1iZXJDaGVjayIsIkFsbG93TmFOIiwiSXNWb2lkQ2hlY2siLCJBbGxvd1ZvaWROdWxsIiwiQW55IiwiQXJyYXkiLCJtaW5JdGVtcyIsIm1heEl0ZW1zIiwidW5pcXVlSXRlbXMiLCJDcmVhdGVFeHByZXNzaW9uIiwiaXRlbXMiLCJwYXJhbWV0ZXIiLCJDcmVhdGVQYXJhbWV0ZXIiLCJCaWdJbnQiLCJtdWx0aXBsZU9mIiwiZXhjbHVzaXZlTWluaW11bSIsImV4Y2x1c2l2ZU1heGltdW0iLCJtaW5pbXVtIiwibWF4aW11bSIsIkJvb2xlYW4iLCJDb25zdHJ1Y3RvciIsIlZpc2l0IiwicmV0dXJucyIsIkRhdGUiLCJleGNsdXNpdmVNaW5pbXVtVGltZXN0YW1wIiwiZXhjbHVzaXZlTWF4aW11bVRpbWVzdGFtcCIsIm1pbmltdW1UaW1lc3RhbXAiLCJtYXhpbXVtVGltZXN0YW1wIiwiRnVuY3Rpb24iLCJJbnRlZ2VyIiwiSW50ZXJzZWN0IiwiY2hlY2sxIiwiYWxsT2YiLCJtYXAiLCJ1bmV2YWx1YXRlZFByb3BlcnRpZXMiLCJrZXlDaGVjayIsIlB1c2hMb2NhbCIsIlJlZ0V4cCIsIktleVJlc29sdmVyIiwiUmVzb2x2ZVBhdHRlcm4iLCJjaGVjazIiLCJUeXBlR3VhcmQiLCJUU2NoZW1hIiwiTGl0ZXJhbCIsImNvbnN0IiwiTmV2ZXIiLCJOb3QiLCJsZWZ0Iiwibm90IiwicmlnaHQiLCJOdWxsIiwibWluUHJvcGVydGllcyIsIm1heFByb3BlcnRpZXMiLCJrbm93bktleXMiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwicHJvcGVydGllcyIsImtub3duS2V5IiwibWVtYmVyRXhwcmVzc2lvbiIsInByb3BlcnR5IiwicmVxdWlyZWQiLCJpbmNsdWRlcyIsIkV4dGVuZHNVbmRlZmluZWQiLCJhZGRpdGlvbmFsUHJvcGVydGllcyIsImtleXMiLCJQcm9taXNlIiwiUmVjb3JkIiwicGF0dGVybktleSIsInBhdHRlcm5TY2hlbWEiLCJlbnRyaWVzIiwicGF0dGVyblByb3BlcnRpZXMiLCJsb2NhbCIsIlJlZiIsImluZGV4IiwiZmluZEluZGV4IiwiZm9yZWlnbiIsInRhcmdldCIsInN0YXRlIiwiZnVuY3Rpb25zIiwiaGFzIiwiQ3JlYXRlRnVuY3Rpb25OYW1lIiwiU3RyaW5nIiwibWluTGVuZ3RoIiwibWF4TGVuZ3RoIiwicGF0dGVybiIsInVuZGVmaW5lZCIsImZvcm1hdCIsIlN5bWJvbCIsIlRlbXBsYXRlTGl0ZXJhbCIsIlRoaXMiLCJmdW5jIiwiVHVwbGUiLCJVbmRlZmluZWQiLCJVbmlvbiIsImV4cHJlc3Npb25zIiwiYW55T2YiLCJVaW50OEFycmF5IiwibWF4Qnl0ZUxlbmd0aCIsIm1pbkJ5dGVMZW5ndGgiLCJVbmtub3duIiwiVm9pZCIsIlVzZXJEZWZpbmVkIiwic2NoZW1hX2tleSIsImN1c3RvbXMiLCJzaXplIiwic2V0Iiwicm9vdCIsInJlZmVyZW5jZXNfIiwic2NoZW1hXyIsIm5hbWUiLCJhZGQiLCJib2R5IiwiQ3JlYXRlRnVuY3Rpb24iLCJQdXNoRnVuY3Rpb24iLCJUeXBlUmVnaXN0cnkiLCJIYXMiLCJsYW5ndWFnZSIsInZhcmlhYmxlcyIsIlNldCIsIk1hcCIsInR5cGUiLCJhbm5vdGF0aW9uIiwiQ3JlYXRlUmV0dXJucyIsImNvbmRpdGlvbiIsImZ1bmN0aW9uQm9keSIsIkdldExvY2FscyIsInZhbHVlcyIsIkJ1aWxkIiwibG9jYWxzIiwib3B0aW9ucyIsImNsZWFyIiwiQ29tcGlsZSIsImNvbXBpbGVkRnVuY3Rpb24iLCJjaGVja0Z1bmN0aW9uIiwia2luZCIsImdldCIsIkdldCIsIkZvcm1hdFJlZ2lzdHJ5IiwiVmFsdWVIYXNoIiwiQ3JlYXRlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@sinclair+typebox@0.28.20/node_modules/@sinclair/typebox/compiler/compiler.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/@sinclair+typebox@0.28.20/node_modules/@sinclair/typebox/compiler/index.js":
/*!***********************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@sinclair+typebox@0.28.20/node_modules/@sinclair/typebox/compiler/index.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*--------------------------------------------------------------------------\n\n@sinclair/typebox/compiler\n\nThe MIT License (MIT)\n\nCopyright (c) 2017-2023 Haydn Paterson (sinclair) <haydn.developer@gmail.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n---------------------------------------------------------------------------*/ var __createBinding = (void 0) && (void 0).__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n        desc = {\n            enumerable: true,\n            get: function() {\n                return m[k];\n            }\n        };\n    }\n    Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar __exportStar = (void 0) && (void 0).__exportStar || function(m, exports1) {\n    for(var p in m)if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.ValueErrorType = void 0;\nvar index_1 = __webpack_require__(/*! ../errors/index */ \"(ssr)/../../node_modules/.pnpm/@sinclair+typebox@0.28.20/node_modules/@sinclair/typebox/errors/index.js\");\nObject.defineProperty(exports, \"ValueErrorType\", ({\n    enumerable: true,\n    get: function() {\n        return index_1.ValueErrorType;\n    }\n}));\n__exportStar(__webpack_require__(/*! ./compiler */ \"(ssr)/../../node_modules/.pnpm/@sinclair+typebox@0.28.20/node_modules/@sinclair/typebox/compiler/compiler.js\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BzaW5jbGFpcit0eXBlYm94QDAuMjguMjAvbm9kZV9tb2R1bGVzL0BzaW5jbGFpci90eXBlYm94L2NvbXBpbGVyL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzJFQTBCMkUsR0FDM0UsSUFBSUEsa0JBQWtCLENBQUMsTUFBRyxLQUFLLE9BQUcsRUFBRUEsZUFBZSxJQUFNQyxDQUFBQSxPQUFPQyxNQUFNLEdBQUksU0FBU0MsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsRUFBRTtJQUMxRixJQUFJQSxPQUFPQyxXQUFXRCxLQUFLRDtJQUMzQixJQUFJRyxPQUFPUCxPQUFPUSx3QkFBd0IsQ0FBQ0wsR0FBR0M7SUFDOUMsSUFBSSxDQUFDRyxRQUFTLFVBQVNBLE9BQU8sQ0FBQ0osRUFBRU0sVUFBVSxHQUFHRixLQUFLRyxRQUFRLElBQUlILEtBQUtJLFlBQVksR0FBRztRQUNqRkosT0FBTztZQUFFSyxZQUFZO1lBQU1DLEtBQUs7Z0JBQWEsT0FBT1YsQ0FBQyxDQUFDQyxFQUFFO1lBQUU7UUFBRTtJQUM5RDtJQUNBSixPQUFPYyxjQUFjLENBQUNaLEdBQUdHLElBQUlFO0FBQ2pDLElBQU0sU0FBU0wsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsRUFBRTtJQUN0QixJQUFJQSxPQUFPQyxXQUFXRCxLQUFLRDtJQUMzQkYsQ0FBQyxDQUFDRyxHQUFHLEdBQUdGLENBQUMsQ0FBQ0MsRUFBRTtBQUNoQixDQUFDO0FBQ0QsSUFBSVcsZUFBZSxDQUFDLE1BQUcsS0FBSyxPQUFHLEVBQUVBLFlBQVksSUFBSyxTQUFTWixDQUFDLEVBQUVhLFFBQU87SUFDakUsSUFBSyxJQUFJQyxLQUFLZCxFQUFHLElBQUljLE1BQU0sYUFBYSxDQUFDakIsT0FBT2tCLFNBQVMsQ0FBQ0MsY0FBYyxDQUFDQyxJQUFJLENBQUNKLFVBQVNDLElBQUlsQixnQkFBZ0JpQixVQUFTYixHQUFHYztBQUMzSDtBQUNBakIsOENBQTZDO0lBQUVxQixPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdETCxzQkFBc0IsR0FBRyxLQUFLO0FBQzlCLElBQUlPLFVBQVVDLG1CQUFPQSxDQUFDLGdJQUFpQjtBQUN2Q3hCLGtEQUFpRDtJQUFFWSxZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPVSxRQUFRRCxjQUFjO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDM0hQLGFBQWFTLG1CQUFPQSxDQUFDLGdJQUFZLEdBQUdSIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ac2luY2xhaXIrdHlwZWJveEAwLjI4LjIwL25vZGVfbW9kdWxlcy9Ac2luY2xhaXIvdHlwZWJveC9jb21waWxlci9pbmRleC5qcz8xODg4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5Ac2luY2xhaXIvdHlwZWJveC9jb21waWxlclxuXG5UaGUgTUlUIExpY2Vuc2UgKE1JVClcblxuQ29weXJpZ2h0IChjKSAyMDE3LTIwMjMgSGF5ZG4gUGF0ZXJzb24gKHNpbmNsYWlyKSA8aGF5ZG4uZGV2ZWxvcGVyQGdtYWlsLmNvbT5cblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxub2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xudG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG5mdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbklNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG5BVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG5MSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuVEhFIFNPRlRXQVJFLlxuXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlZhbHVlRXJyb3JUeXBlID0gdm9pZCAwO1xudmFyIGluZGV4XzEgPSByZXF1aXJlKFwiLi4vZXJyb3JzL2luZGV4XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVmFsdWVFcnJvclR5cGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4XzEuVmFsdWVFcnJvclR5cGU7IH0gfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY29tcGlsZXJcIiksIGV4cG9ydHMpO1xuIl0sIm5hbWVzIjpbIl9fY3JlYXRlQmluZGluZyIsIk9iamVjdCIsImNyZWF0ZSIsIm8iLCJtIiwiayIsImsyIiwidW5kZWZpbmVkIiwiZGVzYyIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsIl9fZXNNb2R1bGUiLCJ3cml0YWJsZSIsImNvbmZpZ3VyYWJsZSIsImVudW1lcmFibGUiLCJnZXQiLCJkZWZpbmVQcm9wZXJ0eSIsIl9fZXhwb3J0U3RhciIsImV4cG9ydHMiLCJwIiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwidmFsdWUiLCJWYWx1ZUVycm9yVHlwZSIsImluZGV4XzEiLCJyZXF1aXJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@sinclair+typebox@0.28.20/node_modules/@sinclair/typebox/compiler/index.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/@sinclair+typebox@0.28.20/node_modules/@sinclair/typebox/errors/errors.js":
/*!**********************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@sinclair+typebox@0.28.20/node_modules/@sinclair/typebox/errors/errors.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.ValueErrors = exports.ValueErrorsDereferenceError = exports.ValueErrorsUnknownTypeError = exports.ValueErrorIterator = exports.ValueErrorType = void 0;\n/*--------------------------------------------------------------------------\n\n@sinclair/typebox/errors\n\nThe MIT License (MIT)\n\nCopyright (c) 2017-2023 Haydn Paterson (sinclair) <haydn.developer@gmail.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n---------------------------------------------------------------------------*/ const Types = __webpack_require__(/*! ../typebox */ \"(ssr)/../../node_modules/.pnpm/@sinclair+typebox@0.28.20/node_modules/@sinclair/typebox/typebox.js\");\nconst index_1 = __webpack_require__(/*! ../system/index */ \"(ssr)/../../node_modules/.pnpm/@sinclair+typebox@0.28.20/node_modules/@sinclair/typebox/system/index.js\");\nconst hash_1 = __webpack_require__(/*! ../value/hash */ \"(ssr)/../../node_modules/.pnpm/@sinclair+typebox@0.28.20/node_modules/@sinclair/typebox/value/hash.js\");\n// -------------------------------------------------------------------\n// ValueErrorType\n// -------------------------------------------------------------------\nvar ValueErrorType;\n(function(ValueErrorType) {\n    ValueErrorType[ValueErrorType[\"Array\"] = 0] = \"Array\";\n    ValueErrorType[ValueErrorType[\"ArrayMinItems\"] = 1] = \"ArrayMinItems\";\n    ValueErrorType[ValueErrorType[\"ArrayMaxItems\"] = 2] = \"ArrayMaxItems\";\n    ValueErrorType[ValueErrorType[\"ArrayUniqueItems\"] = 3] = \"ArrayUniqueItems\";\n    ValueErrorType[ValueErrorType[\"BigInt\"] = 4] = \"BigInt\";\n    ValueErrorType[ValueErrorType[\"BigIntMultipleOf\"] = 5] = \"BigIntMultipleOf\";\n    ValueErrorType[ValueErrorType[\"BigIntExclusiveMinimum\"] = 6] = \"BigIntExclusiveMinimum\";\n    ValueErrorType[ValueErrorType[\"BigIntExclusiveMaximum\"] = 7] = \"BigIntExclusiveMaximum\";\n    ValueErrorType[ValueErrorType[\"BigIntMinimum\"] = 8] = \"BigIntMinimum\";\n    ValueErrorType[ValueErrorType[\"BigIntMaximum\"] = 9] = \"BigIntMaximum\";\n    ValueErrorType[ValueErrorType[\"Boolean\"] = 10] = \"Boolean\";\n    ValueErrorType[ValueErrorType[\"Date\"] = 11] = \"Date\";\n    ValueErrorType[ValueErrorType[\"DateExclusiveMinimumTimestamp\"] = 12] = \"DateExclusiveMinimumTimestamp\";\n    ValueErrorType[ValueErrorType[\"DateExclusiveMaximumTimestamp\"] = 13] = \"DateExclusiveMaximumTimestamp\";\n    ValueErrorType[ValueErrorType[\"DateMinimumTimestamp\"] = 14] = \"DateMinimumTimestamp\";\n    ValueErrorType[ValueErrorType[\"DateMaximumTimestamp\"] = 15] = \"DateMaximumTimestamp\";\n    ValueErrorType[ValueErrorType[\"Function\"] = 16] = \"Function\";\n    ValueErrorType[ValueErrorType[\"Integer\"] = 17] = \"Integer\";\n    ValueErrorType[ValueErrorType[\"IntegerMultipleOf\"] = 18] = \"IntegerMultipleOf\";\n    ValueErrorType[ValueErrorType[\"IntegerExclusiveMinimum\"] = 19] = \"IntegerExclusiveMinimum\";\n    ValueErrorType[ValueErrorType[\"IntegerExclusiveMaximum\"] = 20] = \"IntegerExclusiveMaximum\";\n    ValueErrorType[ValueErrorType[\"IntegerMinimum\"] = 21] = \"IntegerMinimum\";\n    ValueErrorType[ValueErrorType[\"IntegerMaximum\"] = 22] = \"IntegerMaximum\";\n    ValueErrorType[ValueErrorType[\"Intersect\"] = 23] = \"Intersect\";\n    ValueErrorType[ValueErrorType[\"IntersectUnevaluatedProperties\"] = 24] = \"IntersectUnevaluatedProperties\";\n    ValueErrorType[ValueErrorType[\"Literal\"] = 25] = \"Literal\";\n    ValueErrorType[ValueErrorType[\"Never\"] = 26] = \"Never\";\n    ValueErrorType[ValueErrorType[\"Not\"] = 27] = \"Not\";\n    ValueErrorType[ValueErrorType[\"Null\"] = 28] = \"Null\";\n    ValueErrorType[ValueErrorType[\"Number\"] = 29] = \"Number\";\n    ValueErrorType[ValueErrorType[\"NumberMultipleOf\"] = 30] = \"NumberMultipleOf\";\n    ValueErrorType[ValueErrorType[\"NumberExclusiveMinimum\"] = 31] = \"NumberExclusiveMinimum\";\n    ValueErrorType[ValueErrorType[\"NumberExclusiveMaximum\"] = 32] = \"NumberExclusiveMaximum\";\n    ValueErrorType[ValueErrorType[\"NumberMinimum\"] = 33] = \"NumberMinimum\";\n    ValueErrorType[ValueErrorType[\"NumberMaximum\"] = 34] = \"NumberMaximum\";\n    ValueErrorType[ValueErrorType[\"Object\"] = 35] = \"Object\";\n    ValueErrorType[ValueErrorType[\"ObjectMinProperties\"] = 36] = \"ObjectMinProperties\";\n    ValueErrorType[ValueErrorType[\"ObjectMaxProperties\"] = 37] = \"ObjectMaxProperties\";\n    ValueErrorType[ValueErrorType[\"ObjectAdditionalProperties\"] = 38] = \"ObjectAdditionalProperties\";\n    ValueErrorType[ValueErrorType[\"ObjectRequiredProperties\"] = 39] = \"ObjectRequiredProperties\";\n    ValueErrorType[ValueErrorType[\"Promise\"] = 40] = \"Promise\";\n    ValueErrorType[ValueErrorType[\"RecordKeyNumeric\"] = 41] = \"RecordKeyNumeric\";\n    ValueErrorType[ValueErrorType[\"RecordKeyString\"] = 42] = \"RecordKeyString\";\n    ValueErrorType[ValueErrorType[\"String\"] = 43] = \"String\";\n    ValueErrorType[ValueErrorType[\"StringMinLength\"] = 44] = \"StringMinLength\";\n    ValueErrorType[ValueErrorType[\"StringMaxLength\"] = 45] = \"StringMaxLength\";\n    ValueErrorType[ValueErrorType[\"StringPattern\"] = 46] = \"StringPattern\";\n    ValueErrorType[ValueErrorType[\"StringFormatUnknown\"] = 47] = \"StringFormatUnknown\";\n    ValueErrorType[ValueErrorType[\"StringFormat\"] = 48] = \"StringFormat\";\n    ValueErrorType[ValueErrorType[\"Symbol\"] = 49] = \"Symbol\";\n    ValueErrorType[ValueErrorType[\"TupleZeroLength\"] = 50] = \"TupleZeroLength\";\n    ValueErrorType[ValueErrorType[\"TupleLength\"] = 51] = \"TupleLength\";\n    ValueErrorType[ValueErrorType[\"Undefined\"] = 52] = \"Undefined\";\n    ValueErrorType[ValueErrorType[\"Union\"] = 53] = \"Union\";\n    ValueErrorType[ValueErrorType[\"Uint8Array\"] = 54] = \"Uint8Array\";\n    ValueErrorType[ValueErrorType[\"Uint8ArrayMinByteLength\"] = 55] = \"Uint8ArrayMinByteLength\";\n    ValueErrorType[ValueErrorType[\"Uint8ArrayMaxByteLength\"] = 56] = \"Uint8ArrayMaxByteLength\";\n    ValueErrorType[ValueErrorType[\"Void\"] = 57] = \"Void\";\n    ValueErrorType[ValueErrorType[\"Custom\"] = 58] = \"Custom\";\n})(ValueErrorType || (exports.ValueErrorType = ValueErrorType = {}));\n// -------------------------------------------------------------------\n// ValueErrorIterator\n// -------------------------------------------------------------------\nclass ValueErrorIterator {\n    constructor(iterator){\n        this.iterator = iterator;\n    }\n    [Symbol.iterator]() {\n        return this.iterator;\n    }\n    /** Returns the first value error or undefined if no errors */ First() {\n        const next = this.iterator.next();\n        return next.done ? undefined : next.value;\n    }\n}\nexports.ValueErrorIterator = ValueErrorIterator;\n// -------------------------------------------------------------------\n// ValueErrors\n// -------------------------------------------------------------------\nclass ValueErrorsUnknownTypeError extends Error {\n    constructor(schema){\n        super(\"ValueErrors: Unknown type\");\n        this.schema = schema;\n    }\n}\nexports.ValueErrorsUnknownTypeError = ValueErrorsUnknownTypeError;\nclass ValueErrorsDereferenceError extends Error {\n    constructor(schema){\n        super(`ValueErrors: Unable to dereference schema with $id '${schema.$ref}'`);\n        this.schema = schema;\n    }\n}\nexports.ValueErrorsDereferenceError = ValueErrorsDereferenceError;\n/** Provides functionality to generate a sequence of errors against a TypeBox type.  */ var ValueErrors;\n(function(ValueErrors) {\n    // ----------------------------------------------------------------------\n    // Guards\n    // ----------------------------------------------------------------------\n    function IsBigInt(value) {\n        return typeof value === \"bigint\";\n    }\n    function IsInteger(value) {\n        return globalThis.Number.isInteger(value);\n    }\n    function IsString(value) {\n        return typeof value === \"string\";\n    }\n    function IsDefined(value) {\n        return value !== undefined;\n    }\n    // ----------------------------------------------------------------------\n    // Policies\n    // ----------------------------------------------------------------------\n    function IsExactOptionalProperty(value, key) {\n        return index_1.TypeSystem.ExactOptionalPropertyTypes ? key in value : value[key] !== undefined;\n    }\n    function IsObject(value) {\n        const result = typeof value === \"object\" && value !== null;\n        return index_1.TypeSystem.AllowArrayObjects ? result : result && !globalThis.Array.isArray(value);\n    }\n    function IsRecordObject(value) {\n        return IsObject(value) && !(value instanceof globalThis.Date) && !(value instanceof globalThis.Uint8Array);\n    }\n    function IsNumber(value) {\n        const result = typeof value === \"number\";\n        return index_1.TypeSystem.AllowNaN ? result : result && globalThis.Number.isFinite(value);\n    }\n    function IsVoid(value) {\n        const result = value === undefined;\n        return index_1.TypeSystem.AllowVoidNull ? result || value === null : result;\n    }\n    // ----------------------------------------------------------------------\n    // Types\n    // ----------------------------------------------------------------------\n    function* Any(schema, references, path, value) {}\n    function* Array(schema, references, path, value) {\n        if (!globalThis.Array.isArray(value)) {\n            return yield {\n                type: ValueErrorType.Array,\n                schema,\n                path,\n                value,\n                message: `Expected array`\n            };\n        }\n        if (IsDefined(schema.minItems) && !(value.length >= schema.minItems)) {\n            yield {\n                type: ValueErrorType.ArrayMinItems,\n                schema,\n                path,\n                value,\n                message: `Expected array length to be greater or equal to ${schema.minItems}`\n            };\n        }\n        if (IsDefined(schema.maxItems) && !(value.length <= schema.maxItems)) {\n            yield {\n                type: ValueErrorType.ArrayMinItems,\n                schema,\n                path,\n                value,\n                message: `Expected array length to be less or equal to ${schema.maxItems}`\n            };\n        }\n        // prettier-ignore\n        if (schema.uniqueItems === true && !function() {\n            const set = new Set();\n            for (const element of value){\n                const hashed = hash_1.ValueHash.Create(element);\n                if (set.has(hashed)) {\n                    return false;\n                } else {\n                    set.add(hashed);\n                }\n            }\n            return true;\n        }()) {\n            yield {\n                type: ValueErrorType.ArrayUniqueItems,\n                schema,\n                path,\n                value,\n                message: `Expected array elements to be unique`\n            };\n        }\n        for(let i = 0; i < value.length; i++){\n            yield* Visit(schema.items, references, `${path}/${i}`, value[i]);\n        }\n    }\n    function* BigInt(schema, references, path, value) {\n        if (!IsBigInt(value)) {\n            return yield {\n                type: ValueErrorType.BigInt,\n                schema,\n                path,\n                value,\n                message: `Expected bigint`\n            };\n        }\n        if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === globalThis.BigInt(0))) {\n            yield {\n                type: ValueErrorType.BigIntMultipleOf,\n                schema,\n                path,\n                value,\n                message: `Expected bigint to be a multiple of ${schema.multipleOf}`\n            };\n        }\n        if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {\n            yield {\n                type: ValueErrorType.BigIntExclusiveMinimum,\n                schema,\n                path,\n                value,\n                message: `Expected bigint to be greater than ${schema.exclusiveMinimum}`\n            };\n        }\n        if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {\n            yield {\n                type: ValueErrorType.BigIntExclusiveMaximum,\n                schema,\n                path,\n                value,\n                message: `Expected bigint to be less than ${schema.exclusiveMaximum}`\n            };\n        }\n        if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {\n            yield {\n                type: ValueErrorType.BigIntMinimum,\n                schema,\n                path,\n                value,\n                message: `Expected bigint to be greater or equal to ${schema.minimum}`\n            };\n        }\n        if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {\n            yield {\n                type: ValueErrorType.BigIntMaximum,\n                schema,\n                path,\n                value,\n                message: `Expected bigint to be less or equal to ${schema.maximum}`\n            };\n        }\n    }\n    function* Boolean(schema, references, path, value) {\n        if (!(typeof value === \"boolean\")) {\n            return yield {\n                type: ValueErrorType.Boolean,\n                schema,\n                path,\n                value,\n                message: `Expected boolean`\n            };\n        }\n    }\n    function* Constructor(schema, references, path, value) {\n        yield* Visit(schema.returns, references, path, value.prototype);\n    }\n    function* Date(schema, references, path, value) {\n        if (!(value instanceof globalThis.Date)) {\n            return yield {\n                type: ValueErrorType.Date,\n                schema,\n                path,\n                value,\n                message: `Expected Date object`\n            };\n        }\n        if (!globalThis.isFinite(value.getTime())) {\n            return yield {\n                type: ValueErrorType.Date,\n                schema,\n                path,\n                value,\n                message: `Invalid Date`\n            };\n        }\n        if (IsDefined(schema.exclusiveMinimumTimestamp) && !(value.getTime() > schema.exclusiveMinimumTimestamp)) {\n            yield {\n                type: ValueErrorType.DateExclusiveMinimumTimestamp,\n                schema,\n                path,\n                value,\n                message: `Expected Date timestamp to be greater than ${schema.exclusiveMinimum}`\n            };\n        }\n        if (IsDefined(schema.exclusiveMaximumTimestamp) && !(value.getTime() < schema.exclusiveMaximumTimestamp)) {\n            yield {\n                type: ValueErrorType.DateExclusiveMaximumTimestamp,\n                schema,\n                path,\n                value,\n                message: `Expected Date timestamp to be less than ${schema.exclusiveMaximum}`\n            };\n        }\n        if (IsDefined(schema.minimumTimestamp) && !(value.getTime() >= schema.minimumTimestamp)) {\n            yield {\n                type: ValueErrorType.DateMinimumTimestamp,\n                schema,\n                path,\n                value,\n                message: `Expected Date timestamp to be greater or equal to ${schema.minimum}`\n            };\n        }\n        if (IsDefined(schema.maximumTimestamp) && !(value.getTime() <= schema.maximumTimestamp)) {\n            yield {\n                type: ValueErrorType.DateMaximumTimestamp,\n                schema,\n                path,\n                value,\n                message: `Expected Date timestamp to be less or equal to ${schema.maximum}`\n            };\n        }\n    }\n    function* Function(schema, references, path, value) {\n        if (!(typeof value === \"function\")) {\n            return yield {\n                type: ValueErrorType.Function,\n                schema,\n                path,\n                value,\n                message: `Expected function`\n            };\n        }\n    }\n    function* Integer(schema, references, path, value) {\n        if (!IsInteger(value)) {\n            return yield {\n                type: ValueErrorType.Integer,\n                schema,\n                path,\n                value,\n                message: `Expected integer`\n            };\n        }\n        if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === 0)) {\n            yield {\n                type: ValueErrorType.IntegerMultipleOf,\n                schema,\n                path,\n                value,\n                message: `Expected integer to be a multiple of ${schema.multipleOf}`\n            };\n        }\n        if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {\n            yield {\n                type: ValueErrorType.IntegerExclusiveMinimum,\n                schema,\n                path,\n                value,\n                message: `Expected integer to be greater than ${schema.exclusiveMinimum}`\n            };\n        }\n        if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {\n            yield {\n                type: ValueErrorType.IntegerExclusiveMaximum,\n                schema,\n                path,\n                value,\n                message: `Expected integer to be less than ${schema.exclusiveMaximum}`\n            };\n        }\n        if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {\n            yield {\n                type: ValueErrorType.IntegerMinimum,\n                schema,\n                path,\n                value,\n                message: `Expected integer to be greater or equal to ${schema.minimum}`\n            };\n        }\n        if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {\n            yield {\n                type: ValueErrorType.IntegerMaximum,\n                schema,\n                path,\n                value,\n                message: `Expected integer to be less or equal to ${schema.maximum}`\n            };\n        }\n    }\n    function* Intersect(schema, references, path, value) {\n        for (const inner of schema.allOf){\n            const next = Visit(inner, references, path, value).next();\n            if (!next.done) {\n                yield next.value;\n                yield {\n                    type: ValueErrorType.Intersect,\n                    schema,\n                    path,\n                    value,\n                    message: `Expected all sub schemas to be valid`\n                };\n                return;\n            }\n        }\n        if (schema.unevaluatedProperties === false) {\n            const keyCheck = new RegExp(Types.KeyResolver.ResolvePattern(schema));\n            for (const valueKey of globalThis.Object.getOwnPropertyNames(value)){\n                if (!keyCheck.test(valueKey)) {\n                    yield {\n                        type: ValueErrorType.IntersectUnevaluatedProperties,\n                        schema,\n                        path: `${path}/${valueKey}`,\n                        value,\n                        message: `Unexpected property`\n                    };\n                }\n            }\n        }\n        if (typeof schema.unevaluatedProperties === \"object\") {\n            const keyCheck = new RegExp(Types.KeyResolver.ResolvePattern(schema));\n            for (const valueKey of globalThis.Object.getOwnPropertyNames(value)){\n                if (!keyCheck.test(valueKey)) {\n                    const next = Visit(schema.unevaluatedProperties, references, `${path}/${valueKey}`, value[valueKey]).next();\n                    if (!next.done) {\n                        yield next.value;\n                        yield {\n                            type: ValueErrorType.IntersectUnevaluatedProperties,\n                            schema,\n                            path: `${path}/${valueKey}`,\n                            value,\n                            message: `Invalid additional property`\n                        };\n                        return;\n                    }\n                }\n            }\n        }\n    }\n    function* Literal(schema, references, path, value) {\n        if (!(value === schema.const)) {\n            const error = typeof schema.const === \"string\" ? `'${schema.const}'` : schema.const;\n            return yield {\n                type: ValueErrorType.Literal,\n                schema,\n                path,\n                value,\n                message: `Expected ${error}`\n            };\n        }\n    }\n    function* Never(schema, references, path, value) {\n        yield {\n            type: ValueErrorType.Never,\n            schema,\n            path,\n            value,\n            message: `Value cannot be validated`\n        };\n    }\n    function* Not(schema, references, path, value) {\n        if (Visit(schema.allOf[0].not, references, path, value).next().done === true) {\n            yield {\n                type: ValueErrorType.Not,\n                schema,\n                path,\n                value,\n                message: `Value should not validate`\n            };\n        }\n        yield* Visit(schema.allOf[1], references, path, value);\n    }\n    function* Null(schema, references, path, value) {\n        if (!(value === null)) {\n            return yield {\n                type: ValueErrorType.Null,\n                schema,\n                path,\n                value,\n                message: `Expected null`\n            };\n        }\n    }\n    function* Number(schema, references, path, value) {\n        if (!IsNumber(value)) {\n            return yield {\n                type: ValueErrorType.Number,\n                schema,\n                path,\n                value,\n                message: `Expected number`\n            };\n        }\n        if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === 0)) {\n            yield {\n                type: ValueErrorType.NumberMultipleOf,\n                schema,\n                path,\n                value,\n                message: `Expected number to be a multiple of ${schema.multipleOf}`\n            };\n        }\n        if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {\n            yield {\n                type: ValueErrorType.NumberExclusiveMinimum,\n                schema,\n                path,\n                value,\n                message: `Expected number to be greater than ${schema.exclusiveMinimum}`\n            };\n        }\n        if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {\n            yield {\n                type: ValueErrorType.NumberExclusiveMaximum,\n                schema,\n                path,\n                value,\n                message: `Expected number to be less than ${schema.exclusiveMaximum}`\n            };\n        }\n        if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {\n            yield {\n                type: ValueErrorType.NumberMinimum,\n                schema,\n                path,\n                value,\n                message: `Expected number to be greater or equal to ${schema.minimum}`\n            };\n        }\n        if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {\n            yield {\n                type: ValueErrorType.NumberMaximum,\n                schema,\n                path,\n                value,\n                message: `Expected number to be less or equal to ${schema.maximum}`\n            };\n        }\n    }\n    function* Object1(schema, references, path, value) {\n        if (!IsObject(value)) {\n            return yield {\n                type: ValueErrorType.Object,\n                schema,\n                path,\n                value,\n                message: `Expected object`\n            };\n        }\n        if (IsDefined(schema.minProperties) && !(globalThis.Object.getOwnPropertyNames(value).length >= schema.minProperties)) {\n            yield {\n                type: ValueErrorType.ObjectMinProperties,\n                schema,\n                path,\n                value,\n                message: `Expected object to have at least ${schema.minProperties} properties`\n            };\n        }\n        if (IsDefined(schema.maxProperties) && !(globalThis.Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {\n            yield {\n                type: ValueErrorType.ObjectMaxProperties,\n                schema,\n                path,\n                value,\n                message: `Expected object to have less than ${schema.minProperties} properties`\n            };\n        }\n        const requiredKeys = globalThis.Array.isArray(schema.required) ? schema.required : [];\n        const knownKeys = globalThis.Object.getOwnPropertyNames(schema.properties);\n        const unknownKeys = globalThis.Object.getOwnPropertyNames(value);\n        for (const knownKey of knownKeys){\n            const property = schema.properties[knownKey];\n            if (schema.required && schema.required.includes(knownKey)) {\n                yield* Visit(property, references, `${path}/${knownKey}`, value[knownKey]);\n                if (Types.ExtendsUndefined.Check(schema) && !(knownKey in value)) {\n                    yield {\n                        type: ValueErrorType.ObjectRequiredProperties,\n                        schema: property,\n                        path: `${path}/${knownKey}`,\n                        value: undefined,\n                        message: `Expected required property`\n                    };\n                }\n            } else {\n                if (IsExactOptionalProperty(value, knownKey)) {\n                    yield* Visit(property, references, `${path}/${knownKey}`, value[knownKey]);\n                }\n            }\n        }\n        for (const requiredKey of requiredKeys){\n            if (unknownKeys.includes(requiredKey)) continue;\n            yield {\n                type: ValueErrorType.ObjectRequiredProperties,\n                schema: schema.properties[requiredKey],\n                path: `${path}/${requiredKey}`,\n                value: undefined,\n                message: `Expected required property`\n            };\n        }\n        if (schema.additionalProperties === false) {\n            for (const valueKey of unknownKeys){\n                if (!knownKeys.includes(valueKey)) {\n                    yield {\n                        type: ValueErrorType.ObjectAdditionalProperties,\n                        schema,\n                        path: `${path}/${valueKey}`,\n                        value: value[valueKey],\n                        message: `Unexpected property`\n                    };\n                }\n            }\n        }\n        if (typeof schema.additionalProperties === \"object\") {\n            for (const valueKey of unknownKeys){\n                if (knownKeys.includes(valueKey)) continue;\n                yield* Visit(schema.additionalProperties, references, `${path}/${valueKey}`, value[valueKey]);\n            }\n        }\n    }\n    function* Promise(schema, references, path, value) {\n        if (!(typeof value === \"object\" && typeof value.then === \"function\")) {\n            yield {\n                type: ValueErrorType.Promise,\n                schema,\n                path,\n                value,\n                message: `Expected Promise`\n            };\n        }\n    }\n    function* Record(schema, references, path, value) {\n        if (!IsRecordObject(value)) {\n            return yield {\n                type: ValueErrorType.Object,\n                schema,\n                path,\n                value,\n                message: `Expected record object`\n            };\n        }\n        if (IsDefined(schema.minProperties) && !(globalThis.Object.getOwnPropertyNames(value).length >= schema.minProperties)) {\n            yield {\n                type: ValueErrorType.ObjectMinProperties,\n                schema,\n                path,\n                value,\n                message: `Expected object to have at least ${schema.minProperties} properties`\n            };\n        }\n        if (IsDefined(schema.maxProperties) && !(globalThis.Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {\n            yield {\n                type: ValueErrorType.ObjectMaxProperties,\n                schema,\n                path,\n                value,\n                message: `Expected object to have less than ${schema.minProperties} properties`\n            };\n        }\n        const [patternKey, patternSchema] = globalThis.Object.entries(schema.patternProperties)[0];\n        const regex = new RegExp(patternKey);\n        for (const [propertyKey, propertyValue] of globalThis.Object.entries(value)){\n            if (regex.test(propertyKey)) {\n                yield* Visit(patternSchema, references, `${path}/${propertyKey}`, propertyValue);\n                continue;\n            }\n            if (typeof schema.additionalProperties === \"object\") {\n                yield* Visit(schema.additionalProperties, references, `${path}/${propertyKey}`, propertyValue);\n            }\n            if (schema.additionalProperties === false) {\n                const propertyPath = `${path}/${propertyKey}`;\n                const message = `Unexpected property '${propertyPath}'`;\n                return yield {\n                    type: ValueErrorType.ObjectAdditionalProperties,\n                    schema,\n                    path: propertyPath,\n                    value: propertyValue,\n                    message\n                };\n            }\n        }\n    }\n    function* Ref(schema, references, path, value) {\n        const index = references.findIndex((foreign)=>foreign.$id === schema.$ref);\n        if (index === -1) throw new ValueErrorsDereferenceError(schema);\n        const target = references[index];\n        yield* Visit(target, references, path, value);\n    }\n    function* String(schema, references, path, value) {\n        if (!IsString(value)) {\n            return yield {\n                type: ValueErrorType.String,\n                schema,\n                path,\n                value,\n                message: \"Expected string\"\n            };\n        }\n        if (IsDefined(schema.minLength) && !(value.length >= schema.minLength)) {\n            yield {\n                type: ValueErrorType.StringMinLength,\n                schema,\n                path,\n                value,\n                message: `Expected string length greater or equal to ${schema.minLength}`\n            };\n        }\n        if (IsDefined(schema.maxLength) && !(value.length <= schema.maxLength)) {\n            yield {\n                type: ValueErrorType.StringMaxLength,\n                schema,\n                path,\n                value,\n                message: `Expected string length less or equal to ${schema.maxLength}`\n            };\n        }\n        if (schema.pattern !== undefined) {\n            const regex = new RegExp(schema.pattern);\n            if (!regex.test(value)) {\n                yield {\n                    type: ValueErrorType.StringPattern,\n                    schema,\n                    path,\n                    value,\n                    message: `Expected string to match pattern ${schema.pattern}`\n                };\n            }\n        }\n        if (schema.format !== undefined) {\n            if (!Types.FormatRegistry.Has(schema.format)) {\n                yield {\n                    type: ValueErrorType.StringFormatUnknown,\n                    schema,\n                    path,\n                    value,\n                    message: `Unknown string format '${schema.format}'`\n                };\n            } else {\n                const format = Types.FormatRegistry.Get(schema.format);\n                if (!format(value)) {\n                    yield {\n                        type: ValueErrorType.StringFormat,\n                        schema,\n                        path,\n                        value,\n                        message: `Expected string to match format '${schema.format}'`\n                    };\n                }\n            }\n        }\n    }\n    function* Symbol1(schema, references, path, value) {\n        if (!(typeof value === \"symbol\")) {\n            return yield {\n                type: ValueErrorType.Symbol,\n                schema,\n                path,\n                value,\n                message: \"Expected symbol\"\n            };\n        }\n    }\n    function* TemplateLiteral(schema, references, path, value) {\n        if (!IsString(value)) {\n            return yield {\n                type: ValueErrorType.String,\n                schema,\n                path,\n                value,\n                message: \"Expected string\"\n            };\n        }\n        const regex = new RegExp(schema.pattern);\n        if (!regex.test(value)) {\n            yield {\n                type: ValueErrorType.StringPattern,\n                schema,\n                path,\n                value,\n                message: `Expected string to match pattern ${schema.pattern}`\n            };\n        }\n    }\n    function* This(schema, references, path, value) {\n        const index = references.findIndex((foreign)=>foreign.$id === schema.$ref);\n        if (index === -1) throw new ValueErrorsDereferenceError(schema);\n        const target = references[index];\n        yield* Visit(target, references, path, value);\n    }\n    function* Tuple(schema, references, path, value) {\n        if (!globalThis.Array.isArray(value)) {\n            return yield {\n                type: ValueErrorType.Array,\n                schema,\n                path,\n                value,\n                message: \"Expected Array\"\n            };\n        }\n        if (schema.items === undefined && !(value.length === 0)) {\n            return yield {\n                type: ValueErrorType.TupleZeroLength,\n                schema,\n                path,\n                value,\n                message: \"Expected tuple to have 0 elements\"\n            };\n        }\n        if (!(value.length === schema.maxItems)) {\n            yield {\n                type: ValueErrorType.TupleLength,\n                schema,\n                path,\n                value,\n                message: `Expected tuple to have ${schema.maxItems} elements`\n            };\n        }\n        if (!schema.items) {\n            return;\n        }\n        for(let i = 0; i < schema.items.length; i++){\n            yield* Visit(schema.items[i], references, `${path}/${i}`, value[i]);\n        }\n    }\n    function* Undefined(schema, references, path, value) {\n        if (!(value === undefined)) {\n            yield {\n                type: ValueErrorType.Undefined,\n                schema,\n                path,\n                value,\n                message: `Expected undefined`\n            };\n        }\n    }\n    function* Union(schema, references, path, value) {\n        const errors = [];\n        for (const inner of schema.anyOf){\n            const variantErrors = [\n                ...Visit(inner, references, path, value)\n            ];\n            if (variantErrors.length === 0) return;\n            errors.push(...variantErrors);\n        }\n        if (errors.length > 0) {\n            yield {\n                type: ValueErrorType.Union,\n                schema,\n                path,\n                value,\n                message: \"Expected value of union\"\n            };\n        }\n        for (const error of errors){\n            yield error;\n        }\n    }\n    function* Uint8Array(schema, references, path, value) {\n        if (!(value instanceof globalThis.Uint8Array)) {\n            return yield {\n                type: ValueErrorType.Uint8Array,\n                schema,\n                path,\n                value,\n                message: `Expected Uint8Array`\n            };\n        }\n        if (IsDefined(schema.maxByteLength) && !(value.length <= schema.maxByteLength)) {\n            yield {\n                type: ValueErrorType.Uint8ArrayMaxByteLength,\n                schema,\n                path,\n                value,\n                message: `Expected Uint8Array to have a byte length less or equal to ${schema.maxByteLength}`\n            };\n        }\n        if (IsDefined(schema.minByteLength) && !(value.length >= schema.minByteLength)) {\n            yield {\n                type: ValueErrorType.Uint8ArrayMinByteLength,\n                schema,\n                path,\n                value,\n                message: `Expected Uint8Array to have a byte length greater or equal to ${schema.maxByteLength}`\n            };\n        }\n    }\n    function* Unknown(schema, references, path, value) {}\n    function* Void(schema, references, path, value) {\n        if (!IsVoid(value)) {\n            return yield {\n                type: ValueErrorType.Void,\n                schema,\n                path,\n                value,\n                message: `Expected void`\n            };\n        }\n    }\n    function* UserDefined(schema, references, path, value) {\n        const check = Types.TypeRegistry.Get(schema[Types.Kind]);\n        if (!check(schema, value)) {\n            return yield {\n                type: ValueErrorType.Custom,\n                schema,\n                path,\n                value,\n                message: `Expected kind ${schema[Types.Kind]}`\n            };\n        }\n    }\n    function* Visit(schema, references, path, value) {\n        const references_ = IsDefined(schema.$id) ? [\n            ...references,\n            schema\n        ] : references;\n        const schema_ = schema;\n        switch(schema_[Types.Kind]){\n            case \"Any\":\n                return yield* Any(schema_, references_, path, value);\n            case \"Array\":\n                return yield* Array(schema_, references_, path, value);\n            case \"BigInt\":\n                return yield* BigInt(schema_, references_, path, value);\n            case \"Boolean\":\n                return yield* Boolean(schema_, references_, path, value);\n            case \"Constructor\":\n                return yield* Constructor(schema_, references_, path, value);\n            case \"Date\":\n                return yield* Date(schema_, references_, path, value);\n            case \"Function\":\n                return yield* Function(schema_, references_, path, value);\n            case \"Integer\":\n                return yield* Integer(schema_, references_, path, value);\n            case \"Intersect\":\n                return yield* Intersect(schema_, references_, path, value);\n            case \"Literal\":\n                return yield* Literal(schema_, references_, path, value);\n            case \"Never\":\n                return yield* Never(schema_, references_, path, value);\n            case \"Not\":\n                return yield* Not(schema_, references_, path, value);\n            case \"Null\":\n                return yield* Null(schema_, references_, path, value);\n            case \"Number\":\n                return yield* Number(schema_, references_, path, value);\n            case \"Object\":\n                return yield* Object1(schema_, references_, path, value);\n            case \"Promise\":\n                return yield* Promise(schema_, references_, path, value);\n            case \"Record\":\n                return yield* Record(schema_, references_, path, value);\n            case \"Ref\":\n                return yield* Ref(schema_, references_, path, value);\n            case \"String\":\n                return yield* String(schema_, references_, path, value);\n            case \"Symbol\":\n                return yield* Symbol1(schema_, references_, path, value);\n            case \"TemplateLiteral\":\n                return yield* TemplateLiteral(schema_, references_, path, value);\n            case \"This\":\n                return yield* This(schema_, references_, path, value);\n            case \"Tuple\":\n                return yield* Tuple(schema_, references_, path, value);\n            case \"Undefined\":\n                return yield* Undefined(schema_, references_, path, value);\n            case \"Union\":\n                return yield* Union(schema_, references_, path, value);\n            case \"Uint8Array\":\n                return yield* Uint8Array(schema_, references_, path, value);\n            case \"Unknown\":\n                return yield* Unknown(schema_, references_, path, value);\n            case \"Void\":\n                return yield* Void(schema_, references_, path, value);\n            default:\n                if (!Types.TypeRegistry.Has(schema_[Types.Kind])) throw new ValueErrorsUnknownTypeError(schema);\n                return yield* UserDefined(schema_, references_, path, value);\n        }\n    }\n    function Errors(schema, references, value) {\n        const iterator = Visit(schema, references, \"\", value);\n        return new ValueErrorIterator(iterator);\n    }\n    ValueErrors.Errors = Errors;\n})(ValueErrors || (exports.ValueErrors = ValueErrors = {}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BzaW5jbGFpcit0eXBlYm94QDAuMjguMjAvbm9kZV9tb2R1bGVzL0BzaW5jbGFpci90eXBlYm94L2Vycm9ycy9lcnJvcnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELG1CQUFtQixHQUFHQSxtQ0FBbUMsR0FBR0EsbUNBQW1DLEdBQUdBLDBCQUEwQixHQUFHQSxzQkFBc0IsR0FBRyxLQUFLO0FBQzdKOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzsyRUEwQjJFLEdBQzNFLE1BQU1PLFFBQVFDLG1CQUFPQSxDQUFDLHNIQUFZO0FBQ2xDLE1BQU1DLFVBQVVELG1CQUFPQSxDQUFDLGdJQUFpQjtBQUN6QyxNQUFNRSxTQUFTRixtQkFBT0EsQ0FBQyw0SEFBZTtBQUN0QyxzRUFBc0U7QUFDdEUsaUJBQWlCO0FBQ2pCLHNFQUFzRTtBQUN0RSxJQUFJRjtBQUNILFVBQVVBLGNBQWM7SUFDckJBLGNBQWMsQ0FBQ0EsY0FBYyxDQUFDLFFBQVEsR0FBRyxFQUFFLEdBQUc7SUFDOUNBLGNBQWMsQ0FBQ0EsY0FBYyxDQUFDLGdCQUFnQixHQUFHLEVBQUUsR0FBRztJQUN0REEsY0FBYyxDQUFDQSxjQUFjLENBQUMsZ0JBQWdCLEdBQUcsRUFBRSxHQUFHO0lBQ3REQSxjQUFjLENBQUNBLGNBQWMsQ0FBQyxtQkFBbUIsR0FBRyxFQUFFLEdBQUc7SUFDekRBLGNBQWMsQ0FBQ0EsY0FBYyxDQUFDLFNBQVMsR0FBRyxFQUFFLEdBQUc7SUFDL0NBLGNBQWMsQ0FBQ0EsY0FBYyxDQUFDLG1CQUFtQixHQUFHLEVBQUUsR0FBRztJQUN6REEsY0FBYyxDQUFDQSxjQUFjLENBQUMseUJBQXlCLEdBQUcsRUFBRSxHQUFHO0lBQy9EQSxjQUFjLENBQUNBLGNBQWMsQ0FBQyx5QkFBeUIsR0FBRyxFQUFFLEdBQUc7SUFDL0RBLGNBQWMsQ0FBQ0EsY0FBYyxDQUFDLGdC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QUFJN0M7UUFDL0MsT0FBTyxJQUFJSSxtQkFBbUJPO0lBQ2xDO0lBQ0FWLFlBQVlnTSxNQUFNLEdBQUdBO0FBQ3pCLEdBQUdoTSxlQUFnQkYsQ0FBQUEsbUJBQW1CLEdBQUdFLGNBQWMsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHNpbmNsYWlyK3R5cGVib3hAMC4yOC4yMC9ub2RlX21vZHVsZXMvQHNpbmNsYWlyL3R5cGVib3gvZXJyb3JzL2Vycm9ycy5qcz8yZThhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5WYWx1ZUVycm9ycyA9IGV4cG9ydHMuVmFsdWVFcnJvcnNEZXJlZmVyZW5jZUVycm9yID0gZXhwb3J0cy5WYWx1ZUVycm9yc1Vua25vd25UeXBlRXJyb3IgPSBleHBvcnRzLlZhbHVlRXJyb3JJdGVyYXRvciA9IGV4cG9ydHMuVmFsdWVFcnJvclR5cGUgPSB2b2lkIDA7XG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbkBzaW5jbGFpci90eXBlYm94L2Vycm9yc1xuXG5UaGUgTUlUIExpY2Vuc2UgKE1JVClcblxuQ29weXJpZ2h0IChjKSAyMDE3LTIwMjMgSGF5ZG4gUGF0ZXJzb24gKHNpbmNsYWlyKSA8aGF5ZG4uZGV2ZWxvcGVyQGdtYWlsLmNvbT5cblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxub2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xudG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG5mdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbklNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG5BVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG5MSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuVEhFIFNPRlRXQVJFLlxuXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuY29uc3QgVHlwZXMgPSByZXF1aXJlKFwiLi4vdHlwZWJveFwiKTtcbmNvbnN0IGluZGV4XzEgPSByZXF1aXJlKFwiLi4vc3lzdGVtL2luZGV4XCIpO1xuY29uc3QgaGFzaF8xID0gcmVxdWlyZShcIi4uL3ZhbHVlL2hhc2hcIik7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBWYWx1ZUVycm9yVHlwZVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxudmFyIFZhbHVlRXJyb3JUeXBlO1xuKGZ1bmN0aW9uIChWYWx1ZUVycm9yVHlwZSkge1xuICAgIFZhbHVlRXJyb3JUeXBlW1ZhbHVlRXJyb3JUeXBlW1wiQXJyYXlcIl0gPSAwXSA9IFwiQXJyYXlcIjtcbiAgICBWYWx1ZUVycm9yVHlwZVtWYWx1ZUVycm9yVHlwZVtcIkFycmF5TWluSXRlbXNcIl0gPSAxXSA9IFwiQXJyYXlNaW5JdGVtc1wiO1xuICAgIFZhbHVlRXJyb3JUeXBlW1ZhbHVlRXJyb3JUeXBlW1wiQXJyYXlNYXhJdGVtc1wiXSA9IDJdID0gXCJBcnJheU1heEl0ZW1zXCI7XG4gICAgVmFsdWVFcnJvclR5cGVbVmFsdWVFcnJvclR5cGVbXCJBcnJheVVuaXF1ZUl0ZW1zXCJdID0gM10gPSBcIkFycmF5VW5pcXVlSXRlbXNcIjtcbiAgICBWYWx1ZUVycm9yVHlwZVtWYWx1ZUVycm9yVHlwZVtcIkJpZ0ludFwiXSA9IDRdID0gXCJCaWdJbnRcIjtcbiAgICBWYWx1ZUVycm9yVHlwZVtWYWx1ZUVycm9yVHlwZVtcIkJpZ0ludE11bHRpcGxlT2ZcIl0gPSA1XSA9IFwiQmlnSW50TXVsdGlwbGVPZlwiO1xuICAgIFZhbHVlRXJyb3JUeXBlW1ZhbHVlRXJyb3JUeXBlW1wiQmlnSW50RXhjbHVzaXZlTWluaW11bVwiXSA9IDZdID0gXCJCaWdJbnRFeGNsdXNpdmVNaW5pbXVtXCI7XG4gICAgVmFsdWVFcnJvclR5cGVbVmFsdWVFcnJvclR5cGVbXCJCaWdJbnRFeGNsdXNpdmVNYXhpbXVtXCJdID0gN10gPSBcIkJpZ0ludEV4Y2x1c2l2ZU1heGltdW1cIjtcbiAgICBWYWx1ZUVycm9yVHlwZVtWYWx1ZUVycm9yVHlwZVtcIkJpZ0ludE1pbmltdW1cIl0gPSA4XSA9IFwiQmlnSW50TWluaW11bVwiO1xuICAgIFZhbHVlRXJyb3JUeXBlW1ZhbHVlRXJyb3JUeXBlW1wiQmlnSW50TWF4aW11bVwiXSA9IDldID0gXCJCaWdJbnRNYXhpbXVtXCI7XG4gICAgVmFsdWVFcnJvclR5cGVbVmFsdWVFcnJvclR5cGVbXCJCb29sZWFuXCJdID0gMTBdID0gXCJCb29sZWFuXCI7XG4gICAgVmFsdWVFcnJvclR5cGVbVmFsdWVFcnJvclR5cGVbXCJEYXRlXCJdID0gMTFdID0gXCJEYXRlXCI7XG4gICAgVmFsdWVFcnJvclR5cGVbVmFsdWVFcnJvclR5cGVbXCJEYXRlRXhjbHVzaXZlTWluaW11bVRpbWVzdGFtcFwiXSA9IDEyXSA9IFwiRGF0ZUV4Y2x1c2l2ZU1pbmltdW1UaW1lc3RhbXBcIjtcbiAgICBWYWx1ZUVycm9yVHlwZVtWYWx1ZUVycm9yVHlwZVtcIkRhdGVFeGNsdXNpdmVNYXhpbXVtVGltZXN0YW1wXCJdID0gMTNdID0gXCJEYXRlRXhjbHVzaXZlTWF4aW11bVRpbWVzdGFtcFwiO1xuICAgIFZhbHVlRXJyb3JUeXBlW1ZhbHVlRXJyb3JUeXBlW1wiRGF0ZU1pbmltdW1UaW1lc3RhbXBcIl0gPSAxNF0gPSBcIkRhdGVNaW5pbXVtVGltZXN0YW1wXCI7XG4gICAgVmFsdWVFcnJvclR5cGVbVmFsdWVFcnJvclR5cGVbXCJEYXRlTWF4aW11bVRpbWVzdGFtcFwiXSA9IDE1XSA9IFwiRGF0ZU1heGltdW1UaW1lc3RhbXBcIjtcbiAgICBWYWx1ZUVycm9yVHlwZVtWYWx1ZUVycm9yVHlwZVtcIkZ1bmN0aW9uXCJdID0gMTZdID0gXCJGdW5jdGlvblwiO1xuICAgIFZhbHVlRXJyb3JUeXBlW1ZhbHVlRXJyb3JUeXBlW1wiSW50ZWdlclwiXSA9IDE3XSA9IFwiSW50ZWdlclwiO1xuICAgIFZhbHVlRXJyb3JUeXBlW1ZhbHVlRXJyb3JUeXBlW1wiSW50ZWdlck11bHRpcGxlT2ZcIl0gPSAxOF0gPSBcIkludGVnZXJNdWx0aXBsZU9mXCI7XG4gICAgVmFsdWVFcnJvclR5cGVbVmFsdWVFcnJvclR5cGVbXCJJbnRlZ2VyRXhjbHVzaXZlTWluaW11bVwiXSA9IDE5XSA9IFwiSW50ZWdlckV4Y2x1c2l2ZU1pbmltdW1cIjtcbiAgICBWYWx1ZUVycm9yVHlwZVtWYWx1ZUVycm9yVHlwZVtcIkludGVnZXJFeGNsdXNpdmVNYXhpbXVtXCJdID0gMjBdID0gXCJJbnRlZ2VyRXhjbHVzaXZlTWF4aW11bVwiO1xuICAgIFZhbHVlRXJyb3JUeXBlW1ZhbHVlRXJyb3JUeXBlW1wiSW50ZWdlck1pbmltdW1cIl0gPSAyMV0gPSBcIkludGVnZXJNaW5pbXVtXCI7XG4gICAgVmFsdWVFcnJvclR5cGVbVmFsdWVFcnJvclR5cGVbXCJJbnRlZ2VyTWF4aW11bVwiXSA9IDIyXSA9IFwiSW50ZWdlck1heGltdW1cIjtcbiAgICBWYWx1ZUVycm9yVHlwZVtWYWx1ZUVycm9yVHlwZVtcIkludGVyc2VjdFwiXSA9IDIzXSA9IFwiSW50ZXJzZWN0XCI7XG4gICAgVmFsdWVFcnJvclR5cGVbVmFsdWVFcnJvclR5cGVbXCJJbnRlcnNlY3RVbmV2YWx1YXRlZFByb3BlcnRpZXNcIl0gPSAyNF0gPSBcIkludGVyc2VjdFVuZXZhbHVhdGVkUHJvcGVydGllc1wiO1xuICAgIFZhbHVlRXJyb3JUeXBlW1ZhbHVlRXJyb3JUeXBlW1wiTGl0ZXJhbFwiXSA9IDI1XSA9IFwiTGl0ZXJhbFwiO1xuICAgIFZhbHVlRXJyb3JUeXBlW1ZhbHVlRXJyb3JUeXBlW1wiTmV2ZXJcIl0gPSAyNl0gPSBcIk5ldmVyXCI7XG4gICAgVmFsdWVFcnJvclR5cGVbVmFsdWVFcnJvclR5cGVbXCJOb3RcIl0gPSAyN10gPSBcIk5vdFwiO1xuICAgIFZhbHVlRXJyb3JUeXBlW1ZhbHVlRXJyb3JUeXBlW1wiTnVsbFwiXSA9IDI4XSA9IFwiTnVsbFwiO1xuICAgIFZhbHVlRXJyb3JUeXBlW1ZhbHVlRXJyb3JUeXBlW1wiTnVtYmVyXCJdID0gMjldID0gXCJOdW1iZXJcIjtcbiAgICBWYWx1ZUVycm9yVHlwZVtWYWx1ZUVycm9yVHlwZVtcIk51bWJlck11bHRpcGxlT2ZcIl0gPSAzMF0gPSBcIk51bWJlck11bHRpcGxlT2ZcIjtcbiAgICBWYWx1ZUVycm9yVHlwZVtWYWx1ZUVycm9yVHlwZVtcIk51bWJlckV4Y2x1c2l2ZU1pbmltdW1cIl0gPSAzMV0gPSBcIk51bWJlckV4Y2x1c2l2ZU1pbmltdW1cIjtcbiAgICBWYWx1ZUVycm9yVHlwZVtWYWx1ZUVycm9yVHlwZVtcIk51bWJlckV4Y2x1c2l2ZU1heGltdW1cIl0gPSAzMl0gPSBcIk51bWJlckV4Y2x1c2l2ZU1heGltdW1cIjtcbiAgICBWYWx1ZUVycm9yVHlwZVtWYWx1ZUVycm9yVHlwZVtcIk51bWJlck1pbmltdW1cIl0gPSAzM10gPSBcIk51bWJlck1pbmltdW1cIjtcbiAgICBWYWx1ZUVycm9yVHlwZVtWYWx1ZUVycm9yVHlwZVtcIk51bWJlck1heGltdW1cIl0gPSAzNF0gPSBcIk51bWJlck1heGltdW1cIjtcbiAgICBWYWx1ZUVycm9yVHlwZVtWYWx1ZUVycm9yVHlwZVtcIk9iamVjdFwiXSA9IDM1XSA9IFwiT2JqZWN0XCI7XG4gICAgVmFsdWVFcnJvclR5cGVbVmFsdWVFcnJvclR5cGVbXCJPYmplY3RNaW5Qcm9wZXJ0aWVzXCJdID0gMzZdID0gXCJPYmplY3RNaW5Qcm9wZXJ0aWVzXCI7XG4gICAgVmFsdWVFcnJvclR5cGVbVmFsdWVFcnJvclR5cGVbXCJPYmplY3RNYXhQcm9wZXJ0aWVzXCJdID0gMzddID0gXCJPYmplY3RNYXhQcm9wZXJ0aWVzXCI7XG4gICAgVmFsdWVFcnJvclR5cGVbVmFsdWVFcnJvclR5cGVbXCJPYmplY3RBZGRpdGlvbmFsUHJvcGVydGllc1wiXSA9IDM4XSA9IFwiT2JqZWN0QWRkaXRpb25hbFByb3BlcnRpZXNcIjtcbiAgICBWYWx1ZUVycm9yVHlwZVtWYWx1ZUVycm9yVHlwZVtcIk9iamVjdFJlcXVpcmVkUHJvcGVydGllc1wiXSA9IDM5XSA9IFwiT2JqZWN0UmVxdWlyZWRQcm9wZXJ0aWVzXCI7XG4gICAgVmFsdWVFcnJvclR5cGVbVmFsdWVFcnJvclR5cGVbXCJQcm9taXNlXCJdID0gNDBdID0gXCJQcm9taXNlXCI7XG4gICAgVmFsdWVFcnJvclR5cGVbVmFsdWVFcnJvclR5cGVbXCJSZWNvcmRLZXlOdW1lcmljXCJdID0gNDFdID0gXCJSZWNvcmRLZXlOdW1lcmljXCI7XG4gICAgVmFsdWVFcnJvclR5cGVbVmFsdWVFcnJvclR5cGVbXCJSZWNvcmRLZXlTdHJpbmdcIl0gPSA0Ml0gPSBcIlJlY29yZEtleVN0cmluZ1wiO1xuICAgIFZhbHVlRXJyb3JUeXBlW1ZhbHVlRXJyb3JUeXBlW1wiU3RyaW5nXCJdID0gNDNdID0gXCJTdHJpbmdcIjtcbiAgICBWYWx1ZUVycm9yVHlwZVtWYWx1ZUVycm9yVHlwZVtcIlN0cmluZ01pbkxlbmd0aFwiXSA9IDQ0XSA9IFwiU3RyaW5nTWluTGVuZ3RoXCI7XG4gICAgVmFsdWVFcnJvclR5cGVbVmFsdWVFcnJvclR5cGVbXCJTdHJpbmdNYXhMZW5ndGhcIl0gPSA0NV0gPSBcIlN0cmluZ01heExlbmd0aFwiO1xuICAgIFZhbHVlRXJyb3JUeXBlW1ZhbHVlRXJyb3JUeXBlW1wiU3RyaW5nUGF0dGVyblwiXSA9IDQ2XSA9IFwiU3RyaW5nUGF0dGVyblwiO1xuICAgIFZhbHVlRXJyb3JUeXBlW1ZhbHVlRXJyb3JUeXBlW1wiU3RyaW5nRm9ybWF0VW5rbm93blwiXSA9IDQ3XSA9IFwiU3RyaW5nRm9ybWF0VW5rbm93blwiO1xuICAgIFZhbHVlRXJyb3JUeXBlW1ZhbHVlRXJyb3JUeXBlW1wiU3RyaW5nRm9ybWF0XCJdID0gNDhdID0gXCJTdHJpbmdGb3JtYXRcIjtcbiAgICBWYWx1ZUVycm9yVHlwZVtWYWx1ZUVycm9yVHlwZVtcIlN5bWJvbFwiXSA9IDQ5XSA9IFwiU3ltYm9sXCI7XG4gICAgVmFsdWVFcnJvclR5cGVbVmFsdWVFcnJvclR5cGVbXCJUdXBsZVplcm9MZW5ndGhcIl0gPSA1MF0gPSBcIlR1cGxlWmVyb0xlbmd0aFwiO1xuICAgIFZhbHVlRXJyb3JUeXBlW1ZhbHVlRXJyb3JUeXBlW1wiVHVwbGVMZW5ndGhcIl0gPSA1MV0gPSBcIlR1cGxlTGVuZ3RoXCI7XG4gICAgVmFsdWVFcnJvclR5cGVbVmFsdWVFcnJvclR5cGVbXCJVbmRlZmluZWRcIl0gPSA1Ml0gPSBcIlVuZGVmaW5lZFwiO1xuICAgIFZhbHVlRXJyb3JUeXBlW1ZhbHVlRXJyb3JUeXBlW1wiVW5pb25cIl0gPSA1M10gPSBcIlVuaW9uXCI7XG4gICAgVmFsdWVFcnJvclR5cGVbVmFsdWVFcnJvclR5cGVbXCJVaW50OEFycmF5XCJdID0gNTRdID0gXCJVaW50OEFycmF5XCI7XG4gICAgVmFsdWVFcnJvclR5cGVbVmFsdWVFcnJvclR5cGVbXCJVaW50OEFycmF5TWluQnl0ZUxlbmd0aFwiXSA9IDU1XSA9IFwiVWludDhBcnJheU1pbkJ5dGVMZW5ndGhcIjtcbiAgICBWYWx1ZUVycm9yVHlwZVtWYWx1ZUVycm9yVHlwZVtcIlVpbnQ4QXJyYXlNYXhCeXRlTGVuZ3RoXCJdID0gNTZdID0gXCJVaW50OEFycmF5TWF4Qnl0ZUxlbmd0aFwiO1xuICAgIFZhbHVlRXJyb3JUeXBlW1ZhbHVlRXJyb3JUeXBlW1wiVm9pZFwiXSA9IDU3XSA9IFwiVm9pZFwiO1xuICAgIFZhbHVlRXJyb3JUeXBlW1ZhbHVlRXJyb3JUeXBlW1wiQ3VzdG9tXCJdID0gNThdID0gXCJDdXN0b21cIjtcbn0pKFZhbHVlRXJyb3JUeXBlIHx8IChleHBvcnRzLlZhbHVlRXJyb3JUeXBlID0gVmFsdWVFcnJvclR5cGUgPSB7fSkpO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gVmFsdWVFcnJvckl0ZXJhdG9yXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5jbGFzcyBWYWx1ZUVycm9ySXRlcmF0b3Ige1xuICAgIGNvbnN0cnVjdG9yKGl0ZXJhdG9yKSB7XG4gICAgICAgIHRoaXMuaXRlcmF0b3IgPSBpdGVyYXRvcjtcbiAgICB9XG4gICAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLml0ZXJhdG9yO1xuICAgIH1cbiAgICAvKiogUmV0dXJucyB0aGUgZmlyc3QgdmFsdWUgZXJyb3Igb3IgdW5kZWZpbmVkIGlmIG5vIGVycm9ycyAqL1xuICAgIEZpcnN0KCkge1xuICAgICAgICBjb25zdCBuZXh0ID0gdGhpcy5pdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIHJldHVybiBuZXh0LmRvbmUgPyB1bmRlZmluZWQgOiBuZXh0LnZhbHVlO1xuICAgIH1cbn1cbmV4cG9ydHMuVmFsdWVFcnJvckl0ZXJhdG9yID0gVmFsdWVFcnJvckl0ZXJhdG9yO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gVmFsdWVFcnJvcnNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmNsYXNzIFZhbHVlRXJyb3JzVW5rbm93blR5cGVFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihzY2hlbWEpIHtcbiAgICAgICAgc3VwZXIoJ1ZhbHVlRXJyb3JzOiBVbmtub3duIHR5cGUnKTtcbiAgICAgICAgdGhpcy5zY2hlbWEgPSBzY2hlbWE7XG4gICAgfVxufVxuZXhwb3J0cy5WYWx1ZUVycm9yc1Vua25vd25UeXBlRXJyb3IgPSBWYWx1ZUVycm9yc1Vua25vd25UeXBlRXJyb3I7XG5jbGFzcyBWYWx1ZUVycm9yc0RlcmVmZXJlbmNlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3Ioc2NoZW1hKSB7XG4gICAgICAgIHN1cGVyKGBWYWx1ZUVycm9yczogVW5hYmxlIHRvIGRlcmVmZXJlbmNlIHNjaGVtYSB3aXRoICRpZCAnJHtzY2hlbWEuJHJlZn0nYCk7XG4gICAgICAgIHRoaXMuc2NoZW1hID0gc2NoZW1hO1xuICAgIH1cbn1cbmV4cG9ydHMuVmFsdWVFcnJvcnNEZXJlZmVyZW5jZUVycm9yID0gVmFsdWVFcnJvcnNEZXJlZmVyZW5jZUVycm9yO1xuLyoqIFByb3ZpZGVzIGZ1bmN0aW9uYWxpdHkgdG8gZ2VuZXJhdGUgYSBzZXF1ZW5jZSBvZiBlcnJvcnMgYWdhaW5zdCBhIFR5cGVCb3ggdHlwZS4gICovXG52YXIgVmFsdWVFcnJvcnM7XG4oZnVuY3Rpb24gKFZhbHVlRXJyb3JzKSB7XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIEd1YXJkc1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBmdW5jdGlvbiBJc0JpZ0ludCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnYmlnaW50JztcbiAgICB9XG4gICAgZnVuY3Rpb24gSXNJbnRlZ2VyKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBnbG9iYWxUaGlzLk51bWJlci5pc0ludGVnZXIodmFsdWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBJc1N0cmluZyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJztcbiAgICB9XG4gICAgZnVuY3Rpb24gSXNEZWZpbmVkKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gUG9saWNpZXNcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZnVuY3Rpb24gSXNFeGFjdE9wdGlvbmFsUHJvcGVydHkodmFsdWUsIGtleSkge1xuICAgICAgICByZXR1cm4gaW5kZXhfMS5UeXBlU3lzdGVtLkV4YWN0T3B0aW9uYWxQcm9wZXJ0eVR5cGVzID8ga2V5IGluIHZhbHVlIDogdmFsdWVba2V5XSAhPT0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBmdW5jdGlvbiBJc09iamVjdCh2YWx1ZSkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsO1xuICAgICAgICByZXR1cm4gaW5kZXhfMS5UeXBlU3lzdGVtLkFsbG93QXJyYXlPYmplY3RzID8gcmVzdWx0IDogcmVzdWx0ICYmICFnbG9iYWxUaGlzLkFycmF5LmlzQXJyYXkodmFsdWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBJc1JlY29yZE9iamVjdCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gSXNPYmplY3QodmFsdWUpICYmICEodmFsdWUgaW5zdGFuY2VvZiBnbG9iYWxUaGlzLkRhdGUpICYmICEodmFsdWUgaW5zdGFuY2VvZiBnbG9iYWxUaGlzLlVpbnQ4QXJyYXkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBJc051bWJlcih2YWx1ZSkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInO1xuICAgICAgICByZXR1cm4gaW5kZXhfMS5UeXBlU3lzdGVtLkFsbG93TmFOID8gcmVzdWx0IDogcmVzdWx0ICYmIGdsb2JhbFRoaXMuTnVtYmVyLmlzRmluaXRlKHZhbHVlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gSXNWb2lkKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHZhbHVlID09PSB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBpbmRleF8xLlR5cGVTeXN0ZW0uQWxsb3dWb2lkTnVsbCA/IHJlc3VsdCB8fCB2YWx1ZSA9PT0gbnVsbCA6IHJlc3VsdDtcbiAgICB9XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIFR5cGVzXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGZ1bmN0aW9uKiBBbnkoc2NoZW1hLCByZWZlcmVuY2VzLCBwYXRoLCB2YWx1ZSkgeyB9XG4gICAgZnVuY3Rpb24qIEFycmF5KHNjaGVtYSwgcmVmZXJlbmNlcywgcGF0aCwgdmFsdWUpIHtcbiAgICAgICAgaWYgKCFnbG9iYWxUaGlzLkFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgeyB0eXBlOiBWYWx1ZUVycm9yVHlwZS5BcnJheSwgc2NoZW1hLCBwYXRoLCB2YWx1ZSwgbWVzc2FnZTogYEV4cGVjdGVkIGFycmF5YCB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChJc0RlZmluZWQoc2NoZW1hLm1pbkl0ZW1zKSAmJiAhKHZhbHVlLmxlbmd0aCA+PSBzY2hlbWEubWluSXRlbXMpKSB7XG4gICAgICAgICAgICB5aWVsZCB7IHR5cGU6IFZhbHVlRXJyb3JUeXBlLkFycmF5TWluSXRlbXMsIHNjaGVtYSwgcGF0aCwgdmFsdWUsIG1lc3NhZ2U6IGBFeHBlY3RlZCBhcnJheSBsZW5ndGggdG8gYmUgZ3JlYXRlciBvciBlcXVhbCB0byAke3NjaGVtYS5taW5JdGVtc31gIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKElzRGVmaW5lZChzY2hlbWEubWF4SXRlbXMpICYmICEodmFsdWUubGVuZ3RoIDw9IHNjaGVtYS5tYXhJdGVtcykpIHtcbiAgICAgICAgICAgIHlpZWxkIHsgdHlwZTogVmFsdWVFcnJvclR5cGUuQXJyYXlNaW5JdGVtcywgc2NoZW1hLCBwYXRoLCB2YWx1ZSwgbWVzc2FnZTogYEV4cGVjdGVkIGFycmF5IGxlbmd0aCB0byBiZSBsZXNzIG9yIGVxdWFsIHRvICR7c2NoZW1hLm1heEl0ZW1zfWAgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgaWYgKHNjaGVtYS51bmlxdWVJdGVtcyA9PT0gdHJ1ZSAmJiAhKChmdW5jdGlvbiAoKSB7IGNvbnN0IHNldCA9IG5ldyBTZXQoKTsgZm9yIChjb25zdCBlbGVtZW50IG9mIHZhbHVlKSB7XG4gICAgICAgICAgICBjb25zdCBoYXNoZWQgPSBoYXNoXzEuVmFsdWVIYXNoLkNyZWF0ZShlbGVtZW50KTtcbiAgICAgICAgICAgIGlmIChzZXQuaGFzKGhhc2hlZCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZXQuYWRkKGhhc2hlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gcmV0dXJuIHRydWU7IH0pKCkpKSB7XG4gICAgICAgICAgICB5aWVsZCB7IHR5cGU6IFZhbHVlRXJyb3JUeXBlLkFycmF5VW5pcXVlSXRlbXMsIHNjaGVtYSwgcGF0aCwgdmFsdWUsIG1lc3NhZ2U6IGBFeHBlY3RlZCBhcnJheSBlbGVtZW50cyB0byBiZSB1bmlxdWVgIH07XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgeWllbGQqIFZpc2l0KHNjaGVtYS5pdGVtcywgcmVmZXJlbmNlcywgYCR7cGF0aH0vJHtpfWAsIHZhbHVlW2ldKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiogQmlnSW50KHNjaGVtYSwgcmVmZXJlbmNlcywgcGF0aCwgdmFsdWUpIHtcbiAgICAgICAgaWYgKCFJc0JpZ0ludCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCB7IHR5cGU6IFZhbHVlRXJyb3JUeXBlLkJpZ0ludCwgc2NoZW1hLCBwYXRoLCB2YWx1ZSwgbWVzc2FnZTogYEV4cGVjdGVkIGJpZ2ludGAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoSXNEZWZpbmVkKHNjaGVtYS5tdWx0aXBsZU9mKSAmJiAhKHZhbHVlICUgc2NoZW1hLm11bHRpcGxlT2YgPT09IGdsb2JhbFRoaXMuQmlnSW50KDApKSkge1xuICAgICAgICAgICAgeWllbGQgeyB0eXBlOiBWYWx1ZUVycm9yVHlwZS5CaWdJbnRNdWx0aXBsZU9mLCBzY2hlbWEsIHBhdGgsIHZhbHVlLCBtZXNzYWdlOiBgRXhwZWN0ZWQgYmlnaW50IHRvIGJlIGEgbXVsdGlwbGUgb2YgJHtzY2hlbWEubXVsdGlwbGVPZn1gIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKElzRGVmaW5lZChzY2hlbWEuZXhjbHVzaXZlTWluaW11bSkgJiYgISh2YWx1ZSA+IHNjaGVtYS5leGNsdXNpdmVNaW5pbXVtKSkge1xuICAgICAgICAgICAgeWllbGQgeyB0eXBlOiBWYWx1ZUVycm9yVHlwZS5CaWdJbnRFeGNsdXNpdmVNaW5pbXVtLCBzY2hlbWEsIHBhdGgsIHZhbHVlLCBtZXNzYWdlOiBgRXhwZWN0ZWQgYmlnaW50IHRvIGJlIGdyZWF0ZXIgdGhhbiAke3NjaGVtYS5leGNsdXNpdmVNaW5pbXVtfWAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoSXNEZWZpbmVkKHNjaGVtYS5leGNsdXNpdmVNYXhpbXVtKSAmJiAhKHZhbHVlIDwgc2NoZW1hLmV4Y2x1c2l2ZU1heGltdW0pKSB7XG4gICAgICAgICAgICB5aWVsZCB7IHR5cGU6IFZhbHVlRXJyb3JUeXBlLkJpZ0ludEV4Y2x1c2l2ZU1heGltdW0sIHNjaGVtYSwgcGF0aCwgdmFsdWUsIG1lc3NhZ2U6IGBFeHBlY3RlZCBiaWdpbnQgdG8gYmUgbGVzcyB0aGFuICR7c2NoZW1hLmV4Y2x1c2l2ZU1heGltdW19YCB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChJc0RlZmluZWQoc2NoZW1hLm1pbmltdW0pICYmICEodmFsdWUgPj0gc2NoZW1hLm1pbmltdW0pKSB7XG4gICAgICAgICAgICB5aWVsZCB7IHR5cGU6IFZhbHVlRXJyb3JUeXBlLkJpZ0ludE1pbmltdW0sIHNjaGVtYSwgcGF0aCwgdmFsdWUsIG1lc3NhZ2U6IGBFeHBlY3RlZCBiaWdpbnQgdG8gYmUgZ3JlYXRlciBvciBlcXVhbCB0byAke3NjaGVtYS5taW5pbXVtfWAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoSXNEZWZpbmVkKHNjaGVtYS5tYXhpbXVtKSAmJiAhKHZhbHVlIDw9IHNjaGVtYS5tYXhpbXVtKSkge1xuICAgICAgICAgICAgeWllbGQgeyB0eXBlOiBWYWx1ZUVycm9yVHlwZS5CaWdJbnRNYXhpbXVtLCBzY2hlbWEsIHBhdGgsIHZhbHVlLCBtZXNzYWdlOiBgRXhwZWN0ZWQgYmlnaW50IHRvIGJlIGxlc3Mgb3IgZXF1YWwgdG8gJHtzY2hlbWEubWF4aW11bX1gIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24qIEJvb2xlYW4oc2NoZW1hLCByZWZlcmVuY2VzLCBwYXRoLCB2YWx1ZSkge1xuICAgICAgICBpZiAoISh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykpIHtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCB7IHR5cGU6IFZhbHVlRXJyb3JUeXBlLkJvb2xlYW4sIHNjaGVtYSwgcGF0aCwgdmFsdWUsIG1lc3NhZ2U6IGBFeHBlY3RlZCBib29sZWFuYCB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uKiBDb25zdHJ1Y3RvcihzY2hlbWEsIHJlZmVyZW5jZXMsIHBhdGgsIHZhbHVlKSB7XG4gICAgICAgIHlpZWxkKiBWaXNpdChzY2hlbWEucmV0dXJucywgcmVmZXJlbmNlcywgcGF0aCwgdmFsdWUucHJvdG90eXBlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24qIERhdGUoc2NoZW1hLCByZWZlcmVuY2VzLCBwYXRoLCB2YWx1ZSkge1xuICAgICAgICBpZiAoISh2YWx1ZSBpbnN0YW5jZW9mIGdsb2JhbFRoaXMuRGF0ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCB7IHR5cGU6IFZhbHVlRXJyb3JUeXBlLkRhdGUsIHNjaGVtYSwgcGF0aCwgdmFsdWUsIG1lc3NhZ2U6IGBFeHBlY3RlZCBEYXRlIG9iamVjdGAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWdsb2JhbFRoaXMuaXNGaW5pdGUodmFsdWUuZ2V0VGltZSgpKSkge1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHsgdHlwZTogVmFsdWVFcnJvclR5cGUuRGF0ZSwgc2NoZW1hLCBwYXRoLCB2YWx1ZSwgbWVzc2FnZTogYEludmFsaWQgRGF0ZWAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoSXNEZWZpbmVkKHNjaGVtYS5leGNsdXNpdmVNaW5pbXVtVGltZXN0YW1wKSAmJiAhKHZhbHVlLmdldFRpbWUoKSA+IHNjaGVtYS5leGNsdXNpdmVNaW5pbXVtVGltZXN0YW1wKSkge1xuICAgICAgICAgICAgeWllbGQgeyB0eXBlOiBWYWx1ZUVycm9yVHlwZS5EYXRlRXhjbHVzaXZlTWluaW11bVRpbWVzdGFtcCwgc2NoZW1hLCBwYXRoLCB2YWx1ZSwgbWVzc2FnZTogYEV4cGVjdGVkIERhdGUgdGltZXN0YW1wIHRvIGJlIGdyZWF0ZXIgdGhhbiAke3NjaGVtYS5leGNsdXNpdmVNaW5pbXVtfWAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoSXNEZWZpbmVkKHNjaGVtYS5leGNsdXNpdmVNYXhpbXVtVGltZXN0YW1wKSAmJiAhKHZhbHVlLmdldFRpbWUoKSA8IHNjaGVtYS5leGNsdXNpdmVNYXhpbXVtVGltZXN0YW1wKSkge1xuICAgICAgICAgICAgeWllbGQgeyB0eXBlOiBWYWx1ZUVycm9yVHlwZS5EYXRlRXhjbHVzaXZlTWF4aW11bVRpbWVzdGFtcCwgc2NoZW1hLCBwYXRoLCB2YWx1ZSwgbWVzc2FnZTogYEV4cGVjdGVkIERhdGUgdGltZXN0YW1wIHRvIGJlIGxlc3MgdGhhbiAke3NjaGVtYS5leGNsdXNpdmVNYXhpbXVtfWAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoSXNEZWZpbmVkKHNjaGVtYS5taW5pbXVtVGltZXN0YW1wKSAmJiAhKHZhbHVlLmdldFRpbWUoKSA+PSBzY2hlbWEubWluaW11bVRpbWVzdGFtcCkpIHtcbiAgICAgICAgICAgIHlpZWxkIHsgdHlwZTogVmFsdWVFcnJvclR5cGUuRGF0ZU1pbmltdW1UaW1lc3RhbXAsIHNjaGVtYSwgcGF0aCwgdmFsdWUsIG1lc3NhZ2U6IGBFeHBlY3RlZCBEYXRlIHRpbWVzdGFtcCB0byBiZSBncmVhdGVyIG9yIGVxdWFsIHRvICR7c2NoZW1hLm1pbmltdW19YCB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChJc0RlZmluZWQoc2NoZW1hLm1heGltdW1UaW1lc3RhbXApICYmICEodmFsdWUuZ2V0VGltZSgpIDw9IHNjaGVtYS5tYXhpbXVtVGltZXN0YW1wKSkge1xuICAgICAgICAgICAgeWllbGQgeyB0eXBlOiBWYWx1ZUVycm9yVHlwZS5EYXRlTWF4aW11bVRpbWVzdGFtcCwgc2NoZW1hLCBwYXRoLCB2YWx1ZSwgbWVzc2FnZTogYEV4cGVjdGVkIERhdGUgdGltZXN0YW1wIHRvIGJlIGxlc3Mgb3IgZXF1YWwgdG8gJHtzY2hlbWEubWF4aW11bX1gIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24qIEZ1bmN0aW9uKHNjaGVtYSwgcmVmZXJlbmNlcywgcGF0aCwgdmFsdWUpIHtcbiAgICAgICAgaWYgKCEodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSkge1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHsgdHlwZTogVmFsdWVFcnJvclR5cGUuRnVuY3Rpb24sIHNjaGVtYSwgcGF0aCwgdmFsdWUsIG1lc3NhZ2U6IGBFeHBlY3RlZCBmdW5jdGlvbmAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiogSW50ZWdlcihzY2hlbWEsIHJlZmVyZW5jZXMsIHBhdGgsIHZhbHVlKSB7XG4gICAgICAgIGlmICghSXNJbnRlZ2VyKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHsgdHlwZTogVmFsdWVFcnJvclR5cGUuSW50ZWdlciwgc2NoZW1hLCBwYXRoLCB2YWx1ZSwgbWVzc2FnZTogYEV4cGVjdGVkIGludGVnZXJgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKElzRGVmaW5lZChzY2hlbWEubXVsdGlwbGVPZikgJiYgISh2YWx1ZSAlIHNjaGVtYS5tdWx0aXBsZU9mID09PSAwKSkge1xuICAgICAgICAgICAgeWllbGQgeyB0eXBlOiBWYWx1ZUVycm9yVHlwZS5JbnRlZ2VyTXVsdGlwbGVPZiwgc2NoZW1hLCBwYXRoLCB2YWx1ZSwgbWVzc2FnZTogYEV4cGVjdGVkIGludGVnZXIgdG8gYmUgYSBtdWx0aXBsZSBvZiAke3NjaGVtYS5tdWx0aXBsZU9mfWAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoSXNEZWZpbmVkKHNjaGVtYS5leGNsdXNpdmVNaW5pbXVtKSAmJiAhKHZhbHVlID4gc2NoZW1hLmV4Y2x1c2l2ZU1pbmltdW0pKSB7XG4gICAgICAgICAgICB5aWVsZCB7IHR5cGU6IFZhbHVlRXJyb3JUeXBlLkludGVnZXJFeGNsdXNpdmVNaW5pbXVtLCBzY2hlbWEsIHBhdGgsIHZhbHVlLCBtZXNzYWdlOiBgRXhwZWN0ZWQgaW50ZWdlciB0byBiZSBncmVhdGVyIHRoYW4gJHtzY2hlbWEuZXhjbHVzaXZlTWluaW11bX1gIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKElzRGVmaW5lZChzY2hlbWEuZXhjbHVzaXZlTWF4aW11bSkgJiYgISh2YWx1ZSA8IHNjaGVtYS5leGNsdXNpdmVNYXhpbXVtKSkge1xuICAgICAgICAgICAgeWllbGQgeyB0eXBlOiBWYWx1ZUVycm9yVHlwZS5JbnRlZ2VyRXhjbHVzaXZlTWF4aW11bSwgc2NoZW1hLCBwYXRoLCB2YWx1ZSwgbWVzc2FnZTogYEV4cGVjdGVkIGludGVnZXIgdG8gYmUgbGVzcyB0aGFuICR7c2NoZW1hLmV4Y2x1c2l2ZU1heGltdW19YCB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChJc0RlZmluZWQoc2NoZW1hLm1pbmltdW0pICYmICEodmFsdWUgPj0gc2NoZW1hLm1pbmltdW0pKSB7XG4gICAgICAgICAgICB5aWVsZCB7IHR5cGU6IFZhbHVlRXJyb3JUeXBlLkludGVnZXJNaW5pbXVtLCBzY2hlbWEsIHBhdGgsIHZhbHVlLCBtZXNzYWdlOiBgRXhwZWN0ZWQgaW50ZWdlciB0byBiZSBncmVhdGVyIG9yIGVxdWFsIHRvICR7c2NoZW1hLm1pbmltdW19YCB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChJc0RlZmluZWQoc2NoZW1hLm1heGltdW0pICYmICEodmFsdWUgPD0gc2NoZW1hLm1heGltdW0pKSB7XG4gICAgICAgICAgICB5aWVsZCB7IHR5cGU6IFZhbHVlRXJyb3JUeXBlLkludGVnZXJNYXhpbXVtLCBzY2hlbWEsIHBhdGgsIHZhbHVlLCBtZXNzYWdlOiBgRXhwZWN0ZWQgaW50ZWdlciB0byBiZSBsZXNzIG9yIGVxdWFsIHRvICR7c2NoZW1hLm1heGltdW19YCB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uKiBJbnRlcnNlY3Qoc2NoZW1hLCByZWZlcmVuY2VzLCBwYXRoLCB2YWx1ZSkge1xuICAgICAgICBmb3IgKGNvbnN0IGlubmVyIG9mIHNjaGVtYS5hbGxPZikge1xuICAgICAgICAgICAgY29uc3QgbmV4dCA9IFZpc2l0KGlubmVyLCByZWZlcmVuY2VzLCBwYXRoLCB2YWx1ZSkubmV4dCgpO1xuICAgICAgICAgICAgaWYgKCFuZXh0LmRvbmUpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCBuZXh0LnZhbHVlO1xuICAgICAgICAgICAgICAgIHlpZWxkIHsgdHlwZTogVmFsdWVFcnJvclR5cGUuSW50ZXJzZWN0LCBzY2hlbWEsIHBhdGgsIHZhbHVlLCBtZXNzYWdlOiBgRXhwZWN0ZWQgYWxsIHN1YiBzY2hlbWFzIHRvIGJlIHZhbGlkYCB9O1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc2NoZW1hLnVuZXZhbHVhdGVkUHJvcGVydGllcyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleUNoZWNrID0gbmV3IFJlZ0V4cChUeXBlcy5LZXlSZXNvbHZlci5SZXNvbHZlUGF0dGVybihzY2hlbWEpKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdmFsdWVLZXkgb2YgZ2xvYmFsVGhpcy5PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWtleUNoZWNrLnRlc3QodmFsdWVLZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIHsgdHlwZTogVmFsdWVFcnJvclR5cGUuSW50ZXJzZWN0VW5ldmFsdWF0ZWRQcm9wZXJ0aWVzLCBzY2hlbWEsIHBhdGg6IGAke3BhdGh9LyR7dmFsdWVLZXl9YCwgdmFsdWUsIG1lc3NhZ2U6IGBVbmV4cGVjdGVkIHByb3BlcnR5YCB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHNjaGVtYS51bmV2YWx1YXRlZFByb3BlcnRpZXMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBjb25zdCBrZXlDaGVjayA9IG5ldyBSZWdFeHAoVHlwZXMuS2V5UmVzb2x2ZXIuUmVzb2x2ZVBhdHRlcm4oc2NoZW1hKSk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHZhbHVlS2V5IG9mIGdsb2JhbFRoaXMuT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFrZXlDaGVjay50ZXN0KHZhbHVlS2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0ID0gVmlzaXQoc2NoZW1hLnVuZXZhbHVhdGVkUHJvcGVydGllcywgcmVmZXJlbmNlcywgYCR7cGF0aH0vJHt2YWx1ZUtleX1gLCB2YWx1ZVt2YWx1ZUtleV0pLm5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFuZXh0LmRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIG5leHQudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCB7IHR5cGU6IFZhbHVlRXJyb3JUeXBlLkludGVyc2VjdFVuZXZhbHVhdGVkUHJvcGVydGllcywgc2NoZW1hLCBwYXRoOiBgJHtwYXRofS8ke3ZhbHVlS2V5fWAsIHZhbHVlLCBtZXNzYWdlOiBgSW52YWxpZCBhZGRpdGlvbmFsIHByb3BlcnR5YCB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uKiBMaXRlcmFsKHNjaGVtYSwgcmVmZXJlbmNlcywgcGF0aCwgdmFsdWUpIHtcbiAgICAgICAgaWYgKCEodmFsdWUgPT09IHNjaGVtYS5jb25zdCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gdHlwZW9mIHNjaGVtYS5jb25zdCA9PT0gJ3N0cmluZycgPyBgJyR7c2NoZW1hLmNvbnN0fSdgIDogc2NoZW1hLmNvbnN0O1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHsgdHlwZTogVmFsdWVFcnJvclR5cGUuTGl0ZXJhbCwgc2NoZW1hLCBwYXRoLCB2YWx1ZSwgbWVzc2FnZTogYEV4cGVjdGVkICR7ZXJyb3J9YCB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uKiBOZXZlcihzY2hlbWEsIHJlZmVyZW5jZXMsIHBhdGgsIHZhbHVlKSB7XG4gICAgICAgIHlpZWxkIHsgdHlwZTogVmFsdWVFcnJvclR5cGUuTmV2ZXIsIHNjaGVtYSwgcGF0aCwgdmFsdWUsIG1lc3NhZ2U6IGBWYWx1ZSBjYW5ub3QgYmUgdmFsaWRhdGVkYCB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiogTm90KHNjaGVtYSwgcmVmZXJlbmNlcywgcGF0aCwgdmFsdWUpIHtcbiAgICAgICAgaWYgKFZpc2l0KHNjaGVtYS5hbGxPZlswXS5ub3QsIHJlZmVyZW5jZXMsIHBhdGgsIHZhbHVlKS5uZXh0KCkuZG9uZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgeWllbGQgeyB0eXBlOiBWYWx1ZUVycm9yVHlwZS5Ob3QsIHNjaGVtYSwgcGF0aCwgdmFsdWUsIG1lc3NhZ2U6IGBWYWx1ZSBzaG91bGQgbm90IHZhbGlkYXRlYCB9O1xuICAgICAgICB9XG4gICAgICAgIHlpZWxkKiBWaXNpdChzY2hlbWEuYWxsT2ZbMV0sIHJlZmVyZW5jZXMsIHBhdGgsIHZhbHVlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24qIE51bGwoc2NoZW1hLCByZWZlcmVuY2VzLCBwYXRoLCB2YWx1ZSkge1xuICAgICAgICBpZiAoISh2YWx1ZSA9PT0gbnVsbCkpIHtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCB7IHR5cGU6IFZhbHVlRXJyb3JUeXBlLk51bGwsIHNjaGVtYSwgcGF0aCwgdmFsdWUsIG1lc3NhZ2U6IGBFeHBlY3RlZCBudWxsYCB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uKiBOdW1iZXIoc2NoZW1hLCByZWZlcmVuY2VzLCBwYXRoLCB2YWx1ZSkge1xuICAgICAgICBpZiAoIUlzTnVtYmVyKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHsgdHlwZTogVmFsdWVFcnJvclR5cGUuTnVtYmVyLCBzY2hlbWEsIHBhdGgsIHZhbHVlLCBtZXNzYWdlOiBgRXhwZWN0ZWQgbnVtYmVyYCB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChJc0RlZmluZWQoc2NoZW1hLm11bHRpcGxlT2YpICYmICEodmFsdWUgJSBzY2hlbWEubXVsdGlwbGVPZiA9PT0gMCkpIHtcbiAgICAgICAgICAgIHlpZWxkIHsgdHlwZTogVmFsdWVFcnJvclR5cGUuTnVtYmVyTXVsdGlwbGVPZiwgc2NoZW1hLCBwYXRoLCB2YWx1ZSwgbWVzc2FnZTogYEV4cGVjdGVkIG51bWJlciB0byBiZSBhIG11bHRpcGxlIG9mICR7c2NoZW1hLm11bHRpcGxlT2Z9YCB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChJc0RlZmluZWQoc2NoZW1hLmV4Y2x1c2l2ZU1pbmltdW0pICYmICEodmFsdWUgPiBzY2hlbWEuZXhjbHVzaXZlTWluaW11bSkpIHtcbiAgICAgICAgICAgIHlpZWxkIHsgdHlwZTogVmFsdWVFcnJvclR5cGUuTnVtYmVyRXhjbHVzaXZlTWluaW11bSwgc2NoZW1hLCBwYXRoLCB2YWx1ZSwgbWVzc2FnZTogYEV4cGVjdGVkIG51bWJlciB0byBiZSBncmVhdGVyIHRoYW4gJHtzY2hlbWEuZXhjbHVzaXZlTWluaW11bX1gIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKElzRGVmaW5lZChzY2hlbWEuZXhjbHVzaXZlTWF4aW11bSkgJiYgISh2YWx1ZSA8IHNjaGVtYS5leGNsdXNpdmVNYXhpbXVtKSkge1xuICAgICAgICAgICAgeWllbGQgeyB0eXBlOiBWYWx1ZUVycm9yVHlwZS5OdW1iZXJFeGNsdXNpdmVNYXhpbXVtLCBzY2hlbWEsIHBhdGgsIHZhbHVlLCBtZXNzYWdlOiBgRXhwZWN0ZWQgbnVtYmVyIHRvIGJlIGxlc3MgdGhhbiAke3NjaGVtYS5leGNsdXNpdmVNYXhpbXVtfWAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoSXNEZWZpbmVkKHNjaGVtYS5taW5pbXVtKSAmJiAhKHZhbHVlID49IHNjaGVtYS5taW5pbXVtKSkge1xuICAgICAgICAgICAgeWllbGQgeyB0eXBlOiBWYWx1ZUVycm9yVHlwZS5OdW1iZXJNaW5pbXVtLCBzY2hlbWEsIHBhdGgsIHZhbHVlLCBtZXNzYWdlOiBgRXhwZWN0ZWQgbnVtYmVyIHRvIGJlIGdyZWF0ZXIgb3IgZXF1YWwgdG8gJHtzY2hlbWEubWluaW11bX1gIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKElzRGVmaW5lZChzY2hlbWEubWF4aW11bSkgJiYgISh2YWx1ZSA8PSBzY2hlbWEubWF4aW11bSkpIHtcbiAgICAgICAgICAgIHlpZWxkIHsgdHlwZTogVmFsdWVFcnJvclR5cGUuTnVtYmVyTWF4aW11bSwgc2NoZW1hLCBwYXRoLCB2YWx1ZSwgbWVzc2FnZTogYEV4cGVjdGVkIG51bWJlciB0byBiZSBsZXNzIG9yIGVxdWFsIHRvICR7c2NoZW1hLm1heGltdW19YCB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uKiBPYmplY3Qoc2NoZW1hLCByZWZlcmVuY2VzLCBwYXRoLCB2YWx1ZSkge1xuICAgICAgICBpZiAoIUlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHsgdHlwZTogVmFsdWVFcnJvclR5cGUuT2JqZWN0LCBzY2hlbWEsIHBhdGgsIHZhbHVlLCBtZXNzYWdlOiBgRXhwZWN0ZWQgb2JqZWN0YCB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChJc0RlZmluZWQoc2NoZW1hLm1pblByb3BlcnRpZXMpICYmICEoZ2xvYmFsVGhpcy5PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh2YWx1ZSkubGVuZ3RoID49IHNjaGVtYS5taW5Qcm9wZXJ0aWVzKSkge1xuICAgICAgICAgICAgeWllbGQgeyB0eXBlOiBWYWx1ZUVycm9yVHlwZS5PYmplY3RNaW5Qcm9wZXJ0aWVzLCBzY2hlbWEsIHBhdGgsIHZhbHVlLCBtZXNzYWdlOiBgRXhwZWN0ZWQgb2JqZWN0IHRvIGhhdmUgYXQgbGVhc3QgJHtzY2hlbWEubWluUHJvcGVydGllc30gcHJvcGVydGllc2AgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoSXNEZWZpbmVkKHNjaGVtYS5tYXhQcm9wZXJ0aWVzKSAmJiAhKGdsb2JhbFRoaXMuT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModmFsdWUpLmxlbmd0aCA8PSBzY2hlbWEubWF4UHJvcGVydGllcykpIHtcbiAgICAgICAgICAgIHlpZWxkIHsgdHlwZTogVmFsdWVFcnJvclR5cGUuT2JqZWN0TWF4UHJvcGVydGllcywgc2NoZW1hLCBwYXRoLCB2YWx1ZSwgbWVzc2FnZTogYEV4cGVjdGVkIG9iamVjdCB0byBoYXZlIGxlc3MgdGhhbiAke3NjaGVtYS5taW5Qcm9wZXJ0aWVzfSBwcm9wZXJ0aWVzYCB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlcXVpcmVkS2V5cyA9IGdsb2JhbFRoaXMuQXJyYXkuaXNBcnJheShzY2hlbWEucmVxdWlyZWQpID8gc2NoZW1hLnJlcXVpcmVkIDogW107XG4gICAgICAgIGNvbnN0IGtub3duS2V5cyA9IGdsb2JhbFRoaXMuT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoc2NoZW1hLnByb3BlcnRpZXMpO1xuICAgICAgICBjb25zdCB1bmtub3duS2V5cyA9IGdsb2JhbFRoaXMuT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModmFsdWUpO1xuICAgICAgICBmb3IgKGNvbnN0IGtub3duS2V5IG9mIGtub3duS2V5cykge1xuICAgICAgICAgICAgY29uc3QgcHJvcGVydHkgPSBzY2hlbWEucHJvcGVydGllc1trbm93bktleV07XG4gICAgICAgICAgICBpZiAoc2NoZW1hLnJlcXVpcmVkICYmIHNjaGVtYS5yZXF1aXJlZC5pbmNsdWRlcyhrbm93bktleSkpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCogVmlzaXQocHJvcGVydHksIHJlZmVyZW5jZXMsIGAke3BhdGh9LyR7a25vd25LZXl9YCwgdmFsdWVba25vd25LZXldKTtcbiAgICAgICAgICAgICAgICBpZiAoVHlwZXMuRXh0ZW5kc1VuZGVmaW5lZC5DaGVjayhzY2hlbWEpICYmICEoa25vd25LZXkgaW4gdmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIHsgdHlwZTogVmFsdWVFcnJvclR5cGUuT2JqZWN0UmVxdWlyZWRQcm9wZXJ0aWVzLCBzY2hlbWE6IHByb3BlcnR5LCBwYXRoOiBgJHtwYXRofS8ke2tub3duS2V5fWAsIHZhbHVlOiB1bmRlZmluZWQsIG1lc3NhZ2U6IGBFeHBlY3RlZCByZXF1aXJlZCBwcm9wZXJ0eWAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoSXNFeGFjdE9wdGlvbmFsUHJvcGVydHkodmFsdWUsIGtub3duS2V5KSkge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCogVmlzaXQocHJvcGVydHksIHJlZmVyZW5jZXMsIGAke3BhdGh9LyR7a25vd25LZXl9YCwgdmFsdWVba25vd25LZXldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCByZXF1aXJlZEtleSBvZiByZXF1aXJlZEtleXMpIHtcbiAgICAgICAgICAgIGlmICh1bmtub3duS2V5cy5pbmNsdWRlcyhyZXF1aXJlZEtleSkpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB5aWVsZCB7IHR5cGU6IFZhbHVlRXJyb3JUeXBlLk9iamVjdFJlcXVpcmVkUHJvcGVydGllcywgc2NoZW1hOiBzY2hlbWEucHJvcGVydGllc1tyZXF1aXJlZEtleV0sIHBhdGg6IGAke3BhdGh9LyR7cmVxdWlyZWRLZXl9YCwgdmFsdWU6IHVuZGVmaW5lZCwgbWVzc2FnZTogYEV4cGVjdGVkIHJlcXVpcmVkIHByb3BlcnR5YCB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChzY2hlbWEuYWRkaXRpb25hbFByb3BlcnRpZXMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHZhbHVlS2V5IG9mIHVua25vd25LZXlzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFrbm93bktleXMuaW5jbHVkZXModmFsdWVLZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIHsgdHlwZTogVmFsdWVFcnJvclR5cGUuT2JqZWN0QWRkaXRpb25hbFByb3BlcnRpZXMsIHNjaGVtYSwgcGF0aDogYCR7cGF0aH0vJHt2YWx1ZUtleX1gLCB2YWx1ZTogdmFsdWVbdmFsdWVLZXldLCBtZXNzYWdlOiBgVW5leHBlY3RlZCBwcm9wZXJ0eWAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBzY2hlbWEuYWRkaXRpb25hbFByb3BlcnRpZXMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHZhbHVlS2V5IG9mIHVua25vd25LZXlzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGtub3duS2V5cy5pbmNsdWRlcyh2YWx1ZUtleSkpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIHlpZWxkKiBWaXNpdChzY2hlbWEuYWRkaXRpb25hbFByb3BlcnRpZXMsIHJlZmVyZW5jZXMsIGAke3BhdGh9LyR7dmFsdWVLZXl9YCwgdmFsdWVbdmFsdWVLZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiogUHJvbWlzZShzY2hlbWEsIHJlZmVyZW5jZXMsIHBhdGgsIHZhbHVlKSB7XG4gICAgICAgIGlmICghKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHZhbHVlLnRoZW4gPT09ICdmdW5jdGlvbicpKSB7XG4gICAgICAgICAgICB5aWVsZCB7IHR5cGU6IFZhbHVlRXJyb3JUeXBlLlByb21pc2UsIHNjaGVtYSwgcGF0aCwgdmFsdWUsIG1lc3NhZ2U6IGBFeHBlY3RlZCBQcm9taXNlYCB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uKiBSZWNvcmQoc2NoZW1hLCByZWZlcmVuY2VzLCBwYXRoLCB2YWx1ZSkge1xuICAgICAgICBpZiAoIUlzUmVjb3JkT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHsgdHlwZTogVmFsdWVFcnJvclR5cGUuT2JqZWN0LCBzY2hlbWEsIHBhdGgsIHZhbHVlLCBtZXNzYWdlOiBgRXhwZWN0ZWQgcmVjb3JkIG9iamVjdGAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoSXNEZWZpbmVkKHNjaGVtYS5taW5Qcm9wZXJ0aWVzKSAmJiAhKGdsb2JhbFRoaXMuT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModmFsdWUpLmxlbmd0aCA+PSBzY2hlbWEubWluUHJvcGVydGllcykpIHtcbiAgICAgICAgICAgIHlpZWxkIHsgdHlwZTogVmFsdWVFcnJvclR5cGUuT2JqZWN0TWluUHJvcGVydGllcywgc2NoZW1hLCBwYXRoLCB2YWx1ZSwgbWVzc2FnZTogYEV4cGVjdGVkIG9iamVjdCB0byBoYXZlIGF0IGxlYXN0ICR7c2NoZW1hLm1pblByb3BlcnRpZXN9IHByb3BlcnRpZXNgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKElzRGVmaW5lZChzY2hlbWEubWF4UHJvcGVydGllcykgJiYgIShnbG9iYWxUaGlzLk9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKS5sZW5ndGggPD0gc2NoZW1hLm1heFByb3BlcnRpZXMpKSB7XG4gICAgICAgICAgICB5aWVsZCB7IHR5cGU6IFZhbHVlRXJyb3JUeXBlLk9iamVjdE1heFByb3BlcnRpZXMsIHNjaGVtYSwgcGF0aCwgdmFsdWUsIG1lc3NhZ2U6IGBFeHBlY3RlZCBvYmplY3QgdG8gaGF2ZSBsZXNzIHRoYW4gJHtzY2hlbWEubWluUHJvcGVydGllc30gcHJvcGVydGllc2AgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBbcGF0dGVybktleSwgcGF0dGVyblNjaGVtYV0gPSBnbG9iYWxUaGlzLk9iamVjdC5lbnRyaWVzKHNjaGVtYS5wYXR0ZXJuUHJvcGVydGllcylbMF07XG4gICAgICAgIGNvbnN0IHJlZ2V4ID0gbmV3IFJlZ0V4cChwYXR0ZXJuS2V5KTtcbiAgICAgICAgZm9yIChjb25zdCBbcHJvcGVydHlLZXksIHByb3BlcnR5VmFsdWVdIG9mIGdsb2JhbFRoaXMuT2JqZWN0LmVudHJpZXModmFsdWUpKSB7XG4gICAgICAgICAgICBpZiAocmVnZXgudGVzdChwcm9wZXJ0eUtleSkpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCogVmlzaXQocGF0dGVyblNjaGVtYSwgcmVmZXJlbmNlcywgYCR7cGF0aH0vJHtwcm9wZXJ0eUtleX1gLCBwcm9wZXJ0eVZhbHVlKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hLmFkZGl0aW9uYWxQcm9wZXJ0aWVzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIHlpZWxkKiBWaXNpdChzY2hlbWEuYWRkaXRpb25hbFByb3BlcnRpZXMsIHJlZmVyZW5jZXMsIGAke3BhdGh9LyR7cHJvcGVydHlLZXl9YCwgcHJvcGVydHlWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2NoZW1hLmFkZGl0aW9uYWxQcm9wZXJ0aWVzID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb3BlcnR5UGF0aCA9IGAke3BhdGh9LyR7cHJvcGVydHlLZXl9YDtcbiAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gYFVuZXhwZWN0ZWQgcHJvcGVydHkgJyR7cHJvcGVydHlQYXRofSdgO1xuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCB7IHR5cGU6IFZhbHVlRXJyb3JUeXBlLk9iamVjdEFkZGl0aW9uYWxQcm9wZXJ0aWVzLCBzY2hlbWEsIHBhdGg6IHByb3BlcnR5UGF0aCwgdmFsdWU6IHByb3BlcnR5VmFsdWUsIG1lc3NhZ2UgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiogUmVmKHNjaGVtYSwgcmVmZXJlbmNlcywgcGF0aCwgdmFsdWUpIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSByZWZlcmVuY2VzLmZpbmRJbmRleCgoZm9yZWlnbikgPT4gZm9yZWlnbi4kaWQgPT09IHNjaGVtYS4kcmVmKTtcbiAgICAgICAgaWYgKGluZGV4ID09PSAtMSlcbiAgICAgICAgICAgIHRocm93IG5ldyBWYWx1ZUVycm9yc0RlcmVmZXJlbmNlRXJyb3Ioc2NoZW1hKTtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gcmVmZXJlbmNlc1tpbmRleF07XG4gICAgICAgIHlpZWxkKiBWaXNpdCh0YXJnZXQsIHJlZmVyZW5jZXMsIHBhdGgsIHZhbHVlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24qIFN0cmluZyhzY2hlbWEsIHJlZmVyZW5jZXMsIHBhdGgsIHZhbHVlKSB7XG4gICAgICAgIGlmICghSXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgeyB0eXBlOiBWYWx1ZUVycm9yVHlwZS5TdHJpbmcsIHNjaGVtYSwgcGF0aCwgdmFsdWUsIG1lc3NhZ2U6ICdFeHBlY3RlZCBzdHJpbmcnIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKElzRGVmaW5lZChzY2hlbWEubWluTGVuZ3RoKSAmJiAhKHZhbHVlLmxlbmd0aCA+PSBzY2hlbWEubWluTGVuZ3RoKSkge1xuICAgICAgICAgICAgeWllbGQgeyB0eXBlOiBWYWx1ZUVycm9yVHlwZS5TdHJpbmdNaW5MZW5ndGgsIHNjaGVtYSwgcGF0aCwgdmFsdWUsIG1lc3NhZ2U6IGBFeHBlY3RlZCBzdHJpbmcgbGVuZ3RoIGdyZWF0ZXIgb3IgZXF1YWwgdG8gJHtzY2hlbWEubWluTGVuZ3RofWAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoSXNEZWZpbmVkKHNjaGVtYS5tYXhMZW5ndGgpICYmICEodmFsdWUubGVuZ3RoIDw9IHNjaGVtYS5tYXhMZW5ndGgpKSB7XG4gICAgICAgICAgICB5aWVsZCB7IHR5cGU6IFZhbHVlRXJyb3JUeXBlLlN0cmluZ01heExlbmd0aCwgc2NoZW1hLCBwYXRoLCB2YWx1ZSwgbWVzc2FnZTogYEV4cGVjdGVkIHN0cmluZyBsZW5ndGggbGVzcyBvciBlcXVhbCB0byAke3NjaGVtYS5tYXhMZW5ndGh9YCB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChzY2hlbWEucGF0dGVybiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCByZWdleCA9IG5ldyBSZWdFeHAoc2NoZW1hLnBhdHRlcm4pO1xuICAgICAgICAgICAgaWYgKCFyZWdleC50ZXN0KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHlpZWxkIHsgdHlwZTogVmFsdWVFcnJvclR5cGUuU3RyaW5nUGF0dGVybiwgc2NoZW1hLCBwYXRoLCB2YWx1ZSwgbWVzc2FnZTogYEV4cGVjdGVkIHN0cmluZyB0byBtYXRjaCBwYXR0ZXJuICR7c2NoZW1hLnBhdHRlcm59YCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzY2hlbWEuZm9ybWF0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICghVHlwZXMuRm9ybWF0UmVnaXN0cnkuSGFzKHNjaGVtYS5mb3JtYXQpKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgeyB0eXBlOiBWYWx1ZUVycm9yVHlwZS5TdHJpbmdGb3JtYXRVbmtub3duLCBzY2hlbWEsIHBhdGgsIHZhbHVlLCBtZXNzYWdlOiBgVW5rbm93biBzdHJpbmcgZm9ybWF0ICcke3NjaGVtYS5mb3JtYXR9J2AgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZvcm1hdCA9IFR5cGVzLkZvcm1hdFJlZ2lzdHJ5LkdldChzY2hlbWEuZm9ybWF0KTtcbiAgICAgICAgICAgICAgICBpZiAoIWZvcm1hdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgeyB0eXBlOiBWYWx1ZUVycm9yVHlwZS5TdHJpbmdGb3JtYXQsIHNjaGVtYSwgcGF0aCwgdmFsdWUsIG1lc3NhZ2U6IGBFeHBlY3RlZCBzdHJpbmcgdG8gbWF0Y2ggZm9ybWF0ICcke3NjaGVtYS5mb3JtYXR9J2AgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24qIFN5bWJvbChzY2hlbWEsIHJlZmVyZW5jZXMsIHBhdGgsIHZhbHVlKSB7XG4gICAgICAgIGlmICghKHR5cGVvZiB2YWx1ZSA9PT0gJ3N5bWJvbCcpKSB7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgeyB0eXBlOiBWYWx1ZUVycm9yVHlwZS5TeW1ib2wsIHNjaGVtYSwgcGF0aCwgdmFsdWUsIG1lc3NhZ2U6ICdFeHBlY3RlZCBzeW1ib2wnIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24qIFRlbXBsYXRlTGl0ZXJhbChzY2hlbWEsIHJlZmVyZW5jZXMsIHBhdGgsIHZhbHVlKSB7XG4gICAgICAgIGlmICghSXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgeyB0eXBlOiBWYWx1ZUVycm9yVHlwZS5TdHJpbmcsIHNjaGVtYSwgcGF0aCwgdmFsdWUsIG1lc3NhZ2U6ICdFeHBlY3RlZCBzdHJpbmcnIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVnZXggPSBuZXcgUmVnRXhwKHNjaGVtYS5wYXR0ZXJuKTtcbiAgICAgICAgaWYgKCFyZWdleC50ZXN0KHZhbHVlKSkge1xuICAgICAgICAgICAgeWllbGQgeyB0eXBlOiBWYWx1ZUVycm9yVHlwZS5TdHJpbmdQYXR0ZXJuLCBzY2hlbWEsIHBhdGgsIHZhbHVlLCBtZXNzYWdlOiBgRXhwZWN0ZWQgc3RyaW5nIHRvIG1hdGNoIHBhdHRlcm4gJHtzY2hlbWEucGF0dGVybn1gIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24qIFRoaXMoc2NoZW1hLCByZWZlcmVuY2VzLCBwYXRoLCB2YWx1ZSkge1xuICAgICAgICBjb25zdCBpbmRleCA9IHJlZmVyZW5jZXMuZmluZEluZGV4KChmb3JlaWduKSA9PiBmb3JlaWduLiRpZCA9PT0gc2NoZW1hLiRyZWYpO1xuICAgICAgICBpZiAoaW5kZXggPT09IC0xKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFZhbHVlRXJyb3JzRGVyZWZlcmVuY2VFcnJvcihzY2hlbWEpO1xuICAgICAgICBjb25zdCB0YXJnZXQgPSByZWZlcmVuY2VzW2luZGV4XTtcbiAgICAgICAgeWllbGQqIFZpc2l0KHRhcmdldCwgcmVmZXJlbmNlcywgcGF0aCwgdmFsdWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiogVHVwbGUoc2NoZW1hLCByZWZlcmVuY2VzLCBwYXRoLCB2YWx1ZSkge1xuICAgICAgICBpZiAoIWdsb2JhbFRoaXMuQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCB7IHR5cGU6IFZhbHVlRXJyb3JUeXBlLkFycmF5LCBzY2hlbWEsIHBhdGgsIHZhbHVlLCBtZXNzYWdlOiAnRXhwZWN0ZWQgQXJyYXknIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNjaGVtYS5pdGVtcyA9PT0gdW5kZWZpbmVkICYmICEodmFsdWUubGVuZ3RoID09PSAwKSkge1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHsgdHlwZTogVmFsdWVFcnJvclR5cGUuVHVwbGVaZXJvTGVuZ3RoLCBzY2hlbWEsIHBhdGgsIHZhbHVlLCBtZXNzYWdlOiAnRXhwZWN0ZWQgdHVwbGUgdG8gaGF2ZSAwIGVsZW1lbnRzJyB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICghKHZhbHVlLmxlbmd0aCA9PT0gc2NoZW1hLm1heEl0ZW1zKSkge1xuICAgICAgICAgICAgeWllbGQgeyB0eXBlOiBWYWx1ZUVycm9yVHlwZS5UdXBsZUxlbmd0aCwgc2NoZW1hLCBwYXRoLCB2YWx1ZSwgbWVzc2FnZTogYEV4cGVjdGVkIHR1cGxlIHRvIGhhdmUgJHtzY2hlbWEubWF4SXRlbXN9IGVsZW1lbnRzYCB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICghc2NoZW1hLml0ZW1zKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzY2hlbWEuaXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHlpZWxkKiBWaXNpdChzY2hlbWEuaXRlbXNbaV0sIHJlZmVyZW5jZXMsIGAke3BhdGh9LyR7aX1gLCB2YWx1ZVtpXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24qIFVuZGVmaW5lZChzY2hlbWEsIHJlZmVyZW5jZXMsIHBhdGgsIHZhbHVlKSB7XG4gICAgICAgIGlmICghKHZhbHVlID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICB5aWVsZCB7IHR5cGU6IFZhbHVlRXJyb3JUeXBlLlVuZGVmaW5lZCwgc2NoZW1hLCBwYXRoLCB2YWx1ZSwgbWVzc2FnZTogYEV4cGVjdGVkIHVuZGVmaW5lZGAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiogVW5pb24oc2NoZW1hLCByZWZlcmVuY2VzLCBwYXRoLCB2YWx1ZSkge1xuICAgICAgICBjb25zdCBlcnJvcnMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBpbm5lciBvZiBzY2hlbWEuYW55T2YpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhcmlhbnRFcnJvcnMgPSBbLi4uVmlzaXQoaW5uZXIsIHJlZmVyZW5jZXMsIHBhdGgsIHZhbHVlKV07XG4gICAgICAgICAgICBpZiAodmFyaWFudEVycm9ycy5sZW5ndGggPT09IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgZXJyb3JzLnB1c2goLi4udmFyaWFudEVycm9ycyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVycm9ycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB5aWVsZCB7IHR5cGU6IFZhbHVlRXJyb3JUeXBlLlVuaW9uLCBzY2hlbWEsIHBhdGgsIHZhbHVlLCBtZXNzYWdlOiAnRXhwZWN0ZWQgdmFsdWUgb2YgdW5pb24nIH07XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBlcnJvciBvZiBlcnJvcnMpIHtcbiAgICAgICAgICAgIHlpZWxkIGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uKiBVaW50OEFycmF5KHNjaGVtYSwgcmVmZXJlbmNlcywgcGF0aCwgdmFsdWUpIHtcbiAgICAgICAgaWYgKCEodmFsdWUgaW5zdGFuY2VvZiBnbG9iYWxUaGlzLlVpbnQ4QXJyYXkpKSB7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgeyB0eXBlOiBWYWx1ZUVycm9yVHlwZS5VaW50OEFycmF5LCBzY2hlbWEsIHBhdGgsIHZhbHVlLCBtZXNzYWdlOiBgRXhwZWN0ZWQgVWludDhBcnJheWAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoSXNEZWZpbmVkKHNjaGVtYS5tYXhCeXRlTGVuZ3RoKSAmJiAhKHZhbHVlLmxlbmd0aCA8PSBzY2hlbWEubWF4Qnl0ZUxlbmd0aCkpIHtcbiAgICAgICAgICAgIHlpZWxkIHsgdHlwZTogVmFsdWVFcnJvclR5cGUuVWludDhBcnJheU1heEJ5dGVMZW5ndGgsIHNjaGVtYSwgcGF0aCwgdmFsdWUsIG1lc3NhZ2U6IGBFeHBlY3RlZCBVaW50OEFycmF5IHRvIGhhdmUgYSBieXRlIGxlbmd0aCBsZXNzIG9yIGVxdWFsIHRvICR7c2NoZW1hLm1heEJ5dGVMZW5ndGh9YCB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChJc0RlZmluZWQoc2NoZW1hLm1pbkJ5dGVMZW5ndGgpICYmICEodmFsdWUubGVuZ3RoID49IHNjaGVtYS5taW5CeXRlTGVuZ3RoKSkge1xuICAgICAgICAgICAgeWllbGQgeyB0eXBlOiBWYWx1ZUVycm9yVHlwZS5VaW50OEFycmF5TWluQnl0ZUxlbmd0aCwgc2NoZW1hLCBwYXRoLCB2YWx1ZSwgbWVzc2FnZTogYEV4cGVjdGVkIFVpbnQ4QXJyYXkgdG8gaGF2ZSBhIGJ5dGUgbGVuZ3RoIGdyZWF0ZXIgb3IgZXF1YWwgdG8gJHtzY2hlbWEubWF4Qnl0ZUxlbmd0aH1gIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24qIFVua25vd24oc2NoZW1hLCByZWZlcmVuY2VzLCBwYXRoLCB2YWx1ZSkgeyB9XG4gICAgZnVuY3Rpb24qIFZvaWQoc2NoZW1hLCByZWZlcmVuY2VzLCBwYXRoLCB2YWx1ZSkge1xuICAgICAgICBpZiAoIUlzVm9pZCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCB7IHR5cGU6IFZhbHVlRXJyb3JUeXBlLlZvaWQsIHNjaGVtYSwgcGF0aCwgdmFsdWUsIG1lc3NhZ2U6IGBFeHBlY3RlZCB2b2lkYCB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uKiBVc2VyRGVmaW5lZChzY2hlbWEsIHJlZmVyZW5jZXMsIHBhdGgsIHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNoZWNrID0gVHlwZXMuVHlwZVJlZ2lzdHJ5LkdldChzY2hlbWFbVHlwZXMuS2luZF0pO1xuICAgICAgICBpZiAoIWNoZWNrKHNjaGVtYSwgdmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgeyB0eXBlOiBWYWx1ZUVycm9yVHlwZS5DdXN0b20sIHNjaGVtYSwgcGF0aCwgdmFsdWUsIG1lc3NhZ2U6IGBFeHBlY3RlZCBraW5kICR7c2NoZW1hW1R5cGVzLktpbmRdfWAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiogVmlzaXQoc2NoZW1hLCByZWZlcmVuY2VzLCBwYXRoLCB2YWx1ZSkge1xuICAgICAgICBjb25zdCByZWZlcmVuY2VzXyA9IElzRGVmaW5lZChzY2hlbWEuJGlkKSA/IFsuLi5yZWZlcmVuY2VzLCBzY2hlbWFdIDogcmVmZXJlbmNlcztcbiAgICAgICAgY29uc3Qgc2NoZW1hXyA9IHNjaGVtYTtcbiAgICAgICAgc3dpdGNoIChzY2hlbWFfW1R5cGVzLktpbmRdKSB7XG4gICAgICAgICAgICBjYXNlICdBbnknOlxuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCogQW55KHNjaGVtYV8sIHJlZmVyZW5jZXNfLCBwYXRoLCB2YWx1ZSk7XG4gICAgICAgICAgICBjYXNlICdBcnJheSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiBBcnJheShzY2hlbWFfLCByZWZlcmVuY2VzXywgcGF0aCwgdmFsdWUpO1xuICAgICAgICAgICAgY2FzZSAnQmlnSW50JzpcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQqIEJpZ0ludChzY2hlbWFfLCByZWZlcmVuY2VzXywgcGF0aCwgdmFsdWUpO1xuICAgICAgICAgICAgY2FzZSAnQm9vbGVhbic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiBCb29sZWFuKHNjaGVtYV8sIHJlZmVyZW5jZXNfLCBwYXRoLCB2YWx1ZSk7XG4gICAgICAgICAgICBjYXNlICdDb25zdHJ1Y3Rvcic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiBDb25zdHJ1Y3RvcihzY2hlbWFfLCByZWZlcmVuY2VzXywgcGF0aCwgdmFsdWUpO1xuICAgICAgICAgICAgY2FzZSAnRGF0ZSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiBEYXRlKHNjaGVtYV8sIHJlZmVyZW5jZXNfLCBwYXRoLCB2YWx1ZSk7XG4gICAgICAgICAgICBjYXNlICdGdW5jdGlvbic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiBGdW5jdGlvbihzY2hlbWFfLCByZWZlcmVuY2VzXywgcGF0aCwgdmFsdWUpO1xuICAgICAgICAgICAgY2FzZSAnSW50ZWdlcic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiBJbnRlZ2VyKHNjaGVtYV8sIHJlZmVyZW5jZXNfLCBwYXRoLCB2YWx1ZSk7XG4gICAgICAgICAgICBjYXNlICdJbnRlcnNlY3QnOlxuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCogSW50ZXJzZWN0KHNjaGVtYV8sIHJlZmVyZW5jZXNfLCBwYXRoLCB2YWx1ZSk7XG4gICAgICAgICAgICBjYXNlICdMaXRlcmFsJzpcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQqIExpdGVyYWwoc2NoZW1hXywgcmVmZXJlbmNlc18sIHBhdGgsIHZhbHVlKTtcbiAgICAgICAgICAgIGNhc2UgJ05ldmVyJzpcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQqIE5ldmVyKHNjaGVtYV8sIHJlZmVyZW5jZXNfLCBwYXRoLCB2YWx1ZSk7XG4gICAgICAgICAgICBjYXNlICdOb3QnOlxuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCogTm90KHNjaGVtYV8sIHJlZmVyZW5jZXNfLCBwYXRoLCB2YWx1ZSk7XG4gICAgICAgICAgICBjYXNlICdOdWxsJzpcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQqIE51bGwoc2NoZW1hXywgcmVmZXJlbmNlc18sIHBhdGgsIHZhbHVlKTtcbiAgICAgICAgICAgIGNhc2UgJ051bWJlcic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiBOdW1iZXIoc2NoZW1hXywgcmVmZXJlbmNlc18sIHBhdGgsIHZhbHVlKTtcbiAgICAgICAgICAgIGNhc2UgJ09iamVjdCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiBPYmplY3Qoc2NoZW1hXywgcmVmZXJlbmNlc18sIHBhdGgsIHZhbHVlKTtcbiAgICAgICAgICAgIGNhc2UgJ1Byb21pc2UnOlxuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCogUHJvbWlzZShzY2hlbWFfLCByZWZlcmVuY2VzXywgcGF0aCwgdmFsdWUpO1xuICAgICAgICAgICAgY2FzZSAnUmVjb3JkJzpcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQqIFJlY29yZChzY2hlbWFfLCByZWZlcmVuY2VzXywgcGF0aCwgdmFsdWUpO1xuICAgICAgICAgICAgY2FzZSAnUmVmJzpcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQqIFJlZihzY2hlbWFfLCByZWZlcmVuY2VzXywgcGF0aCwgdmFsdWUpO1xuICAgICAgICAgICAgY2FzZSAnU3RyaW5nJzpcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQqIFN0cmluZyhzY2hlbWFfLCByZWZlcmVuY2VzXywgcGF0aCwgdmFsdWUpO1xuICAgICAgICAgICAgY2FzZSAnU3ltYm9sJzpcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQqIFN5bWJvbChzY2hlbWFfLCByZWZlcmVuY2VzXywgcGF0aCwgdmFsdWUpO1xuICAgICAgICAgICAgY2FzZSAnVGVtcGxhdGVMaXRlcmFsJzpcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQqIFRlbXBsYXRlTGl0ZXJhbChzY2hlbWFfLCByZWZlcmVuY2VzXywgcGF0aCwgdmFsdWUpO1xuICAgICAgICAgICAgY2FzZSAnVGhpcyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiBUaGlzKHNjaGVtYV8sIHJlZmVyZW5jZXNfLCBwYXRoLCB2YWx1ZSk7XG4gICAgICAgICAgICBjYXNlICdUdXBsZSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiBUdXBsZShzY2hlbWFfLCByZWZlcmVuY2VzXywgcGF0aCwgdmFsdWUpO1xuICAgICAgICAgICAgY2FzZSAnVW5kZWZpbmVkJzpcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQqIFVuZGVmaW5lZChzY2hlbWFfLCByZWZlcmVuY2VzXywgcGF0aCwgdmFsdWUpO1xuICAgICAgICAgICAgY2FzZSAnVW5pb24nOlxuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCogVW5pb24oc2NoZW1hXywgcmVmZXJlbmNlc18sIHBhdGgsIHZhbHVlKTtcbiAgICAgICAgICAgIGNhc2UgJ1VpbnQ4QXJyYXknOlxuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCogVWludDhBcnJheShzY2hlbWFfLCByZWZlcmVuY2VzXywgcGF0aCwgdmFsdWUpO1xuICAgICAgICAgICAgY2FzZSAnVW5rbm93bic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiBVbmtub3duKHNjaGVtYV8sIHJlZmVyZW5jZXNfLCBwYXRoLCB2YWx1ZSk7XG4gICAgICAgICAgICBjYXNlICdWb2lkJzpcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQqIFZvaWQoc2NoZW1hXywgcmVmZXJlbmNlc18sIHBhdGgsIHZhbHVlKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgaWYgKCFUeXBlcy5UeXBlUmVnaXN0cnkuSGFzKHNjaGVtYV9bVHlwZXMuS2luZF0pKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcnNVbmtub3duVHlwZUVycm9yKHNjaGVtYSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiBVc2VyRGVmaW5lZChzY2hlbWFfLCByZWZlcmVuY2VzXywgcGF0aCwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIEVycm9ycyhzY2hlbWEsIHJlZmVyZW5jZXMsIHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGl0ZXJhdG9yID0gVmlzaXQoc2NoZW1hLCByZWZlcmVuY2VzLCAnJywgdmFsdWUpO1xuICAgICAgICByZXR1cm4gbmV3IFZhbHVlRXJyb3JJdGVyYXRvcihpdGVyYXRvcik7XG4gICAgfVxuICAgIFZhbHVlRXJyb3JzLkVycm9ycyA9IEVycm9ycztcbn0pKFZhbHVlRXJyb3JzIHx8IChleHBvcnRzLlZhbHVlRXJyb3JzID0gVmFsdWVFcnJvcnMgPSB7fSkpO1xuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiVmFsdWVFcnJvcnMiLCJWYWx1ZUVycm9yc0RlcmVmZXJlbmNlRXJyb3IiLCJWYWx1ZUVycm9yc1Vua25vd25UeXBlRXJyb3IiLCJWYWx1ZUVycm9ySXRlcmF0b3IiLCJWYWx1ZUVycm9yVHlwZSIsIlR5cGVzIiwicmVxdWlyZSIsImluZGV4XzEiLCJoYXNoXzEiLCJjb25zdHJ1Y3RvciIsIml0ZXJhdG9yIiwiU3ltYm9sIiwiRmlyc3QiLCJuZXh0IiwiZG9uZSIsInVuZGVmaW5lZCIsIkVycm9yIiwic2NoZW1hIiwiJHJlZiIsIklzQmlnSW50IiwiSXNJbnRlZ2VyIiwiZ2xvYmFsVGhpcyIsIk51bWJlciIsImlzSW50ZWdlciIsIklzU3RyaW5nIiwiSXNEZWZpbmVkIiwiSXNFeGFjdE9wdGlvbmFsUHJvcGVydHkiLCJrZXkiLCJUeXBlU3lzdGVtIiwiRXhhY3RPcHRpb25hbFByb3BlcnR5VHlwZXMiLCJJc09iamVjdCIsInJlc3VsdCIsIkFsbG93QXJyYXlPYmplY3RzIiwiQXJyYXkiLCJpc0FycmF5IiwiSXNSZWNvcmRPYmplY3QiLCJEYXRlIiwiVWludDhBcnJheSIsIklzTnVtYmVyIiwiQWxsb3dOYU4iLCJpc0Zpbml0ZSIsIklzVm9pZCIsIkFsbG93Vm9pZE51bGwiLCJBbnkiLCJyZWZlcmVuY2VzIiwicGF0aCIsInR5cGUiLCJtZXNzYWdlIiwibWluSXRlbXMiLCJsZW5ndGgiLCJBcnJheU1pbkl0ZW1zIiwibWF4SXRlbXMiLCJ1bmlxdWVJdGVtcyIsInNldCIsIlNldCIsImVsZW1lbnQiLCJoYXNoZWQiLCJWYWx1ZUhhc2giLCJDcmVhdGUiLCJoYXMiLCJhZGQiLCJBcnJheVVuaXF1ZUl0ZW1zIiwiaSIsIlZpc2l0IiwiaXRlbXMiLCJCaWdJbnQiLCJtdWx0aXBsZU9mIiwiQmlnSW50TXVsdGlwbGVPZiIsImV4Y2x1c2l2ZU1pbmltdW0iLCJCaWdJbnRFeGNsdXNpdmVNaW5pbXVtIiwiZXhjbHVzaXZlTWF4aW11bSIsIkJpZ0ludEV4Y2x1c2l2ZU1heGltdW0iLCJtaW5pbXVtIiwiQmlnSW50TWluaW11bSIsIm1heGltdW0iLCJCaWdJbnRNYXhpbXVtIiwiQm9vbGVhbiIsIkNvbnN0cnVjdG9yIiwicmV0dXJucyIsInByb3RvdHlwZSIsImdldFRpbWUiLCJleGNsdXNpdmVNaW5pbXVtVGltZXN0YW1wIiwiRGF0ZUV4Y2x1c2l2ZU1pbmltdW1UaW1lc3RhbXAiLCJleGNsdXNpdmVNYXhpbXVtVGltZXN0YW1wIiwiRGF0ZUV4Y2x1c2l2ZU1heGltdW1UaW1lc3RhbXAiLCJtaW5pbXVtVGltZXN0YW1wIiwiRGF0ZU1pbmltdW1UaW1lc3RhbXAiLCJtYXhpbXVtVGltZXN0YW1wIiwiRGF0ZU1heGltdW1UaW1lc3RhbXAiLCJGdW5jdGlvbiIsIkludGVnZXIiLCJJbnRlZ2VyTXVsdGlwbGVPZiIsIkludGVnZXJFeGNsdXNpdmVNaW5pbXVtIiwiSW50ZWdlckV4Y2x1c2l2ZU1heGltdW0iLCJJbnRlZ2VyTWluaW11bSIsIkludGVnZXJNYXhpbXVtIiwiSW50ZXJzZWN0IiwiaW5uZXIiLCJhbGxPZiIsInVuZXZhbHVhdGVkUHJvcGVydGllcyIsImtleUNoZWNrIiwiUmVnRXhwIiwiS2V5UmVzb2x2ZXIiLCJSZXNvbHZlUGF0dGVybiIsInZhbHVlS2V5IiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsInRlc3QiLCJJbnRlcnNlY3RVbmV2YWx1YXRlZFByb3BlcnRpZXMiLCJMaXRlcmFsIiwiY29uc3QiLCJlcnJvciIsIk5ldmVyIiwiTm90Iiwibm90IiwiTnVsbCIsIk51bWJlck11bHRpcGxlT2YiLCJOdW1iZXJFeGNsdXNpdmVNaW5pbXVtIiwiTnVtYmVyRXhjbHVzaXZlTWF4aW11bSIsIk51bWJlck1pbmltdW0iLCJOdW1iZXJNYXhpbXVtIiwibWluUHJvcGVydGllcyIsIk9iamVjdE1pblByb3BlcnRpZXMiLCJtYXhQcm9wZXJ0aWVzIiwiT2JqZWN0TWF4UHJvcGVydGllcyIsInJlcXVpcmVkS2V5cyIsInJlcXVpcmVkIiwia25vd25LZXlzIiwicHJvcGVydGllcyIsInVua25vd25LZXlzIiwia25vd25LZXkiLCJwcm9wZXJ0eSIsImluY2x1ZGVzIiwiRXh0ZW5kc1VuZGVmaW5lZCIsIkNoZWNrIiwiT2JqZWN0UmVxdWlyZWRQcm9wZXJ0aWVzIiwicmVxdWlyZWRLZXkiLCJhZGRpdGlvbmFsUHJvcGVydGllcyIsIk9iamVjdEFkZGl0aW9uYWxQcm9wZXJ0aWVzIiwiUHJvbWlzZSIsInRoZW4iLCJSZWNvcmQiLCJwYXR0ZXJuS2V5IiwicGF0dGVyblNjaGVtYSIsImVudHJpZXMiLCJwYXR0ZXJuUHJvcGVydGllcyIsInJlZ2V4IiwicHJvcGVydHlLZXkiLCJwcm9wZXJ0eVZhbHVlIiwicHJvcGVydHlQYXRoIiwiUmVmIiwiaW5kZXgiLCJmaW5kSW5kZXgiLCJmb3JlaWduIiwiJGlkIiwidGFyZ2V0IiwiU3RyaW5nIiwibWluTGVuZ3RoIiwiU3RyaW5nTWluTGVuZ3RoIiwibWF4TGVuZ3RoIiwiU3RyaW5nTWF4TGVuZ3RoIiwicGF0dGVybiIsIlN0cmluZ1BhdHRlcm4iLCJmb3JtYXQiLCJGb3JtYXRSZWdpc3RyeSIsIkhhcyIsIlN0cmluZ0Zvcm1hdFVua25vd24iLCJHZXQiLCJTdHJpbmdGb3JtYXQiLCJUZW1wbGF0ZUxpdGVyYWwiLCJUaGlzIiwiVHVwbGUiLCJUdXBsZVplcm9MZW5ndGgiLCJUdXBsZUxlbmd0aCIsIlVuZGVmaW5lZCIsIlVuaW9uIiwiZXJyb3JzIiwiYW55T2YiLCJ2YXJpYW50RXJyb3JzIiwicHVzaCIsIm1heEJ5dGVMZW5ndGgiLCJVaW50OEFycmF5TWF4Qnl0ZUxlbmd0aCIsIm1pbkJ5dGVMZW5ndGgiLCJVaW50OEFycmF5TWluQnl0ZUxlbmd0aCIsIlVua25vd24iLCJWb2lkIiwiVXNlckRlZmluZWQiLCJjaGVjayIsIlR5cGVSZWdpc3RyeSIsIktpbmQiLCJDdXN0b20iLCJyZWZlcmVuY2VzXyIsInNjaGVtYV8iLCJFcnJvcnMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@sinclair+typebox@0.28.20/node_modules/@sinclair/typebox/errors/errors.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/@sinclair+typebox@0.28.20/node_modules/@sinclair/typebox/errors/index.js":
/*!*********************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@sinclair+typebox@0.28.20/node_modules/@sinclair/typebox/errors/index.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*--------------------------------------------------------------------------\n\n@sinclair/typebox/errors\n\nThe MIT License (MIT)\n\nCopyright (c) 2017-2023 Haydn Paterson (sinclair) <haydn.developer@gmail.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n---------------------------------------------------------------------------*/ var __createBinding = (void 0) && (void 0).__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n        desc = {\n            enumerable: true,\n            get: function() {\n                return m[k];\n            }\n        };\n    }\n    Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar __exportStar = (void 0) && (void 0).__exportStar || function(m, exports1) {\n    for(var p in m)if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n__exportStar(__webpack_require__(/*! ./errors */ \"(ssr)/../../node_modules/.pnpm/@sinclair+typebox@0.28.20/node_modules/@sinclair/typebox/errors/errors.js\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BzaW5jbGFpcit0eXBlYm94QDAuMjguMjAvbm9kZV9tb2R1bGVzL0BzaW5jbGFpci90eXBlYm94L2Vycm9ycy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzsyRUEwQjJFLEdBQzNFLElBQUlBLGtCQUFrQixDQUFDLE1BQUcsS0FBSyxPQUFHLEVBQUVBLGVBQWUsSUFBTUMsQ0FBQUEsT0FBT0MsTUFBTSxHQUFJLFNBQVNDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLEVBQUU7SUFDMUYsSUFBSUEsT0FBT0MsV0FBV0QsS0FBS0Q7SUFDM0IsSUFBSUcsT0FBT1AsT0FBT1Esd0JBQXdCLENBQUNMLEdBQUdDO0lBQzlDLElBQUksQ0FBQ0csUUFBUyxVQUFTQSxPQUFPLENBQUNKLEVBQUVNLFVBQVUsR0FBR0YsS0FBS0csUUFBUSxJQUFJSCxLQUFLSSxZQUFZLEdBQUc7UUFDakZKLE9BQU87WUFBRUssWUFBWTtZQUFNQyxLQUFLO2dCQUFhLE9BQU9WLENBQUMsQ0FBQ0MsRUFBRTtZQUFFO1FBQUU7SUFDOUQ7SUFDQUosT0FBT2MsY0FBYyxDQUFDWixHQUFHRyxJQUFJRTtBQUNqQyxJQUFNLFNBQVNMLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLEVBQUU7SUFDdEIsSUFBSUEsT0FBT0MsV0FBV0QsS0FBS0Q7SUFDM0JGLENBQUMsQ0FBQ0csR0FBRyxHQUFHRixDQUFDLENBQUNDLEVBQUU7QUFDaEIsQ0FBQztBQUNELElBQUlXLGVBQWUsQ0FBQyxNQUFHLEtBQUssT0FBRyxFQUFFQSxZQUFZLElBQUssU0FBU1osQ0FBQyxFQUFFYSxRQUFPO0lBQ2pFLElBQUssSUFBSUMsS0FBS2QsRUFBRyxJQUFJYyxNQUFNLGFBQWEsQ0FBQ2pCLE9BQU9rQixTQUFTLENBQUNDLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDSixVQUFTQyxJQUFJbEIsZ0JBQWdCaUIsVUFBU2IsR0FBR2M7QUFDM0g7QUFDQWpCLDhDQUE2QztJQUFFcUIsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3RE4sYUFBYU8sbUJBQU9BLENBQUMsMEhBQVUsR0FBR04iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BzaW5jbGFpcit0eXBlYm94QDAuMjguMjAvbm9kZV9tb2R1bGVzL0BzaW5jbGFpci90eXBlYm94L2Vycm9ycy9pbmRleC5qcz9mMmY4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5Ac2luY2xhaXIvdHlwZWJveC9lcnJvcnNcblxuVGhlIE1JVCBMaWNlbnNlIChNSVQpXG5cbkNvcHlyaWdodCAoYykgMjAxNy0yMDIzIEhheWRuIFBhdGVyc29uIChzaW5jbGFpcikgPGhheWRuLmRldmVsb3BlckBnbWFpbC5jb20+XG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbm9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbmluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbnRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbmNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbmFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG5JTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbkZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbk9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cblRIRSBTT0ZUV0FSRS5cblxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2Vycm9yc1wiKSwgZXhwb3J0cyk7XG4iXSwibmFtZXMiOlsiX19jcmVhdGVCaW5kaW5nIiwiT2JqZWN0IiwiY3JlYXRlIiwibyIsIm0iLCJrIiwiazIiLCJ1bmRlZmluZWQiLCJkZXNjIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiX19lc01vZHVsZSIsIndyaXRhYmxlIiwiY29uZmlndXJhYmxlIiwiZW51bWVyYWJsZSIsImdldCIsImRlZmluZVByb3BlcnR5IiwiX19leHBvcnRTdGFyIiwiZXhwb3J0cyIsInAiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJ2YWx1ZSIsInJlcXVpcmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@sinclair+typebox@0.28.20/node_modules/@sinclair/typebox/errors/index.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/@sinclair+typebox@0.28.20/node_modules/@sinclair/typebox/system/index.js":
/*!*********************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@sinclair+typebox@0.28.20/node_modules/@sinclair/typebox/system/index.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*--------------------------------------------------------------------------\n\n@sinclair/typebox/system\n\nThe MIT License (MIT)\n\nCopyright (c) 2017-2023 Haydn Paterson (sinclair) <haydn.developer@gmail.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n---------------------------------------------------------------------------*/ var __createBinding = (void 0) && (void 0).__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n        desc = {\n            enumerable: true,\n            get: function() {\n                return m[k];\n            }\n        };\n    }\n    Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar __exportStar = (void 0) && (void 0).__exportStar || function(m, exports1) {\n    for(var p in m)if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n__exportStar(__webpack_require__(/*! ./system */ \"(ssr)/../../node_modules/.pnpm/@sinclair+typebox@0.28.20/node_modules/@sinclair/typebox/system/system.js\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BzaW5jbGFpcit0eXBlYm94QDAuMjguMjAvbm9kZV9tb2R1bGVzL0BzaW5jbGFpci90eXBlYm94L3N5c3RlbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzsyRUEwQjJFLEdBQzNFLElBQUlBLGtCQUFrQixDQUFDLE1BQUcsS0FBSyxPQUFHLEVBQUVBLGVBQWUsSUFBTUMsQ0FBQUEsT0FBT0MsTUFBTSxHQUFJLFNBQVNDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLEVBQUU7SUFDMUYsSUFBSUEsT0FBT0MsV0FBV0QsS0FBS0Q7SUFDM0IsSUFBSUcsT0FBT1AsT0FBT1Esd0JBQXdCLENBQUNMLEdBQUdDO0lBQzlDLElBQUksQ0FBQ0csUUFBUyxVQUFTQSxPQUFPLENBQUNKLEVBQUVNLFVBQVUsR0FBR0YsS0FBS0csUUFBUSxJQUFJSCxLQUFLSSxZQUFZLEdBQUc7UUFDakZKLE9BQU87WUFBRUssWUFBWTtZQUFNQyxLQUFLO2dCQUFhLE9BQU9WLENBQUMsQ0FBQ0MsRUFBRTtZQUFFO1FBQUU7SUFDOUQ7SUFDQUosT0FBT2MsY0FBYyxDQUFDWixHQUFHRyxJQUFJRTtBQUNqQyxJQUFNLFNBQVNMLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLEVBQUU7SUFDdEIsSUFBSUEsT0FBT0MsV0FBV0QsS0FBS0Q7SUFDM0JGLENBQUMsQ0FBQ0csR0FBRyxHQUFHRixDQUFDLENBQUNDLEVBQUU7QUFDaEIsQ0FBQztBQUNELElBQUlXLGVBQWUsQ0FBQyxNQUFHLEtBQUssT0FBRyxFQUFFQSxZQUFZLElBQUssU0FBU1osQ0FBQyxFQUFFYSxRQUFPO0lBQ2pFLElBQUssSUFBSUMsS0FBS2QsRUFBRyxJQUFJYyxNQUFNLGFBQWEsQ0FBQ2pCLE9BQU9rQixTQUFTLENBQUNDLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDSixVQUFTQyxJQUFJbEIsZ0JBQWdCaUIsVUFBU2IsR0FBR2M7QUFDM0g7QUFDQWpCLDhDQUE2QztJQUFFcUIsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3RE4sYUFBYU8sbUJBQU9BLENBQUMsMEhBQVUsR0FBR04iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BzaW5jbGFpcit0eXBlYm94QDAuMjguMjAvbm9kZV9tb2R1bGVzL0BzaW5jbGFpci90eXBlYm94L3N5c3RlbS9pbmRleC5qcz9lZmQyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5Ac2luY2xhaXIvdHlwZWJveC9zeXN0ZW1cblxuVGhlIE1JVCBMaWNlbnNlIChNSVQpXG5cbkNvcHlyaWdodCAoYykgMjAxNy0yMDIzIEhheWRuIFBhdGVyc29uIChzaW5jbGFpcikgPGhheWRuLmRldmVsb3BlckBnbWFpbC5jb20+XG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbm9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbmluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbnRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbmNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbmFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG5JTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbkZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbk9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cblRIRSBTT0ZUV0FSRS5cblxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3N5c3RlbVwiKSwgZXhwb3J0cyk7XG4iXSwibmFtZXMiOlsiX19jcmVhdGVCaW5kaW5nIiwiT2JqZWN0IiwiY3JlYXRlIiwibyIsIm0iLCJrIiwiazIiLCJ1bmRlZmluZWQiLCJkZXNjIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiX19lc01vZHVsZSIsIndyaXRhYmxlIiwiY29uZmlndXJhYmxlIiwiZW51bWVyYWJsZSIsImdldCIsImRlZmluZVByb3BlcnR5IiwiX19leHBvcnRTdGFyIiwiZXhwb3J0cyIsInAiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJ2YWx1ZSIsInJlcXVpcmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@sinclair+typebox@0.28.20/node_modules/@sinclair/typebox/system/index.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/@sinclair+typebox@0.28.20/node_modules/@sinclair/typebox/system/system.js":
/*!**********************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@sinclair+typebox@0.28.20/node_modules/@sinclair/typebox/system/system.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*--------------------------------------------------------------------------\n\n@sinclair/typebox/system\n\nThe MIT License (MIT)\n\nCopyright (c) 2017-2023 Haydn Paterson (sinclair) <haydn.developer@gmail.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n---------------------------------------------------------------------------*/ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.TypeSystem = exports.TypeSystemDuplicateFormat = exports.TypeSystemDuplicateTypeKind = void 0;\nconst Types = __webpack_require__(/*! ../typebox */ \"(ssr)/../../node_modules/.pnpm/@sinclair+typebox@0.28.20/node_modules/@sinclair/typebox/typebox.js\");\nclass TypeSystemDuplicateTypeKind extends Error {\n    constructor(kind){\n        super(`Duplicate type kind '${kind}' detected`);\n    }\n}\nexports.TypeSystemDuplicateTypeKind = TypeSystemDuplicateTypeKind;\nclass TypeSystemDuplicateFormat extends Error {\n    constructor(kind){\n        super(`Duplicate string format '${kind}' detected`);\n    }\n}\nexports.TypeSystemDuplicateFormat = TypeSystemDuplicateFormat;\n/** Creates user defined types and formats and provides overrides for value checking behaviours */ var TypeSystem;\n(function(TypeSystem) {\n    // ------------------------------------------------------------------------\n    // Assertion Policies\n    // ------------------------------------------------------------------------\n    /** Sets whether TypeBox should assert optional properties using the TypeScript `exactOptionalPropertyTypes` assertion policy. The default is `false` */ TypeSystem.ExactOptionalPropertyTypes = false;\n    /** Sets whether arrays should be treated as a kind of objects. The default is `false` */ TypeSystem.AllowArrayObjects = false;\n    /** Sets whether `NaN` or `Infinity` should be treated as valid numeric values. The default is `false` */ TypeSystem.AllowNaN = false;\n    /** Sets whether `null` should validate for void types. The default is `false` */ TypeSystem.AllowVoidNull = false;\n    // ------------------------------------------------------------------------\n    // String Formats and Types\n    // ------------------------------------------------------------------------\n    /** Creates a new type */ function Type(kind, check) {\n        if (Types.TypeRegistry.Has(kind)) throw new TypeSystemDuplicateTypeKind(kind);\n        Types.TypeRegistry.Set(kind, check);\n        return (options = {})=>Types.Type.Unsafe({\n                ...options,\n                [Types.Kind]: kind\n            });\n    }\n    TypeSystem.Type = Type;\n    /** Creates a new string format */ function Format(format, check) {\n        if (Types.FormatRegistry.Has(format)) throw new TypeSystemDuplicateFormat(format);\n        Types.FormatRegistry.Set(format, check);\n        return format;\n    }\n    TypeSystem.Format = Format;\n})(TypeSystem || (exports.TypeSystem = TypeSystem = {}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BzaW5jbGFpcit0eXBlYm94QDAuMjguMjAvbm9kZV9tb2R1bGVzL0BzaW5jbGFpci90eXBlYm94L3N5c3RlbS9zeXN0ZW0uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7MkVBMEIyRSxHQUMzRUEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGtCQUFrQixHQUFHQSxpQ0FBaUMsR0FBR0EsbUNBQW1DLEdBQUcsS0FBSztBQUNwRyxNQUFNSyxRQUFRQyxtQkFBT0EsQ0FBQyxzSEFBWTtBQUNsQyxNQUFNRixvQ0FBb0NHO0lBQ3RDQyxZQUFZQyxJQUFJLENBQUU7UUFDZCxLQUFLLENBQUMsQ0FBQyxxQkFBcUIsRUFBRUEsS0FBSyxVQUFVLENBQUM7SUFDbEQ7QUFDSjtBQUNBVCxtQ0FBbUMsR0FBR0k7QUFDdEMsTUFBTUQsa0NBQWtDSTtJQUNwQ0MsWUFBWUMsSUFBSSxDQUFFO1FBQ2QsS0FBSyxDQUFDLENBQUMseUJBQXlCLEVBQUVBLEtBQUssVUFBVSxDQUFDO0lBQ3REO0FBQ0o7QUFDQVQsaUNBQWlDLEdBQUdHO0FBQ3BDLGdHQUFnRyxHQUNoRyxJQUFJRDtBQUNILFVBQVVBLFVBQVU7SUFDakIsMkVBQTJFO0lBQzNFLHFCQUFxQjtJQUNyQiwyRUFBMkU7SUFDM0Usc0pBQXNKLEdBQ3RKQSxXQUFXUSwwQkFBMEIsR0FBRztJQUN4Qyx1RkFBdUYsR0FDdkZSLFdBQVdTLGlCQUFpQixHQUFHO0lBQy9CLHVHQUF1RyxHQUN2R1QsV0FBV1UsUUFBUSxHQUFHO0lBQ3RCLCtFQUErRSxHQUMvRVYsV0FBV1csYUFBYSxHQUFHO0lBQzNCLDJFQUEyRTtJQUMzRSwyQkFBMkI7SUFDM0IsMkVBQTJFO0lBQzNFLHVCQUF1QixHQUN2QixTQUFTQyxLQUFLTCxJQUFJLEVBQUVNLEtBQUs7UUFDckIsSUFBSVYsTUFBTVcsWUFBWSxDQUFDQyxHQUFHLENBQUNSLE9BQ3ZCLE1BQU0sSUFBSUwsNEJBQTRCSztRQUMxQ0osTUFBTVcsWUFBWSxDQUFDRSxHQUFHLENBQUNULE1BQU1NO1FBQzdCLE9BQU8sQ0FBQ0ksVUFBVSxDQUFDLENBQUMsR0FBS2QsTUFBTVMsSUFBSSxDQUFDTSxNQUFNLENBQUM7Z0JBQUUsR0FBR0QsT0FBTztnQkFBRSxDQUFDZCxNQUFNZ0IsSUFBSSxDQUFDLEVBQUVaO1lBQUs7SUFDaEY7SUFDQVAsV0FBV1ksSUFBSSxHQUFHQTtJQUNsQixnQ0FBZ0MsR0FDaEMsU0FBU1EsT0FBT0MsTUFBTSxFQUFFUixLQUFLO1FBQ3pCLElBQUlWLE1BQU1tQixjQUFjLENBQUNQLEdBQUcsQ0FBQ00sU0FDekIsTUFBTSxJQUFJcEIsMEJBQTBCb0I7UUFDeENsQixNQUFNbUIsY0FBYyxDQUFDTixHQUFHLENBQUNLLFFBQVFSO1FBQ2pDLE9BQU9RO0lBQ1g7SUFDQXJCLFdBQVdvQixNQUFNLEdBQUdBO0FBQ3hCLEdBQUdwQixjQUFlRixDQUFBQSxrQkFBa0IsR0FBR0UsYUFBYSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ac2luY2xhaXIrdHlwZWJveEAwLjI4LjIwL25vZGVfbW9kdWxlcy9Ac2luY2xhaXIvdHlwZWJveC9zeXN0ZW0vc3lzdGVtLmpzPzUwODkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbkBzaW5jbGFpci90eXBlYm94L3N5c3RlbVxuXG5UaGUgTUlUIExpY2Vuc2UgKE1JVClcblxuQ29weXJpZ2h0IChjKSAyMDE3LTIwMjMgSGF5ZG4gUGF0ZXJzb24gKHNpbmNsYWlyKSA8aGF5ZG4uZGV2ZWxvcGVyQGdtYWlsLmNvbT5cblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxub2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xudG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG5mdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbklNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG5BVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG5MSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuVEhFIFNPRlRXQVJFLlxuXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5UeXBlU3lzdGVtID0gZXhwb3J0cy5UeXBlU3lzdGVtRHVwbGljYXRlRm9ybWF0ID0gZXhwb3J0cy5UeXBlU3lzdGVtRHVwbGljYXRlVHlwZUtpbmQgPSB2b2lkIDA7XG5jb25zdCBUeXBlcyA9IHJlcXVpcmUoXCIuLi90eXBlYm94XCIpO1xuY2xhc3MgVHlwZVN5c3RlbUR1cGxpY2F0ZVR5cGVLaW5kIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGtpbmQpIHtcbiAgICAgICAgc3VwZXIoYER1cGxpY2F0ZSB0eXBlIGtpbmQgJyR7a2luZH0nIGRldGVjdGVkYCk7XG4gICAgfVxufVxuZXhwb3J0cy5UeXBlU3lzdGVtRHVwbGljYXRlVHlwZUtpbmQgPSBUeXBlU3lzdGVtRHVwbGljYXRlVHlwZUtpbmQ7XG5jbGFzcyBUeXBlU3lzdGVtRHVwbGljYXRlRm9ybWF0IGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGtpbmQpIHtcbiAgICAgICAgc3VwZXIoYER1cGxpY2F0ZSBzdHJpbmcgZm9ybWF0ICcke2tpbmR9JyBkZXRlY3RlZGApO1xuICAgIH1cbn1cbmV4cG9ydHMuVHlwZVN5c3RlbUR1cGxpY2F0ZUZvcm1hdCA9IFR5cGVTeXN0ZW1EdXBsaWNhdGVGb3JtYXQ7XG4vKiogQ3JlYXRlcyB1c2VyIGRlZmluZWQgdHlwZXMgYW5kIGZvcm1hdHMgYW5kIHByb3ZpZGVzIG92ZXJyaWRlcyBmb3IgdmFsdWUgY2hlY2tpbmcgYmVoYXZpb3VycyAqL1xudmFyIFR5cGVTeXN0ZW07XG4oZnVuY3Rpb24gKFR5cGVTeXN0ZW0pIHtcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBBc3NlcnRpb24gUG9saWNpZXNcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvKiogU2V0cyB3aGV0aGVyIFR5cGVCb3ggc2hvdWxkIGFzc2VydCBvcHRpb25hbCBwcm9wZXJ0aWVzIHVzaW5nIHRoZSBUeXBlU2NyaXB0IGBleGFjdE9wdGlvbmFsUHJvcGVydHlUeXBlc2AgYXNzZXJ0aW9uIHBvbGljeS4gVGhlIGRlZmF1bHQgaXMgYGZhbHNlYCAqL1xuICAgIFR5cGVTeXN0ZW0uRXhhY3RPcHRpb25hbFByb3BlcnR5VHlwZXMgPSBmYWxzZTtcbiAgICAvKiogU2V0cyB3aGV0aGVyIGFycmF5cyBzaG91bGQgYmUgdHJlYXRlZCBhcyBhIGtpbmQgb2Ygb2JqZWN0cy4gVGhlIGRlZmF1bHQgaXMgYGZhbHNlYCAqL1xuICAgIFR5cGVTeXN0ZW0uQWxsb3dBcnJheU9iamVjdHMgPSBmYWxzZTtcbiAgICAvKiogU2V0cyB3aGV0aGVyIGBOYU5gIG9yIGBJbmZpbml0eWAgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgdmFsaWQgbnVtZXJpYyB2YWx1ZXMuIFRoZSBkZWZhdWx0IGlzIGBmYWxzZWAgKi9cbiAgICBUeXBlU3lzdGVtLkFsbG93TmFOID0gZmFsc2U7XG4gICAgLyoqIFNldHMgd2hldGhlciBgbnVsbGAgc2hvdWxkIHZhbGlkYXRlIGZvciB2b2lkIHR5cGVzLiBUaGUgZGVmYXVsdCBpcyBgZmFsc2VgICovXG4gICAgVHlwZVN5c3RlbS5BbGxvd1ZvaWROdWxsID0gZmFsc2U7XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gU3RyaW5nIEZvcm1hdHMgYW5kIFR5cGVzXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLyoqIENyZWF0ZXMgYSBuZXcgdHlwZSAqL1xuICAgIGZ1bmN0aW9uIFR5cGUoa2luZCwgY2hlY2spIHtcbiAgICAgICAgaWYgKFR5cGVzLlR5cGVSZWdpc3RyeS5IYXMoa2luZCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZVN5c3RlbUR1cGxpY2F0ZVR5cGVLaW5kKGtpbmQpO1xuICAgICAgICBUeXBlcy5UeXBlUmVnaXN0cnkuU2V0KGtpbmQsIGNoZWNrKTtcbiAgICAgICAgcmV0dXJuIChvcHRpb25zID0ge30pID0+IFR5cGVzLlR5cGUuVW5zYWZlKHsgLi4ub3B0aW9ucywgW1R5cGVzLktpbmRdOiBraW5kIH0pO1xuICAgIH1cbiAgICBUeXBlU3lzdGVtLlR5cGUgPSBUeXBlO1xuICAgIC8qKiBDcmVhdGVzIGEgbmV3IHN0cmluZyBmb3JtYXQgKi9cbiAgICBmdW5jdGlvbiBGb3JtYXQoZm9ybWF0LCBjaGVjaykge1xuICAgICAgICBpZiAoVHlwZXMuRm9ybWF0UmVnaXN0cnkuSGFzKGZvcm1hdCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZVN5c3RlbUR1cGxpY2F0ZUZvcm1hdChmb3JtYXQpO1xuICAgICAgICBUeXBlcy5Gb3JtYXRSZWdpc3RyeS5TZXQoZm9ybWF0LCBjaGVjayk7XG4gICAgICAgIHJldHVybiBmb3JtYXQ7XG4gICAgfVxuICAgIFR5cGVTeXN0ZW0uRm9ybWF0ID0gRm9ybWF0O1xufSkoVHlwZVN5c3RlbSB8fCAoZXhwb3J0cy5UeXBlU3lzdGVtID0gVHlwZVN5c3RlbSA9IHt9KSk7XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJUeXBlU3lzdGVtIiwiVHlwZVN5c3RlbUR1cGxpY2F0ZUZvcm1hdCIsIlR5cGVTeXN0ZW1EdXBsaWNhdGVUeXBlS2luZCIsIlR5cGVzIiwicmVxdWlyZSIsIkVycm9yIiwiY29uc3RydWN0b3IiLCJraW5kIiwiRXhhY3RPcHRpb25hbFByb3BlcnR5VHlwZXMiLCJBbGxvd0FycmF5T2JqZWN0cyIsIkFsbG93TmFOIiwiQWxsb3dWb2lkTnVsbCIsIlR5cGUiLCJjaGVjayIsIlR5cGVSZWdpc3RyeSIsIkhhcyIsIlNldCIsIm9wdGlvbnMiLCJVbnNhZmUiLCJLaW5kIiwiRm9ybWF0IiwiZm9ybWF0IiwiRm9ybWF0UmVnaXN0cnkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@sinclair+typebox@0.28.20/node_modules/@sinclair/typebox/system/system.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/@sinclair+typebox@0.28.20/node_modules/@sinclair/typebox/typebox.js":
/*!****************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@sinclair+typebox@0.28.20/node_modules/@sinclair/typebox/typebox.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*--------------------------------------------------------------------------\n\n@sinclair/typebox\n\nThe MIT License (MIT)\n\nCopyright (c) 2017-2023 Haydn Paterson (sinclair) <haydn.developer@gmail.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n---------------------------------------------------------------------------*/ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Type = exports.StandardType = exports.ExtendedTypeBuilder = exports.StandardTypeBuilder = exports.TypeBuilder = exports.TemplateLiteralDslParser = exports.TemplateLiteralGenerator = exports.TemplateLiteralFinite = exports.TemplateLiteralParser = exports.TemplateLiteralParserError = exports.TemplateLiteralResolver = exports.TemplateLiteralPattern = exports.UnionResolver = exports.KeyArrayResolver = exports.KeyResolver = exports.ObjectMap = exports.IndexedAccessor = exports.TypeClone = exports.TypeExtends = exports.TypeExtendsResult = exports.ExtendsUndefined = exports.TypeGuard = exports.TypeGuardUnknownTypeError = exports.FormatRegistry = exports.TypeRegistry = exports.PatternStringExact = exports.PatternNumberExact = exports.PatternBooleanExact = exports.PatternString = exports.PatternNumber = exports.PatternBoolean = exports.Kind = exports.Hint = exports.Modifier = void 0;\n// --------------------------------------------------------------------------\n// Symbols\n// --------------------------------------------------------------------------\nexports.Modifier = Symbol.for(\"TypeBox.Modifier\");\nexports.Hint = Symbol.for(\"TypeBox.Hint\");\nexports.Kind = Symbol.for(\"TypeBox.Kind\");\n// --------------------------------------------------------------------------\n// Patterns\n// --------------------------------------------------------------------------\nexports.PatternBoolean = \"(true|false)\";\nexports.PatternNumber = \"(0|[1-9][0-9]*)\";\nexports.PatternString = \"(.*)\";\nexports.PatternBooleanExact = `^${exports.PatternBoolean}$`;\nexports.PatternNumberExact = `^${exports.PatternNumber}$`;\nexports.PatternStringExact = `^${exports.PatternString}$`;\n/** A registry for user defined types */ var TypeRegistry;\n(function(TypeRegistry) {\n    const map = new Map();\n    /** Returns the entries in this registry */ function Entries() {\n        return new Map(map);\n    }\n    TypeRegistry.Entries = Entries;\n    /** Clears all user defined types */ function Clear() {\n        return map.clear();\n    }\n    TypeRegistry.Clear = Clear;\n    /** Returns true if this registry contains this kind */ function Has(kind) {\n        return map.has(kind);\n    }\n    TypeRegistry.Has = Has;\n    /** Sets a validation function for a user defined type */ function Set1(kind, func) {\n        map.set(kind, func);\n    }\n    TypeRegistry.Set = Set1;\n    /** Gets a custom validation function for a user defined type */ function Get(kind) {\n        return map.get(kind);\n    }\n    TypeRegistry.Get = Get;\n})(TypeRegistry || (exports.TypeRegistry = TypeRegistry = {}));\n/** A registry for user defined string formats */ var FormatRegistry;\n(function(FormatRegistry) {\n    const map = new Map();\n    /** Returns the entries in this registry */ function Entries() {\n        return new Map(map);\n    }\n    FormatRegistry.Entries = Entries;\n    /** Clears all user defined string formats */ function Clear() {\n        return map.clear();\n    }\n    FormatRegistry.Clear = Clear;\n    /** Returns true if the user defined string format exists */ function Has(format) {\n        return map.has(format);\n    }\n    FormatRegistry.Has = Has;\n    /** Sets a validation function for a user defined string format */ function Set1(format, func) {\n        map.set(format, func);\n    }\n    FormatRegistry.Set = Set1;\n    /** Gets a validation function for a user defined string format */ function Get(format) {\n        return map.get(format);\n    }\n    FormatRegistry.Get = Get;\n})(FormatRegistry || (exports.FormatRegistry = FormatRegistry = {}));\n// --------------------------------------------------------------------------\n// TypeGuard\n// --------------------------------------------------------------------------\nclass TypeGuardUnknownTypeError extends Error {\n    constructor(schema){\n        super(\"TypeGuard: Unknown type\");\n        this.schema = schema;\n    }\n}\nexports.TypeGuardUnknownTypeError = TypeGuardUnknownTypeError;\n/** Provides functions to test if JavaScript values are TypeBox types */ var TypeGuard;\n(function(TypeGuard) {\n    function IsObject(value) {\n        return typeof value === \"object\" && value !== null && !Array.isArray(value);\n    }\n    function IsArray(value) {\n        return typeof value === \"object\" && value !== null && Array.isArray(value);\n    }\n    function IsPattern(value) {\n        try {\n            new RegExp(value);\n            return true;\n        } catch  {\n            return false;\n        }\n    }\n    function IsControlCharacterFree(value) {\n        if (typeof value !== \"string\") return false;\n        for(let i = 0; i < value.length; i++){\n            const code = value.charCodeAt(i);\n            if (code >= 7 && code <= 13 || code === 27 || code === 127) {\n                return false;\n            }\n        }\n        return true;\n    }\n    function IsAdditionalProperties(value) {\n        return IsOptionalBoolean(value) || TSchema(value);\n    }\n    function IsBigInt(value) {\n        return typeof value === \"bigint\";\n    }\n    function IsString(value) {\n        return typeof value === \"string\";\n    }\n    function IsNumber(value) {\n        return typeof value === \"number\" && globalThis.Number.isFinite(value);\n    }\n    function IsBoolean(value) {\n        return typeof value === \"boolean\";\n    }\n    function IsOptionalBigInt(value) {\n        return value === undefined || value !== undefined && IsBigInt(value);\n    }\n    function IsOptionalNumber(value) {\n        return value === undefined || value !== undefined && IsNumber(value);\n    }\n    function IsOptionalBoolean(value) {\n        return value === undefined || value !== undefined && IsBoolean(value);\n    }\n    function IsOptionalString(value) {\n        return value === undefined || value !== undefined && IsString(value);\n    }\n    function IsOptionalPattern(value) {\n        return value === undefined || value !== undefined && IsString(value) && IsControlCharacterFree(value) && IsPattern(value);\n    }\n    function IsOptionalFormat(value) {\n        return value === undefined || value !== undefined && IsString(value) && IsControlCharacterFree(value);\n    }\n    function IsOptionalSchema(value) {\n        return value === undefined || TSchema(value);\n    }\n    /** Returns true if the given schema is TAny */ function TAny(schema) {\n        return TKind(schema) && schema[exports.Kind] === \"Any\" && IsOptionalString(schema.$id);\n    }\n    TypeGuard.TAny = TAny;\n    /** Returns true if the given schema is TArray */ function TArray(schema) {\n        return TKind(schema) && schema[exports.Kind] === \"Array\" && schema.type === \"array\" && IsOptionalString(schema.$id) && TSchema(schema.items) && IsOptionalNumber(schema.minItems) && IsOptionalNumber(schema.maxItems) && IsOptionalBoolean(schema.uniqueItems);\n    }\n    TypeGuard.TArray = TArray;\n    /** Returns true if the given schema is TBigInt */ function TBigInt(schema) {\n        // prettier-ignore\n        return TKind(schema) && schema[exports.Kind] === \"BigInt\" && schema.type === \"null\" && schema.typeOf === \"BigInt\" && IsOptionalString(schema.$id) && IsOptionalBigInt(schema.multipleOf) && IsOptionalBigInt(schema.minimum) && IsOptionalBigInt(schema.maximum) && IsOptionalBigInt(schema.exclusiveMinimum) && IsOptionalBigInt(schema.exclusiveMaximum);\n    }\n    TypeGuard.TBigInt = TBigInt;\n    /** Returns true if the given schema is TBoolean */ function TBoolean(schema) {\n        // prettier-ignore\n        return TKind(schema) && schema[exports.Kind] === \"Boolean\" && schema.type === \"boolean\" && IsOptionalString(schema.$id);\n    }\n    TypeGuard.TBoolean = TBoolean;\n    /** Returns true if the given schema is TConstructor */ function TConstructor(schema) {\n        // prettier-ignore\n        if (!(TKind(schema) && schema[exports.Kind] === \"Constructor\" && schema.type === \"object\" && schema.instanceOf === \"Constructor\" && IsOptionalString(schema.$id) && IsArray(schema.parameters) && TSchema(schema.returns))) {\n            return false;\n        }\n        for (const parameter of schema.parameters){\n            if (!TSchema(parameter)) return false;\n        }\n        return true;\n    }\n    TypeGuard.TConstructor = TConstructor;\n    /** Returns true if the given schema is TDate */ function TDate(schema) {\n        return TKind(schema) && schema[exports.Kind] === \"Date\" && schema.type === \"object\" && schema.instanceOf === \"Date\" && IsOptionalString(schema.$id) && IsOptionalNumber(schema.minimumTimestamp) && IsOptionalNumber(schema.maximumTimestamp) && IsOptionalNumber(schema.exclusiveMinimumTimestamp) && IsOptionalNumber(schema.exclusiveMaximumTimestamp);\n    }\n    TypeGuard.TDate = TDate;\n    /** Returns true if the given schema is TFunction */ function TFunction(schema) {\n        // prettier-ignore\n        if (!(TKind(schema) && schema[exports.Kind] === \"Function\" && schema.type === \"object\" && schema.instanceOf === \"Function\" && IsOptionalString(schema.$id) && IsArray(schema.parameters) && TSchema(schema.returns))) {\n            return false;\n        }\n        for (const parameter of schema.parameters){\n            if (!TSchema(parameter)) return false;\n        }\n        return true;\n    }\n    TypeGuard.TFunction = TFunction;\n    /** Returns true if the given schema is TInteger */ function TInteger(schema) {\n        return TKind(schema) && schema[exports.Kind] === \"Integer\" && schema.type === \"integer\" && IsOptionalString(schema.$id) && IsOptionalNumber(schema.multipleOf) && IsOptionalNumber(schema.minimum) && IsOptionalNumber(schema.maximum) && IsOptionalNumber(schema.exclusiveMinimum) && IsOptionalNumber(schema.exclusiveMaximum);\n    }\n    TypeGuard.TInteger = TInteger;\n    /** Returns true if the given schema is TIntersect */ function TIntersect(schema) {\n        // prettier-ignore\n        if (!(TKind(schema) && schema[exports.Kind] === \"Intersect\" && IsArray(schema.allOf) && IsOptionalString(schema.type) && (IsOptionalBoolean(schema.unevaluatedProperties) || IsOptionalSchema(schema.unevaluatedProperties)) && IsOptionalString(schema.$id))) {\n            return false;\n        }\n        if (\"type\" in schema && schema.type !== \"object\") {\n            return false;\n        }\n        for (const inner of schema.allOf){\n            if (!TSchema(inner)) return false;\n        }\n        return true;\n    }\n    TypeGuard.TIntersect = TIntersect;\n    /** Returns true if the given schema is TKind */ function TKind(schema) {\n        return IsObject(schema) && exports.Kind in schema && typeof schema[exports.Kind] === \"string\"; // TS 4.1.5: any required for symbol indexer\n    }\n    TypeGuard.TKind = TKind;\n    /** Returns true if the given schema is TLiteral<string> */ function TLiteralString(schema) {\n        return TKind(schema) && schema[exports.Kind] === \"Literal\" && IsOptionalString(schema.$id) && typeof schema.const === \"string\";\n    }\n    TypeGuard.TLiteralString = TLiteralString;\n    /** Returns true if the given schema is TLiteral<number> */ function TLiteralNumber(schema) {\n        return TKind(schema) && schema[exports.Kind] === \"Literal\" && IsOptionalString(schema.$id) && typeof schema.const === \"number\";\n    }\n    TypeGuard.TLiteralNumber = TLiteralNumber;\n    /** Returns true if the given schema is TLiteral<boolean> */ function TLiteralBoolean(schema) {\n        return TKind(schema) && schema[exports.Kind] === \"Literal\" && IsOptionalString(schema.$id) && typeof schema.const === \"boolean\";\n    }\n    TypeGuard.TLiteralBoolean = TLiteralBoolean;\n    /** Returns true if the given schema is TLiteral */ function TLiteral(schema) {\n        return TLiteralString(schema) || TLiteralNumber(schema) || TLiteralBoolean(schema);\n    }\n    TypeGuard.TLiteral = TLiteral;\n    /** Returns true if the given schema is TNever */ function TNever(schema) {\n        return TKind(schema) && schema[exports.Kind] === \"Never\" && IsObject(schema.not) && globalThis.Object.getOwnPropertyNames(schema.not).length === 0;\n    }\n    TypeGuard.TNever = TNever;\n    /** Returns true if the given schema is TNot */ function TNot(schema) {\n        // prettier-ignore\n        return TKind(schema) && schema[exports.Kind] === \"Not\" && IsArray(schema.allOf) && schema.allOf.length === 2 && IsObject(schema.allOf[0]) && TSchema(schema.allOf[0].not) && TSchema(schema.allOf[1]);\n    }\n    TypeGuard.TNot = TNot;\n    /** Returns true if the given schema is TNull */ function TNull(schema) {\n        // prettier-ignore\n        return TKind(schema) && schema[exports.Kind] === \"Null\" && schema.type === \"null\" && IsOptionalString(schema.$id);\n    }\n    TypeGuard.TNull = TNull;\n    /** Returns true if the given schema is TNumber */ function TNumber(schema) {\n        return TKind(schema) && schema[exports.Kind] === \"Number\" && schema.type === \"number\" && IsOptionalString(schema.$id) && IsOptionalNumber(schema.multipleOf) && IsOptionalNumber(schema.minimum) && IsOptionalNumber(schema.maximum) && IsOptionalNumber(schema.exclusiveMinimum) && IsOptionalNumber(schema.exclusiveMaximum);\n    }\n    TypeGuard.TNumber = TNumber;\n    /** Returns true if the given schema is TObject */ function TObject(schema) {\n        if (!(TKind(schema) && schema[exports.Kind] === \"Object\" && schema.type === \"object\" && IsOptionalString(schema.$id) && IsObject(schema.properties) && IsAdditionalProperties(schema.additionalProperties) && IsOptionalNumber(schema.minProperties) && IsOptionalNumber(schema.maxProperties))) {\n            return false;\n        }\n        for (const [key, value] of Object.entries(schema.properties)){\n            if (!IsControlCharacterFree(key)) return false;\n            if (!TSchema(value)) return false;\n        }\n        return true;\n    }\n    TypeGuard.TObject = TObject;\n    /** Returns true if the given schema is TPromise */ function TPromise(schema) {\n        // prettier-ignore\n        return TKind(schema) && schema[exports.Kind] === \"Promise\" && schema.type === \"object\" && schema.instanceOf === \"Promise\" && IsOptionalString(schema.$id) && TSchema(schema.item);\n    }\n    TypeGuard.TPromise = TPromise;\n    /** Returns true if the given schema is TRecord */ function TRecord(schema) {\n        // prettier-ignore\n        if (!(TKind(schema) && schema[exports.Kind] === \"Record\" && schema.type === \"object\" && IsOptionalString(schema.$id) && IsAdditionalProperties(schema.additionalProperties) && IsObject(schema.patternProperties))) {\n            return false;\n        }\n        const keys = Object.keys(schema.patternProperties);\n        if (keys.length !== 1) {\n            return false;\n        }\n        if (!IsPattern(keys[0])) {\n            return false;\n        }\n        if (!TSchema(schema.patternProperties[keys[0]])) {\n            return false;\n        }\n        return true;\n    }\n    TypeGuard.TRecord = TRecord;\n    /** Returns true if the given schema is TRef */ function TRef(schema) {\n        // prettier-ignore\n        return TKind(schema) && schema[exports.Kind] === \"Ref\" && IsOptionalString(schema.$id) && IsString(schema.$ref);\n    }\n    TypeGuard.TRef = TRef;\n    /** Returns true if the given schema is TString */ function TString(schema) {\n        return TKind(schema) && schema[exports.Kind] === \"String\" && schema.type === \"string\" && IsOptionalString(schema.$id) && IsOptionalNumber(schema.minLength) && IsOptionalNumber(schema.maxLength) && IsOptionalPattern(schema.pattern) && IsOptionalFormat(schema.format);\n    }\n    TypeGuard.TString = TString;\n    /** Returns true if the given schema is TSymbol */ function TSymbol(schema) {\n        // prettier-ignore\n        return TKind(schema) && schema[exports.Kind] === \"Symbol\" && schema.type === \"null\" && schema.typeOf === \"Symbol\" && IsOptionalString(schema.$id);\n    }\n    TypeGuard.TSymbol = TSymbol;\n    /** Returns true if the given schema is TTemplateLiteral */ function TTemplateLiteral(schema) {\n        // prettier-ignore\n        return TKind(schema) && schema[exports.Kind] === \"TemplateLiteral\" && schema.type === \"string\" && IsString(schema.pattern) && schema.pattern[0] === \"^\" && schema.pattern[schema.pattern.length - 1] === \"$\";\n    }\n    TypeGuard.TTemplateLiteral = TTemplateLiteral;\n    /** Returns true if the given schema is TThis */ function TThis(schema) {\n        // prettier-ignore\n        return TKind(schema) && schema[exports.Kind] === \"This\" && IsOptionalString(schema.$id) && IsString(schema.$ref);\n    }\n    TypeGuard.TThis = TThis;\n    /** Returns true if the given schema is TTuple */ function TTuple(schema) {\n        // prettier-ignore\n        if (!(TKind(schema) && schema[exports.Kind] === \"Tuple\" && schema.type === \"array\" && IsOptionalString(schema.$id) && IsNumber(schema.minItems) && IsNumber(schema.maxItems) && schema.minItems === schema.maxItems)) {\n            return false;\n        }\n        if (schema.items === undefined && schema.additionalItems === undefined && schema.minItems === 0) {\n            return true;\n        }\n        if (!IsArray(schema.items)) {\n            return false;\n        }\n        for (const inner of schema.items){\n            if (!TSchema(inner)) return false;\n        }\n        return true;\n    }\n    TypeGuard.TTuple = TTuple;\n    /** Returns true if the given schema is TUndefined */ function TUndefined(schema) {\n        // prettier-ignore\n        return TKind(schema) && schema[exports.Kind] === \"Undefined\" && schema.type === \"null\" && schema.typeOf === \"Undefined\" && IsOptionalString(schema.$id);\n    }\n    TypeGuard.TUndefined = TUndefined;\n    /** Returns true if the given schema is TUnion<Literal<string | number>[]> */ function TUnionLiteral(schema) {\n        return TUnion(schema) && schema.anyOf.every((schema)=>TLiteralString(schema) || TLiteralNumber(schema));\n    }\n    TypeGuard.TUnionLiteral = TUnionLiteral;\n    /** Returns true if the given schema is TUnion */ function TUnion(schema) {\n        // prettier-ignore\n        if (!(TKind(schema) && schema[exports.Kind] === \"Union\" && IsArray(schema.anyOf) && IsOptionalString(schema.$id))) {\n            return false;\n        }\n        for (const inner of schema.anyOf){\n            if (!TSchema(inner)) return false;\n        }\n        return true;\n    }\n    TypeGuard.TUnion = TUnion;\n    /** Returns true if the given schema is TUint8Array */ function TUint8Array(schema) {\n        return TKind(schema) && schema[exports.Kind] === \"Uint8Array\" && schema.type === \"object\" && IsOptionalString(schema.$id) && schema.instanceOf === \"Uint8Array\" && IsOptionalNumber(schema.minByteLength) && IsOptionalNumber(schema.maxByteLength);\n    }\n    TypeGuard.TUint8Array = TUint8Array;\n    /** Returns true if the given schema is TUnknown */ function TUnknown(schema) {\n        // prettier-ignore\n        return TKind(schema) && schema[exports.Kind] === \"Unknown\" && IsOptionalString(schema.$id);\n    }\n    TypeGuard.TUnknown = TUnknown;\n    /** Returns true if the given schema is a raw TUnsafe */ function TUnsafe(schema) {\n        // prettier-ignore\n        return TKind(schema) && schema[exports.Kind] === \"Unsafe\";\n    }\n    TypeGuard.TUnsafe = TUnsafe;\n    /** Returns true if the given schema is TVoid */ function TVoid(schema) {\n        // prettier-ignore\n        return TKind(schema) && schema[exports.Kind] === \"Void\" && schema.type === \"null\" && schema.typeOf === \"Void\" && IsOptionalString(schema.$id);\n    }\n    TypeGuard.TVoid = TVoid;\n    /** Returns true if this schema has the ReadonlyOptional modifier */ function TReadonlyOptional(schema) {\n        return IsObject(schema) && schema[exports.Modifier] === \"ReadonlyOptional\";\n    }\n    TypeGuard.TReadonlyOptional = TReadonlyOptional;\n    /** Returns true if this schema has the Readonly modifier */ function TReadonly(schema) {\n        return IsObject(schema) && schema[exports.Modifier] === \"Readonly\";\n    }\n    TypeGuard.TReadonly = TReadonly;\n    /** Returns true if this schema has the Optional modifier */ function TOptional(schema) {\n        return IsObject(schema) && schema[exports.Modifier] === \"Optional\";\n    }\n    TypeGuard.TOptional = TOptional;\n    /** Returns true if the given schema is TSchema */ function TSchema(schema) {\n        return typeof schema === \"object\" && (TAny(schema) || TArray(schema) || TBoolean(schema) || TBigInt(schema) || TConstructor(schema) || TDate(schema) || TFunction(schema) || TInteger(schema) || TIntersect(schema) || TLiteral(schema) || TNever(schema) || TNot(schema) || TNull(schema) || TNumber(schema) || TObject(schema) || TPromise(schema) || TRecord(schema) || TRef(schema) || TString(schema) || TSymbol(schema) || TTemplateLiteral(schema) || TThis(schema) || TTuple(schema) || TUndefined(schema) || TUnion(schema) || TUint8Array(schema) || TUnknown(schema) || TUnsafe(schema) || TVoid(schema) || TKind(schema) && TypeRegistry.Has(schema[exports.Kind]));\n    }\n    TypeGuard.TSchema = TSchema;\n})(TypeGuard || (exports.TypeGuard = TypeGuard = {}));\n// --------------------------------------------------------------------------\n// ExtendsUndefined\n// --------------------------------------------------------------------------\n/** Fast undefined check used for properties of type undefined */ var ExtendsUndefined;\n(function(ExtendsUndefined) {\n    function Check(schema) {\n        if (schema[exports.Kind] === \"Undefined\") return true;\n        if (schema[exports.Kind] === \"Not\") {\n            const not = schema;\n            return Check(not.allOf[1]);\n        }\n        if (schema[exports.Kind] === \"Intersect\") {\n            const intersect = schema;\n            return intersect.allOf.every((schema)=>Check(schema));\n        }\n        if (schema[exports.Kind] === \"Union\") {\n            const union = schema;\n            return union.anyOf.some((schema)=>Check(schema));\n        }\n        return false;\n    }\n    ExtendsUndefined.Check = Check;\n})(ExtendsUndefined || (exports.ExtendsUndefined = ExtendsUndefined = {}));\n// --------------------------------------------------------------------------\n// TypeExtends\n// --------------------------------------------------------------------------\nvar TypeExtendsResult;\n(function(TypeExtendsResult) {\n    TypeExtendsResult[TypeExtendsResult[\"Union\"] = 0] = \"Union\";\n    TypeExtendsResult[TypeExtendsResult[\"True\"] = 1] = \"True\";\n    TypeExtendsResult[TypeExtendsResult[\"False\"] = 2] = \"False\";\n})(TypeExtendsResult || (exports.TypeExtendsResult = TypeExtendsResult = {}));\nvar TypeExtends;\n(function(TypeExtends) {\n    // --------------------------------------------------------------------------\n    // IntoBooleanResult\n    // --------------------------------------------------------------------------\n    function IntoBooleanResult(result) {\n        return result === TypeExtendsResult.False ? TypeExtendsResult.False : TypeExtendsResult.True;\n    }\n    // --------------------------------------------------------------------------\n    // Any\n    // --------------------------------------------------------------------------\n    function AnyRight(left, right) {\n        return TypeExtendsResult.True;\n    }\n    function Any(left, right) {\n        if (TypeGuard.TIntersect(right)) return IntersectRight(left, right);\n        if (TypeGuard.TUnion(right) && right.anyOf.some((schema)=>TypeGuard.TAny(schema) || TypeGuard.TUnknown(schema))) return TypeExtendsResult.True;\n        if (TypeGuard.TUnion(right)) return TypeExtendsResult.Union;\n        if (TypeGuard.TUnknown(right)) return TypeExtendsResult.True;\n        if (TypeGuard.TAny(right)) return TypeExtendsResult.True;\n        return TypeExtendsResult.Union;\n    }\n    // --------------------------------------------------------------------------\n    // Array\n    // --------------------------------------------------------------------------\n    function ArrayRight(left, right) {\n        if (TypeGuard.TUnknown(left)) return TypeExtendsResult.False;\n        if (TypeGuard.TAny(left)) return TypeExtendsResult.Union;\n        if (TypeGuard.TNever(left)) return TypeExtendsResult.True;\n        return TypeExtendsResult.False;\n    }\n    function Array1(left, right) {\n        if (TypeGuard.TIntersect(right)) return IntersectRight(left, right);\n        if (TypeGuard.TUnion(right)) return UnionRight(left, right);\n        if (TypeGuard.TUnknown(right)) return UnknownRight(left, right);\n        if (TypeGuard.TAny(right)) return AnyRight(left, right);\n        if (TypeGuard.TObject(right) && IsObjectArrayLike(right)) return TypeExtendsResult.True;\n        if (!TypeGuard.TArray(right)) return TypeExtendsResult.False;\n        return IntoBooleanResult(Visit(left.items, right.items));\n    }\n    // --------------------------------------------------------------------------\n    // BigInt\n    // --------------------------------------------------------------------------\n    function BigInt(left, right) {\n        if (TypeGuard.TIntersect(right)) return IntersectRight(left, right);\n        if (TypeGuard.TUnion(right)) return UnionRight(left, right);\n        if (TypeGuard.TNever(right)) return NeverRight(left, right);\n        if (TypeGuard.TUnknown(right)) return UnknownRight(left, right);\n        if (TypeGuard.TAny(right)) return AnyRight(left, right);\n        if (TypeGuard.TObject(right)) return ObjectRight(left, right);\n        if (TypeGuard.TRecord(right)) return RecordRight(left, right);\n        return TypeGuard.TBigInt(right) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    // --------------------------------------------------------------------------\n    // Boolean\n    // --------------------------------------------------------------------------\n    function BooleanRight(left, right) {\n        if (TypeGuard.TLiteral(left) && typeof left.const === \"boolean\") return TypeExtendsResult.True;\n        return TypeGuard.TBoolean(left) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    function Boolean(left, right) {\n        if (TypeGuard.TIntersect(right)) return IntersectRight(left, right);\n        if (TypeGuard.TUnion(right)) return UnionRight(left, right);\n        if (TypeGuard.TNever(right)) return NeverRight(left, right);\n        if (TypeGuard.TUnknown(right)) return UnknownRight(left, right);\n        if (TypeGuard.TAny(right)) return AnyRight(left, right);\n        if (TypeGuard.TObject(right)) return ObjectRight(left, right);\n        if (TypeGuard.TRecord(right)) return RecordRight(left, right);\n        return TypeGuard.TBoolean(right) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    // --------------------------------------------------------------------------\n    // Constructor\n    // --------------------------------------------------------------------------\n    function Constructor(left, right) {\n        if (TypeGuard.TIntersect(right)) return IntersectRight(left, right);\n        if (TypeGuard.TUnion(right)) return UnionRight(left, right);\n        if (TypeGuard.TUnknown(right)) return UnknownRight(left, right);\n        if (TypeGuard.TAny(right)) return AnyRight(left, right);\n        if (TypeGuard.TObject(right)) return ObjectRight(left, right);\n        if (!TypeGuard.TConstructor(right)) return TypeExtendsResult.False;\n        if (left.parameters.length > right.parameters.length) return TypeExtendsResult.False;\n        if (!left.parameters.every((schema, index)=>IntoBooleanResult(Visit(right.parameters[index], schema)) === TypeExtendsResult.True)) {\n            return TypeExtendsResult.False;\n        }\n        return IntoBooleanResult(Visit(left.returns, right.returns));\n    }\n    // --------------------------------------------------------------------------\n    // Date\n    // --------------------------------------------------------------------------\n    function Date(left, right) {\n        if (TypeGuard.TIntersect(right)) return IntersectRight(left, right);\n        if (TypeGuard.TUnion(right)) return UnionRight(left, right);\n        if (TypeGuard.TUnknown(right)) return UnknownRight(left, right);\n        if (TypeGuard.TAny(right)) return AnyRight(left, right);\n        if (TypeGuard.TObject(right)) return ObjectRight(left, right);\n        if (TypeGuard.TRecord(right)) return RecordRight(left, right);\n        return TypeGuard.TDate(right) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    // --------------------------------------------------------------------------\n    // Function\n    // --------------------------------------------------------------------------\n    function Function(left, right) {\n        if (TypeGuard.TIntersect(right)) return IntersectRight(left, right);\n        if (TypeGuard.TUnion(right)) return UnionRight(left, right);\n        if (TypeGuard.TUnknown(right)) return UnknownRight(left, right);\n        if (TypeGuard.TAny(right)) return AnyRight(left, right);\n        if (TypeGuard.TObject(right)) return ObjectRight(left, right);\n        if (!TypeGuard.TFunction(right)) return TypeExtendsResult.False;\n        if (left.parameters.length > right.parameters.length) return TypeExtendsResult.False;\n        if (!left.parameters.every((schema, index)=>IntoBooleanResult(Visit(right.parameters[index], schema)) === TypeExtendsResult.True)) {\n            return TypeExtendsResult.False;\n        }\n        return IntoBooleanResult(Visit(left.returns, right.returns));\n    }\n    // --------------------------------------------------------------------------\n    // Integer\n    // --------------------------------------------------------------------------\n    function IntegerRight(left, right) {\n        if (TypeGuard.TLiteral(left) && typeof left.const === \"number\") return TypeExtendsResult.True;\n        return TypeGuard.TNumber(left) || TypeGuard.TInteger(left) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    function Integer(left, right) {\n        if (TypeGuard.TIntersect(right)) return IntersectRight(left, right);\n        if (TypeGuard.TUnion(right)) return UnionRight(left, right);\n        if (TypeGuard.TNever(right)) return NeverRight(left, right);\n        if (TypeGuard.TUnknown(right)) return UnknownRight(left, right);\n        if (TypeGuard.TAny(right)) return AnyRight(left, right);\n        if (TypeGuard.TObject(right)) return ObjectRight(left, right);\n        if (TypeGuard.TRecord(right)) return RecordRight(left, right);\n        return TypeGuard.TInteger(right) || TypeGuard.TNumber(right) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    // --------------------------------------------------------------------------\n    // Intersect\n    // --------------------------------------------------------------------------\n    function IntersectRight(left, right) {\n        return right.allOf.every((schema)=>Visit(left, schema) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    function Intersect(left, right) {\n        return left.allOf.some((schema)=>Visit(schema, right) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    // --------------------------------------------------------------------------\n    // Literal\n    // --------------------------------------------------------------------------\n    function IsLiteralString(schema) {\n        return typeof schema.const === \"string\";\n    }\n    function IsLiteralNumber(schema) {\n        return typeof schema.const === \"number\";\n    }\n    function IsLiteralBoolean(schema) {\n        return typeof schema.const === \"boolean\";\n    }\n    function Literal(left, right) {\n        if (TypeGuard.TIntersect(right)) return IntersectRight(left, right);\n        if (TypeGuard.TUnion(right)) return UnionRight(left, right);\n        if (TypeGuard.TNever(right)) return NeverRight(left, right);\n        if (TypeGuard.TUnknown(right)) return UnknownRight(left, right);\n        if (TypeGuard.TAny(right)) return AnyRight(left, right);\n        if (TypeGuard.TObject(right)) return ObjectRight(left, right);\n        if (TypeGuard.TRecord(right)) return RecordRight(left, right);\n        if (TypeGuard.TString(right)) return StringRight(left, right);\n        if (TypeGuard.TNumber(right)) return NumberRight(left, right);\n        if (TypeGuard.TInteger(right)) return IntegerRight(left, right);\n        if (TypeGuard.TBoolean(right)) return BooleanRight(left, right);\n        return TypeGuard.TLiteral(right) && right.const === left.const ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    // --------------------------------------------------------------------------\n    // Never\n    // --------------------------------------------------------------------------\n    function NeverRight(left, right) {\n        return TypeExtendsResult.False;\n    }\n    function Never(left, right) {\n        return TypeExtendsResult.True;\n    }\n    // --------------------------------------------------------------------------\n    // Null\n    // --------------------------------------------------------------------------\n    function Null(left, right) {\n        if (TypeGuard.TIntersect(right)) return IntersectRight(left, right);\n        if (TypeGuard.TUnion(right)) return UnionRight(left, right);\n        if (TypeGuard.TNever(right)) return NeverRight(left, right);\n        if (TypeGuard.TUnknown(right)) return UnknownRight(left, right);\n        if (TypeGuard.TAny(right)) return AnyRight(left, right);\n        if (TypeGuard.TObject(right)) return ObjectRight(left, right);\n        if (TypeGuard.TRecord(right)) return RecordRight(left, right);\n        return TypeGuard.TNull(right) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    // --------------------------------------------------------------------------\n    // Number\n    // --------------------------------------------------------------------------\n    function NumberRight(left, right) {\n        if (TypeGuard.TLiteral(left) && IsLiteralNumber(left)) return TypeExtendsResult.True;\n        return TypeGuard.TNumber(left) || TypeGuard.TInteger(left) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    function Number(left, right) {\n        if (TypeGuard.TIntersect(right)) return IntersectRight(left, right);\n        if (TypeGuard.TUnion(right)) return UnionRight(left, right);\n        if (TypeGuard.TNever(right)) return NeverRight(left, right);\n        if (TypeGuard.TUnknown(right)) return UnknownRight(left, right);\n        if (TypeGuard.TAny(right)) return AnyRight(left, right);\n        if (TypeGuard.TObject(right)) return ObjectRight(left, right);\n        if (TypeGuard.TRecord(right)) return RecordRight(left, right);\n        return TypeGuard.TInteger(right) || TypeGuard.TNumber(right) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    // --------------------------------------------------------------------------\n    // Object\n    // --------------------------------------------------------------------------\n    function IsObjectPropertyCount(schema, count) {\n        return globalThis.Object.keys(schema.properties).length === count;\n    }\n    function IsObjectStringLike(schema) {\n        return IsObjectArrayLike(schema);\n    }\n    function IsObjectSymbolLike(schema) {\n        // prettier-ignore\n        return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && \"description\" in schema.properties && TypeGuard.TUnion(schema.properties.description) && schema.properties.description.anyOf.length === 2 && (TypeGuard.TString(schema.properties.description.anyOf[0]) && TypeGuard.TUndefined(schema.properties.description.anyOf[1]) || TypeGuard.TString(schema.properties.description.anyOf[1]) && TypeGuard.TUndefined(schema.properties.description.anyOf[0]));\n    }\n    function IsObjectNumberLike(schema) {\n        return IsObjectPropertyCount(schema, 0);\n    }\n    function IsObjectBooleanLike(schema) {\n        return IsObjectPropertyCount(schema, 0);\n    }\n    function IsObjectBigIntLike(schema) {\n        return IsObjectPropertyCount(schema, 0);\n    }\n    function IsObjectDateLike(schema) {\n        return IsObjectPropertyCount(schema, 0);\n    }\n    function IsObjectUint8ArrayLike(schema) {\n        return IsObjectArrayLike(schema);\n    }\n    function IsObjectFunctionLike(schema) {\n        const length = exports.Type.Number();\n        return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && \"length\" in schema.properties && IntoBooleanResult(Visit(schema.properties[\"length\"], length)) === TypeExtendsResult.True;\n    }\n    function IsObjectConstructorLike(schema) {\n        return IsObjectPropertyCount(schema, 0);\n    }\n    function IsObjectArrayLike(schema) {\n        const length = exports.Type.Number();\n        return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && \"length\" in schema.properties && IntoBooleanResult(Visit(schema.properties[\"length\"], length)) === TypeExtendsResult.True;\n    }\n    function IsObjectPromiseLike(schema) {\n        const then = exports.Type.Function([\n            exports.Type.Any()\n        ], exports.Type.Any());\n        return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && \"then\" in schema.properties && IntoBooleanResult(Visit(schema.properties[\"then\"], then)) === TypeExtendsResult.True;\n    }\n    // --------------------------------------------------------------------------\n    // Property\n    // --------------------------------------------------------------------------\n    function Property(left, right) {\n        if (Visit(left, right) === TypeExtendsResult.False) return TypeExtendsResult.False;\n        if (TypeGuard.TOptional(left) && !TypeGuard.TOptional(right)) return TypeExtendsResult.False;\n        return TypeExtendsResult.True;\n    }\n    function ObjectRight(left, right) {\n        if (TypeGuard.TUnknown(left)) return TypeExtendsResult.False;\n        if (TypeGuard.TAny(left)) return TypeExtendsResult.Union;\n        if (TypeGuard.TNever(left)) return TypeExtendsResult.True;\n        if (TypeGuard.TLiteral(left) && IsLiteralString(left) && IsObjectStringLike(right)) return TypeExtendsResult.True;\n        if (TypeGuard.TLiteral(left) && IsLiteralNumber(left) && IsObjectNumberLike(right)) return TypeExtendsResult.True;\n        if (TypeGuard.TLiteral(left) && IsLiteralBoolean(left) && IsObjectBooleanLike(right)) return TypeExtendsResult.True;\n        if (TypeGuard.TSymbol(left) && IsObjectSymbolLike(right)) return TypeExtendsResult.True;\n        if (TypeGuard.TBigInt(left) && IsObjectBigIntLike(right)) return TypeExtendsResult.True;\n        if (TypeGuard.TString(left) && IsObjectStringLike(right)) return TypeExtendsResult.True;\n        if (TypeGuard.TSymbol(left) && IsObjectSymbolLike(right)) return TypeExtendsResult.True;\n        if (TypeGuard.TNumber(left) && IsObjectNumberLike(right)) return TypeExtendsResult.True;\n        if (TypeGuard.TInteger(left) && IsObjectNumberLike(right)) return TypeExtendsResult.True;\n        if (TypeGuard.TBoolean(left) && IsObjectBooleanLike(right)) return TypeExtendsResult.True;\n        if (TypeGuard.TUint8Array(left) && IsObjectUint8ArrayLike(right)) return TypeExtendsResult.True;\n        if (TypeGuard.TDate(left) && IsObjectDateLike(right)) return TypeExtendsResult.True;\n        if (TypeGuard.TConstructor(left) && IsObjectConstructorLike(right)) return TypeExtendsResult.True;\n        if (TypeGuard.TFunction(left) && IsObjectFunctionLike(right)) return TypeExtendsResult.True;\n        if (TypeGuard.TRecord(left) && TypeGuard.TString(RecordKey(left))) {\n            // When expressing a Record with literal key values, the Record is converted into a Object with\n            // the Hint assigned as `Record`. This is used to invert the extends logic.\n            return right[exports.Hint] === \"Record\" ? TypeExtendsResult.True : TypeExtendsResult.False;\n        }\n        if (TypeGuard.TRecord(left) && TypeGuard.TNumber(RecordKey(left))) {\n            return IsObjectPropertyCount(right, 0) ? TypeExtendsResult.True : TypeExtendsResult.False;\n        }\n        return TypeExtendsResult.False;\n    }\n    function Object1(left, right) {\n        if (TypeGuard.TIntersect(right)) return IntersectRight(left, right);\n        if (TypeGuard.TUnion(right)) return UnionRight(left, right);\n        if (TypeGuard.TUnknown(right)) return UnknownRight(left, right);\n        if (TypeGuard.TAny(right)) return AnyRight(left, right);\n        if (TypeGuard.TRecord(right)) return RecordRight(left, right);\n        if (!TypeGuard.TObject(right)) return TypeExtendsResult.False;\n        for (const key of globalThis.Object.keys(right.properties)){\n            if (!(key in left.properties)) return TypeExtendsResult.False;\n            if (Property(left.properties[key], right.properties[key]) === TypeExtendsResult.False) {\n                return TypeExtendsResult.False;\n            }\n        }\n        return TypeExtendsResult.True;\n    }\n    // --------------------------------------------------------------------------\n    // Promise\n    // --------------------------------------------------------------------------\n    function Promise(left, right) {\n        if (TypeGuard.TIntersect(right)) return IntersectRight(left, right);\n        if (TypeGuard.TUnion(right)) return UnionRight(left, right);\n        if (TypeGuard.TUnknown(right)) return UnknownRight(left, right);\n        if (TypeGuard.TAny(right)) return AnyRight(left, right);\n        if (TypeGuard.TObject(right) && IsObjectPromiseLike(right)) return TypeExtendsResult.True;\n        if (!TypeGuard.TPromise(right)) return TypeExtendsResult.False;\n        return IntoBooleanResult(Visit(left.item, right.item));\n    }\n    // --------------------------------------------------------------------------\n    // Record\n    // --------------------------------------------------------------------------\n    function RecordKey(schema) {\n        if (exports.PatternNumberExact in schema.patternProperties) return exports.Type.Number();\n        if (exports.PatternStringExact in schema.patternProperties) return exports.Type.String();\n        throw Error(\"TypeExtends: Cannot get record key\");\n    }\n    function RecordValue(schema) {\n        if (exports.PatternNumberExact in schema.patternProperties) return schema.patternProperties[exports.PatternNumberExact];\n        if (exports.PatternStringExact in schema.patternProperties) return schema.patternProperties[exports.PatternStringExact];\n        throw Error(\"TypeExtends: Cannot get record value\");\n    }\n    function RecordRight(left, right) {\n        const Key = RecordKey(right);\n        const Value = RecordValue(right);\n        if (TypeGuard.TLiteral(left) && IsLiteralString(left) && TypeGuard.TNumber(Key) && IntoBooleanResult(Visit(left, Value)) === TypeExtendsResult.True) return TypeExtendsResult.True;\n        if (TypeGuard.TUint8Array(left) && TypeGuard.TNumber(Key)) return Visit(left, Value);\n        if (TypeGuard.TString(left) && TypeGuard.TNumber(Key)) return Visit(left, Value);\n        if (TypeGuard.TArray(left) && TypeGuard.TNumber(Key)) return Visit(left, Value);\n        if (TypeGuard.TObject(left)) {\n            for (const key of globalThis.Object.keys(left.properties)){\n                if (Property(Value, left.properties[key]) === TypeExtendsResult.False) {\n                    return TypeExtendsResult.False;\n                }\n            }\n            return TypeExtendsResult.True;\n        }\n        return TypeExtendsResult.False;\n    }\n    function Record(left, right) {\n        const Value = RecordValue(left);\n        if (TypeGuard.TIntersect(right)) return IntersectRight(left, right);\n        if (TypeGuard.TUnion(right)) return UnionRight(left, right);\n        if (TypeGuard.TUnknown(right)) return UnknownRight(left, right);\n        if (TypeGuard.TAny(right)) return AnyRight(left, right);\n        if (TypeGuard.TObject(right)) return ObjectRight(left, right);\n        if (!TypeGuard.TRecord(right)) return TypeExtendsResult.False;\n        return Visit(Value, RecordValue(right));\n    }\n    // --------------------------------------------------------------------------\n    // String\n    // --------------------------------------------------------------------------\n    function StringRight(left, right) {\n        if (TypeGuard.TLiteral(left) && typeof left.const === \"string\") return TypeExtendsResult.True;\n        return TypeGuard.TString(left) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    function String(left, right) {\n        if (TypeGuard.TIntersect(right)) return IntersectRight(left, right);\n        if (TypeGuard.TUnion(right)) return UnionRight(left, right);\n        if (TypeGuard.TNever(right)) return NeverRight(left, right);\n        if (TypeGuard.TUnknown(right)) return UnknownRight(left, right);\n        if (TypeGuard.TAny(right)) return AnyRight(left, right);\n        if (TypeGuard.TObject(right)) return ObjectRight(left, right);\n        if (TypeGuard.TRecord(right)) return RecordRight(left, right);\n        return TypeGuard.TString(right) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    // --------------------------------------------------------------------------\n    // Symbol\n    // --------------------------------------------------------------------------\n    function Symbol1(left, right) {\n        if (TypeGuard.TIntersect(right)) return IntersectRight(left, right);\n        if (TypeGuard.TUnion(right)) return UnionRight(left, right);\n        if (TypeGuard.TNever(right)) return NeverRight(left, right);\n        if (TypeGuard.TUnknown(right)) return UnknownRight(left, right);\n        if (TypeGuard.TAny(right)) return AnyRight(left, right);\n        if (TypeGuard.TObject(right)) return ObjectRight(left, right);\n        if (TypeGuard.TRecord(right)) return RecordRight(left, right);\n        return TypeGuard.TSymbol(right) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    // --------------------------------------------------------------------------\n    // Tuple\n    // --------------------------------------------------------------------------\n    function TupleRight(left, right) {\n        if (TypeGuard.TUnknown(left)) return TypeExtendsResult.False;\n        if (TypeGuard.TAny(left)) return TypeExtendsResult.Union;\n        if (TypeGuard.TNever(left)) return TypeExtendsResult.True;\n        return TypeExtendsResult.False;\n    }\n    function IsArrayOfTuple(left, right) {\n        return TypeGuard.TArray(right) && left.items !== undefined && left.items.every((schema)=>Visit(schema, right.items) === TypeExtendsResult.True);\n    }\n    function Tuple(left, right) {\n        if (TypeGuard.TIntersect(right)) return IntersectRight(left, right);\n        if (TypeGuard.TUnion(right)) return UnionRight(left, right);\n        if (TypeGuard.TUnknown(right)) return UnknownRight(left, right);\n        if (TypeGuard.TAny(right)) return AnyRight(left, right);\n        if (TypeGuard.TObject(right) && IsObjectArrayLike(right)) return TypeExtendsResult.True;\n        if (TypeGuard.TArray(right) && IsArrayOfTuple(left, right)) return TypeExtendsResult.True;\n        if (!TypeGuard.TTuple(right)) return TypeExtendsResult.False;\n        if (left.items === undefined && right.items !== undefined || left.items !== undefined && right.items === undefined) return TypeExtendsResult.False;\n        if (left.items === undefined && right.items === undefined) return TypeExtendsResult.True;\n        return left.items.every((schema, index)=>Visit(schema, right.items[index]) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    // --------------------------------------------------------------------------\n    // Uint8Array\n    // --------------------------------------------------------------------------\n    function Uint8Array(left, right) {\n        if (TypeGuard.TIntersect(right)) return IntersectRight(left, right);\n        if (TypeGuard.TUnion(right)) return UnionRight(left, right);\n        if (TypeGuard.TUnknown(right)) return UnknownRight(left, right);\n        if (TypeGuard.TAny(right)) return AnyRight(left, right);\n        if (TypeGuard.TObject(right)) return ObjectRight(left, right);\n        if (TypeGuard.TRecord(right)) return RecordRight(left, right);\n        return TypeGuard.TUint8Array(right) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    // --------------------------------------------------------------------------\n    // Undefined\n    // --------------------------------------------------------------------------\n    function Undefined(left, right) {\n        if (TypeGuard.TIntersect(right)) return IntersectRight(left, right);\n        if (TypeGuard.TUnion(right)) return UnionRight(left, right);\n        if (TypeGuard.TNever(right)) return NeverRight(left, right);\n        if (TypeGuard.TUnknown(right)) return UnknownRight(left, right);\n        if (TypeGuard.TAny(right)) return AnyRight(left, right);\n        if (TypeGuard.TObject(right)) return ObjectRight(left, right);\n        if (TypeGuard.TRecord(right)) return RecordRight(left, right);\n        if (TypeGuard.TVoid(right)) return VoidRight(left, right);\n        return TypeGuard.TUndefined(right) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    // --------------------------------------------------------------------------\n    // Union\n    // --------------------------------------------------------------------------\n    function UnionRight(left, right) {\n        return right.anyOf.some((schema)=>Visit(left, schema) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    function Union(left, right) {\n        return left.anyOf.every((schema)=>Visit(schema, right) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    // --------------------------------------------------------------------------\n    // Unknown\n    // --------------------------------------------------------------------------\n    function UnknownRight(left, right) {\n        return TypeExtendsResult.True;\n    }\n    function Unknown(left, right) {\n        if (TypeGuard.TIntersect(right)) return IntersectRight(left, right);\n        if (TypeGuard.TUnion(right)) return UnionRight(left, right);\n        if (TypeGuard.TAny(right)) return AnyRight(left, right);\n        if (TypeGuard.TString(right)) return StringRight(left, right);\n        if (TypeGuard.TNumber(right)) return NumberRight(left, right);\n        if (TypeGuard.TInteger(right)) return IntegerRight(left, right);\n        if (TypeGuard.TBoolean(right)) return BooleanRight(left, right);\n        if (TypeGuard.TArray(right)) return ArrayRight(left, right);\n        if (TypeGuard.TTuple(right)) return TupleRight(left, right);\n        if (TypeGuard.TObject(right)) return ObjectRight(left, right);\n        return TypeGuard.TUnknown(right) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    // --------------------------------------------------------------------------\n    // Void\n    // --------------------------------------------------------------------------\n    function VoidRight(left, right) {\n        if (TypeGuard.TUndefined(left)) return TypeExtendsResult.True;\n        return TypeGuard.TUndefined(left) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    function Void(left, right) {\n        if (TypeGuard.TIntersect(right)) return IntersectRight(left, right);\n        if (TypeGuard.TUnion(right)) return UnionRight(left, right);\n        if (TypeGuard.TUnknown(right)) return UnknownRight(left, right);\n        if (TypeGuard.TAny(right)) return AnyRight(left, right);\n        if (TypeGuard.TObject(right)) return ObjectRight(left, right);\n        return TypeGuard.TVoid(right) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    function Visit(left, right) {\n        // Template Literal Union Unwrap\n        if (TypeGuard.TTemplateLiteral(left)) return Visit(TemplateLiteralResolver.Resolve(left), right);\n        if (TypeGuard.TTemplateLiteral(right)) return Visit(left, TemplateLiteralResolver.Resolve(right));\n        // Standard Extends\n        if (TypeGuard.TAny(left)) return Any(left, right);\n        if (TypeGuard.TArray(left)) return Array1(left, right);\n        if (TypeGuard.TBigInt(left)) return BigInt(left, right);\n        if (TypeGuard.TBoolean(left)) return Boolean(left, right);\n        if (TypeGuard.TConstructor(left)) return Constructor(left, right);\n        if (TypeGuard.TDate(left)) return Date(left, right);\n        if (TypeGuard.TFunction(left)) return Function(left, right);\n        if (TypeGuard.TInteger(left)) return Integer(left, right);\n        if (TypeGuard.TIntersect(left)) return Intersect(left, right);\n        if (TypeGuard.TLiteral(left)) return Literal(left, right);\n        if (TypeGuard.TNever(left)) return Never(left, right);\n        if (TypeGuard.TNull(left)) return Null(left, right);\n        if (TypeGuard.TNumber(left)) return Number(left, right);\n        if (TypeGuard.TObject(left)) return Object1(left, right);\n        if (TypeGuard.TRecord(left)) return Record(left, right);\n        if (TypeGuard.TString(left)) return String(left, right);\n        if (TypeGuard.TSymbol(left)) return Symbol1(left, right);\n        if (TypeGuard.TTuple(left)) return Tuple(left, right);\n        if (TypeGuard.TPromise(left)) return Promise(left, right);\n        if (TypeGuard.TUint8Array(left)) return Uint8Array(left, right);\n        if (TypeGuard.TUndefined(left)) return Undefined(left, right);\n        if (TypeGuard.TUnion(left)) return Union(left, right);\n        if (TypeGuard.TUnknown(left)) return Unknown(left, right);\n        if (TypeGuard.TVoid(left)) return Void(left, right);\n        throw Error(`TypeExtends: Unknown left type operand '${left[exports.Kind]}'`);\n    }\n    function Extends(left, right) {\n        return Visit(left, right);\n    }\n    TypeExtends.Extends = Extends;\n})(TypeExtends || (exports.TypeExtends = TypeExtends = {}));\n// --------------------------------------------------------------------------\n// TypeClone\n// --------------------------------------------------------------------------\n/** Specialized Clone for Types */ var TypeClone;\n(function(TypeClone) {\n    function IsObject(value) {\n        return typeof value === \"object\" && value !== null;\n    }\n    function IsArray(value) {\n        return globalThis.Array.isArray(value);\n    }\n    function Array1(value) {\n        return value.map((value)=>Visit(value));\n    }\n    function Object1(value) {\n        const clonedProperties = globalThis.Object.getOwnPropertyNames(value).reduce((acc, key)=>{\n            return {\n                ...acc,\n                [key]: Visit(value[key])\n            };\n        }, {});\n        const clonedSymbols = globalThis.Object.getOwnPropertySymbols(value).reduce((acc, key)=>{\n            return {\n                ...acc,\n                [key]: Visit(value[key])\n            };\n        }, {});\n        return {\n            ...clonedProperties,\n            ...clonedSymbols\n        };\n    }\n    function Visit(value) {\n        if (IsArray(value)) return Array1(value);\n        if (IsObject(value)) return Object1(value);\n        return value;\n    }\n    /** Clones a type. */ function Clone(schema, options) {\n        return {\n            ...Visit(schema),\n            ...options\n        };\n    }\n    TypeClone.Clone = Clone;\n})(TypeClone || (exports.TypeClone = TypeClone = {}));\n// --------------------------------------------------------------------------\n// IndexedAccessor\n// --------------------------------------------------------------------------\nvar IndexedAccessor;\n(function(IndexedAccessor) {\n    function Intersect(schema, key) {\n        const schemas = schema.allOf.reduce((acc, schema)=>{\n            const indexed = Visit(schema, key);\n            return indexed[exports.Kind] === \"Never\" ? acc : [\n                ...acc,\n                indexed\n            ];\n        }, []);\n        return exports.Type.Intersect(schemas);\n    }\n    function Union(schema, key) {\n        const schemas = schema.anyOf.map((schema)=>Visit(schema, key));\n        return exports.Type.Union(schemas);\n    }\n    function Object1(schema, key) {\n        const property = schema.properties[key];\n        return property === undefined ? exports.Type.Never() : exports.Type.Union([\n            property\n        ]);\n    }\n    function Tuple(schema, key) {\n        const items = schema.items;\n        if (items === undefined) return exports.Type.Never();\n        const element = items[key]; //\n        if (element === undefined) return exports.Type.Never();\n        return element;\n    }\n    function Visit(schema, key) {\n        if (schema[exports.Kind] === \"Intersect\") return Intersect(schema, key);\n        if (schema[exports.Kind] === \"Union\") return Union(schema, key);\n        if (schema[exports.Kind] === \"Object\") return Object1(schema, key);\n        if (schema[exports.Kind] === \"Tuple\") return Tuple(schema, key);\n        return exports.Type.Never();\n    }\n    function Resolve(schema, keys, options = {}) {\n        // prettier-ignore\n        return exports.Type.Union(keys.map((key)=>Visit(schema, key.toString())), options);\n    }\n    IndexedAccessor.Resolve = Resolve;\n})(IndexedAccessor || (exports.IndexedAccessor = IndexedAccessor = {}));\n// --------------------------------------------------------------------------\n// ObjectMap\n// --------------------------------------------------------------------------\nvar ObjectMap;\n(function(ObjectMap) {\n    function Intersect(schema, callback) {\n        // prettier-ignore\n        return exports.Type.Intersect(schema.allOf.map((inner)=>Visit(inner, callback)), {\n            ...schema\n        });\n    }\n    function Union(schema, callback) {\n        // prettier-ignore\n        return exports.Type.Union(schema.anyOf.map((inner)=>Visit(inner, callback)), {\n            ...schema\n        });\n    }\n    function Object1(schema, callback) {\n        return callback(schema);\n    }\n    function Visit(schema, callback) {\n        // There are cases where users need to map objects with unregistered kinds. Using a TypeGuard here would\n        // prevent sub schema mapping as unregistered kinds will not pass TSchema checks. This is notable in the\n        // case of TObject where unregistered property kinds cause the TObject check to fail. As mapping is only\n        // used for composition, we use explicit checks instead.\n        if (schema[exports.Kind] === \"Intersect\") return Intersect(schema, callback);\n        if (schema[exports.Kind] === \"Union\") return Union(schema, callback);\n        if (schema[exports.Kind] === \"Object\") return Object1(schema, callback);\n        return schema;\n    }\n    function Map1(schema, callback, options) {\n        return {\n            ...Visit(TypeClone.Clone(schema, {}), callback),\n            ...options\n        };\n    }\n    ObjectMap.Map = Map1;\n})(ObjectMap || (exports.ObjectMap = ObjectMap = {}));\nvar KeyResolver;\n(function(KeyResolver) {\n    function UnwrapPattern(key) {\n        return key[0] === \"^\" && key[key.length - 1] === \"$\" ? key.slice(1, key.length - 1) : key;\n    }\n    function Intersect(schema, options) {\n        return schema.allOf.reduce((acc, schema)=>[\n                ...acc,\n                ...Visit(schema, options)\n            ], []);\n    }\n    function Union(schema, options) {\n        const sets = schema.anyOf.map((inner)=>Visit(inner, options));\n        return [\n            ...sets.reduce((set, outer)=>outer.map((key)=>sets.every((inner)=>inner.includes(key)) ? set.add(key) : set)[0], new Set())\n        ];\n    }\n    function Object1(schema, options) {\n        return globalThis.Object.keys(schema.properties);\n    }\n    function Record(schema, options) {\n        return options.includePatterns ? globalThis.Object.keys(schema.patternProperties) : [];\n    }\n    function Visit(schema, options) {\n        if (TypeGuard.TIntersect(schema)) return Intersect(schema, options);\n        if (TypeGuard.TUnion(schema)) return Union(schema, options);\n        if (TypeGuard.TObject(schema)) return Object1(schema, options);\n        if (TypeGuard.TRecord(schema)) return Record(schema, options);\n        return [];\n    }\n    /** Resolves an array of keys in this schema */ function ResolveKeys(schema, options) {\n        return [\n            ...new Set(Visit(schema, options))\n        ];\n    }\n    KeyResolver.ResolveKeys = ResolveKeys;\n    /** Resolves a regular expression pattern matching all keys in this schema */ function ResolvePattern(schema) {\n        const keys = ResolveKeys(schema, {\n            includePatterns: true\n        });\n        const pattern = keys.map((key)=>`(${UnwrapPattern(key)})`);\n        return `^(${pattern.join(\"|\")})$`;\n    }\n    KeyResolver.ResolvePattern = ResolvePattern;\n})(KeyResolver || (exports.KeyResolver = KeyResolver = {}));\n// --------------------------------------------------------------------------\n// KeyArrayResolver\n// --------------------------------------------------------------------------\nvar KeyArrayResolver;\n(function(KeyArrayResolver) {\n    /** Resolves an array of string[] keys from the given schema or array type. */ function Resolve(schema) {\n        if (globalThis.Array.isArray(schema)) return schema;\n        if (TypeGuard.TUnionLiteral(schema)) return schema.anyOf.map((schema)=>schema.const.toString());\n        if (TypeGuard.TLiteral(schema)) return [\n            schema.const\n        ];\n        if (TypeGuard.TTemplateLiteral(schema)) {\n            const expression = TemplateLiteralParser.ParseExact(schema.pattern);\n            if (!TemplateLiteralFinite.Check(expression)) throw Error(\"KeyArrayResolver: Cannot resolve keys from infinite template expression\");\n            return [\n                ...TemplateLiteralGenerator.Generate(expression)\n            ];\n        }\n        return [];\n    }\n    KeyArrayResolver.Resolve = Resolve;\n})(KeyArrayResolver || (exports.KeyArrayResolver = KeyArrayResolver = {}));\n// --------------------------------------------------------------------------\n// UnionResolver\n// --------------------------------------------------------------------------\nvar UnionResolver;\n(function(UnionResolver) {\n    function* Union(union) {\n        for (const schema of union.anyOf){\n            if (schema[exports.Kind] === \"Union\") {\n                yield* Union(schema);\n            } else {\n                yield schema;\n            }\n        }\n    }\n    /** Returns a resolved union with interior unions flattened */ function Resolve(union) {\n        return exports.Type.Union([\n            ...Union(union)\n        ], {\n            ...union\n        });\n    }\n    UnionResolver.Resolve = Resolve;\n})(UnionResolver || (exports.UnionResolver = UnionResolver = {}));\n// --------------------------------------------------------------------------\n// TemplateLiteralPattern\n// --------------------------------------------------------------------------\nvar TemplateLiteralPattern;\n(function(TemplateLiteralPattern) {\n    function Escape(value) {\n        return value.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n    }\n    function Visit(schema, acc) {\n        if (TypeGuard.TTemplateLiteral(schema)) {\n            const pattern = schema.pattern.slice(1, schema.pattern.length - 1);\n            return pattern;\n        } else if (TypeGuard.TUnion(schema)) {\n            const tokens = schema.anyOf.map((schema)=>Visit(schema, acc)).join(\"|\");\n            return `(${tokens})`;\n        } else if (TypeGuard.TNumber(schema)) {\n            return `${acc}${exports.PatternNumber}`;\n        } else if (TypeGuard.TInteger(schema)) {\n            return `${acc}${exports.PatternNumber}`;\n        } else if (TypeGuard.TBigInt(schema)) {\n            return `${acc}${exports.PatternNumber}`;\n        } else if (TypeGuard.TString(schema)) {\n            return `${acc}${exports.PatternString}`;\n        } else if (TypeGuard.TLiteral(schema)) {\n            return `${acc}${Escape(schema.const.toString())}`;\n        } else if (TypeGuard.TBoolean(schema)) {\n            return `${acc}${exports.PatternBoolean}`;\n        } else if (TypeGuard.TNever(schema)) {\n            throw Error(\"TemplateLiteralPattern: TemplateLiteral cannot operate on types of TNever\");\n        } else {\n            throw Error(`TemplateLiteralPattern: Unexpected Kind '${schema[exports.Kind]}'`);\n        }\n    }\n    function Create(kinds) {\n        return `^${kinds.map((schema)=>Visit(schema, \"\")).join(\"\")}\\$`;\n    }\n    TemplateLiteralPattern.Create = Create;\n})(TemplateLiteralPattern || (exports.TemplateLiteralPattern = TemplateLiteralPattern = {}));\n// --------------------------------------------------------------------------------------\n// TemplateLiteralResolver\n// --------------------------------------------------------------------------------------\nvar TemplateLiteralResolver;\n(function(TemplateLiteralResolver) {\n    /** Resolves a template literal as a TUnion */ function Resolve(template) {\n        const expression = TemplateLiteralParser.ParseExact(template.pattern);\n        if (!TemplateLiteralFinite.Check(expression)) return exports.Type.String();\n        const literals = [\n            ...TemplateLiteralGenerator.Generate(expression)\n        ].map((value)=>exports.Type.Literal(value));\n        return exports.Type.Union(literals);\n    }\n    TemplateLiteralResolver.Resolve = Resolve;\n})(TemplateLiteralResolver || (exports.TemplateLiteralResolver = TemplateLiteralResolver = {}));\n// --------------------------------------------------------------------------------------\n// TemplateLiteralParser\n// --------------------------------------------------------------------------------------\nclass TemplateLiteralParserError extends Error {\n    constructor(message){\n        super(message);\n    }\n}\nexports.TemplateLiteralParserError = TemplateLiteralParserError;\nvar TemplateLiteralParser;\n(function(TemplateLiteralParser) {\n    function IsNonEscaped(pattern, index, char) {\n        return pattern[index] === char && pattern.charCodeAt(index - 1) !== 92;\n    }\n    function IsOpenParen(pattern, index) {\n        return IsNonEscaped(pattern, index, \"(\");\n    }\n    function IsCloseParen(pattern, index) {\n        return IsNonEscaped(pattern, index, \")\");\n    }\n    function IsSeparator(pattern, index) {\n        return IsNonEscaped(pattern, index, \"|\");\n    }\n    function IsGroup(pattern) {\n        if (!(IsOpenParen(pattern, 0) && IsCloseParen(pattern, pattern.length - 1))) return false;\n        let count = 0;\n        for(let index = 0; index < pattern.length; index++){\n            if (IsOpenParen(pattern, index)) count += 1;\n            if (IsCloseParen(pattern, index)) count -= 1;\n            if (count === 0 && index !== pattern.length - 1) return false;\n        }\n        return true;\n    }\n    function InGroup(pattern) {\n        return pattern.slice(1, pattern.length - 1);\n    }\n    function IsPrecedenceOr(pattern) {\n        let count = 0;\n        for(let index = 0; index < pattern.length; index++){\n            if (IsOpenParen(pattern, index)) count += 1;\n            if (IsCloseParen(pattern, index)) count -= 1;\n            if (IsSeparator(pattern, index) && count === 0) return true;\n        }\n        return false;\n    }\n    function IsPrecedenceAnd(pattern) {\n        for(let index = 0; index < pattern.length; index++){\n            if (IsOpenParen(pattern, index)) return true;\n        }\n        return false;\n    }\n    function Or(pattern) {\n        let [count, start] = [\n            0,\n            0\n        ];\n        const expressions = [];\n        for(let index = 0; index < pattern.length; index++){\n            if (IsOpenParen(pattern, index)) count += 1;\n            if (IsCloseParen(pattern, index)) count -= 1;\n            if (IsSeparator(pattern, index) && count === 0) {\n                const range = pattern.slice(start, index);\n                if (range.length > 0) expressions.push(Parse(range));\n                start = index + 1;\n            }\n        }\n        const range = pattern.slice(start);\n        if (range.length > 0) expressions.push(Parse(range));\n        if (expressions.length === 0) return {\n            type: \"const\",\n            const: \"\"\n        };\n        if (expressions.length === 1) return expressions[0];\n        return {\n            type: \"or\",\n            expr: expressions\n        };\n    }\n    function And(pattern) {\n        function Group(value, index) {\n            if (!IsOpenParen(value, index)) throw new TemplateLiteralParserError(`TemplateLiteralParser: Index must point to open parens`);\n            let count = 0;\n            for(let scan = index; scan < value.length; scan++){\n                if (IsOpenParen(value, scan)) count += 1;\n                if (IsCloseParen(value, scan)) count -= 1;\n                if (count === 0) return [\n                    index,\n                    scan\n                ];\n            }\n            throw new TemplateLiteralParserError(`TemplateLiteralParser: Unclosed group parens in expression`);\n        }\n        function Range(pattern, index) {\n            for(let scan = index; scan < pattern.length; scan++){\n                if (IsOpenParen(pattern, scan)) return [\n                    index,\n                    scan\n                ];\n            }\n            return [\n                index,\n                pattern.length\n            ];\n        }\n        const expressions = [];\n        for(let index = 0; index < pattern.length; index++){\n            if (IsOpenParen(pattern, index)) {\n                const [start, end] = Group(pattern, index);\n                const range = pattern.slice(start, end + 1);\n                expressions.push(Parse(range));\n                index = end;\n            } else {\n                const [start, end] = Range(pattern, index);\n                const range = pattern.slice(start, end);\n                if (range.length > 0) expressions.push(Parse(range));\n                index = end - 1;\n            }\n        }\n        if (expressions.length === 0) return {\n            type: \"const\",\n            const: \"\"\n        };\n        if (expressions.length === 1) return expressions[0];\n        return {\n            type: \"and\",\n            expr: expressions\n        };\n    }\n    /** Parses a pattern and returns an expression tree */ function Parse(pattern) {\n        if (IsGroup(pattern)) return Parse(InGroup(pattern));\n        if (IsPrecedenceOr(pattern)) return Or(pattern);\n        if (IsPrecedenceAnd(pattern)) return And(pattern);\n        return {\n            type: \"const\",\n            const: pattern\n        };\n    }\n    TemplateLiteralParser.Parse = Parse;\n    /** Parses a pattern and strips forward and trailing ^ and $ */ function ParseExact(pattern) {\n        return Parse(pattern.slice(1, pattern.length - 1));\n    }\n    TemplateLiteralParser.ParseExact = ParseExact;\n})(TemplateLiteralParser || (exports.TemplateLiteralParser = TemplateLiteralParser = {}));\n// --------------------------------------------------------------------------------------\n// TemplateLiteralFinite\n// --------------------------------------------------------------------------------------\nvar TemplateLiteralFinite;\n(function(TemplateLiteralFinite) {\n    function IsNumber(expression) {\n        // prettier-ignore\n        return expression.type === \"or\" && expression.expr.length === 2 && expression.expr[0].type === \"const\" && expression.expr[0].const === \"0\" && expression.expr[1].type === \"const\" && expression.expr[1].const === \"[1-9][0-9]*\";\n    }\n    function IsBoolean(expression) {\n        // prettier-ignore\n        return expression.type === \"or\" && expression.expr.length === 2 && expression.expr[0].type === \"const\" && expression.expr[0].const === \"true\" && expression.expr[1].type === \"const\" && expression.expr[1].const === \"false\";\n    }\n    function IsString(expression) {\n        return expression.type === \"const\" && expression.const === \".*\";\n    }\n    function Check(expression) {\n        if (IsBoolean(expression)) return true;\n        if (IsNumber(expression) || IsString(expression)) return false;\n        if (expression.type === \"and\") return expression.expr.every((expr)=>Check(expr));\n        if (expression.type === \"or\") return expression.expr.every((expr)=>Check(expr));\n        if (expression.type === \"const\") return true;\n        throw Error(`TemplateLiteralFinite: Unknown expression type`);\n    }\n    TemplateLiteralFinite.Check = Check;\n})(TemplateLiteralFinite || (exports.TemplateLiteralFinite = TemplateLiteralFinite = {}));\n// --------------------------------------------------------------------------------------\n// TemplateLiteralGenerator\n// --------------------------------------------------------------------------------------\nvar TemplateLiteralGenerator;\n(function(TemplateLiteralGenerator) {\n    function* Reduce(buffer) {\n        if (buffer.length === 1) return yield* buffer[0];\n        for (const left of buffer[0]){\n            for (const right of Reduce(buffer.slice(1))){\n                yield `${left}${right}`;\n            }\n        }\n    }\n    function* And(expression) {\n        return yield* Reduce(expression.expr.map((expr)=>[\n                ...Generate(expr)\n            ]));\n    }\n    function* Or(expression) {\n        for (const expr of expression.expr)yield* Generate(expr);\n    }\n    function* Const(expression) {\n        return yield expression.const;\n    }\n    function* Generate(expression) {\n        if (expression.type === \"and\") return yield* And(expression);\n        if (expression.type === \"or\") return yield* Or(expression);\n        if (expression.type === \"const\") return yield* Const(expression);\n        throw Error(\"TemplateLiteralGenerator: Unknown expression\");\n    }\n    TemplateLiteralGenerator.Generate = Generate;\n})(TemplateLiteralGenerator || (exports.TemplateLiteralGenerator = TemplateLiteralGenerator = {}));\n// ---------------------------------------------------------------------\n// TemplateLiteralDslParser\n// ---------------------------------------------------------------------\nvar TemplateLiteralDslParser;\n(function(TemplateLiteralDslParser) {\n    function* ParseUnion(template) {\n        const trim = template.trim().replace(/\"|'/g, \"\");\n        if (trim === \"boolean\") return yield exports.Type.Boolean();\n        if (trim === \"number\") return yield exports.Type.Number();\n        if (trim === \"bigint\") return yield exports.Type.BigInt();\n        if (trim === \"string\") return yield exports.Type.String();\n        const literals = trim.split(\"|\").map((literal)=>exports.Type.Literal(literal.trim()));\n        return yield literals.length === 0 ? exports.Type.Never() : literals.length === 1 ? literals[0] : exports.Type.Union(literals);\n    }\n    function* ParseTerminal(template) {\n        if (template[1] !== \"{\") {\n            const L = exports.Type.Literal(\"$\");\n            const R = ParseLiteral(template.slice(1));\n            return yield* [\n                L,\n                ...R\n            ];\n        }\n        for(let i = 2; i < template.length; i++){\n            if (template[i] === \"}\") {\n                const L = ParseUnion(template.slice(2, i));\n                const R = ParseLiteral(template.slice(i + 1));\n                return yield* [\n                    ...L,\n                    ...R\n                ];\n            }\n        }\n        yield exports.Type.Literal(template);\n    }\n    function* ParseLiteral(template) {\n        for(let i = 0; i < template.length; i++){\n            if (template[i] === \"$\") {\n                const L = exports.Type.Literal(template.slice(0, i));\n                const R = ParseTerminal(template.slice(i));\n                return yield* [\n                    L,\n                    ...R\n                ];\n            }\n        }\n        yield exports.Type.Literal(template);\n    }\n    function Parse(template_dsl) {\n        return [\n            ...ParseLiteral(template_dsl)\n        ];\n    }\n    TemplateLiteralDslParser.Parse = Parse;\n})(TemplateLiteralDslParser || (exports.TemplateLiteralDslParser = TemplateLiteralDslParser = {}));\n// --------------------------------------------------------------------------\n// TypeOrdinal: Used for auto $id generation\n// --------------------------------------------------------------------------\nlet TypeOrdinal = 0;\n// --------------------------------------------------------------------------\n// TypeBuilder\n// --------------------------------------------------------------------------\nclass TypeBuilder {\n    /** `[Utility]` Creates a schema without `static` and `params` types */ Create(schema) {\n        return schema;\n    }\n    /** `[Standard]` Omits compositing symbols from this schema */ Strict(schema) {\n        return JSON.parse(JSON.stringify(schema));\n    }\n}\nexports.TypeBuilder = TypeBuilder;\n// --------------------------------------------------------------------------\n// StandardTypeBuilder\n// --------------------------------------------------------------------------\nclass StandardTypeBuilder extends TypeBuilder {\n    // ------------------------------------------------------------------------\n    // Modifiers\n    // ------------------------------------------------------------------------\n    /** `[Modifier]` Creates a Optional property */ Optional(schema) {\n        return {\n            [exports.Modifier]: \"Optional\",\n            ...TypeClone.Clone(schema, {})\n        };\n    }\n    /** `[Modifier]` Creates a ReadonlyOptional property */ ReadonlyOptional(schema) {\n        return {\n            [exports.Modifier]: \"ReadonlyOptional\",\n            ...TypeClone.Clone(schema, {})\n        };\n    }\n    /** `[Modifier]` Creates a Readonly object or property */ Readonly(schema) {\n        return {\n            [exports.Modifier]: \"Readonly\",\n            ...schema\n        };\n    }\n    // ------------------------------------------------------------------------\n    // Types\n    // ------------------------------------------------------------------------\n    /** `[Standard]` Creates an Any type */ Any(options = {}) {\n        return this.Create({\n            ...options,\n            [exports.Kind]: \"Any\"\n        });\n    }\n    /** `[Standard]` Creates an Array type */ Array(items, options = {}) {\n        return this.Create({\n            ...options,\n            [exports.Kind]: \"Array\",\n            type: \"array\",\n            items: TypeClone.Clone(items, {})\n        });\n    }\n    /** `[Standard]` Creates a Boolean type */ Boolean(options = {}) {\n        return this.Create({\n            ...options,\n            [exports.Kind]: \"Boolean\",\n            type: \"boolean\"\n        });\n    }\n    /** `[Standard]` Creates a Composite object type. */ Composite(objects, options) {\n        const intersect = exports.Type.Intersect(objects, {});\n        const keys = KeyResolver.ResolveKeys(intersect, {\n            includePatterns: false\n        });\n        const properties = keys.reduce((acc, key)=>({\n                ...acc,\n                [key]: exports.Type.Index(intersect, [\n                    key\n                ])\n            }), {});\n        return exports.Type.Object(properties, options);\n    }\n    /** `[Standard]` Creates a Enum type */ Enum(item, options = {}) {\n        // prettier-ignore\n        const values = globalThis.Object.keys(item).filter((key)=>isNaN(key)).map((key)=>item[key]);\n        const anyOf = values.map((value)=>typeof value === \"string\" ? {\n                [exports.Kind]: \"Literal\",\n                type: \"string\",\n                const: value\n            } : {\n                [exports.Kind]: \"Literal\",\n                type: \"number\",\n                const: value\n            });\n        return this.Create({\n            ...options,\n            [exports.Kind]: \"Union\",\n            anyOf\n        });\n    }\n    /** `[Standard]` A conditional type expression that will return the true type if the left type extends the right */ Extends(left, right, trueType, falseType, options = {}) {\n        switch(TypeExtends.Extends(left, right)){\n            case TypeExtendsResult.Union:\n                return this.Union([\n                    TypeClone.Clone(trueType, options),\n                    TypeClone.Clone(falseType, options)\n                ]);\n            case TypeExtendsResult.True:\n                return TypeClone.Clone(trueType, options);\n            case TypeExtendsResult.False:\n                return TypeClone.Clone(falseType, options);\n        }\n    }\n    /** `[Standard]` Excludes from the left type any type that is not assignable to the right */ Exclude(left, right, options = {}) {\n        if (TypeGuard.TTemplateLiteral(left)) return this.Exclude(TemplateLiteralResolver.Resolve(left), right, options);\n        if (TypeGuard.TTemplateLiteral(right)) return this.Exclude(left, TemplateLiteralResolver.Resolve(right), options);\n        if (TypeGuard.TUnion(left)) {\n            const narrowed = left.anyOf.filter((inner)=>TypeExtends.Extends(inner, right) === TypeExtendsResult.False);\n            return narrowed.length === 1 ? TypeClone.Clone(narrowed[0], options) : this.Union(narrowed, options);\n        } else {\n            return TypeExtends.Extends(left, right) !== TypeExtendsResult.False ? this.Never(options) : TypeClone.Clone(left, options);\n        }\n    }\n    /** `[Standard]` Extracts from the left type any type that is assignable to the right */ Extract(left, right, options = {}) {\n        if (TypeGuard.TTemplateLiteral(left)) return this.Extract(TemplateLiteralResolver.Resolve(left), right, options);\n        if (TypeGuard.TTemplateLiteral(right)) return this.Extract(left, TemplateLiteralResolver.Resolve(right), options);\n        if (TypeGuard.TUnion(left)) {\n            const narrowed = left.anyOf.filter((inner)=>TypeExtends.Extends(inner, right) !== TypeExtendsResult.False);\n            return narrowed.length === 1 ? TypeClone.Clone(narrowed[0], options) : this.Union(narrowed, options);\n        } else {\n            return TypeExtends.Extends(left, right) !== TypeExtendsResult.False ? TypeClone.Clone(left, options) : this.Never(options);\n        }\n    }\n    /** `[Standard]` Returns indexed property types for the given keys */ Index(schema, unresolved, options = {}) {\n        if (TypeGuard.TArray(schema) && TypeGuard.TNumber(unresolved)) {\n            return TypeClone.Clone(schema.items, options);\n        } else if (TypeGuard.TTuple(schema) && TypeGuard.TNumber(unresolved)) {\n            const items = schema.items === undefined ? [] : schema.items;\n            const cloned = items.map((schema)=>TypeClone.Clone(schema, {}));\n            return this.Union(cloned, options);\n        } else {\n            const keys = KeyArrayResolver.Resolve(unresolved);\n            const clone = TypeClone.Clone(schema, {});\n            return IndexedAccessor.Resolve(clone, keys, options);\n        }\n    }\n    /** `[Standard]` Creates an Integer type */ Integer(options = {}) {\n        return this.Create({\n            ...options,\n            [exports.Kind]: \"Integer\",\n            type: \"integer\"\n        });\n    }\n    Intersect(allOf, options = {}) {\n        if (allOf.length === 0) return exports.Type.Never();\n        if (allOf.length === 1) return TypeClone.Clone(allOf[0], options);\n        const objects = allOf.every((schema)=>TypeGuard.TObject(schema));\n        const cloned = allOf.map((schema)=>TypeClone.Clone(schema, {}));\n        const clonedUnevaluatedProperties = TypeGuard.TSchema(options.unevaluatedProperties) ? {\n            unevaluatedProperties: TypeClone.Clone(options.unevaluatedProperties, {})\n        } : {};\n        if (options.unevaluatedProperties === false || TypeGuard.TSchema(options.unevaluatedProperties) || objects) {\n            return this.Create({\n                ...options,\n                ...clonedUnevaluatedProperties,\n                [exports.Kind]: \"Intersect\",\n                type: \"object\",\n                allOf: cloned\n            });\n        } else {\n            return this.Create({\n                ...options,\n                ...clonedUnevaluatedProperties,\n                [exports.Kind]: \"Intersect\",\n                allOf: cloned\n            });\n        }\n    }\n    /** `[Standard]` Creates a KeyOf type */ KeyOf(schema, options = {}) {\n        if (TypeGuard.TRecord(schema)) {\n            const pattern = Object.getOwnPropertyNames(schema.patternProperties)[0];\n            if (pattern === exports.PatternNumberExact) return this.Number(options);\n            if (pattern === exports.PatternStringExact) return this.String(options);\n            throw Error(\"StandardTypeBuilder: Unable to resolve key type from Record key pattern\");\n        } else if (TypeGuard.TTuple(schema)) {\n            const items = schema.items === undefined ? [] : schema.items;\n            const literals = items.map((_, index)=>exports.Type.Literal(index));\n            return this.Union(literals, options);\n        } else if (TypeGuard.TArray(schema)) {\n            return this.Number(options);\n        } else {\n            const keys = KeyResolver.ResolveKeys(schema, {\n                includePatterns: false\n            });\n            if (keys.length === 0) return this.Never(options);\n            const literals = keys.map((key)=>this.Literal(key));\n            return this.Union(literals, options);\n        }\n    }\n    /** `[Standard]` Creates a Literal type */ Literal(value, options = {}) {\n        return this.Create({\n            ...options,\n            [exports.Kind]: \"Literal\",\n            const: value,\n            type: typeof value\n        });\n    }\n    /** `[Standard]` Creates a Never type */ Never(options = {}) {\n        return this.Create({\n            ...options,\n            [exports.Kind]: \"Never\",\n            not: {}\n        });\n    }\n    /** `[Standard]` Creates a Not type. The first argument is the disallowed type, the second is the allowed. */ Not(not, schema, options) {\n        return this.Create({\n            ...options,\n            [exports.Kind]: \"Not\",\n            allOf: [\n                {\n                    not: TypeClone.Clone(not, {})\n                },\n                TypeClone.Clone(schema, {})\n            ]\n        });\n    }\n    /** `[Standard]` Creates a Null type */ Null(options = {}) {\n        return this.Create({\n            ...options,\n            [exports.Kind]: \"Null\",\n            type: \"null\"\n        });\n    }\n    /** `[Standard]` Creates a Number type */ Number(options = {}) {\n        return this.Create({\n            ...options,\n            [exports.Kind]: \"Number\",\n            type: \"number\"\n        });\n    }\n    /** `[Standard]` Creates an Object type */ Object(properties, options = {}) {\n        const propertyKeys = globalThis.Object.getOwnPropertyNames(properties);\n        const optionalKeys = propertyKeys.filter((key)=>TypeGuard.TOptional(properties[key]) || TypeGuard.TReadonlyOptional(properties[key]));\n        const requiredKeys = propertyKeys.filter((name)=>!optionalKeys.includes(name));\n        const clonedAdditionalProperties = TypeGuard.TSchema(options.additionalProperties) ? {\n            additionalProperties: TypeClone.Clone(options.additionalProperties, {})\n        } : {};\n        const clonedProperties = propertyKeys.reduce((acc, key)=>({\n                ...acc,\n                [key]: TypeClone.Clone(properties[key], {})\n            }), {});\n        if (requiredKeys.length > 0) {\n            return this.Create({\n                ...options,\n                ...clonedAdditionalProperties,\n                [exports.Kind]: \"Object\",\n                type: \"object\",\n                properties: clonedProperties,\n                required: requiredKeys\n            });\n        } else {\n            return this.Create({\n                ...options,\n                ...clonedAdditionalProperties,\n                [exports.Kind]: \"Object\",\n                type: \"object\",\n                properties: clonedProperties\n            });\n        }\n    }\n    Omit(schema, unresolved, options = {}) {\n        const keys = KeyArrayResolver.Resolve(unresolved);\n        // prettier-ignore\n        return ObjectMap.Map(TypeClone.Clone(schema, {}), (schema)=>{\n            if (schema.required) {\n                schema.required = schema.required.filter((key)=>!keys.includes(key));\n                if (schema.required.length === 0) delete schema.required;\n            }\n            for (const key of globalThis.Object.keys(schema.properties)){\n                if (keys.includes(key)) delete schema.properties[key];\n            }\n            return this.Create(schema);\n        }, options);\n    }\n    /** `[Standard]` Creates a mapped type where all properties are Optional */ Partial(schema, options = {}) {\n        function Apply(schema) {\n            // prettier-ignore\n            switch(schema[exports.Modifier]){\n                case \"ReadonlyOptional\":\n                    schema[exports.Modifier] = \"ReadonlyOptional\";\n                    break;\n                case \"Readonly\":\n                    schema[exports.Modifier] = \"ReadonlyOptional\";\n                    break;\n                case \"Optional\":\n                    schema[exports.Modifier] = \"Optional\";\n                    break;\n                default:\n                    schema[exports.Modifier] = \"Optional\";\n                    break;\n            }\n        }\n        // prettier-ignore\n        return ObjectMap.Map(TypeClone.Clone(schema, {}), (schema)=>{\n            delete schema.required;\n            globalThis.Object.keys(schema.properties).forEach((key)=>Apply(schema.properties[key]));\n            return schema;\n        }, options);\n    }\n    Pick(schema, unresolved, options = {}) {\n        const keys = KeyArrayResolver.Resolve(unresolved);\n        // prettier-ignore\n        return ObjectMap.Map(TypeClone.Clone(schema, {}), (schema)=>{\n            if (schema.required) {\n                schema.required = schema.required.filter((key)=>keys.includes(key));\n                if (schema.required.length === 0) delete schema.required;\n            }\n            for (const key of globalThis.Object.keys(schema.properties)){\n                if (!keys.includes(key)) delete schema.properties[key];\n            }\n            return this.Create(schema);\n        }, options);\n    }\n    /** `[Standard]` Creates a Record type */ Record(key, schema, options = {}) {\n        if (TypeGuard.TTemplateLiteral(key)) {\n            const expression = TemplateLiteralParser.ParseExact(key.pattern);\n            // prettier-ignore\n            return TemplateLiteralFinite.Check(expression) ? this.Object([\n                ...TemplateLiteralGenerator.Generate(expression)\n            ].reduce((acc, key)=>({\n                    ...acc,\n                    [key]: TypeClone.Clone(schema, {})\n                }), {}), options) : this.Create({\n                ...options,\n                [exports.Kind]: \"Record\",\n                type: \"object\",\n                patternProperties: {\n                    [key.pattern]: TypeClone.Clone(schema, {})\n                }\n            });\n        } else if (TypeGuard.TUnion(key)) {\n            const union = UnionResolver.Resolve(key);\n            if (TypeGuard.TUnionLiteral(union)) {\n                const properties = union.anyOf.reduce((acc, literal)=>({\n                        ...acc,\n                        [literal.const]: TypeClone.Clone(schema, {})\n                    }), {});\n                return this.Object(properties, {\n                    ...options,\n                    [exports.Hint]: \"Record\"\n                });\n            } else throw Error(\"TypeBuilder: Record key of type union contains non-literal types\");\n        } else if (TypeGuard.TLiteral(key)) {\n            if (typeof key.const === \"string\" || typeof key.const === \"number\") {\n                return this.Object({\n                    [key.const]: TypeClone.Clone(schema, {})\n                }, options);\n            } else throw Error(\"TypeBuilder: Record key of type literal is not of type string or number\");\n        } else if (TypeGuard.TInteger(key) || TypeGuard.TNumber(key)) {\n            const pattern = exports.PatternNumberExact;\n            return this.Create({\n                ...options,\n                [exports.Kind]: \"Record\",\n                type: \"object\",\n                patternProperties: {\n                    [pattern]: TypeClone.Clone(schema, {})\n                }\n            });\n        } else if (TypeGuard.TString(key)) {\n            const pattern = key.pattern === undefined ? exports.PatternStringExact : key.pattern;\n            return this.Create({\n                ...options,\n                [exports.Kind]: \"Record\",\n                type: \"object\",\n                patternProperties: {\n                    [pattern]: TypeClone.Clone(schema, {})\n                }\n            });\n        } else {\n            throw Error(`StandardTypeBuilder: Record key is an invalid type`);\n        }\n    }\n    /** `[Standard]` Creates a Recursive type */ Recursive(callback, options = {}) {\n        if (options.$id === undefined) options.$id = `T${TypeOrdinal++}`;\n        const thisType = callback({\n            [exports.Kind]: \"This\",\n            $ref: `${options.$id}`\n        });\n        thisType.$id = options.$id;\n        return this.Create({\n            ...options,\n            [exports.Hint]: \"Recursive\",\n            ...thisType\n        });\n    }\n    /** `[Standard]` Creates a Ref type. The referenced type must contain a $id */ Ref(schema, options = {}) {\n        if (schema.$id === undefined) throw Error(\"StandardTypeBuilder.Ref: Target type must specify an $id\");\n        return this.Create({\n            ...options,\n            [exports.Kind]: \"Ref\",\n            $ref: schema.$id\n        });\n    }\n    /** `[Standard]` Creates a mapped type where all properties are Required */ Required(schema, options = {}) {\n        function Apply(schema) {\n            // prettier-ignore\n            switch(schema[exports.Modifier]){\n                case \"ReadonlyOptional\":\n                    schema[exports.Modifier] = \"Readonly\";\n                    break;\n                case \"Readonly\":\n                    schema[exports.Modifier] = \"Readonly\";\n                    break;\n                case \"Optional\":\n                    delete schema[exports.Modifier];\n                    break;\n                default:\n                    delete schema[exports.Modifier];\n                    break;\n            }\n        }\n        // prettier-ignore\n        return ObjectMap.Map(TypeClone.Clone(schema, {}), (schema)=>{\n            schema.required = globalThis.Object.keys(schema.properties);\n            globalThis.Object.keys(schema.properties).forEach((key)=>Apply(schema.properties[key]));\n            return schema;\n        }, options);\n    }\n    /** `[Standard]` Returns a schema array which allows types to compose with the JavaScript spread operator */ Rest(schema) {\n        if (TypeGuard.TTuple(schema)) {\n            if (schema.items === undefined) return [];\n            return schema.items.map((schema)=>TypeClone.Clone(schema, {}));\n        } else {\n            return [\n                TypeClone.Clone(schema, {})\n            ];\n        }\n    }\n    /** `[Standard]` Creates a String type */ String(options = {}) {\n        return this.Create({\n            ...options,\n            [exports.Kind]: \"String\",\n            type: \"string\"\n        });\n    }\n    /** `[Standard]` Creates a template literal type */ TemplateLiteral(unresolved, options = {}) {\n        // prettier-ignore\n        const pattern = typeof unresolved === \"string\" ? TemplateLiteralPattern.Create(TemplateLiteralDslParser.Parse(unresolved)) : TemplateLiteralPattern.Create(unresolved);\n        return this.Create({\n            ...options,\n            [exports.Kind]: \"TemplateLiteral\",\n            type: \"string\",\n            pattern\n        });\n    }\n    /** `[Standard]` Creates a Tuple type */ Tuple(items, options = {}) {\n        const [additionalItems, minItems, maxItems] = [\n            false,\n            items.length,\n            items.length\n        ];\n        const clonedItems = items.map((item)=>TypeClone.Clone(item, {}));\n        // prettier-ignore\n        const schema = items.length > 0 ? {\n            ...options,\n            [exports.Kind]: \"Tuple\",\n            type: \"array\",\n            items: clonedItems,\n            additionalItems,\n            minItems,\n            maxItems\n        } : {\n            ...options,\n            [exports.Kind]: \"Tuple\",\n            type: \"array\",\n            minItems,\n            maxItems\n        };\n        return this.Create(schema);\n    }\n    Union(union, options = {}) {\n        if (TypeGuard.TTemplateLiteral(union)) {\n            return TemplateLiteralResolver.Resolve(union);\n        } else {\n            const anyOf = union;\n            if (anyOf.length === 0) return this.Never(options);\n            if (anyOf.length === 1) return this.Create(TypeClone.Clone(anyOf[0], options));\n            const clonedAnyOf = anyOf.map((schema)=>TypeClone.Clone(schema, {}));\n            return this.Create({\n                ...options,\n                [exports.Kind]: \"Union\",\n                anyOf: clonedAnyOf\n            });\n        }\n    }\n    /** `[Standard]` Creates an Unknown type */ Unknown(options = {}) {\n        return this.Create({\n            ...options,\n            [exports.Kind]: \"Unknown\"\n        });\n    }\n    /** `[Standard]` Creates a Unsafe type that infers for the generic argument */ Unsafe(options = {}) {\n        return this.Create({\n            ...options,\n            [exports.Kind]: options[exports.Kind] || \"Unsafe\"\n        });\n    }\n}\nexports.StandardTypeBuilder = StandardTypeBuilder;\n// --------------------------------------------------------------------------\n// ExtendedTypeBuilder\n// --------------------------------------------------------------------------\nclass ExtendedTypeBuilder extends StandardTypeBuilder {\n    /** `[Extended]` Creates a BigInt type */ BigInt(options = {}) {\n        return this.Create({\n            ...options,\n            [exports.Kind]: \"BigInt\",\n            type: \"null\",\n            typeOf: \"BigInt\"\n        });\n    }\n    /** `[Extended]` Extracts the ConstructorParameters from the given Constructor type */ ConstructorParameters(schema, options = {}) {\n        return this.Tuple([\n            ...schema.parameters\n        ], {\n            ...options\n        });\n    }\n    /** `[Extended]` Creates a Constructor type */ Constructor(parameters, returns, options) {\n        const clonedReturns = TypeClone.Clone(returns, {});\n        const clonedParameters = parameters.map((parameter)=>TypeClone.Clone(parameter, {}));\n        return this.Create({\n            ...options,\n            [exports.Kind]: \"Constructor\",\n            type: \"object\",\n            instanceOf: \"Constructor\",\n            parameters: clonedParameters,\n            returns: clonedReturns\n        });\n    }\n    /** `[Extended]` Creates a Date type */ Date(options = {}) {\n        return this.Create({\n            ...options,\n            [exports.Kind]: \"Date\",\n            type: \"object\",\n            instanceOf: \"Date\"\n        });\n    }\n    /** `[Extended]` Creates a Function type */ Function(parameters, returns, options) {\n        const clonedReturns = TypeClone.Clone(returns, {});\n        const clonedParameters = parameters.map((parameter)=>TypeClone.Clone(parameter, {}));\n        return this.Create({\n            ...options,\n            [exports.Kind]: \"Function\",\n            type: \"object\",\n            instanceOf: \"Function\",\n            parameters: clonedParameters,\n            returns: clonedReturns\n        });\n    }\n    /** `[Extended]` Extracts the InstanceType from the given Constructor */ InstanceType(schema, options = {}) {\n        return TypeClone.Clone(schema.returns, options);\n    }\n    /** `[Extended]` Extracts the Parameters from the given Function type */ Parameters(schema, options = {}) {\n        return this.Tuple(schema.parameters, {\n            ...options\n        });\n    }\n    /** `[Extended]` Creates a Promise type */ Promise(item, options = {}) {\n        return this.Create({\n            ...options,\n            [exports.Kind]: \"Promise\",\n            type: \"object\",\n            instanceOf: \"Promise\",\n            item: TypeClone.Clone(item, {})\n        });\n    }\n    /** `[Extended]` Creates a regular expression type */ RegEx(regex, options = {}) {\n        return this.Create({\n            ...options,\n            [exports.Kind]: \"String\",\n            type: \"string\",\n            pattern: regex.source\n        });\n    }\n    /** `[Extended]` Extracts the ReturnType from the given Function */ ReturnType(schema, options = {}) {\n        return TypeClone.Clone(schema.returns, options);\n    }\n    /** `[Extended]` Creates a Symbol type */ Symbol(options) {\n        return this.Create({\n            ...options,\n            [exports.Kind]: \"Symbol\",\n            type: \"null\",\n            typeOf: \"Symbol\"\n        });\n    }\n    /** `[Extended]` Creates a Undefined type */ Undefined(options = {}) {\n        return this.Create({\n            ...options,\n            [exports.Kind]: \"Undefined\",\n            type: \"null\",\n            typeOf: \"Undefined\"\n        });\n    }\n    /** `[Extended]` Creates a Uint8Array type */ Uint8Array(options = {}) {\n        return this.Create({\n            ...options,\n            [exports.Kind]: \"Uint8Array\",\n            type: \"object\",\n            instanceOf: \"Uint8Array\"\n        });\n    }\n    /** `[Extended]` Creates a Void type */ Void(options = {}) {\n        return this.Create({\n            ...options,\n            [exports.Kind]: \"Void\",\n            type: \"null\",\n            typeOf: \"Void\"\n        });\n    }\n}\nexports.ExtendedTypeBuilder = ExtendedTypeBuilder;\n/** JSON Schema TypeBuilder with Static Resolution for TypeScript */ exports.StandardType = new StandardTypeBuilder();\n/** JSON Schema TypeBuilder with Static Resolution for TypeScript */ exports.Type = new ExtendedTypeBuilder();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BzaW5jbGFpcit0eXBlYm94QDAuMjguMjAvbm9kZV9tb2R1bGVzL0BzaW5jbGFpci90eXBlYm94L3R5cGVib3guanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7MkVBMEIyRSxHQUMzRUEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELFlBQVksR0FBR0Esb0JBQW9CLEdBQUdBLDJCQUEyQixHQUFHQSwyQkFBMkIsR0FBR0EsbUJBQW1CLEdBQUdBLGdDQUFnQyxHQUFHQSxnQ0FBZ0MsR0FBR0EsNkJBQTZCLEdBQUdBLDZCQUE2QixHQUFHQSxrQ0FBa0MsR0FBR0EsK0JBQStCLEdBQUdBLDhCQUE4QixHQUFHQSxxQkFBcUIsR0FBR0Esd0JBQXdCLEdBQUdBLG1CQUFtQixHQUFHQSxpQkFBaUIsR0FBR0EsdUJBQXVCLEdBQUdBLGlCQUFpQixHQUFHQSxtQkFBbUIsR0FBR0EseUJBQXlCLEdBQUdBLHdCQUF3QixHQUFHQSxpQkFBaUIsR0FBR0EsaUNBQWlDLEdBQUdBLHNCQUFzQixHQUFHQSxvQkFBb0IsR0FBR0EsMEJBQTBCLEdBQUdBLDBCQUEwQixHQUFHQSwyQkFBMkIsR0FBR0EscUJBQXFCLEdBQUdBLHFCQUFxQixHQUFHQSxzQkFBc0IsR0FBR0EsWUFBWSxHQUFHQSxZQUFZLEdBQUdBLGdCQUFnQixHQUFHLEtBQUs7QUFDNzNCLDZFQUE2RTtBQUM3RSxVQUFVO0FBQ1YsNkVBQTZFO0FBQzdFQSxnQkFBZ0IsR0FBR29DLE9BQU9DLEdBQUcsQ0FBQztBQUM5QnJDLFlBQVksR0FBR29DLE9BQU9DLEdBQUcsQ0FBQztBQUMxQnJDLFlBQVksR0FBR29DLE9BQU9DLEdBQUcsQ0FBQztBQUMxQiw2RUFBNkU7QUFDN0UsV0FBVztBQUNYLDZFQUE2RTtBQUM3RXJDLHNCQUFzQixHQUFHO0FBQ3pCQSxxQkFBcUIsR0FBRztBQUN4QkEscUJBQXFCLEdB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Q0o7QUFDQTdGLDJCQUEyQixHQUFHSTtBQUM5QixrRUFBa0UsR0FDbEVKLG9CQUFvQixHQUFHLElBQUlLO0FBQzNCLGtFQUFrRSxHQUNsRUwsWUFBWSxHQUFHLElBQUlJIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ac2luY2xhaXIrdHlwZWJveEAwLjI4LjIwL25vZGVfbW9kdWxlcy9Ac2luY2xhaXIvdHlwZWJveC90eXBlYm94LmpzP2YyZmEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbkBzaW5jbGFpci90eXBlYm94XG5cblRoZSBNSVQgTGljZW5zZSAoTUlUKVxuXG5Db3B5cmlnaHQgKGMpIDIwMTctMjAyMyBIYXlkbiBQYXRlcnNvbiAoc2luY2xhaXIpIDxoYXlkbi5kZXZlbG9wZXJAZ21haWwuY29tPlxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG5vZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG5pbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG50byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG5jb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbmZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG5hbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG5GSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbkFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbkxJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG5PVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG5USEUgU09GVFdBUkUuXG5cbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlR5cGUgPSBleHBvcnRzLlN0YW5kYXJkVHlwZSA9IGV4cG9ydHMuRXh0ZW5kZWRUeXBlQnVpbGRlciA9IGV4cG9ydHMuU3RhbmRhcmRUeXBlQnVpbGRlciA9IGV4cG9ydHMuVHlwZUJ1aWxkZXIgPSBleHBvcnRzLlRlbXBsYXRlTGl0ZXJhbERzbFBhcnNlciA9IGV4cG9ydHMuVGVtcGxhdGVMaXRlcmFsR2VuZXJhdG9yID0gZXhwb3J0cy5UZW1wbGF0ZUxpdGVyYWxGaW5pdGUgPSBleHBvcnRzLlRlbXBsYXRlTGl0ZXJhbFBhcnNlciA9IGV4cG9ydHMuVGVtcGxhdGVMaXRlcmFsUGFyc2VyRXJyb3IgPSBleHBvcnRzLlRlbXBsYXRlTGl0ZXJhbFJlc29sdmVyID0gZXhwb3J0cy5UZW1wbGF0ZUxpdGVyYWxQYXR0ZXJuID0gZXhwb3J0cy5VbmlvblJlc29sdmVyID0gZXhwb3J0cy5LZXlBcnJheVJlc29sdmVyID0gZXhwb3J0cy5LZXlSZXNvbHZlciA9IGV4cG9ydHMuT2JqZWN0TWFwID0gZXhwb3J0cy5JbmRleGVkQWNjZXNzb3IgPSBleHBvcnRzLlR5cGVDbG9uZSA9IGV4cG9ydHMuVHlwZUV4dGVuZHMgPSBleHBvcnRzLlR5cGVFeHRlbmRzUmVzdWx0ID0gZXhwb3J0cy5FeHRlbmRzVW5kZWZpbmVkID0gZXhwb3J0cy5UeXBlR3VhcmQgPSBleHBvcnRzLlR5cGVHdWFyZFVua25vd25UeXBlRXJyb3IgPSBleHBvcnRzLkZvcm1hdFJlZ2lzdHJ5ID0gZXhwb3J0cy5UeXBlUmVnaXN0cnkgPSBleHBvcnRzLlBhdHRlcm5TdHJpbmdFeGFjdCA9IGV4cG9ydHMuUGF0dGVybk51bWJlckV4YWN0ID0gZXhwb3J0cy5QYXR0ZXJuQm9vbGVhbkV4YWN0ID0gZXhwb3J0cy5QYXR0ZXJuU3RyaW5nID0gZXhwb3J0cy5QYXR0ZXJuTnVtYmVyID0gZXhwb3J0cy5QYXR0ZXJuQm9vbGVhbiA9IGV4cG9ydHMuS2luZCA9IGV4cG9ydHMuSGludCA9IGV4cG9ydHMuTW9kaWZpZXIgPSB2b2lkIDA7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gU3ltYm9sc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmV4cG9ydHMuTW9kaWZpZXIgPSBTeW1ib2wuZm9yKCdUeXBlQm94Lk1vZGlmaWVyJyk7XG5leHBvcnRzLkhpbnQgPSBTeW1ib2wuZm9yKCdUeXBlQm94LkhpbnQnKTtcbmV4cG9ydHMuS2luZCA9IFN5bWJvbC5mb3IoJ1R5cGVCb3guS2luZCcpO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFBhdHRlcm5zXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZXhwb3J0cy5QYXR0ZXJuQm9vbGVhbiA9ICcodHJ1ZXxmYWxzZSknO1xuZXhwb3J0cy5QYXR0ZXJuTnVtYmVyID0gJygwfFsxLTldWzAtOV0qKSc7XG5leHBvcnRzLlBhdHRlcm5TdHJpbmcgPSAnKC4qKSc7XG5leHBvcnRzLlBhdHRlcm5Cb29sZWFuRXhhY3QgPSBgXiR7ZXhwb3J0cy5QYXR0ZXJuQm9vbGVhbn0kYDtcbmV4cG9ydHMuUGF0dGVybk51bWJlckV4YWN0ID0gYF4ke2V4cG9ydHMuUGF0dGVybk51bWJlcn0kYDtcbmV4cG9ydHMuUGF0dGVyblN0cmluZ0V4YWN0ID0gYF4ke2V4cG9ydHMuUGF0dGVyblN0cmluZ30kYDtcbi8qKiBBIHJlZ2lzdHJ5IGZvciB1c2VyIGRlZmluZWQgdHlwZXMgKi9cbnZhciBUeXBlUmVnaXN0cnk7XG4oZnVuY3Rpb24gKFR5cGVSZWdpc3RyeSkge1xuICAgIGNvbnN0IG1hcCA9IG5ldyBNYXAoKTtcbiAgICAvKiogUmV0dXJucyB0aGUgZW50cmllcyBpbiB0aGlzIHJlZ2lzdHJ5ICovXG4gICAgZnVuY3Rpb24gRW50cmllcygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNYXAobWFwKTtcbiAgICB9XG4gICAgVHlwZVJlZ2lzdHJ5LkVudHJpZXMgPSBFbnRyaWVzO1xuICAgIC8qKiBDbGVhcnMgYWxsIHVzZXIgZGVmaW5lZCB0eXBlcyAqL1xuICAgIGZ1bmN0aW9uIENsZWFyKCkge1xuICAgICAgICByZXR1cm4gbWFwLmNsZWFyKCk7XG4gICAgfVxuICAgIFR5cGVSZWdpc3RyeS5DbGVhciA9IENsZWFyO1xuICAgIC8qKiBSZXR1cm5zIHRydWUgaWYgdGhpcyByZWdpc3RyeSBjb250YWlucyB0aGlzIGtpbmQgKi9cbiAgICBmdW5jdGlvbiBIYXMoa2luZCkge1xuICAgICAgICByZXR1cm4gbWFwLmhhcyhraW5kKTtcbiAgICB9XG4gICAgVHlwZVJlZ2lzdHJ5LkhhcyA9IEhhcztcbiAgICAvKiogU2V0cyBhIHZhbGlkYXRpb24gZnVuY3Rpb24gZm9yIGEgdXNlciBkZWZpbmVkIHR5cGUgKi9cbiAgICBmdW5jdGlvbiBTZXQoa2luZCwgZnVuYykge1xuICAgICAgICBtYXAuc2V0KGtpbmQsIGZ1bmMpO1xuICAgIH1cbiAgICBUeXBlUmVnaXN0cnkuU2V0ID0gU2V0O1xuICAgIC8qKiBHZXRzIGEgY3VzdG9tIHZhbGlkYXRpb24gZnVuY3Rpb24gZm9yIGEgdXNlciBkZWZpbmVkIHR5cGUgKi9cbiAgICBmdW5jdGlvbiBHZXQoa2luZCkge1xuICAgICAgICByZXR1cm4gbWFwLmdldChraW5kKTtcbiAgICB9XG4gICAgVHlwZVJlZ2lzdHJ5LkdldCA9IEdldDtcbn0pKFR5cGVSZWdpc3RyeSB8fCAoZXhwb3J0cy5UeXBlUmVnaXN0cnkgPSBUeXBlUmVnaXN0cnkgPSB7fSkpO1xuLyoqIEEgcmVnaXN0cnkgZm9yIHVzZXIgZGVmaW5lZCBzdHJpbmcgZm9ybWF0cyAqL1xudmFyIEZvcm1hdFJlZ2lzdHJ5O1xuKGZ1bmN0aW9uIChGb3JtYXRSZWdpc3RyeSkge1xuICAgIGNvbnN0IG1hcCA9IG5ldyBNYXAoKTtcbiAgICAvKiogUmV0dXJucyB0aGUgZW50cmllcyBpbiB0aGlzIHJlZ2lzdHJ5ICovXG4gICAgZnVuY3Rpb24gRW50cmllcygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNYXAobWFwKTtcbiAgICB9XG4gICAgRm9ybWF0UmVnaXN0cnkuRW50cmllcyA9IEVudHJpZXM7XG4gICAgLyoqIENsZWFycyBhbGwgdXNlciBkZWZpbmVkIHN0cmluZyBmb3JtYXRzICovXG4gICAgZnVuY3Rpb24gQ2xlYXIoKSB7XG4gICAgICAgIHJldHVybiBtYXAuY2xlYXIoKTtcbiAgICB9XG4gICAgRm9ybWF0UmVnaXN0cnkuQ2xlYXIgPSBDbGVhcjtcbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIHRoZSB1c2VyIGRlZmluZWQgc3RyaW5nIGZvcm1hdCBleGlzdHMgKi9cbiAgICBmdW5jdGlvbiBIYXMoZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiBtYXAuaGFzKGZvcm1hdCk7XG4gICAgfVxuICAgIEZvcm1hdFJlZ2lzdHJ5LkhhcyA9IEhhcztcbiAgICAvKiogU2V0cyBhIHZhbGlkYXRpb24gZnVuY3Rpb24gZm9yIGEgdXNlciBkZWZpbmVkIHN0cmluZyBmb3JtYXQgKi9cbiAgICBmdW5jdGlvbiBTZXQoZm9ybWF0LCBmdW5jKSB7XG4gICAgICAgIG1hcC5zZXQoZm9ybWF0LCBmdW5jKTtcbiAgICB9XG4gICAgRm9ybWF0UmVnaXN0cnkuU2V0ID0gU2V0O1xuICAgIC8qKiBHZXRzIGEgdmFsaWRhdGlvbiBmdW5jdGlvbiBmb3IgYSB1c2VyIGRlZmluZWQgc3RyaW5nIGZvcm1hdCAqL1xuICAgIGZ1bmN0aW9uIEdldChmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIG1hcC5nZXQoZm9ybWF0KTtcbiAgICB9XG4gICAgRm9ybWF0UmVnaXN0cnkuR2V0ID0gR2V0O1xufSkoRm9ybWF0UmVnaXN0cnkgfHwgKGV4cG9ydHMuRm9ybWF0UmVnaXN0cnkgPSBGb3JtYXRSZWdpc3RyeSA9IHt9KSk7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gVHlwZUd1YXJkXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuY2xhc3MgVHlwZUd1YXJkVW5rbm93blR5cGVFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihzY2hlbWEpIHtcbiAgICAgICAgc3VwZXIoJ1R5cGVHdWFyZDogVW5rbm93biB0eXBlJyk7XG4gICAgICAgIHRoaXMuc2NoZW1hID0gc2NoZW1hO1xuICAgIH1cbn1cbmV4cG9ydHMuVHlwZUd1YXJkVW5rbm93blR5cGVFcnJvciA9IFR5cGVHdWFyZFVua25vd25UeXBlRXJyb3I7XG4vKiogUHJvdmlkZXMgZnVuY3Rpb25zIHRvIHRlc3QgaWYgSmF2YVNjcmlwdCB2YWx1ZXMgYXJlIFR5cGVCb3ggdHlwZXMgKi9cbnZhciBUeXBlR3VhcmQ7XG4oZnVuY3Rpb24gKFR5cGVHdWFyZCkge1xuICAgIGZ1bmN0aW9uIElzT2JqZWN0KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsICYmICFBcnJheS5pc0FycmF5KHZhbHVlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gSXNBcnJheSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCAmJiBBcnJheS5pc0FycmF5KHZhbHVlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gSXNQYXR0ZXJuKHZhbHVlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBuZXcgUmVnRXhwKHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBJc0NvbnRyb2xDaGFyYWN0ZXJGcmVlKHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBjb2RlID0gdmFsdWUuY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgIGlmICgoY29kZSA+PSA3ICYmIGNvZGUgPD0gMTMpIHx8IGNvZGUgPT09IDI3IHx8IGNvZGUgPT09IDEyNykge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gSXNBZGRpdGlvbmFsUHJvcGVydGllcyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gSXNPcHRpb25hbEJvb2xlYW4odmFsdWUpIHx8IFRTY2hlbWEodmFsdWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBJc0JpZ0ludCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnYmlnaW50JztcbiAgICB9XG4gICAgZnVuY3Rpb24gSXNTdHJpbmcodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZyc7XG4gICAgfVxuICAgIGZ1bmN0aW9uIElzTnVtYmVyKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIGdsb2JhbFRoaXMuTnVtYmVyLmlzRmluaXRlKHZhbHVlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gSXNCb29sZWFuKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJztcbiAgICB9XG4gICAgZnVuY3Rpb24gSXNPcHRpb25hbEJpZ0ludCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCB8fCAodmFsdWUgIT09IHVuZGVmaW5lZCAmJiBJc0JpZ0ludCh2YWx1ZSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBJc09wdGlvbmFsTnVtYmVyKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8ICh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIElzTnVtYmVyKHZhbHVlKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIElzT3B0aW9uYWxCb29sZWFuKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8ICh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIElzQm9vbGVhbih2YWx1ZSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBJc09wdGlvbmFsU3RyaW5nKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8ICh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIElzU3RyaW5nKHZhbHVlKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIElzT3B0aW9uYWxQYXR0ZXJuKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8ICh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIElzU3RyaW5nKHZhbHVlKSAmJiBJc0NvbnRyb2xDaGFyYWN0ZXJGcmVlKHZhbHVlKSAmJiBJc1BhdHRlcm4odmFsdWUpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gSXNPcHRpb25hbEZvcm1hdCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCB8fCAodmFsdWUgIT09IHVuZGVmaW5lZCAmJiBJc1N0cmluZyh2YWx1ZSkgJiYgSXNDb250cm9sQ2hhcmFjdGVyRnJlZSh2YWx1ZSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBJc09wdGlvbmFsU2NoZW1hKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IFRTY2hlbWEodmFsdWUpO1xuICAgIH1cbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBzY2hlbWEgaXMgVEFueSAqL1xuICAgIGZ1bmN0aW9uIFRBbnkoc2NoZW1hKSB7XG4gICAgICAgIHJldHVybiBUS2luZChzY2hlbWEpICYmIHNjaGVtYVtleHBvcnRzLktpbmRdID09PSAnQW55JyAmJiBJc09wdGlvbmFsU3RyaW5nKHNjaGVtYS4kaWQpO1xuICAgIH1cbiAgICBUeXBlR3VhcmQuVEFueSA9IFRBbnk7XG4gICAgLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gc2NoZW1hIGlzIFRBcnJheSAqL1xuICAgIGZ1bmN0aW9uIFRBcnJheShzY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIChUS2luZChzY2hlbWEpICYmXG4gICAgICAgICAgICBzY2hlbWFbZXhwb3J0cy5LaW5kXSA9PT0gJ0FycmF5JyAmJlxuICAgICAgICAgICAgc2NoZW1hLnR5cGUgPT09ICdhcnJheScgJiZcbiAgICAgICAgICAgIElzT3B0aW9uYWxTdHJpbmcoc2NoZW1hLiRpZCkgJiZcbiAgICAgICAgICAgIFRTY2hlbWEoc2NoZW1hLml0ZW1zKSAmJlxuICAgICAgICAgICAgSXNPcHRpb25hbE51bWJlcihzY2hlbWEubWluSXRlbXMpICYmXG4gICAgICAgICAgICBJc09wdGlvbmFsTnVtYmVyKHNjaGVtYS5tYXhJdGVtcykgJiZcbiAgICAgICAgICAgIElzT3B0aW9uYWxCb29sZWFuKHNjaGVtYS51bmlxdWVJdGVtcykpO1xuICAgIH1cbiAgICBUeXBlR3VhcmQuVEFycmF5ID0gVEFycmF5O1xuICAgIC8qKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHNjaGVtYSBpcyBUQmlnSW50ICovXG4gICAgZnVuY3Rpb24gVEJpZ0ludChzY2hlbWEpIHtcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIHJldHVybiAoVEtpbmQoc2NoZW1hKSAmJlxuICAgICAgICAgICAgc2NoZW1hW2V4cG9ydHMuS2luZF0gPT09ICdCaWdJbnQnICYmXG4gICAgICAgICAgICBzY2hlbWEudHlwZSA9PT0gJ251bGwnICYmXG4gICAgICAgICAgICBzY2hlbWEudHlwZU9mID09PSAnQmlnSW50JyAmJlxuICAgICAgICAgICAgSXNPcHRpb25hbFN0cmluZyhzY2hlbWEuJGlkKSAmJlxuICAgICAgICAgICAgSXNPcHRpb25hbEJpZ0ludChzY2hlbWEubXVsdGlwbGVPZikgJiZcbiAgICAgICAgICAgIElzT3B0aW9uYWxCaWdJbnQoc2NoZW1hLm1pbmltdW0pICYmXG4gICAgICAgICAgICBJc09wdGlvbmFsQmlnSW50KHNjaGVtYS5tYXhpbXVtKSAmJlxuICAgICAgICAgICAgSXNPcHRpb25hbEJpZ0ludChzY2hlbWEuZXhjbHVzaXZlTWluaW11bSkgJiZcbiAgICAgICAgICAgIElzT3B0aW9uYWxCaWdJbnQoc2NoZW1hLmV4Y2x1c2l2ZU1heGltdW0pKTtcbiAgICB9XG4gICAgVHlwZUd1YXJkLlRCaWdJbnQgPSBUQmlnSW50O1xuICAgIC8qKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHNjaGVtYSBpcyBUQm9vbGVhbiAqL1xuICAgIGZ1bmN0aW9uIFRCb29sZWFuKHNjaGVtYSkge1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgcmV0dXJuIChUS2luZChzY2hlbWEpICYmXG4gICAgICAgICAgICBzY2hlbWFbZXhwb3J0cy5LaW5kXSA9PT0gJ0Jvb2xlYW4nICYmXG4gICAgICAgICAgICBzY2hlbWEudHlwZSA9PT0gJ2Jvb2xlYW4nICYmXG4gICAgICAgICAgICBJc09wdGlvbmFsU3RyaW5nKHNjaGVtYS4kaWQpKTtcbiAgICB9XG4gICAgVHlwZUd1YXJkLlRCb29sZWFuID0gVEJvb2xlYW47XG4gICAgLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gc2NoZW1hIGlzIFRDb25zdHJ1Y3RvciAqL1xuICAgIGZ1bmN0aW9uIFRDb25zdHJ1Y3RvcihzY2hlbWEpIHtcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIGlmICghKFRLaW5kKHNjaGVtYSkgJiZcbiAgICAgICAgICAgIHNjaGVtYVtleHBvcnRzLktpbmRdID09PSAnQ29uc3RydWN0b3InICYmXG4gICAgICAgICAgICBzY2hlbWEudHlwZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgIHNjaGVtYS5pbnN0YW5jZU9mID09PSAnQ29uc3RydWN0b3InICYmXG4gICAgICAgICAgICBJc09wdGlvbmFsU3RyaW5nKHNjaGVtYS4kaWQpICYmXG4gICAgICAgICAgICBJc0FycmF5KHNjaGVtYS5wYXJhbWV0ZXJzKSAmJlxuICAgICAgICAgICAgVFNjaGVtYShzY2hlbWEucmV0dXJucykpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBwYXJhbWV0ZXIgb2Ygc2NoZW1hLnBhcmFtZXRlcnMpIHtcbiAgICAgICAgICAgIGlmICghVFNjaGVtYShwYXJhbWV0ZXIpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgVHlwZUd1YXJkLlRDb25zdHJ1Y3RvciA9IFRDb25zdHJ1Y3RvcjtcbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBzY2hlbWEgaXMgVERhdGUgKi9cbiAgICBmdW5jdGlvbiBURGF0ZShzY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIChUS2luZChzY2hlbWEpICYmXG4gICAgICAgICAgICBzY2hlbWFbZXhwb3J0cy5LaW5kXSA9PT0gJ0RhdGUnICYmXG4gICAgICAgICAgICBzY2hlbWEudHlwZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgIHNjaGVtYS5pbnN0YW5jZU9mID09PSAnRGF0ZScgJiZcbiAgICAgICAgICAgIElzT3B0aW9uYWxTdHJpbmcoc2NoZW1hLiRpZCkgJiZcbiAgICAgICAgICAgIElzT3B0aW9uYWxOdW1iZXIoc2NoZW1hLm1pbmltdW1UaW1lc3RhbXApICYmXG4gICAgICAgICAgICBJc09wdGlvbmFsTnVtYmVyKHNjaGVtYS5tYXhpbXVtVGltZXN0YW1wKSAmJlxuICAgICAgICAgICAgSXNPcHRpb25hbE51bWJlcihzY2hlbWEuZXhjbHVzaXZlTWluaW11bVRpbWVzdGFtcCkgJiZcbiAgICAgICAgICAgIElzT3B0aW9uYWxOdW1iZXIoc2NoZW1hLmV4Y2x1c2l2ZU1heGltdW1UaW1lc3RhbXApKTtcbiAgICB9XG4gICAgVHlwZUd1YXJkLlREYXRlID0gVERhdGU7XG4gICAgLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gc2NoZW1hIGlzIFRGdW5jdGlvbiAqL1xuICAgIGZ1bmN0aW9uIFRGdW5jdGlvbihzY2hlbWEpIHtcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIGlmICghKFRLaW5kKHNjaGVtYSkgJiZcbiAgICAgICAgICAgIHNjaGVtYVtleHBvcnRzLktpbmRdID09PSAnRnVuY3Rpb24nICYmXG4gICAgICAgICAgICBzY2hlbWEudHlwZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgIHNjaGVtYS5pbnN0YW5jZU9mID09PSAnRnVuY3Rpb24nICYmXG4gICAgICAgICAgICBJc09wdGlvbmFsU3RyaW5nKHNjaGVtYS4kaWQpICYmXG4gICAgICAgICAgICBJc0FycmF5KHNjaGVtYS5wYXJhbWV0ZXJzKSAmJlxuICAgICAgICAgICAgVFNjaGVtYShzY2hlbWEucmV0dXJucykpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBwYXJhbWV0ZXIgb2Ygc2NoZW1hLnBhcmFtZXRlcnMpIHtcbiAgICAgICAgICAgIGlmICghVFNjaGVtYShwYXJhbWV0ZXIpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgVHlwZUd1YXJkLlRGdW5jdGlvbiA9IFRGdW5jdGlvbjtcbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBzY2hlbWEgaXMgVEludGVnZXIgKi9cbiAgICBmdW5jdGlvbiBUSW50ZWdlcihzY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIChUS2luZChzY2hlbWEpICYmXG4gICAgICAgICAgICBzY2hlbWFbZXhwb3J0cy5LaW5kXSA9PT0gJ0ludGVnZXInICYmXG4gICAgICAgICAgICBzY2hlbWEudHlwZSA9PT0gJ2ludGVnZXInICYmXG4gICAgICAgICAgICBJc09wdGlvbmFsU3RyaW5nKHNjaGVtYS4kaWQpICYmXG4gICAgICAgICAgICBJc09wdGlvbmFsTnVtYmVyKHNjaGVtYS5tdWx0aXBsZU9mKSAmJlxuICAgICAgICAgICAgSXNPcHRpb25hbE51bWJlcihzY2hlbWEubWluaW11bSkgJiZcbiAgICAgICAgICAgIElzT3B0aW9uYWxOdW1iZXIoc2NoZW1hLm1heGltdW0pICYmXG4gICAgICAgICAgICBJc09wdGlvbmFsTnVtYmVyKHNjaGVtYS5leGNsdXNpdmVNaW5pbXVtKSAmJlxuICAgICAgICAgICAgSXNPcHRpb25hbE51bWJlcihzY2hlbWEuZXhjbHVzaXZlTWF4aW11bSkpO1xuICAgIH1cbiAgICBUeXBlR3VhcmQuVEludGVnZXIgPSBUSW50ZWdlcjtcbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBzY2hlbWEgaXMgVEludGVyc2VjdCAqL1xuICAgIGZ1bmN0aW9uIFRJbnRlcnNlY3Qoc2NoZW1hKSB7XG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICBpZiAoIShUS2luZChzY2hlbWEpICYmXG4gICAgICAgICAgICBzY2hlbWFbZXhwb3J0cy5LaW5kXSA9PT0gJ0ludGVyc2VjdCcgJiZcbiAgICAgICAgICAgIElzQXJyYXkoc2NoZW1hLmFsbE9mKSAmJlxuICAgICAgICAgICAgSXNPcHRpb25hbFN0cmluZyhzY2hlbWEudHlwZSkgJiZcbiAgICAgICAgICAgIChJc09wdGlvbmFsQm9vbGVhbihzY2hlbWEudW5ldmFsdWF0ZWRQcm9wZXJ0aWVzKSB8fCBJc09wdGlvbmFsU2NoZW1hKHNjaGVtYS51bmV2YWx1YXRlZFByb3BlcnRpZXMpKSAmJlxuICAgICAgICAgICAgSXNPcHRpb25hbFN0cmluZyhzY2hlbWEuJGlkKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoJ3R5cGUnIGluIHNjaGVtYSAmJiBzY2hlbWEudHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGlubmVyIG9mIHNjaGVtYS5hbGxPZikge1xuICAgICAgICAgICAgaWYgKCFUU2NoZW1hKGlubmVyKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIFR5cGVHdWFyZC5USW50ZXJzZWN0ID0gVEludGVyc2VjdDtcbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBzY2hlbWEgaXMgVEtpbmQgKi9cbiAgICBmdW5jdGlvbiBUS2luZChzY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIElzT2JqZWN0KHNjaGVtYSkgJiYgZXhwb3J0cy5LaW5kIGluIHNjaGVtYSAmJiB0eXBlb2Ygc2NoZW1hW2V4cG9ydHMuS2luZF0gPT09ICdzdHJpbmcnOyAvLyBUUyA0LjEuNTogYW55IHJlcXVpcmVkIGZvciBzeW1ib2wgaW5kZXhlclxuICAgIH1cbiAgICBUeXBlR3VhcmQuVEtpbmQgPSBUS2luZDtcbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBzY2hlbWEgaXMgVExpdGVyYWw8c3RyaW5nPiAqL1xuICAgIGZ1bmN0aW9uIFRMaXRlcmFsU3RyaW5nKHNjaGVtYSkge1xuICAgICAgICByZXR1cm4gVEtpbmQoc2NoZW1hKSAmJiBzY2hlbWFbZXhwb3J0cy5LaW5kXSA9PT0gJ0xpdGVyYWwnICYmIElzT3B0aW9uYWxTdHJpbmcoc2NoZW1hLiRpZCkgJiYgdHlwZW9mIHNjaGVtYS5jb25zdCA9PT0gJ3N0cmluZyc7XG4gICAgfVxuICAgIFR5cGVHdWFyZC5UTGl0ZXJhbFN0cmluZyA9IFRMaXRlcmFsU3RyaW5nO1xuICAgIC8qKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHNjaGVtYSBpcyBUTGl0ZXJhbDxudW1iZXI+ICovXG4gICAgZnVuY3Rpb24gVExpdGVyYWxOdW1iZXIoc2NoZW1hKSB7XG4gICAgICAgIHJldHVybiBUS2luZChzY2hlbWEpICYmIHNjaGVtYVtleHBvcnRzLktpbmRdID09PSAnTGl0ZXJhbCcgJiYgSXNPcHRpb25hbFN0cmluZyhzY2hlbWEuJGlkKSAmJiB0eXBlb2Ygc2NoZW1hLmNvbnN0ID09PSAnbnVtYmVyJztcbiAgICB9XG4gICAgVHlwZUd1YXJkLlRMaXRlcmFsTnVtYmVyID0gVExpdGVyYWxOdW1iZXI7XG4gICAgLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gc2NoZW1hIGlzIFRMaXRlcmFsPGJvb2xlYW4+ICovXG4gICAgZnVuY3Rpb24gVExpdGVyYWxCb29sZWFuKHNjaGVtYSkge1xuICAgICAgICByZXR1cm4gVEtpbmQoc2NoZW1hKSAmJiBzY2hlbWFbZXhwb3J0cy5LaW5kXSA9PT0gJ0xpdGVyYWwnICYmIElzT3B0aW9uYWxTdHJpbmcoc2NoZW1hLiRpZCkgJiYgdHlwZW9mIHNjaGVtYS5jb25zdCA9PT0gJ2Jvb2xlYW4nO1xuICAgIH1cbiAgICBUeXBlR3VhcmQuVExpdGVyYWxCb29sZWFuID0gVExpdGVyYWxCb29sZWFuO1xuICAgIC8qKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHNjaGVtYSBpcyBUTGl0ZXJhbCAqL1xuICAgIGZ1bmN0aW9uIFRMaXRlcmFsKHNjaGVtYSkge1xuICAgICAgICByZXR1cm4gVExpdGVyYWxTdHJpbmcoc2NoZW1hKSB8fCBUTGl0ZXJhbE51bWJlcihzY2hlbWEpIHx8IFRMaXRlcmFsQm9vbGVhbihzY2hlbWEpO1xuICAgIH1cbiAgICBUeXBlR3VhcmQuVExpdGVyYWwgPSBUTGl0ZXJhbDtcbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBzY2hlbWEgaXMgVE5ldmVyICovXG4gICAgZnVuY3Rpb24gVE5ldmVyKHNjaGVtYSkge1xuICAgICAgICByZXR1cm4gVEtpbmQoc2NoZW1hKSAmJiBzY2hlbWFbZXhwb3J0cy5LaW5kXSA9PT0gJ05ldmVyJyAmJiBJc09iamVjdChzY2hlbWEubm90KSAmJiBnbG9iYWxUaGlzLk9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHNjaGVtYS5ub3QpLmxlbmd0aCA9PT0gMDtcbiAgICB9XG4gICAgVHlwZUd1YXJkLlROZXZlciA9IFROZXZlcjtcbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBzY2hlbWEgaXMgVE5vdCAqL1xuICAgIGZ1bmN0aW9uIFROb3Qoc2NoZW1hKSB7XG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICByZXR1cm4gKFRLaW5kKHNjaGVtYSkgJiZcbiAgICAgICAgICAgIHNjaGVtYVtleHBvcnRzLktpbmRdID09PSAnTm90JyAmJlxuICAgICAgICAgICAgSXNBcnJheShzY2hlbWEuYWxsT2YpICYmXG4gICAgICAgICAgICBzY2hlbWEuYWxsT2YubGVuZ3RoID09PSAyICYmXG4gICAgICAgICAgICBJc09iamVjdChzY2hlbWEuYWxsT2ZbMF0pICYmXG4gICAgICAgICAgICBUU2NoZW1hKHNjaGVtYS5hbGxPZlswXS5ub3QpICYmXG4gICAgICAgICAgICBUU2NoZW1hKHNjaGVtYS5hbGxPZlsxXSkpO1xuICAgIH1cbiAgICBUeXBlR3VhcmQuVE5vdCA9IFROb3Q7XG4gICAgLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gc2NoZW1hIGlzIFROdWxsICovXG4gICAgZnVuY3Rpb24gVE51bGwoc2NoZW1hKSB7XG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICByZXR1cm4gKFRLaW5kKHNjaGVtYSkgJiZcbiAgICAgICAgICAgIHNjaGVtYVtleHBvcnRzLktpbmRdID09PSAnTnVsbCcgJiZcbiAgICAgICAgICAgIHNjaGVtYS50eXBlID09PSAnbnVsbCcgJiZcbiAgICAgICAgICAgIElzT3B0aW9uYWxTdHJpbmcoc2NoZW1hLiRpZCkpO1xuICAgIH1cbiAgICBUeXBlR3VhcmQuVE51bGwgPSBUTnVsbDtcbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBzY2hlbWEgaXMgVE51bWJlciAqL1xuICAgIGZ1bmN0aW9uIFROdW1iZXIoc2NoZW1hKSB7XG4gICAgICAgIHJldHVybiAoVEtpbmQoc2NoZW1hKSAmJlxuICAgICAgICAgICAgc2NoZW1hW2V4cG9ydHMuS2luZF0gPT09ICdOdW1iZXInICYmXG4gICAgICAgICAgICBzY2hlbWEudHlwZSA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgICAgIElzT3B0aW9uYWxTdHJpbmcoc2NoZW1hLiRpZCkgJiZcbiAgICAgICAgICAgIElzT3B0aW9uYWxOdW1iZXIoc2NoZW1hLm11bHRpcGxlT2YpICYmXG4gICAgICAgICAgICBJc09wdGlvbmFsTnVtYmVyKHNjaGVtYS5taW5pbXVtKSAmJlxuICAgICAgICAgICAgSXNPcHRpb25hbE51bWJlcihzY2hlbWEubWF4aW11bSkgJiZcbiAgICAgICAgICAgIElzT3B0aW9uYWxOdW1iZXIoc2NoZW1hLmV4Y2x1c2l2ZU1pbmltdW0pICYmXG4gICAgICAgICAgICBJc09wdGlvbmFsTnVtYmVyKHNjaGVtYS5leGNsdXNpdmVNYXhpbXVtKSk7XG4gICAgfVxuICAgIFR5cGVHdWFyZC5UTnVtYmVyID0gVE51bWJlcjtcbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBzY2hlbWEgaXMgVE9iamVjdCAqL1xuICAgIGZ1bmN0aW9uIFRPYmplY3Qoc2NoZW1hKSB7XG4gICAgICAgIGlmICghKFRLaW5kKHNjaGVtYSkgJiZcbiAgICAgICAgICAgIHNjaGVtYVtleHBvcnRzLktpbmRdID09PSAnT2JqZWN0JyAmJlxuICAgICAgICAgICAgc2NoZW1hLnR5cGUgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICBJc09wdGlvbmFsU3RyaW5nKHNjaGVtYS4kaWQpICYmXG4gICAgICAgICAgICBJc09iamVjdChzY2hlbWEucHJvcGVydGllcykgJiZcbiAgICAgICAgICAgIElzQWRkaXRpb25hbFByb3BlcnRpZXMoc2NoZW1hLmFkZGl0aW9uYWxQcm9wZXJ0aWVzKSAmJlxuICAgICAgICAgICAgSXNPcHRpb25hbE51bWJlcihzY2hlbWEubWluUHJvcGVydGllcykgJiZcbiAgICAgICAgICAgIElzT3B0aW9uYWxOdW1iZXIoc2NoZW1hLm1heFByb3BlcnRpZXMpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHNjaGVtYS5wcm9wZXJ0aWVzKSkge1xuICAgICAgICAgICAgaWYgKCFJc0NvbnRyb2xDaGFyYWN0ZXJGcmVlKGtleSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgaWYgKCFUU2NoZW1hKHZhbHVlKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIFR5cGVHdWFyZC5UT2JqZWN0ID0gVE9iamVjdDtcbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBzY2hlbWEgaXMgVFByb21pc2UgKi9cbiAgICBmdW5jdGlvbiBUUHJvbWlzZShzY2hlbWEpIHtcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIHJldHVybiAoVEtpbmQoc2NoZW1hKSAmJlxuICAgICAgICAgICAgc2NoZW1hW2V4cG9ydHMuS2luZF0gPT09ICdQcm9taXNlJyAmJlxuICAgICAgICAgICAgc2NoZW1hLnR5cGUgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICBzY2hlbWEuaW5zdGFuY2VPZiA9PT0gJ1Byb21pc2UnICYmXG4gICAgICAgICAgICBJc09wdGlvbmFsU3RyaW5nKHNjaGVtYS4kaWQpICYmXG4gICAgICAgICAgICBUU2NoZW1hKHNjaGVtYS5pdGVtKSk7XG4gICAgfVxuICAgIFR5cGVHdWFyZC5UUHJvbWlzZSA9IFRQcm9taXNlO1xuICAgIC8qKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHNjaGVtYSBpcyBUUmVjb3JkICovXG4gICAgZnVuY3Rpb24gVFJlY29yZChzY2hlbWEpIHtcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIGlmICghKFRLaW5kKHNjaGVtYSkgJiZcbiAgICAgICAgICAgIHNjaGVtYVtleHBvcnRzLktpbmRdID09PSAnUmVjb3JkJyAmJlxuICAgICAgICAgICAgc2NoZW1hLnR5cGUgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICBJc09wdGlvbmFsU3RyaW5nKHNjaGVtYS4kaWQpICYmXG4gICAgICAgICAgICBJc0FkZGl0aW9uYWxQcm9wZXJ0aWVzKHNjaGVtYS5hZGRpdGlvbmFsUHJvcGVydGllcykgJiZcbiAgICAgICAgICAgIElzT2JqZWN0KHNjaGVtYS5wYXR0ZXJuUHJvcGVydGllcykpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHNjaGVtYS5wYXR0ZXJuUHJvcGVydGllcyk7XG4gICAgICAgIGlmIChrZXlzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghSXNQYXR0ZXJuKGtleXNbMF0pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFUU2NoZW1hKHNjaGVtYS5wYXR0ZXJuUHJvcGVydGllc1trZXlzWzBdXSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgVHlwZUd1YXJkLlRSZWNvcmQgPSBUUmVjb3JkO1xuICAgIC8qKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHNjaGVtYSBpcyBUUmVmICovXG4gICAgZnVuY3Rpb24gVFJlZihzY2hlbWEpIHtcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIHJldHVybiAoVEtpbmQoc2NoZW1hKSAmJlxuICAgICAgICAgICAgc2NoZW1hW2V4cG9ydHMuS2luZF0gPT09ICdSZWYnICYmXG4gICAgICAgICAgICBJc09wdGlvbmFsU3RyaW5nKHNjaGVtYS4kaWQpICYmXG4gICAgICAgICAgICBJc1N0cmluZyhzY2hlbWEuJHJlZikpO1xuICAgIH1cbiAgICBUeXBlR3VhcmQuVFJlZiA9IFRSZWY7XG4gICAgLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gc2NoZW1hIGlzIFRTdHJpbmcgKi9cbiAgICBmdW5jdGlvbiBUU3RyaW5nKHNjaGVtYSkge1xuICAgICAgICByZXR1cm4gKFRLaW5kKHNjaGVtYSkgJiZcbiAgICAgICAgICAgIHNjaGVtYVtleHBvcnRzLktpbmRdID09PSAnU3RyaW5nJyAmJlxuICAgICAgICAgICAgc2NoZW1hLnR5cGUgPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgICBJc09wdGlvbmFsU3RyaW5nKHNjaGVtYS4kaWQpICYmXG4gICAgICAgICAgICBJc09wdGlvbmFsTnVtYmVyKHNjaGVtYS5taW5MZW5ndGgpICYmXG4gICAgICAgICAgICBJc09wdGlvbmFsTnVtYmVyKHNjaGVtYS5tYXhMZW5ndGgpICYmXG4gICAgICAgICAgICBJc09wdGlvbmFsUGF0dGVybihzY2hlbWEucGF0dGVybikgJiZcbiAgICAgICAgICAgIElzT3B0aW9uYWxGb3JtYXQoc2NoZW1hLmZvcm1hdCkpO1xuICAgIH1cbiAgICBUeXBlR3VhcmQuVFN0cmluZyA9IFRTdHJpbmc7XG4gICAgLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gc2NoZW1hIGlzIFRTeW1ib2wgKi9cbiAgICBmdW5jdGlvbiBUU3ltYm9sKHNjaGVtYSkge1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgcmV0dXJuIChUS2luZChzY2hlbWEpICYmXG4gICAgICAgICAgICBzY2hlbWFbZXhwb3J0cy5LaW5kXSA9PT0gJ1N5bWJvbCcgJiZcbiAgICAgICAgICAgIHNjaGVtYS50eXBlID09PSAnbnVsbCcgJiZcbiAgICAgICAgICAgIHNjaGVtYS50eXBlT2YgPT09ICdTeW1ib2wnICYmXG4gICAgICAgICAgICBJc09wdGlvbmFsU3RyaW5nKHNjaGVtYS4kaWQpKTtcbiAgICB9XG4gICAgVHlwZUd1YXJkLlRTeW1ib2wgPSBUU3ltYm9sO1xuICAgIC8qKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHNjaGVtYSBpcyBUVGVtcGxhdGVMaXRlcmFsICovXG4gICAgZnVuY3Rpb24gVFRlbXBsYXRlTGl0ZXJhbChzY2hlbWEpIHtcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIHJldHVybiAoVEtpbmQoc2NoZW1hKSAmJlxuICAgICAgICAgICAgc2NoZW1hW2V4cG9ydHMuS2luZF0gPT09ICdUZW1wbGF0ZUxpdGVyYWwnICYmXG4gICAgICAgICAgICBzY2hlbWEudHlwZSA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgICAgIElzU3RyaW5nKHNjaGVtYS5wYXR0ZXJuKSAmJlxuICAgICAgICAgICAgc2NoZW1hLnBhdHRlcm5bMF0gPT09ICdeJyAmJlxuICAgICAgICAgICAgc2NoZW1hLnBhdHRlcm5bc2NoZW1hLnBhdHRlcm4ubGVuZ3RoIC0gMV0gPT09ICckJyk7XG4gICAgfVxuICAgIFR5cGVHdWFyZC5UVGVtcGxhdGVMaXRlcmFsID0gVFRlbXBsYXRlTGl0ZXJhbDtcbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBzY2hlbWEgaXMgVFRoaXMgKi9cbiAgICBmdW5jdGlvbiBUVGhpcyhzY2hlbWEpIHtcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIHJldHVybiAoVEtpbmQoc2NoZW1hKSAmJlxuICAgICAgICAgICAgc2NoZW1hW2V4cG9ydHMuS2luZF0gPT09ICdUaGlzJyAmJlxuICAgICAgICAgICAgSXNPcHRpb25hbFN0cmluZyhzY2hlbWEuJGlkKSAmJlxuICAgICAgICAgICAgSXNTdHJpbmcoc2NoZW1hLiRyZWYpKTtcbiAgICB9XG4gICAgVHlwZUd1YXJkLlRUaGlzID0gVFRoaXM7XG4gICAgLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gc2NoZW1hIGlzIFRUdXBsZSAqL1xuICAgIGZ1bmN0aW9uIFRUdXBsZShzY2hlbWEpIHtcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIGlmICghKFRLaW5kKHNjaGVtYSkgJiZcbiAgICAgICAgICAgIHNjaGVtYVtleHBvcnRzLktpbmRdID09PSAnVHVwbGUnICYmXG4gICAgICAgICAgICBzY2hlbWEudHlwZSA9PT0gJ2FycmF5JyAmJlxuICAgICAgICAgICAgSXNPcHRpb25hbFN0cmluZyhzY2hlbWEuJGlkKSAmJlxuICAgICAgICAgICAgSXNOdW1iZXIoc2NoZW1hLm1pbkl0ZW1zKSAmJlxuICAgICAgICAgICAgSXNOdW1iZXIoc2NoZW1hLm1heEl0ZW1zKSAmJlxuICAgICAgICAgICAgc2NoZW1hLm1pbkl0ZW1zID09PSBzY2hlbWEubWF4SXRlbXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNjaGVtYS5pdGVtcyA9PT0gdW5kZWZpbmVkICYmIHNjaGVtYS5hZGRpdGlvbmFsSXRlbXMgPT09IHVuZGVmaW5lZCAmJiBzY2hlbWEubWluSXRlbXMgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghSXNBcnJheShzY2hlbWEuaXRlbXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBpbm5lciBvZiBzY2hlbWEuaXRlbXMpIHtcbiAgICAgICAgICAgIGlmICghVFNjaGVtYShpbm5lcikpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBUeXBlR3VhcmQuVFR1cGxlID0gVFR1cGxlO1xuICAgIC8qKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHNjaGVtYSBpcyBUVW5kZWZpbmVkICovXG4gICAgZnVuY3Rpb24gVFVuZGVmaW5lZChzY2hlbWEpIHtcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIHJldHVybiAoVEtpbmQoc2NoZW1hKSAmJlxuICAgICAgICAgICAgc2NoZW1hW2V4cG9ydHMuS2luZF0gPT09ICdVbmRlZmluZWQnICYmXG4gICAgICAgICAgICBzY2hlbWEudHlwZSA9PT0gJ251bGwnICYmXG4gICAgICAgICAgICBzY2hlbWEudHlwZU9mID09PSAnVW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgSXNPcHRpb25hbFN0cmluZyhzY2hlbWEuJGlkKSk7XG4gICAgfVxuICAgIFR5cGVHdWFyZC5UVW5kZWZpbmVkID0gVFVuZGVmaW5lZDtcbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBzY2hlbWEgaXMgVFVuaW9uPExpdGVyYWw8c3RyaW5nIHwgbnVtYmVyPltdPiAqL1xuICAgIGZ1bmN0aW9uIFRVbmlvbkxpdGVyYWwoc2NoZW1hKSB7XG4gICAgICAgIHJldHVybiBUVW5pb24oc2NoZW1hKSAmJiBzY2hlbWEuYW55T2YuZXZlcnkoKHNjaGVtYSkgPT4gVExpdGVyYWxTdHJpbmcoc2NoZW1hKSB8fCBUTGl0ZXJhbE51bWJlcihzY2hlbWEpKTtcbiAgICB9XG4gICAgVHlwZUd1YXJkLlRVbmlvbkxpdGVyYWwgPSBUVW5pb25MaXRlcmFsO1xuICAgIC8qKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHNjaGVtYSBpcyBUVW5pb24gKi9cbiAgICBmdW5jdGlvbiBUVW5pb24oc2NoZW1hKSB7XG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICBpZiAoIShUS2luZChzY2hlbWEpICYmXG4gICAgICAgICAgICBzY2hlbWFbZXhwb3J0cy5LaW5kXSA9PT0gJ1VuaW9uJyAmJlxuICAgICAgICAgICAgSXNBcnJheShzY2hlbWEuYW55T2YpICYmXG4gICAgICAgICAgICBJc09wdGlvbmFsU3RyaW5nKHNjaGVtYS4kaWQpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgaW5uZXIgb2Ygc2NoZW1hLmFueU9mKSB7XG4gICAgICAgICAgICBpZiAoIVRTY2hlbWEoaW5uZXIpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgVHlwZUd1YXJkLlRVbmlvbiA9IFRVbmlvbjtcbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBzY2hlbWEgaXMgVFVpbnQ4QXJyYXkgKi9cbiAgICBmdW5jdGlvbiBUVWludDhBcnJheShzY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIFRLaW5kKHNjaGVtYSkgJiYgc2NoZW1hW2V4cG9ydHMuS2luZF0gPT09ICdVaW50OEFycmF5JyAmJiBzY2hlbWEudHlwZSA9PT0gJ29iamVjdCcgJiYgSXNPcHRpb25hbFN0cmluZyhzY2hlbWEuJGlkKSAmJiBzY2hlbWEuaW5zdGFuY2VPZiA9PT0gJ1VpbnQ4QXJyYXknICYmIElzT3B0aW9uYWxOdW1iZXIoc2NoZW1hLm1pbkJ5dGVMZW5ndGgpICYmIElzT3B0aW9uYWxOdW1iZXIoc2NoZW1hLm1heEJ5dGVMZW5ndGgpO1xuICAgIH1cbiAgICBUeXBlR3VhcmQuVFVpbnQ4QXJyYXkgPSBUVWludDhBcnJheTtcbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBzY2hlbWEgaXMgVFVua25vd24gKi9cbiAgICBmdW5jdGlvbiBUVW5rbm93bihzY2hlbWEpIHtcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIHJldHVybiAoVEtpbmQoc2NoZW1hKSAmJlxuICAgICAgICAgICAgc2NoZW1hW2V4cG9ydHMuS2luZF0gPT09ICdVbmtub3duJyAmJlxuICAgICAgICAgICAgSXNPcHRpb25hbFN0cmluZyhzY2hlbWEuJGlkKSk7XG4gICAgfVxuICAgIFR5cGVHdWFyZC5UVW5rbm93biA9IFRVbmtub3duO1xuICAgIC8qKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHNjaGVtYSBpcyBhIHJhdyBUVW5zYWZlICovXG4gICAgZnVuY3Rpb24gVFVuc2FmZShzY2hlbWEpIHtcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIHJldHVybiAoVEtpbmQoc2NoZW1hKSAmJlxuICAgICAgICAgICAgc2NoZW1hW2V4cG9ydHMuS2luZF0gPT09ICdVbnNhZmUnKTtcbiAgICB9XG4gICAgVHlwZUd1YXJkLlRVbnNhZmUgPSBUVW5zYWZlO1xuICAgIC8qKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHNjaGVtYSBpcyBUVm9pZCAqL1xuICAgIGZ1bmN0aW9uIFRWb2lkKHNjaGVtYSkge1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgcmV0dXJuIChUS2luZChzY2hlbWEpICYmXG4gICAgICAgICAgICBzY2hlbWFbZXhwb3J0cy5LaW5kXSA9PT0gJ1ZvaWQnICYmXG4gICAgICAgICAgICBzY2hlbWEudHlwZSA9PT0gJ251bGwnICYmXG4gICAgICAgICAgICBzY2hlbWEudHlwZU9mID09PSAnVm9pZCcgJiZcbiAgICAgICAgICAgIElzT3B0aW9uYWxTdHJpbmcoc2NoZW1hLiRpZCkpO1xuICAgIH1cbiAgICBUeXBlR3VhcmQuVFZvaWQgPSBUVm9pZDtcbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIHRoaXMgc2NoZW1hIGhhcyB0aGUgUmVhZG9ubHlPcHRpb25hbCBtb2RpZmllciAqL1xuICAgIGZ1bmN0aW9uIFRSZWFkb25seU9wdGlvbmFsKHNjaGVtYSkge1xuICAgICAgICByZXR1cm4gSXNPYmplY3Qoc2NoZW1hKSAmJiBzY2hlbWFbZXhwb3J0cy5Nb2RpZmllcl0gPT09ICdSZWFkb25seU9wdGlvbmFsJztcbiAgICB9XG4gICAgVHlwZUd1YXJkLlRSZWFkb25seU9wdGlvbmFsID0gVFJlYWRvbmx5T3B0aW9uYWw7XG4gICAgLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIHNjaGVtYSBoYXMgdGhlIFJlYWRvbmx5IG1vZGlmaWVyICovXG4gICAgZnVuY3Rpb24gVFJlYWRvbmx5KHNjaGVtYSkge1xuICAgICAgICByZXR1cm4gSXNPYmplY3Qoc2NoZW1hKSAmJiBzY2hlbWFbZXhwb3J0cy5Nb2RpZmllcl0gPT09ICdSZWFkb25seSc7XG4gICAgfVxuICAgIFR5cGVHdWFyZC5UUmVhZG9ubHkgPSBUUmVhZG9ubHk7XG4gICAgLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIHNjaGVtYSBoYXMgdGhlIE9wdGlvbmFsIG1vZGlmaWVyICovXG4gICAgZnVuY3Rpb24gVE9wdGlvbmFsKHNjaGVtYSkge1xuICAgICAgICByZXR1cm4gSXNPYmplY3Qoc2NoZW1hKSAmJiBzY2hlbWFbZXhwb3J0cy5Nb2RpZmllcl0gPT09ICdPcHRpb25hbCc7XG4gICAgfVxuICAgIFR5cGVHdWFyZC5UT3B0aW9uYWwgPSBUT3B0aW9uYWw7XG4gICAgLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gc2NoZW1hIGlzIFRTY2hlbWEgKi9cbiAgICBmdW5jdGlvbiBUU2NoZW1hKHNjaGVtYSkge1xuICAgICAgICByZXR1cm4gKHR5cGVvZiBzY2hlbWEgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICAoVEFueShzY2hlbWEpIHx8XG4gICAgICAgICAgICAgICAgVEFycmF5KHNjaGVtYSkgfHxcbiAgICAgICAgICAgICAgICBUQm9vbGVhbihzY2hlbWEpIHx8XG4gICAgICAgICAgICAgICAgVEJpZ0ludChzY2hlbWEpIHx8XG4gICAgICAgICAgICAgICAgVENvbnN0cnVjdG9yKHNjaGVtYSkgfHxcbiAgICAgICAgICAgICAgICBURGF0ZShzY2hlbWEpIHx8XG4gICAgICAgICAgICAgICAgVEZ1bmN0aW9uKHNjaGVtYSkgfHxcbiAgICAgICAgICAgICAgICBUSW50ZWdlcihzY2hlbWEpIHx8XG4gICAgICAgICAgICAgICAgVEludGVyc2VjdChzY2hlbWEpIHx8XG4gICAgICAgICAgICAgICAgVExpdGVyYWwoc2NoZW1hKSB8fFxuICAgICAgICAgICAgICAgIFROZXZlcihzY2hlbWEpIHx8XG4gICAgICAgICAgICAgICAgVE5vdChzY2hlbWEpIHx8XG4gICAgICAgICAgICAgICAgVE51bGwoc2NoZW1hKSB8fFxuICAgICAgICAgICAgICAgIFROdW1iZXIoc2NoZW1hKSB8fFxuICAgICAgICAgICAgICAgIFRPYmplY3Qoc2NoZW1hKSB8fFxuICAgICAgICAgICAgICAgIFRQcm9taXNlKHNjaGVtYSkgfHxcbiAgICAgICAgICAgICAgICBUUmVjb3JkKHNjaGVtYSkgfHxcbiAgICAgICAgICAgICAgICBUUmVmKHNjaGVtYSkgfHxcbiAgICAgICAgICAgICAgICBUU3RyaW5nKHNjaGVtYSkgfHxcbiAgICAgICAgICAgICAgICBUU3ltYm9sKHNjaGVtYSkgfHxcbiAgICAgICAgICAgICAgICBUVGVtcGxhdGVMaXRlcmFsKHNjaGVtYSkgfHxcbiAgICAgICAgICAgICAgICBUVGhpcyhzY2hlbWEpIHx8XG4gICAgICAgICAgICAgICAgVFR1cGxlKHNjaGVtYSkgfHxcbiAgICAgICAgICAgICAgICBUVW5kZWZpbmVkKHNjaGVtYSkgfHxcbiAgICAgICAgICAgICAgICBUVW5pb24oc2NoZW1hKSB8fFxuICAgICAgICAgICAgICAgIFRVaW50OEFycmF5KHNjaGVtYSkgfHxcbiAgICAgICAgICAgICAgICBUVW5rbm93bihzY2hlbWEpIHx8XG4gICAgICAgICAgICAgICAgVFVuc2FmZShzY2hlbWEpIHx8XG4gICAgICAgICAgICAgICAgVFZvaWQoc2NoZW1hKSB8fFxuICAgICAgICAgICAgICAgIChUS2luZChzY2hlbWEpICYmIFR5cGVSZWdpc3RyeS5IYXMoc2NoZW1hW2V4cG9ydHMuS2luZF0pKSkpO1xuICAgIH1cbiAgICBUeXBlR3VhcmQuVFNjaGVtYSA9IFRTY2hlbWE7XG59KShUeXBlR3VhcmQgfHwgKGV4cG9ydHMuVHlwZUd1YXJkID0gVHlwZUd1YXJkID0ge30pKTtcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBFeHRlbmRzVW5kZWZpbmVkXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLyoqIEZhc3QgdW5kZWZpbmVkIGNoZWNrIHVzZWQgZm9yIHByb3BlcnRpZXMgb2YgdHlwZSB1bmRlZmluZWQgKi9cbnZhciBFeHRlbmRzVW5kZWZpbmVkO1xuKGZ1bmN0aW9uIChFeHRlbmRzVW5kZWZpbmVkKSB7XG4gICAgZnVuY3Rpb24gQ2hlY2soc2NoZW1hKSB7XG4gICAgICAgIGlmIChzY2hlbWFbZXhwb3J0cy5LaW5kXSA9PT0gJ1VuZGVmaW5lZCcpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKHNjaGVtYVtleHBvcnRzLktpbmRdID09PSAnTm90Jykge1xuICAgICAgICAgICAgY29uc3Qgbm90ID0gc2NoZW1hO1xuICAgICAgICAgICAgcmV0dXJuIENoZWNrKG5vdC5hbGxPZlsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNjaGVtYVtleHBvcnRzLktpbmRdID09PSAnSW50ZXJzZWN0Jykge1xuICAgICAgICAgICAgY29uc3QgaW50ZXJzZWN0ID0gc2NoZW1hO1xuICAgICAgICAgICAgcmV0dXJuIGludGVyc2VjdC5hbGxPZi5ldmVyeSgoc2NoZW1hKSA9PiBDaGVjayhzY2hlbWEpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2NoZW1hW2V4cG9ydHMuS2luZF0gPT09ICdVbmlvbicpIHtcbiAgICAgICAgICAgIGNvbnN0IHVuaW9uID0gc2NoZW1hO1xuICAgICAgICAgICAgcmV0dXJuIHVuaW9uLmFueU9mLnNvbWUoKHNjaGVtYSkgPT4gQ2hlY2soc2NoZW1hKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBFeHRlbmRzVW5kZWZpbmVkLkNoZWNrID0gQ2hlY2s7XG59KShFeHRlbmRzVW5kZWZpbmVkIHx8IChleHBvcnRzLkV4dGVuZHNVbmRlZmluZWQgPSBFeHRlbmRzVW5kZWZpbmVkID0ge30pKTtcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBUeXBlRXh0ZW5kc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbnZhciBUeXBlRXh0ZW5kc1Jlc3VsdDtcbihmdW5jdGlvbiAoVHlwZUV4dGVuZHNSZXN1bHQpIHtcbiAgICBUeXBlRXh0ZW5kc1Jlc3VsdFtUeXBlRXh0ZW5kc1Jlc3VsdFtcIlVuaW9uXCJdID0gMF0gPSBcIlVuaW9uXCI7XG4gICAgVHlwZUV4dGVuZHNSZXN1bHRbVHlwZUV4dGVuZHNSZXN1bHRbXCJUcnVlXCJdID0gMV0gPSBcIlRydWVcIjtcbiAgICBUeXBlRXh0ZW5kc1Jlc3VsdFtUeXBlRXh0ZW5kc1Jlc3VsdFtcIkZhbHNlXCJdID0gMl0gPSBcIkZhbHNlXCI7XG59KShUeXBlRXh0ZW5kc1Jlc3VsdCB8fCAoZXhwb3J0cy5UeXBlRXh0ZW5kc1Jlc3VsdCA9IFR5cGVFeHRlbmRzUmVzdWx0ID0ge30pKTtcbnZhciBUeXBlRXh0ZW5kcztcbihmdW5jdGlvbiAoVHlwZUV4dGVuZHMpIHtcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIEludG9Cb29sZWFuUmVzdWx0XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBmdW5jdGlvbiBJbnRvQm9vbGVhblJlc3VsdChyZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gVHlwZUV4dGVuZHNSZXN1bHQuRmFsc2UgPyBUeXBlRXh0ZW5kc1Jlc3VsdC5GYWxzZSA6IFR5cGVFeHRlbmRzUmVzdWx0LlRydWU7XG4gICAgfVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gQW55XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBmdW5jdGlvbiBBbnlSaWdodChsZWZ0LCByaWdodCkge1xuICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gQW55KGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVEludGVyc2VjdChyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gSW50ZXJzZWN0UmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRVbmlvbihyaWdodCkgJiYgcmlnaHQuYW55T2Yuc29tZSgoc2NoZW1hKSA9PiBUeXBlR3VhcmQuVEFueShzY2hlbWEpIHx8IFR5cGVHdWFyZC5UVW5rbm93bihzY2hlbWEpKSlcbiAgICAgICAgICAgIHJldHVybiBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRVbmlvbihyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuVW5pb247XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFVua25vd24ocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LlRydWU7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVEFueShyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZTtcbiAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LlVuaW9uO1xuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIEFycmF5XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBmdW5jdGlvbiBBcnJheVJpZ2h0KGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFVua25vd24obGVmdCkpXG4gICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuRmFsc2U7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVEFueShsZWZ0KSlcbiAgICAgICAgICAgIHJldHVybiBUeXBlRXh0ZW5kc1Jlc3VsdC5VbmlvbjtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UTmV2ZXIobGVmdCkpXG4gICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZTtcbiAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBBcnJheShsZWZ0LCByaWdodCkge1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRJbnRlcnNlY3QocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIEludGVyc2VjdFJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVW5pb24ocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFVuaW9uUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRVbmtub3duKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBVbmtub3duUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRBbnkocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIEFueVJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UT2JqZWN0KHJpZ2h0KSAmJiBJc09iamVjdEFycmF5TGlrZShyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZTtcbiAgICAgICAgaWYgKCFUeXBlR3VhcmQuVEFycmF5KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBUeXBlRXh0ZW5kc1Jlc3VsdC5GYWxzZTtcbiAgICAgICAgcmV0dXJuIEludG9Cb29sZWFuUmVzdWx0KFZpc2l0KGxlZnQuaXRlbXMsIHJpZ2h0Lml0ZW1zKSk7XG4gICAgfVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gQmlnSW50XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBmdW5jdGlvbiBCaWdJbnQobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5USW50ZXJzZWN0KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBJbnRlcnNlY3RSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFVuaW9uKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBVbmlvblJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UTmV2ZXIocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIE5ldmVyUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRVbmtub3duKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBVbmtub3duUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRBbnkocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIEFueVJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UT2JqZWN0KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBPYmplY3RSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFJlY29yZChyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gUmVjb3JkUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICByZXR1cm4gVHlwZUd1YXJkLlRCaWdJbnQocmlnaHQpID8gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZSA6IFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlO1xuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIEJvb2xlYW5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGZ1bmN0aW9uIEJvb2xlYW5SaWdodChsZWZ0LCByaWdodCkge1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRMaXRlcmFsKGxlZnQpICYmIHR5cGVvZiBsZWZ0LmNvbnN0ID09PSAnYm9vbGVhbicpXG4gICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZTtcbiAgICAgICAgcmV0dXJuIFR5cGVHdWFyZC5UQm9vbGVhbihsZWZ0KSA/IFR5cGVFeHRlbmRzUmVzdWx0LlRydWUgOiBUeXBlRXh0ZW5kc1Jlc3VsdC5GYWxzZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gQm9vbGVhbihsZWZ0LCByaWdodCkge1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRJbnRlcnNlY3QocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIEludGVyc2VjdFJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVW5pb24ocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFVuaW9uUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlROZXZlcihyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gTmV2ZXJSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFVua25vd24ocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFVua25vd25SaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVEFueShyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gQW55UmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRPYmplY3QocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdFJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UUmVjb3JkKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBSZWNvcmRSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIHJldHVybiBUeXBlR3VhcmQuVEJvb2xlYW4ocmlnaHQpID8gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZSA6IFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlO1xuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIENvbnN0cnVjdG9yXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBmdW5jdGlvbiBDb25zdHJ1Y3RvcihsZWZ0LCByaWdodCkge1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRJbnRlcnNlY3QocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIEludGVyc2VjdFJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVW5pb24ocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFVuaW9uUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRVbmtub3duKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBVbmtub3duUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRBbnkocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIEFueVJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UT2JqZWN0KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBPYmplY3RSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmICghVHlwZUd1YXJkLlRDb25zdHJ1Y3RvcihyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuRmFsc2U7XG4gICAgICAgIGlmIChsZWZ0LnBhcmFtZXRlcnMubGVuZ3RoID4gcmlnaHQucGFyYW1ldGVycy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuRmFsc2U7XG4gICAgICAgIGlmICghbGVmdC5wYXJhbWV0ZXJzLmV2ZXJ5KChzY2hlbWEsIGluZGV4KSA9PiBJbnRvQm9vbGVhblJlc3VsdChWaXNpdChyaWdodC5wYXJhbWV0ZXJzW2luZGV4XSwgc2NoZW1hKSkgPT09IFR5cGVFeHRlbmRzUmVzdWx0LlRydWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuRmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEludG9Cb29sZWFuUmVzdWx0KFZpc2l0KGxlZnQucmV0dXJucywgcmlnaHQucmV0dXJucykpO1xuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIERhdGVcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGZ1bmN0aW9uIERhdGUobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5USW50ZXJzZWN0KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBJbnRlcnNlY3RSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFVuaW9uKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBVbmlvblJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVW5rbm93bihyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVW5rbm93blJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UQW55KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBBbnlSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVE9iamVjdChyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0UmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRSZWNvcmQocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFJlY29yZFJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgcmV0dXJuIFR5cGVHdWFyZC5URGF0ZShyaWdodCkgPyBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlIDogVHlwZUV4dGVuZHNSZXN1bHQuRmFsc2U7XG4gICAgfVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gRnVuY3Rpb25cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGZ1bmN0aW9uIEZ1bmN0aW9uKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVEludGVyc2VjdChyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gSW50ZXJzZWN0UmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRVbmlvbihyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVW5pb25SaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFVua25vd24ocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFVua25vd25SaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVEFueShyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gQW55UmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRPYmplY3QocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdFJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKCFUeXBlR3VhcmQuVEZ1bmN0aW9uKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBUeXBlRXh0ZW5kc1Jlc3VsdC5GYWxzZTtcbiAgICAgICAgaWYgKGxlZnQucGFyYW1ldGVycy5sZW5ndGggPiByaWdodC5wYXJhbWV0ZXJzLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBUeXBlRXh0ZW5kc1Jlc3VsdC5GYWxzZTtcbiAgICAgICAgaWYgKCFsZWZ0LnBhcmFtZXRlcnMuZXZlcnkoKHNjaGVtYSwgaW5kZXgpID0+IEludG9Cb29sZWFuUmVzdWx0KFZpc2l0KHJpZ2h0LnBhcmFtZXRlcnNbaW5kZXhdLCBzY2hlbWEpKSA9PT0gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBUeXBlRXh0ZW5kc1Jlc3VsdC5GYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gSW50b0Jvb2xlYW5SZXN1bHQoVmlzaXQobGVmdC5yZXR1cm5zLCByaWdodC5yZXR1cm5zKSk7XG4gICAgfVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gSW50ZWdlclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZnVuY3Rpb24gSW50ZWdlclJpZ2h0KGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVExpdGVyYWwobGVmdCkgJiYgdHlwZW9mIGxlZnQuY29uc3QgPT09ICdudW1iZXInKVxuICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LlRydWU7XG4gICAgICAgIHJldHVybiBUeXBlR3VhcmQuVE51bWJlcihsZWZ0KSB8fCBUeXBlR3VhcmQuVEludGVnZXIobGVmdCkgPyBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlIDogVHlwZUV4dGVuZHNSZXN1bHQuRmFsc2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIEludGVnZXIobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5USW50ZXJzZWN0KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBJbnRlcnNlY3RSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFVuaW9uKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBVbmlvblJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UTmV2ZXIocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIE5ldmVyUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRVbmtub3duKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBVbmtub3duUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRBbnkocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIEFueVJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UT2JqZWN0KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBPYmplY3RSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFJlY29yZChyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gUmVjb3JkUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICByZXR1cm4gVHlwZUd1YXJkLlRJbnRlZ2VyKHJpZ2h0KSB8fCBUeXBlR3VhcmQuVE51bWJlcihyaWdodCkgPyBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlIDogVHlwZUV4dGVuZHNSZXN1bHQuRmFsc2U7XG4gICAgfVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gSW50ZXJzZWN0XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBmdW5jdGlvbiBJbnRlcnNlY3RSaWdodChsZWZ0LCByaWdodCkge1xuICAgICAgICByZXR1cm4gcmlnaHQuYWxsT2YuZXZlcnkoKHNjaGVtYSkgPT4gVmlzaXQobGVmdCwgc2NoZW1hKSA9PT0gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZSkgPyBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlIDogVHlwZUV4dGVuZHNSZXN1bHQuRmFsc2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIEludGVyc2VjdChsZWZ0LCByaWdodCkge1xuICAgICAgICByZXR1cm4gbGVmdC5hbGxPZi5zb21lKChzY2hlbWEpID0+IFZpc2l0KHNjaGVtYSwgcmlnaHQpID09PSBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlKSA/IFR5cGVFeHRlbmRzUmVzdWx0LlRydWUgOiBUeXBlRXh0ZW5kc1Jlc3VsdC5GYWxzZTtcbiAgICB9XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBMaXRlcmFsXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBmdW5jdGlvbiBJc0xpdGVyYWxTdHJpbmcoc2NoZW1hKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2Ygc2NoZW1hLmNvbnN0ID09PSAnc3RyaW5nJztcbiAgICB9XG4gICAgZnVuY3Rpb24gSXNMaXRlcmFsTnVtYmVyKHNjaGVtYSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHNjaGVtYS5jb25zdCA9PT0gJ251bWJlcic7XG4gICAgfVxuICAgIGZ1bmN0aW9uIElzTGl0ZXJhbEJvb2xlYW4oc2NoZW1hKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2Ygc2NoZW1hLmNvbnN0ID09PSAnYm9vbGVhbic7XG4gICAgfVxuICAgIGZ1bmN0aW9uIExpdGVyYWwobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5USW50ZXJzZWN0KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBJbnRlcnNlY3RSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFVuaW9uKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBVbmlvblJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UTmV2ZXIocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIE5ldmVyUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRVbmtub3duKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBVbmtub3duUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRBbnkocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIEFueVJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UT2JqZWN0KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBPYmplY3RSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFJlY29yZChyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gUmVjb3JkUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRTdHJpbmcocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFN0cmluZ1JpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UTnVtYmVyKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBOdW1iZXJSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVEludGVnZXIocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIEludGVnZXJSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVEJvb2xlYW4ocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIEJvb2xlYW5SaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIHJldHVybiBUeXBlR3VhcmQuVExpdGVyYWwocmlnaHQpICYmIHJpZ2h0LmNvbnN0ID09PSBsZWZ0LmNvbnN0ID8gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZSA6IFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlO1xuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIE5ldmVyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBmdW5jdGlvbiBOZXZlclJpZ2h0KGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIHJldHVybiBUeXBlRXh0ZW5kc1Jlc3VsdC5GYWxzZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gTmV2ZXIobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LlRydWU7XG4gICAgfVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gTnVsbFxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZnVuY3Rpb24gTnVsbChsZWZ0LCByaWdodCkge1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRJbnRlcnNlY3QocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIEludGVyc2VjdFJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVW5pb24ocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFVuaW9uUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlROZXZlcihyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gTmV2ZXJSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFVua25vd24ocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFVua25vd25SaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVEFueShyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gQW55UmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRPYmplY3QocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdFJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UUmVjb3JkKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBSZWNvcmRSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIHJldHVybiBUeXBlR3VhcmQuVE51bGwocmlnaHQpID8gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZSA6IFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlO1xuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIE51bWJlclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZnVuY3Rpb24gTnVtYmVyUmlnaHQobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UTGl0ZXJhbChsZWZ0KSAmJiBJc0xpdGVyYWxOdW1iZXIobGVmdCkpXG4gICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZTtcbiAgICAgICAgcmV0dXJuIFR5cGVHdWFyZC5UTnVtYmVyKGxlZnQpIHx8IFR5cGVHdWFyZC5USW50ZWdlcihsZWZ0KSA/IFR5cGVFeHRlbmRzUmVzdWx0LlRydWUgOiBUeXBlRXh0ZW5kc1Jlc3VsdC5GYWxzZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gTnVtYmVyKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVEludGVyc2VjdChyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gSW50ZXJzZWN0UmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRVbmlvbihyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVW5pb25SaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVE5ldmVyKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBOZXZlclJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVW5rbm93bihyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVW5rbm93blJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UQW55KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBBbnlSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVE9iamVjdChyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0UmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRSZWNvcmQocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFJlY29yZFJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgcmV0dXJuIFR5cGVHdWFyZC5USW50ZWdlcihyaWdodCkgfHwgVHlwZUd1YXJkLlROdW1iZXIocmlnaHQpID8gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZSA6IFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlO1xuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIE9iamVjdFxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZnVuY3Rpb24gSXNPYmplY3RQcm9wZXJ0eUNvdW50KHNjaGVtYSwgY291bnQpIHtcbiAgICAgICAgcmV0dXJuIGdsb2JhbFRoaXMuT2JqZWN0LmtleXMoc2NoZW1hLnByb3BlcnRpZXMpLmxlbmd0aCA9PT0gY291bnQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIElzT2JqZWN0U3RyaW5nTGlrZShzY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIElzT2JqZWN0QXJyYXlMaWtlKHNjaGVtYSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIElzT2JqZWN0U3ltYm9sTGlrZShzY2hlbWEpIHtcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIHJldHVybiBJc09iamVjdFByb3BlcnR5Q291bnQoc2NoZW1hLCAwKSB8fCAoSXNPYmplY3RQcm9wZXJ0eUNvdW50KHNjaGVtYSwgMSkgJiYgJ2Rlc2NyaXB0aW9uJyBpbiBzY2hlbWEucHJvcGVydGllcyAmJiBUeXBlR3VhcmQuVFVuaW9uKHNjaGVtYS5wcm9wZXJ0aWVzLmRlc2NyaXB0aW9uKSAmJiBzY2hlbWEucHJvcGVydGllcy5kZXNjcmlwdGlvbi5hbnlPZi5sZW5ndGggPT09IDIgJiYgKChUeXBlR3VhcmQuVFN0cmluZyhzY2hlbWEucHJvcGVydGllcy5kZXNjcmlwdGlvbi5hbnlPZlswXSkgJiZcbiAgICAgICAgICAgIFR5cGVHdWFyZC5UVW5kZWZpbmVkKHNjaGVtYS5wcm9wZXJ0aWVzLmRlc2NyaXB0aW9uLmFueU9mWzFdKSkgfHwgKFR5cGVHdWFyZC5UU3RyaW5nKHNjaGVtYS5wcm9wZXJ0aWVzLmRlc2NyaXB0aW9uLmFueU9mWzFdKSAmJlxuICAgICAgICAgICAgVHlwZUd1YXJkLlRVbmRlZmluZWQoc2NoZW1hLnByb3BlcnRpZXMuZGVzY3JpcHRpb24uYW55T2ZbMF0pKSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBJc09iamVjdE51bWJlckxpa2Uoc2NoZW1hKSB7XG4gICAgICAgIHJldHVybiBJc09iamVjdFByb3BlcnR5Q291bnQoc2NoZW1hLCAwKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gSXNPYmplY3RCb29sZWFuTGlrZShzY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIElzT2JqZWN0UHJvcGVydHlDb3VudChzY2hlbWEsIDApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBJc09iamVjdEJpZ0ludExpa2Uoc2NoZW1hKSB7XG4gICAgICAgIHJldHVybiBJc09iamVjdFByb3BlcnR5Q291bnQoc2NoZW1hLCAwKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gSXNPYmplY3REYXRlTGlrZShzY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIElzT2JqZWN0UHJvcGVydHlDb3VudChzY2hlbWEsIDApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBJc09iamVjdFVpbnQ4QXJyYXlMaWtlKHNjaGVtYSkge1xuICAgICAgICByZXR1cm4gSXNPYmplY3RBcnJheUxpa2Uoc2NoZW1hKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gSXNPYmplY3RGdW5jdGlvbkxpa2Uoc2NoZW1hKSB7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IGV4cG9ydHMuVHlwZS5OdW1iZXIoKTtcbiAgICAgICAgcmV0dXJuIElzT2JqZWN0UHJvcGVydHlDb3VudChzY2hlbWEsIDApIHx8IChJc09iamVjdFByb3BlcnR5Q291bnQoc2NoZW1hLCAxKSAmJiAnbGVuZ3RoJyBpbiBzY2hlbWEucHJvcGVydGllcyAmJiBJbnRvQm9vbGVhblJlc3VsdChWaXNpdChzY2hlbWEucHJvcGVydGllc1snbGVuZ3RoJ10sIGxlbmd0aCkpID09PSBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gSXNPYmplY3RDb25zdHJ1Y3Rvckxpa2Uoc2NoZW1hKSB7XG4gICAgICAgIHJldHVybiBJc09iamVjdFByb3BlcnR5Q291bnQoc2NoZW1hLCAwKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gSXNPYmplY3RBcnJheUxpa2Uoc2NoZW1hKSB7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IGV4cG9ydHMuVHlwZS5OdW1iZXIoKTtcbiAgICAgICAgcmV0dXJuIElzT2JqZWN0UHJvcGVydHlDb3VudChzY2hlbWEsIDApIHx8IChJc09iamVjdFByb3BlcnR5Q291bnQoc2NoZW1hLCAxKSAmJiAnbGVuZ3RoJyBpbiBzY2hlbWEucHJvcGVydGllcyAmJiBJbnRvQm9vbGVhblJlc3VsdChWaXNpdChzY2hlbWEucHJvcGVydGllc1snbGVuZ3RoJ10sIGxlbmd0aCkpID09PSBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gSXNPYmplY3RQcm9taXNlTGlrZShzY2hlbWEpIHtcbiAgICAgICAgY29uc3QgdGhlbiA9IGV4cG9ydHMuVHlwZS5GdW5jdGlvbihbZXhwb3J0cy5UeXBlLkFueSgpXSwgZXhwb3J0cy5UeXBlLkFueSgpKTtcbiAgICAgICAgcmV0dXJuIElzT2JqZWN0UHJvcGVydHlDb3VudChzY2hlbWEsIDApIHx8IChJc09iamVjdFByb3BlcnR5Q291bnQoc2NoZW1hLCAxKSAmJiAndGhlbicgaW4gc2NoZW1hLnByb3BlcnRpZXMgJiYgSW50b0Jvb2xlYW5SZXN1bHQoVmlzaXQoc2NoZW1hLnByb3BlcnRpZXNbJ3RoZW4nXSwgdGhlbikpID09PSBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlKTtcbiAgICB9XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBQcm9wZXJ0eVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZnVuY3Rpb24gUHJvcGVydHkobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgaWYgKFZpc2l0KGxlZnQsIHJpZ2h0KSA9PT0gVHlwZUV4dGVuZHNSZXN1bHQuRmFsc2UpXG4gICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuRmFsc2U7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVE9wdGlvbmFsKGxlZnQpICYmICFUeXBlR3VhcmQuVE9wdGlvbmFsKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBUeXBlRXh0ZW5kc1Jlc3VsdC5GYWxzZTtcbiAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LlRydWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIE9iamVjdFJpZ2h0KGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFVua25vd24obGVmdCkpXG4gICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuRmFsc2U7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVEFueShsZWZ0KSlcbiAgICAgICAgICAgIHJldHVybiBUeXBlRXh0ZW5kc1Jlc3VsdC5VbmlvbjtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UTmV2ZXIobGVmdCkpXG4gICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UTGl0ZXJhbChsZWZ0KSAmJiBJc0xpdGVyYWxTdHJpbmcobGVmdCkgJiYgSXNPYmplY3RTdHJpbmdMaWtlKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRMaXRlcmFsKGxlZnQpICYmIElzTGl0ZXJhbE51bWJlcihsZWZ0KSAmJiBJc09iamVjdE51bWJlckxpa2UocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LlRydWU7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVExpdGVyYWwobGVmdCkgJiYgSXNMaXRlcmFsQm9vbGVhbihsZWZ0KSAmJiBJc09iamVjdEJvb2xlYW5MaWtlKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRTeW1ib2wobGVmdCkgJiYgSXNPYmplY3RTeW1ib2xMaWtlKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRCaWdJbnQobGVmdCkgJiYgSXNPYmplY3RCaWdJbnRMaWtlKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRTdHJpbmcobGVmdCkgJiYgSXNPYmplY3RTdHJpbmdMaWtlKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRTeW1ib2wobGVmdCkgJiYgSXNPYmplY3RTeW1ib2xMaWtlKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlROdW1iZXIobGVmdCkgJiYgSXNPYmplY3ROdW1iZXJMaWtlKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRJbnRlZ2VyKGxlZnQpICYmIElzT2JqZWN0TnVtYmVyTGlrZShyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UQm9vbGVhbihsZWZ0KSAmJiBJc09iamVjdEJvb2xlYW5MaWtlKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRVaW50OEFycmF5KGxlZnQpICYmIElzT2JqZWN0VWludDhBcnJheUxpa2UocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LlRydWU7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVERhdGUobGVmdCkgJiYgSXNPYmplY3REYXRlTGlrZShyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UQ29uc3RydWN0b3IobGVmdCkgJiYgSXNPYmplY3RDb25zdHJ1Y3Rvckxpa2UocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LlRydWU7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVEZ1bmN0aW9uKGxlZnQpICYmIElzT2JqZWN0RnVuY3Rpb25MaWtlKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRSZWNvcmQobGVmdCkgJiYgVHlwZUd1YXJkLlRTdHJpbmcoUmVjb3JkS2V5KGxlZnQpKSkge1xuICAgICAgICAgICAgLy8gV2hlbiBleHByZXNzaW5nIGEgUmVjb3JkIHdpdGggbGl0ZXJhbCBrZXkgdmFsdWVzLCB0aGUgUmVjb3JkIGlzIGNvbnZlcnRlZCBpbnRvIGEgT2JqZWN0IHdpdGhcbiAgICAgICAgICAgIC8vIHRoZSBIaW50IGFzc2lnbmVkIGFzIGBSZWNvcmRgLiBUaGlzIGlzIHVzZWQgdG8gaW52ZXJ0IHRoZSBleHRlbmRzIGxvZ2ljLlxuICAgICAgICAgICAgcmV0dXJuIHJpZ2h0W2V4cG9ydHMuSGludF0gPT09ICdSZWNvcmQnID8gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZSA6IFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFJlY29yZChsZWZ0KSAmJiBUeXBlR3VhcmQuVE51bWJlcihSZWNvcmRLZXkobGVmdCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gSXNPYmplY3RQcm9wZXJ0eUNvdW50KHJpZ2h0LCAwKSA/IFR5cGVFeHRlbmRzUmVzdWx0LlRydWUgOiBUeXBlRXh0ZW5kc1Jlc3VsdC5GYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuRmFsc2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIE9iamVjdChsZWZ0LCByaWdodCkge1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRJbnRlcnNlY3QocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIEludGVyc2VjdFJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVW5pb24ocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFVuaW9uUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRVbmtub3duKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBVbmtub3duUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRBbnkocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIEFueVJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UUmVjb3JkKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBSZWNvcmRSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmICghVHlwZUd1YXJkLlRPYmplY3QocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBnbG9iYWxUaGlzLk9iamVjdC5rZXlzKHJpZ2h0LnByb3BlcnRpZXMpKSB7XG4gICAgICAgICAgICBpZiAoIShrZXkgaW4gbGVmdC5wcm9wZXJ0aWVzKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuRmFsc2U7XG4gICAgICAgICAgICBpZiAoUHJvcGVydHkobGVmdC5wcm9wZXJ0aWVzW2tleV0sIHJpZ2h0LnByb3BlcnRpZXNba2V5XSkgPT09IFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlO1xuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIFByb21pc2VcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGZ1bmN0aW9uIFByb21pc2UobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5USW50ZXJzZWN0KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBJbnRlcnNlY3RSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFVuaW9uKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBVbmlvblJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVW5rbm93bihyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVW5rbm93blJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UQW55KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBBbnlSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVE9iamVjdChyaWdodCkgJiYgSXNPYmplY3RQcm9taXNlTGlrZShyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZTtcbiAgICAgICAgaWYgKCFUeXBlR3VhcmQuVFByb21pc2UocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlO1xuICAgICAgICByZXR1cm4gSW50b0Jvb2xlYW5SZXN1bHQoVmlzaXQobGVmdC5pdGVtLCByaWdodC5pdGVtKSk7XG4gICAgfVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gUmVjb3JkXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBmdW5jdGlvbiBSZWNvcmRLZXkoc2NoZW1hKSB7XG4gICAgICAgIGlmIChleHBvcnRzLlBhdHRlcm5OdW1iZXJFeGFjdCBpbiBzY2hlbWEucGF0dGVyblByb3BlcnRpZXMpXG4gICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5UeXBlLk51bWJlcigpO1xuICAgICAgICBpZiAoZXhwb3J0cy5QYXR0ZXJuU3RyaW5nRXhhY3QgaW4gc2NoZW1hLnBhdHRlcm5Qcm9wZXJ0aWVzKVxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuVHlwZS5TdHJpbmcoKTtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ1R5cGVFeHRlbmRzOiBDYW5ub3QgZ2V0IHJlY29yZCBrZXknKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gUmVjb3JkVmFsdWUoc2NoZW1hKSB7XG4gICAgICAgIGlmIChleHBvcnRzLlBhdHRlcm5OdW1iZXJFeGFjdCBpbiBzY2hlbWEucGF0dGVyblByb3BlcnRpZXMpXG4gICAgICAgICAgICByZXR1cm4gc2NoZW1hLnBhdHRlcm5Qcm9wZXJ0aWVzW2V4cG9ydHMuUGF0dGVybk51bWJlckV4YWN0XTtcbiAgICAgICAgaWYgKGV4cG9ydHMuUGF0dGVyblN0cmluZ0V4YWN0IGluIHNjaGVtYS5wYXR0ZXJuUHJvcGVydGllcylcbiAgICAgICAgICAgIHJldHVybiBzY2hlbWEucGF0dGVyblByb3BlcnRpZXNbZXhwb3J0cy5QYXR0ZXJuU3RyaW5nRXhhY3RdO1xuICAgICAgICB0aHJvdyBFcnJvcignVHlwZUV4dGVuZHM6IENhbm5vdCBnZXQgcmVjb3JkIHZhbHVlJyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFJlY29yZFJpZ2h0KGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIGNvbnN0IEtleSA9IFJlY29yZEtleShyaWdodCk7XG4gICAgICAgIGNvbnN0IFZhbHVlID0gUmVjb3JkVmFsdWUocmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRMaXRlcmFsKGxlZnQpICYmIElzTGl0ZXJhbFN0cmluZyhsZWZ0KSAmJiBUeXBlR3VhcmQuVE51bWJlcihLZXkpICYmIEludG9Cb29sZWFuUmVzdWx0KFZpc2l0KGxlZnQsIFZhbHVlKSkgPT09IFR5cGVFeHRlbmRzUmVzdWx0LlRydWUpXG4gICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVWludDhBcnJheShsZWZ0KSAmJiBUeXBlR3VhcmQuVE51bWJlcihLZXkpKVxuICAgICAgICAgICAgcmV0dXJuIFZpc2l0KGxlZnQsIFZhbHVlKTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UU3RyaW5nKGxlZnQpICYmIFR5cGVHdWFyZC5UTnVtYmVyKEtleSkpXG4gICAgICAgICAgICByZXR1cm4gVmlzaXQobGVmdCwgVmFsdWUpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRBcnJheShsZWZ0KSAmJiBUeXBlR3VhcmQuVE51bWJlcihLZXkpKVxuICAgICAgICAgICAgcmV0dXJuIFZpc2l0KGxlZnQsIFZhbHVlKTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UT2JqZWN0KGxlZnQpKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBnbG9iYWxUaGlzLk9iamVjdC5rZXlzKGxlZnQucHJvcGVydGllcykpIHtcbiAgICAgICAgICAgICAgICBpZiAoUHJvcGVydHkoVmFsdWUsIGxlZnQucHJvcGVydGllc1trZXldKSA9PT0gVHlwZUV4dGVuZHNSZXN1bHQuRmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBUeXBlRXh0ZW5kc1Jlc3VsdC5GYWxzZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gUmVjb3JkKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIGNvbnN0IFZhbHVlID0gUmVjb3JkVmFsdWUobGVmdCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVEludGVyc2VjdChyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gSW50ZXJzZWN0UmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRVbmlvbihyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVW5pb25SaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFVua25vd24ocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFVua25vd25SaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVEFueShyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gQW55UmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRPYmplY3QocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdFJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKCFUeXBlR3VhcmQuVFJlY29yZChyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuRmFsc2U7XG4gICAgICAgIHJldHVybiBWaXNpdChWYWx1ZSwgUmVjb3JkVmFsdWUocmlnaHQpKTtcbiAgICB9XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBTdHJpbmdcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGZ1bmN0aW9uIFN0cmluZ1JpZ2h0KGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVExpdGVyYWwobGVmdCkgJiYgdHlwZW9mIGxlZnQuY29uc3QgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LlRydWU7XG4gICAgICAgIHJldHVybiBUeXBlR3VhcmQuVFN0cmluZyhsZWZ0KSA/IFR5cGVFeHRlbmRzUmVzdWx0LlRydWUgOiBUeXBlRXh0ZW5kc1Jlc3VsdC5GYWxzZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gU3RyaW5nKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVEludGVyc2VjdChyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gSW50ZXJzZWN0UmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRVbmlvbihyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVW5pb25SaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVE5ldmVyKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBOZXZlclJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVW5rbm93bihyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVW5rbm93blJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UQW55KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBBbnlSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVE9iamVjdChyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0UmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRSZWNvcmQocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFJlY29yZFJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgcmV0dXJuIFR5cGVHdWFyZC5UU3RyaW5nKHJpZ2h0KSA/IFR5cGVFeHRlbmRzUmVzdWx0LlRydWUgOiBUeXBlRXh0ZW5kc1Jlc3VsdC5GYWxzZTtcbiAgICB9XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBTeW1ib2xcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGZ1bmN0aW9uIFN5bWJvbChsZWZ0LCByaWdodCkge1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRJbnRlcnNlY3QocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIEludGVyc2VjdFJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVW5pb24ocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFVuaW9uUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlROZXZlcihyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gTmV2ZXJSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFVua25vd24ocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFVua25vd25SaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVEFueShyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gQW55UmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRPYmplY3QocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdFJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UUmVjb3JkKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBSZWNvcmRSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIHJldHVybiBUeXBlR3VhcmQuVFN5bWJvbChyaWdodCkgPyBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlIDogVHlwZUV4dGVuZHNSZXN1bHQuRmFsc2U7XG4gICAgfVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gVHVwbGVcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGZ1bmN0aW9uIFR1cGxlUmlnaHQobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVW5rbm93bihsZWZ0KSlcbiAgICAgICAgICAgIHJldHVybiBUeXBlRXh0ZW5kc1Jlc3VsdC5GYWxzZTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UQW55KGxlZnQpKVxuICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LlVuaW9uO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlROZXZlcihsZWZ0KSlcbiAgICAgICAgICAgIHJldHVybiBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlO1xuICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuRmFsc2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIElzQXJyYXlPZlR1cGxlKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIHJldHVybiBUeXBlR3VhcmQuVEFycmF5KHJpZ2h0KSAmJiBsZWZ0Lml0ZW1zICE9PSB1bmRlZmluZWQgJiYgbGVmdC5pdGVtcy5ldmVyeSgoc2NoZW1hKSA9PiBWaXNpdChzY2hlbWEsIHJpZ2h0Lml0ZW1zKSA9PT0gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFR1cGxlKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVEludGVyc2VjdChyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gSW50ZXJzZWN0UmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRVbmlvbihyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVW5pb25SaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFVua25vd24ocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFVua25vd25SaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVEFueShyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gQW55UmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRPYmplY3QocmlnaHQpICYmIElzT2JqZWN0QXJyYXlMaWtlKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRBcnJheShyaWdodCkgJiYgSXNBcnJheU9mVHVwbGUobGVmdCwgcmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LlRydWU7XG4gICAgICAgIGlmICghVHlwZUd1YXJkLlRUdXBsZShyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuRmFsc2U7XG4gICAgICAgIGlmICgobGVmdC5pdGVtcyA9PT0gdW5kZWZpbmVkICYmIHJpZ2h0Lml0ZW1zICE9PSB1bmRlZmluZWQpIHx8IChsZWZ0Lml0ZW1zICE9PSB1bmRlZmluZWQgJiYgcmlnaHQuaXRlbXMgPT09IHVuZGVmaW5lZCkpXG4gICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuRmFsc2U7XG4gICAgICAgIGlmIChsZWZ0Lml0ZW1zID09PSB1bmRlZmluZWQgJiYgcmlnaHQuaXRlbXMgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybiBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlO1xuICAgICAgICByZXR1cm4gbGVmdC5pdGVtcy5ldmVyeSgoc2NoZW1hLCBpbmRleCkgPT4gVmlzaXQoc2NoZW1hLCByaWdodC5pdGVtc1tpbmRleF0pID09PSBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlKSA/IFR5cGVFeHRlbmRzUmVzdWx0LlRydWUgOiBUeXBlRXh0ZW5kc1Jlc3VsdC5GYWxzZTtcbiAgICB9XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBVaW50OEFycmF5XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBmdW5jdGlvbiBVaW50OEFycmF5KGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVEludGVyc2VjdChyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gSW50ZXJzZWN0UmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRVbmlvbihyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVW5pb25SaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFVua25vd24ocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFVua25vd25SaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVEFueShyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gQW55UmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRPYmplY3QocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdFJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UUmVjb3JkKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBSZWNvcmRSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIHJldHVybiBUeXBlR3VhcmQuVFVpbnQ4QXJyYXkocmlnaHQpID8gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZSA6IFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlO1xuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIFVuZGVmaW5lZFxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZnVuY3Rpb24gVW5kZWZpbmVkKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVEludGVyc2VjdChyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gSW50ZXJzZWN0UmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRVbmlvbihyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVW5pb25SaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVE5ldmVyKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBOZXZlclJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVW5rbm93bihyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVW5rbm93blJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UQW55KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBBbnlSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVE9iamVjdChyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0UmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRSZWNvcmQocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFJlY29yZFJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVm9pZChyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVm9pZFJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgcmV0dXJuIFR5cGVHdWFyZC5UVW5kZWZpbmVkKHJpZ2h0KSA/IFR5cGVFeHRlbmRzUmVzdWx0LlRydWUgOiBUeXBlRXh0ZW5kc1Jlc3VsdC5GYWxzZTtcbiAgICB9XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBVbmlvblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZnVuY3Rpb24gVW5pb25SaWdodChsZWZ0LCByaWdodCkge1xuICAgICAgICByZXR1cm4gcmlnaHQuYW55T2Yuc29tZSgoc2NoZW1hKSA9PiBWaXNpdChsZWZ0LCBzY2hlbWEpID09PSBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlKSA/IFR5cGVFeHRlbmRzUmVzdWx0LlRydWUgOiBUeXBlRXh0ZW5kc1Jlc3VsdC5GYWxzZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gVW5pb24obGVmdCwgcmlnaHQpIHtcbiAgICAgICAgcmV0dXJuIGxlZnQuYW55T2YuZXZlcnkoKHNjaGVtYSkgPT4gVmlzaXQoc2NoZW1hLCByaWdodCkgPT09IFR5cGVFeHRlbmRzUmVzdWx0LlRydWUpID8gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZSA6IFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlO1xuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIFVua25vd25cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGZ1bmN0aW9uIFVua25vd25SaWdodChsZWZ0LCByaWdodCkge1xuICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gVW5rbm93bihsZWZ0LCByaWdodCkge1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRJbnRlcnNlY3QocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIEludGVyc2VjdFJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVW5pb24ocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFVuaW9uUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRBbnkocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIEFueVJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UU3RyaW5nKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBTdHJpbmdSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVE51bWJlcihyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gTnVtYmVyUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRJbnRlZ2VyKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBJbnRlZ2VyUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRCb29sZWFuKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBCb29sZWFuUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRBcnJheShyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gQXJyYXlSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFR1cGxlKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBUdXBsZVJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UT2JqZWN0KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBPYmplY3RSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIHJldHVybiBUeXBlR3VhcmQuVFVua25vd24ocmlnaHQpID8gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZSA6IFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlO1xuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIFZvaWRcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGZ1bmN0aW9uIFZvaWRSaWdodChsZWZ0LCByaWdodCkge1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRVbmRlZmluZWQobGVmdCkpXG4gICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZTtcbiAgICAgICAgcmV0dXJuIFR5cGVHdWFyZC5UVW5kZWZpbmVkKGxlZnQpID8gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZSA6IFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBWb2lkKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVEludGVyc2VjdChyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gSW50ZXJzZWN0UmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRVbmlvbihyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVW5pb25SaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFVua25vd24ocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFVua25vd25SaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVEFueShyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gQW55UmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRPYmplY3QocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdFJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgcmV0dXJuIFR5cGVHdWFyZC5UVm9pZChyaWdodCkgPyBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlIDogVHlwZUV4dGVuZHNSZXN1bHQuRmFsc2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFZpc2l0KGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIC8vIFRlbXBsYXRlIExpdGVyYWwgVW5pb24gVW53cmFwXG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFRlbXBsYXRlTGl0ZXJhbChsZWZ0KSlcbiAgICAgICAgICAgIHJldHVybiBWaXNpdChUZW1wbGF0ZUxpdGVyYWxSZXNvbHZlci5SZXNvbHZlKGxlZnQpLCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFRlbXBsYXRlTGl0ZXJhbChyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVmlzaXQobGVmdCwgVGVtcGxhdGVMaXRlcmFsUmVzb2x2ZXIuUmVzb2x2ZShyaWdodCkpO1xuICAgICAgICAvLyBTdGFuZGFyZCBFeHRlbmRzXG4gICAgICAgIGlmIChUeXBlR3VhcmQuVEFueShsZWZ0KSlcbiAgICAgICAgICAgIHJldHVybiBBbnkobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRBcnJheShsZWZ0KSlcbiAgICAgICAgICAgIHJldHVybiBBcnJheShsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVEJpZ0ludChsZWZ0KSlcbiAgICAgICAgICAgIHJldHVybiBCaWdJbnQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRCb29sZWFuKGxlZnQpKVxuICAgICAgICAgICAgcmV0dXJuIEJvb2xlYW4obGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRDb25zdHJ1Y3RvcihsZWZ0KSlcbiAgICAgICAgICAgIHJldHVybiBDb25zdHJ1Y3RvcihsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVERhdGUobGVmdCkpXG4gICAgICAgICAgICByZXR1cm4gRGF0ZShsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVEZ1bmN0aW9uKGxlZnQpKVxuICAgICAgICAgICAgcmV0dXJuIEZ1bmN0aW9uKGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5USW50ZWdlcihsZWZ0KSlcbiAgICAgICAgICAgIHJldHVybiBJbnRlZ2VyKGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5USW50ZXJzZWN0KGxlZnQpKVxuICAgICAgICAgICAgcmV0dXJuIEludGVyc2VjdChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVExpdGVyYWwobGVmdCkpXG4gICAgICAgICAgICByZXR1cm4gTGl0ZXJhbChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVE5ldmVyKGxlZnQpKVxuICAgICAgICAgICAgcmV0dXJuIE5ldmVyKGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UTnVsbChsZWZ0KSlcbiAgICAgICAgICAgIHJldHVybiBOdWxsKGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UTnVtYmVyKGxlZnQpKVxuICAgICAgICAgICAgcmV0dXJuIE51bWJlcihsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVE9iamVjdChsZWZ0KSlcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRSZWNvcmQobGVmdCkpXG4gICAgICAgICAgICByZXR1cm4gUmVjb3JkKGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UU3RyaW5nKGxlZnQpKVxuICAgICAgICAgICAgcmV0dXJuIFN0cmluZyhsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFN5bWJvbChsZWZ0KSlcbiAgICAgICAgICAgIHJldHVybiBTeW1ib2wobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRUdXBsZShsZWZ0KSlcbiAgICAgICAgICAgIHJldHVybiBUdXBsZShsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFByb21pc2UobGVmdCkpXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZShsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFVpbnQ4QXJyYXkobGVmdCkpXG4gICAgICAgICAgICByZXR1cm4gVWludDhBcnJheShsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFVuZGVmaW5lZChsZWZ0KSlcbiAgICAgICAgICAgIHJldHVybiBVbmRlZmluZWQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRVbmlvbihsZWZ0KSlcbiAgICAgICAgICAgIHJldHVybiBVbmlvbihsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFVua25vd24obGVmdCkpXG4gICAgICAgICAgICByZXR1cm4gVW5rbm93bihsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFZvaWQobGVmdCkpXG4gICAgICAgICAgICByZXR1cm4gVm9pZChsZWZ0LCByaWdodCk7XG4gICAgICAgIHRocm93IEVycm9yKGBUeXBlRXh0ZW5kczogVW5rbm93biBsZWZ0IHR5cGUgb3BlcmFuZCAnJHtsZWZ0W2V4cG9ydHMuS2luZF19J2ApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBFeHRlbmRzKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIHJldHVybiBWaXNpdChsZWZ0LCByaWdodCk7XG4gICAgfVxuICAgIFR5cGVFeHRlbmRzLkV4dGVuZHMgPSBFeHRlbmRzO1xufSkoVHlwZUV4dGVuZHMgfHwgKGV4cG9ydHMuVHlwZUV4dGVuZHMgPSBUeXBlRXh0ZW5kcyA9IHt9KSk7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gVHlwZUNsb25lXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLyoqIFNwZWNpYWxpemVkIENsb25lIGZvciBUeXBlcyAqL1xudmFyIFR5cGVDbG9uZTtcbihmdW5jdGlvbiAoVHlwZUNsb25lKSB7XG4gICAgZnVuY3Rpb24gSXNPYmplY3QodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIElzQXJyYXkodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGdsb2JhbFRoaXMuQXJyYXkuaXNBcnJheSh2YWx1ZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIEFycmF5KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5tYXAoKHZhbHVlKSA9PiBWaXNpdCh2YWx1ZSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBPYmplY3QodmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2xvbmVkUHJvcGVydGllcyA9IGdsb2JhbFRoaXMuT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModmFsdWUpLnJlZHVjZSgoYWNjLCBrZXkpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7IC4uLmFjYywgW2tleV06IFZpc2l0KHZhbHVlW2tleV0pIH07XG4gICAgICAgIH0sIHt9KTtcbiAgICAgICAgY29uc3QgY2xvbmVkU3ltYm9scyA9IGdsb2JhbFRoaXMuT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyh2YWx1ZSkucmVkdWNlKChhY2MsIGtleSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHsgLi4uYWNjLCBba2V5XTogVmlzaXQodmFsdWVba2V5XSkgfTtcbiAgICAgICAgfSwge30pO1xuICAgICAgICByZXR1cm4geyAuLi5jbG9uZWRQcm9wZXJ0aWVzLCAuLi5jbG9uZWRTeW1ib2xzIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIFZpc2l0KHZhbHVlKSB7XG4gICAgICAgIGlmIChJc0FycmF5KHZhbHVlKSlcbiAgICAgICAgICAgIHJldHVybiBBcnJheSh2YWx1ZSk7XG4gICAgICAgIGlmIChJc09iamVjdCh2YWx1ZSkpXG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0KHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICAvKiogQ2xvbmVzIGEgdHlwZS4gKi9cbiAgICBmdW5jdGlvbiBDbG9uZShzY2hlbWEsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHsgLi4uVmlzaXQoc2NoZW1hKSwgLi4ub3B0aW9ucyB9O1xuICAgIH1cbiAgICBUeXBlQ2xvbmUuQ2xvbmUgPSBDbG9uZTtcbn0pKFR5cGVDbG9uZSB8fCAoZXhwb3J0cy5UeXBlQ2xvbmUgPSBUeXBlQ2xvbmUgPSB7fSkpO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEluZGV4ZWRBY2Nlc3NvclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbnZhciBJbmRleGVkQWNjZXNzb3I7XG4oZnVuY3Rpb24gKEluZGV4ZWRBY2Nlc3Nvcikge1xuICAgIGZ1bmN0aW9uIEludGVyc2VjdChzY2hlbWEsIGtleSkge1xuICAgICAgICBjb25zdCBzY2hlbWFzID0gc2NoZW1hLmFsbE9mLnJlZHVjZSgoYWNjLCBzY2hlbWEpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ZWQgPSBWaXNpdChzY2hlbWEsIGtleSk7XG4gICAgICAgICAgICByZXR1cm4gaW5kZXhlZFtleHBvcnRzLktpbmRdID09PSAnTmV2ZXInID8gYWNjIDogWy4uLmFjYywgaW5kZXhlZF07XG4gICAgICAgIH0sIFtdKTtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuVHlwZS5JbnRlcnNlY3Qoc2NoZW1hcyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFVuaW9uKHNjaGVtYSwga2V5KSB7XG4gICAgICAgIGNvbnN0IHNjaGVtYXMgPSBzY2hlbWEuYW55T2YubWFwKChzY2hlbWEpID0+IFZpc2l0KHNjaGVtYSwga2V5KSk7XG4gICAgICAgIHJldHVybiBleHBvcnRzLlR5cGUuVW5pb24oc2NoZW1hcyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIE9iamVjdChzY2hlbWEsIGtleSkge1xuICAgICAgICBjb25zdCBwcm9wZXJ0eSA9IHNjaGVtYS5wcm9wZXJ0aWVzW2tleV07XG4gICAgICAgIHJldHVybiBwcm9wZXJ0eSA9PT0gdW5kZWZpbmVkID8gZXhwb3J0cy5UeXBlLk5ldmVyKCkgOiBleHBvcnRzLlR5cGUuVW5pb24oW3Byb3BlcnR5XSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFR1cGxlKHNjaGVtYSwga2V5KSB7XG4gICAgICAgIGNvbnN0IGl0ZW1zID0gc2NoZW1hLml0ZW1zO1xuICAgICAgICBpZiAoaXRlbXMgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLlR5cGUuTmV2ZXIoKTtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IGl0ZW1zW2tleV07IC8vXG4gICAgICAgIGlmIChlbGVtZW50ID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5UeXBlLk5ldmVyKCk7XG4gICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH1cbiAgICBmdW5jdGlvbiBWaXNpdChzY2hlbWEsIGtleSkge1xuICAgICAgICBpZiAoc2NoZW1hW2V4cG9ydHMuS2luZF0gPT09ICdJbnRlcnNlY3QnKVxuICAgICAgICAgICAgcmV0dXJuIEludGVyc2VjdChzY2hlbWEsIGtleSk7XG4gICAgICAgIGlmIChzY2hlbWFbZXhwb3J0cy5LaW5kXSA9PT0gJ1VuaW9uJylcbiAgICAgICAgICAgIHJldHVybiBVbmlvbihzY2hlbWEsIGtleSk7XG4gICAgICAgIGlmIChzY2hlbWFbZXhwb3J0cy5LaW5kXSA9PT0gJ09iamVjdCcpXG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0KHNjaGVtYSwga2V5KTtcbiAgICAgICAgaWYgKHNjaGVtYVtleHBvcnRzLktpbmRdID09PSAnVHVwbGUnKVxuICAgICAgICAgICAgcmV0dXJuIFR1cGxlKHNjaGVtYSwga2V5KTtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuVHlwZS5OZXZlcigpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBSZXNvbHZlKHNjaGVtYSwga2V5cywgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICByZXR1cm4gZXhwb3J0cy5UeXBlLlVuaW9uKGtleXMubWFwKChrZXkpID0+IFZpc2l0KHNjaGVtYSwga2V5LnRvU3RyaW5nKCkpKSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIEluZGV4ZWRBY2Nlc3Nvci5SZXNvbHZlID0gUmVzb2x2ZTtcbn0pKEluZGV4ZWRBY2Nlc3NvciB8fCAoZXhwb3J0cy5JbmRleGVkQWNjZXNzb3IgPSBJbmRleGVkQWNjZXNzb3IgPSB7fSkpO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIE9iamVjdE1hcFxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbnZhciBPYmplY3RNYXA7XG4oZnVuY3Rpb24gKE9iamVjdE1hcCkge1xuICAgIGZ1bmN0aW9uIEludGVyc2VjdChzY2hlbWEsIGNhbGxiYWNrKSB7XG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICByZXR1cm4gZXhwb3J0cy5UeXBlLkludGVyc2VjdChzY2hlbWEuYWxsT2YubWFwKChpbm5lcikgPT4gVmlzaXQoaW5uZXIsIGNhbGxiYWNrKSksIHsgLi4uc2NoZW1hIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBVbmlvbihzY2hlbWEsIGNhbGxiYWNrKSB7XG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICByZXR1cm4gZXhwb3J0cy5UeXBlLlVuaW9uKHNjaGVtYS5hbnlPZi5tYXAoKGlubmVyKSA9PiBWaXNpdChpbm5lciwgY2FsbGJhY2spKSwgeyAuLi5zY2hlbWEgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIE9iamVjdChzY2hlbWEsIGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhzY2hlbWEpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBWaXNpdChzY2hlbWEsIGNhbGxiYWNrKSB7XG4gICAgICAgIC8vIFRoZXJlIGFyZSBjYXNlcyB3aGVyZSB1c2VycyBuZWVkIHRvIG1hcCBvYmplY3RzIHdpdGggdW5yZWdpc3RlcmVkIGtpbmRzLiBVc2luZyBhIFR5cGVHdWFyZCBoZXJlIHdvdWxkXG4gICAgICAgIC8vIHByZXZlbnQgc3ViIHNjaGVtYSBtYXBwaW5nIGFzIHVucmVnaXN0ZXJlZCBraW5kcyB3aWxsIG5vdCBwYXNzIFRTY2hlbWEgY2hlY2tzLiBUaGlzIGlzIG5vdGFibGUgaW4gdGhlXG4gICAgICAgIC8vIGNhc2Ugb2YgVE9iamVjdCB3aGVyZSB1bnJlZ2lzdGVyZWQgcHJvcGVydHkga2luZHMgY2F1c2UgdGhlIFRPYmplY3QgY2hlY2sgdG8gZmFpbC4gQXMgbWFwcGluZyBpcyBvbmx5XG4gICAgICAgIC8vIHVzZWQgZm9yIGNvbXBvc2l0aW9uLCB3ZSB1c2UgZXhwbGljaXQgY2hlY2tzIGluc3RlYWQuXG4gICAgICAgIGlmIChzY2hlbWFbZXhwb3J0cy5LaW5kXSA9PT0gJ0ludGVyc2VjdCcpXG4gICAgICAgICAgICByZXR1cm4gSW50ZXJzZWN0KHNjaGVtYSwgY2FsbGJhY2spO1xuICAgICAgICBpZiAoc2NoZW1hW2V4cG9ydHMuS2luZF0gPT09ICdVbmlvbicpXG4gICAgICAgICAgICByZXR1cm4gVW5pb24oc2NoZW1hLCBjYWxsYmFjayk7XG4gICAgICAgIGlmIChzY2hlbWFbZXhwb3J0cy5LaW5kXSA9PT0gJ09iamVjdCcpXG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0KHNjaGVtYSwgY2FsbGJhY2spO1xuICAgICAgICByZXR1cm4gc2NoZW1hO1xuICAgIH1cbiAgICBmdW5jdGlvbiBNYXAoc2NoZW1hLCBjYWxsYmFjaywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4geyAuLi5WaXNpdChUeXBlQ2xvbmUuQ2xvbmUoc2NoZW1hLCB7fSksIGNhbGxiYWNrKSwgLi4ub3B0aW9ucyB9O1xuICAgIH1cbiAgICBPYmplY3RNYXAuTWFwID0gTWFwO1xufSkoT2JqZWN0TWFwIHx8IChleHBvcnRzLk9iamVjdE1hcCA9IE9iamVjdE1hcCA9IHt9KSk7XG52YXIgS2V5UmVzb2x2ZXI7XG4oZnVuY3Rpb24gKEtleVJlc29sdmVyKSB7XG4gICAgZnVuY3Rpb24gVW53cmFwUGF0dGVybihrZXkpIHtcbiAgICAgICAgcmV0dXJuIGtleVswXSA9PT0gJ14nICYmIGtleVtrZXkubGVuZ3RoIC0gMV0gPT09ICckJyA/IGtleS5zbGljZSgxLCBrZXkubGVuZ3RoIC0gMSkgOiBrZXk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIEludGVyc2VjdChzY2hlbWEsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHNjaGVtYS5hbGxPZi5yZWR1Y2UoKGFjYywgc2NoZW1hKSA9PiBbLi4uYWNjLCAuLi5WaXNpdChzY2hlbWEsIG9wdGlvbnMpXSwgW10pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBVbmlvbihzY2hlbWEsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3Qgc2V0cyA9IHNjaGVtYS5hbnlPZi5tYXAoKGlubmVyKSA9PiBWaXNpdChpbm5lciwgb3B0aW9ucykpO1xuICAgICAgICByZXR1cm4gWy4uLnNldHMucmVkdWNlKChzZXQsIG91dGVyKSA9PiBvdXRlci5tYXAoKGtleSkgPT4gKHNldHMuZXZlcnkoKGlubmVyKSA9PiBpbm5lci5pbmNsdWRlcyhrZXkpKSA/IHNldC5hZGQoa2V5KSA6IHNldCkpWzBdLCBuZXcgU2V0KCkpXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gT2JqZWN0KHNjaGVtYSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gZ2xvYmFsVGhpcy5PYmplY3Qua2V5cyhzY2hlbWEucHJvcGVydGllcyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFJlY29yZChzY2hlbWEsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMuaW5jbHVkZVBhdHRlcm5zID8gZ2xvYmFsVGhpcy5PYmplY3Qua2V5cyhzY2hlbWEucGF0dGVyblByb3BlcnRpZXMpIDogW107XG4gICAgfVxuICAgIGZ1bmN0aW9uIFZpc2l0KHNjaGVtYSwgb3B0aW9ucykge1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRJbnRlcnNlY3Qoc2NoZW1hKSlcbiAgICAgICAgICAgIHJldHVybiBJbnRlcnNlY3Qoc2NoZW1hLCBvcHRpb25zKTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVW5pb24oc2NoZW1hKSlcbiAgICAgICAgICAgIHJldHVybiBVbmlvbihzY2hlbWEsIG9wdGlvbnMpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRPYmplY3Qoc2NoZW1hKSlcbiAgICAgICAgICAgIHJldHVybiBPYmplY3Qoc2NoZW1hLCBvcHRpb25zKTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UUmVjb3JkKHNjaGVtYSkpXG4gICAgICAgICAgICByZXR1cm4gUmVjb3JkKHNjaGVtYSwgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgLyoqIFJlc29sdmVzIGFuIGFycmF5IG9mIGtleXMgaW4gdGhpcyBzY2hlbWEgKi9cbiAgICBmdW5jdGlvbiBSZXNvbHZlS2V5cyhzY2hlbWEsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIFsuLi5uZXcgU2V0KFZpc2l0KHNjaGVtYSwgb3B0aW9ucykpXTtcbiAgICB9XG4gICAgS2V5UmVzb2x2ZXIuUmVzb2x2ZUtleXMgPSBSZXNvbHZlS2V5cztcbiAgICAvKiogUmVzb2x2ZXMgYSByZWd1bGFyIGV4cHJlc3Npb24gcGF0dGVybiBtYXRjaGluZyBhbGwga2V5cyBpbiB0aGlzIHNjaGVtYSAqL1xuICAgIGZ1bmN0aW9uIFJlc29sdmVQYXR0ZXJuKHNjaGVtYSkge1xuICAgICAgICBjb25zdCBrZXlzID0gUmVzb2x2ZUtleXMoc2NoZW1hLCB7IGluY2x1ZGVQYXR0ZXJuczogdHJ1ZSB9KTtcbiAgICAgICAgY29uc3QgcGF0dGVybiA9IGtleXMubWFwKChrZXkpID0+IGAoJHtVbndyYXBQYXR0ZXJuKGtleSl9KWApO1xuICAgICAgICByZXR1cm4gYF4oJHtwYXR0ZXJuLmpvaW4oJ3wnKX0pJGA7XG4gICAgfVxuICAgIEtleVJlc29sdmVyLlJlc29sdmVQYXR0ZXJuID0gUmVzb2x2ZVBhdHRlcm47XG59KShLZXlSZXNvbHZlciB8fCAoZXhwb3J0cy5LZXlSZXNvbHZlciA9IEtleVJlc29sdmVyID0ge30pKTtcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBLZXlBcnJheVJlc29sdmVyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxudmFyIEtleUFycmF5UmVzb2x2ZXI7XG4oZnVuY3Rpb24gKEtleUFycmF5UmVzb2x2ZXIpIHtcbiAgICAvKiogUmVzb2x2ZXMgYW4gYXJyYXkgb2Ygc3RyaW5nW10ga2V5cyBmcm9tIHRoZSBnaXZlbiBzY2hlbWEgb3IgYXJyYXkgdHlwZS4gKi9cbiAgICBmdW5jdGlvbiBSZXNvbHZlKHNjaGVtYSkge1xuICAgICAgICBpZiAoZ2xvYmFsVGhpcy5BcnJheS5pc0FycmF5KHNjaGVtYSkpXG4gICAgICAgICAgICByZXR1cm4gc2NoZW1hO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRVbmlvbkxpdGVyYWwoc2NoZW1hKSlcbiAgICAgICAgICAgIHJldHVybiBzY2hlbWEuYW55T2YubWFwKChzY2hlbWEpID0+IHNjaGVtYS5jb25zdC50b1N0cmluZygpKTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UTGl0ZXJhbChzY2hlbWEpKVxuICAgICAgICAgICAgcmV0dXJuIFtzY2hlbWEuY29uc3RdO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRUZW1wbGF0ZUxpdGVyYWwoc2NoZW1hKSkge1xuICAgICAgICAgICAgY29uc3QgZXhwcmVzc2lvbiA9IFRlbXBsYXRlTGl0ZXJhbFBhcnNlci5QYXJzZUV4YWN0KHNjaGVtYS5wYXR0ZXJuKTtcbiAgICAgICAgICAgIGlmICghVGVtcGxhdGVMaXRlcmFsRmluaXRlLkNoZWNrKGV4cHJlc3Npb24pKVxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCdLZXlBcnJheVJlc29sdmVyOiBDYW5ub3QgcmVzb2x2ZSBrZXlzIGZyb20gaW5maW5pdGUgdGVtcGxhdGUgZXhwcmVzc2lvbicpO1xuICAgICAgICAgICAgcmV0dXJuIFsuLi5UZW1wbGF0ZUxpdGVyYWxHZW5lcmF0b3IuR2VuZXJhdGUoZXhwcmVzc2lvbildO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgS2V5QXJyYXlSZXNvbHZlci5SZXNvbHZlID0gUmVzb2x2ZTtcbn0pKEtleUFycmF5UmVzb2x2ZXIgfHwgKGV4cG9ydHMuS2V5QXJyYXlSZXNvbHZlciA9IEtleUFycmF5UmVzb2x2ZXIgPSB7fSkpO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFVuaW9uUmVzb2x2ZXJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG52YXIgVW5pb25SZXNvbHZlcjtcbihmdW5jdGlvbiAoVW5pb25SZXNvbHZlcikge1xuICAgIGZ1bmN0aW9uKiBVbmlvbih1bmlvbikge1xuICAgICAgICBmb3IgKGNvbnN0IHNjaGVtYSBvZiB1bmlvbi5hbnlPZikge1xuICAgICAgICAgICAgaWYgKHNjaGVtYVtleHBvcnRzLktpbmRdID09PSAnVW5pb24nKSB7XG4gICAgICAgICAgICAgICAgeWllbGQqIFVuaW9uKHNjaGVtYSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB5aWVsZCBzY2hlbWE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIFJldHVybnMgYSByZXNvbHZlZCB1bmlvbiB3aXRoIGludGVyaW9yIHVuaW9ucyBmbGF0dGVuZWQgKi9cbiAgICBmdW5jdGlvbiBSZXNvbHZlKHVuaW9uKSB7XG4gICAgICAgIHJldHVybiBleHBvcnRzLlR5cGUuVW5pb24oWy4uLlVuaW9uKHVuaW9uKV0sIHsgLi4udW5pb24gfSk7XG4gICAgfVxuICAgIFVuaW9uUmVzb2x2ZXIuUmVzb2x2ZSA9IFJlc29sdmU7XG59KShVbmlvblJlc29sdmVyIHx8IChleHBvcnRzLlVuaW9uUmVzb2x2ZXIgPSBVbmlvblJlc29sdmVyID0ge30pKTtcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBUZW1wbGF0ZUxpdGVyYWxQYXR0ZXJuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxudmFyIFRlbXBsYXRlTGl0ZXJhbFBhdHRlcm47XG4oZnVuY3Rpb24gKFRlbXBsYXRlTGl0ZXJhbFBhdHRlcm4pIHtcbiAgICBmdW5jdGlvbiBFc2NhcGUodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLnJlcGxhY2UoL1suKis/XiR7fSgpfFtcXF1cXFxcXS9nLCAnXFxcXCQmJyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFZpc2l0KHNjaGVtYSwgYWNjKSB7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFRlbXBsYXRlTGl0ZXJhbChzY2hlbWEpKSB7XG4gICAgICAgICAgICBjb25zdCBwYXR0ZXJuID0gc2NoZW1hLnBhdHRlcm4uc2xpY2UoMSwgc2NoZW1hLnBhdHRlcm4ubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICByZXR1cm4gcGF0dGVybjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChUeXBlR3VhcmQuVFVuaW9uKHNjaGVtYSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHRva2VucyA9IHNjaGVtYS5hbnlPZi5tYXAoKHNjaGVtYSkgPT4gVmlzaXQoc2NoZW1hLCBhY2MpKS5qb2luKCd8Jyk7XG4gICAgICAgICAgICByZXR1cm4gYCgke3Rva2Vuc30pYDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChUeXBlR3VhcmQuVE51bWJlcihzY2hlbWEpKSB7XG4gICAgICAgICAgICByZXR1cm4gYCR7YWNjfSR7ZXhwb3J0cy5QYXR0ZXJuTnVtYmVyfWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoVHlwZUd1YXJkLlRJbnRlZ2VyKHNjaGVtYSkpIHtcbiAgICAgICAgICAgIHJldHVybiBgJHthY2N9JHtleHBvcnRzLlBhdHRlcm5OdW1iZXJ9YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChUeXBlR3VhcmQuVEJpZ0ludChzY2hlbWEpKSB7XG4gICAgICAgICAgICByZXR1cm4gYCR7YWNjfSR7ZXhwb3J0cy5QYXR0ZXJuTnVtYmVyfWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoVHlwZUd1YXJkLlRTdHJpbmcoc2NoZW1hKSkge1xuICAgICAgICAgICAgcmV0dXJuIGAke2FjY30ke2V4cG9ydHMuUGF0dGVyblN0cmluZ31gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFR5cGVHdWFyZC5UTGl0ZXJhbChzY2hlbWEpKSB7XG4gICAgICAgICAgICByZXR1cm4gYCR7YWNjfSR7RXNjYXBlKHNjaGVtYS5jb25zdC50b1N0cmluZygpKX1gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFR5cGVHdWFyZC5UQm9vbGVhbihzY2hlbWEpKSB7XG4gICAgICAgICAgICByZXR1cm4gYCR7YWNjfSR7ZXhwb3J0cy5QYXR0ZXJuQm9vbGVhbn1gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFR5cGVHdWFyZC5UTmV2ZXIoc2NoZW1hKSkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ1RlbXBsYXRlTGl0ZXJhbFBhdHRlcm46IFRlbXBsYXRlTGl0ZXJhbCBjYW5ub3Qgb3BlcmF0ZSBvbiB0eXBlcyBvZiBUTmV2ZXInKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKGBUZW1wbGF0ZUxpdGVyYWxQYXR0ZXJuOiBVbmV4cGVjdGVkIEtpbmQgJyR7c2NoZW1hW2V4cG9ydHMuS2luZF19J2ApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIENyZWF0ZShraW5kcykge1xuICAgICAgICByZXR1cm4gYF4ke2tpbmRzLm1hcCgoc2NoZW1hKSA9PiBWaXNpdChzY2hlbWEsICcnKSkuam9pbignJyl9XFwkYDtcbiAgICB9XG4gICAgVGVtcGxhdGVMaXRlcmFsUGF0dGVybi5DcmVhdGUgPSBDcmVhdGU7XG59KShUZW1wbGF0ZUxpdGVyYWxQYXR0ZXJuIHx8IChleHBvcnRzLlRlbXBsYXRlTGl0ZXJhbFBhdHRlcm4gPSBUZW1wbGF0ZUxpdGVyYWxQYXR0ZXJuID0ge30pKTtcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBUZW1wbGF0ZUxpdGVyYWxSZXNvbHZlclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbnZhciBUZW1wbGF0ZUxpdGVyYWxSZXNvbHZlcjtcbihmdW5jdGlvbiAoVGVtcGxhdGVMaXRlcmFsUmVzb2x2ZXIpIHtcbiAgICAvKiogUmVzb2x2ZXMgYSB0ZW1wbGF0ZSBsaXRlcmFsIGFzIGEgVFVuaW9uICovXG4gICAgZnVuY3Rpb24gUmVzb2x2ZSh0ZW1wbGF0ZSkge1xuICAgICAgICBjb25zdCBleHByZXNzaW9uID0gVGVtcGxhdGVMaXRlcmFsUGFyc2VyLlBhcnNlRXhhY3QodGVtcGxhdGUucGF0dGVybik7XG4gICAgICAgIGlmICghVGVtcGxhdGVMaXRlcmFsRmluaXRlLkNoZWNrKGV4cHJlc3Npb24pKVxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuVHlwZS5TdHJpbmcoKTtcbiAgICAgICAgY29uc3QgbGl0ZXJhbHMgPSBbLi4uVGVtcGxhdGVMaXRlcmFsR2VuZXJhdG9yLkdlbmVyYXRlKGV4cHJlc3Npb24pXS5tYXAoKHZhbHVlKSA9PiBleHBvcnRzLlR5cGUuTGl0ZXJhbCh2YWx1ZSkpO1xuICAgICAgICByZXR1cm4gZXhwb3J0cy5UeXBlLlVuaW9uKGxpdGVyYWxzKTtcbiAgICB9XG4gICAgVGVtcGxhdGVMaXRlcmFsUmVzb2x2ZXIuUmVzb2x2ZSA9IFJlc29sdmU7XG59KShUZW1wbGF0ZUxpdGVyYWxSZXNvbHZlciB8fCAoZXhwb3J0cy5UZW1wbGF0ZUxpdGVyYWxSZXNvbHZlciA9IFRlbXBsYXRlTGl0ZXJhbFJlc29sdmVyID0ge30pKTtcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBUZW1wbGF0ZUxpdGVyYWxQYXJzZXJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5jbGFzcyBUZW1wbGF0ZUxpdGVyYWxQYXJzZXJFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIH1cbn1cbmV4cG9ydHMuVGVtcGxhdGVMaXRlcmFsUGFyc2VyRXJyb3IgPSBUZW1wbGF0ZUxpdGVyYWxQYXJzZXJFcnJvcjtcbnZhciBUZW1wbGF0ZUxpdGVyYWxQYXJzZXI7XG4oZnVuY3Rpb24gKFRlbXBsYXRlTGl0ZXJhbFBhcnNlcikge1xuICAgIGZ1bmN0aW9uIElzTm9uRXNjYXBlZChwYXR0ZXJuLCBpbmRleCwgY2hhcikge1xuICAgICAgICByZXR1cm4gcGF0dGVybltpbmRleF0gPT09IGNoYXIgJiYgcGF0dGVybi5jaGFyQ29kZUF0KGluZGV4IC0gMSkgIT09IDkyO1xuICAgIH1cbiAgICBmdW5jdGlvbiBJc09wZW5QYXJlbihwYXR0ZXJuLCBpbmRleCkge1xuICAgICAgICByZXR1cm4gSXNOb25Fc2NhcGVkKHBhdHRlcm4sIGluZGV4LCAnKCcpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBJc0Nsb3NlUGFyZW4ocGF0dGVybiwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIElzTm9uRXNjYXBlZChwYXR0ZXJuLCBpbmRleCwgJyknKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gSXNTZXBhcmF0b3IocGF0dGVybiwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIElzTm9uRXNjYXBlZChwYXR0ZXJuLCBpbmRleCwgJ3wnKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gSXNHcm91cChwYXR0ZXJuKSB7XG4gICAgICAgIGlmICghKElzT3BlblBhcmVuKHBhdHRlcm4sIDApICYmIElzQ2xvc2VQYXJlbihwYXR0ZXJuLCBwYXR0ZXJuLmxlbmd0aCAtIDEpKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IGNvdW50ID0gMDtcbiAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHBhdHRlcm4ubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICBpZiAoSXNPcGVuUGFyZW4ocGF0dGVybiwgaW5kZXgpKVxuICAgICAgICAgICAgICAgIGNvdW50ICs9IDE7XG4gICAgICAgICAgICBpZiAoSXNDbG9zZVBhcmVuKHBhdHRlcm4sIGluZGV4KSlcbiAgICAgICAgICAgICAgICBjb3VudCAtPSAxO1xuICAgICAgICAgICAgaWYgKGNvdW50ID09PSAwICYmIGluZGV4ICE9PSBwYXR0ZXJuLmxlbmd0aCAtIDEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBJbkdyb3VwKHBhdHRlcm4pIHtcbiAgICAgICAgcmV0dXJuIHBhdHRlcm4uc2xpY2UoMSwgcGF0dGVybi5sZW5ndGggLSAxKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gSXNQcmVjZWRlbmNlT3IocGF0dGVybikge1xuICAgICAgICBsZXQgY291bnQgPSAwO1xuICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgcGF0dGVybi5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgIGlmIChJc09wZW5QYXJlbihwYXR0ZXJuLCBpbmRleCkpXG4gICAgICAgICAgICAgICAgY291bnQgKz0gMTtcbiAgICAgICAgICAgIGlmIChJc0Nsb3NlUGFyZW4ocGF0dGVybiwgaW5kZXgpKVxuICAgICAgICAgICAgICAgIGNvdW50IC09IDE7XG4gICAgICAgICAgICBpZiAoSXNTZXBhcmF0b3IocGF0dGVybiwgaW5kZXgpICYmIGNvdW50ID09PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gSXNQcmVjZWRlbmNlQW5kKHBhdHRlcm4pIHtcbiAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHBhdHRlcm4ubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICBpZiAoSXNPcGVuUGFyZW4ocGF0dGVybiwgaW5kZXgpKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gT3IocGF0dGVybikge1xuICAgICAgICBsZXQgW2NvdW50LCBzdGFydF0gPSBbMCwgMF07XG4gICAgICAgIGNvbnN0IGV4cHJlc3Npb25zID0gW107XG4gICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBwYXR0ZXJuLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgaWYgKElzT3BlblBhcmVuKHBhdHRlcm4sIGluZGV4KSlcbiAgICAgICAgICAgICAgICBjb3VudCArPSAxO1xuICAgICAgICAgICAgaWYgKElzQ2xvc2VQYXJlbihwYXR0ZXJuLCBpbmRleCkpXG4gICAgICAgICAgICAgICAgY291bnQgLT0gMTtcbiAgICAgICAgICAgIGlmIChJc1NlcGFyYXRvcihwYXR0ZXJuLCBpbmRleCkgJiYgY291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCByYW5nZSA9IHBhdHRlcm4uc2xpY2Uoc3RhcnQsIGluZGV4KTtcbiAgICAgICAgICAgICAgICBpZiAocmFuZ2UubGVuZ3RoID4gMClcbiAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbnMucHVzaChQYXJzZShyYW5nZSkpO1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0gaW5kZXggKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJhbmdlID0gcGF0dGVybi5zbGljZShzdGFydCk7XG4gICAgICAgIGlmIChyYW5nZS5sZW5ndGggPiAwKVxuICAgICAgICAgICAgZXhwcmVzc2lvbnMucHVzaChQYXJzZShyYW5nZSkpO1xuICAgICAgICBpZiAoZXhwcmVzc2lvbnMubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogJ2NvbnN0JywgY29uc3Q6ICcnIH07XG4gICAgICAgIGlmIChleHByZXNzaW9ucy5sZW5ndGggPT09IDEpXG4gICAgICAgICAgICByZXR1cm4gZXhwcmVzc2lvbnNbMF07XG4gICAgICAgIHJldHVybiB7IHR5cGU6ICdvcicsIGV4cHI6IGV4cHJlc3Npb25zIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIEFuZChwYXR0ZXJuKSB7XG4gICAgICAgIGZ1bmN0aW9uIEdyb3VwKHZhbHVlLCBpbmRleCkge1xuICAgICAgICAgICAgaWYgKCFJc09wZW5QYXJlbih2YWx1ZSwgaW5kZXgpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUZW1wbGF0ZUxpdGVyYWxQYXJzZXJFcnJvcihgVGVtcGxhdGVMaXRlcmFsUGFyc2VyOiBJbmRleCBtdXN0IHBvaW50IHRvIG9wZW4gcGFyZW5zYCk7XG4gICAgICAgICAgICBsZXQgY291bnQgPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgc2NhbiA9IGluZGV4OyBzY2FuIDwgdmFsdWUubGVuZ3RoOyBzY2FuKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoSXNPcGVuUGFyZW4odmFsdWUsIHNjYW4pKVxuICAgICAgICAgICAgICAgICAgICBjb3VudCArPSAxO1xuICAgICAgICAgICAgICAgIGlmIChJc0Nsb3NlUGFyZW4odmFsdWUsIHNjYW4pKVxuICAgICAgICAgICAgICAgICAgICBjb3VudCAtPSAxO1xuICAgICAgICAgICAgICAgIGlmIChjb3VudCA9PT0gMClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtpbmRleCwgc2Nhbl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgVGVtcGxhdGVMaXRlcmFsUGFyc2VyRXJyb3IoYFRlbXBsYXRlTGl0ZXJhbFBhcnNlcjogVW5jbG9zZWQgZ3JvdXAgcGFyZW5zIGluIGV4cHJlc3Npb25gKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBSYW5nZShwYXR0ZXJuLCBpbmRleCkge1xuICAgICAgICAgICAgZm9yIChsZXQgc2NhbiA9IGluZGV4OyBzY2FuIDwgcGF0dGVybi5sZW5ndGg7IHNjYW4rKykge1xuICAgICAgICAgICAgICAgIGlmIChJc09wZW5QYXJlbihwYXR0ZXJuLCBzY2FuKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtpbmRleCwgc2Nhbl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW2luZGV4LCBwYXR0ZXJuLmxlbmd0aF07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXhwcmVzc2lvbnMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHBhdHRlcm4ubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICBpZiAoSXNPcGVuUGFyZW4ocGF0dGVybiwgaW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgW3N0YXJ0LCBlbmRdID0gR3JvdXAocGF0dGVybiwgaW5kZXgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJhbmdlID0gcGF0dGVybi5zbGljZShzdGFydCwgZW5kICsgMSk7XG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvbnMucHVzaChQYXJzZShyYW5nZSkpO1xuICAgICAgICAgICAgICAgIGluZGV4ID0gZW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgW3N0YXJ0LCBlbmRdID0gUmFuZ2UocGF0dGVybiwgaW5kZXgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJhbmdlID0gcGF0dGVybi5zbGljZShzdGFydCwgZW5kKTtcbiAgICAgICAgICAgICAgICBpZiAocmFuZ2UubGVuZ3RoID4gMClcbiAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbnMucHVzaChQYXJzZShyYW5nZSkpO1xuICAgICAgICAgICAgICAgIGluZGV4ID0gZW5kIC0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZXhwcmVzc2lvbnMubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogJ2NvbnN0JywgY29uc3Q6ICcnIH07XG4gICAgICAgIGlmIChleHByZXNzaW9ucy5sZW5ndGggPT09IDEpXG4gICAgICAgICAgICByZXR1cm4gZXhwcmVzc2lvbnNbMF07XG4gICAgICAgIHJldHVybiB7IHR5cGU6ICdhbmQnLCBleHByOiBleHByZXNzaW9ucyB9O1xuICAgIH1cbiAgICAvKiogUGFyc2VzIGEgcGF0dGVybiBhbmQgcmV0dXJucyBhbiBleHByZXNzaW9uIHRyZWUgKi9cbiAgICBmdW5jdGlvbiBQYXJzZShwYXR0ZXJuKSB7XG4gICAgICAgIGlmIChJc0dyb3VwKHBhdHRlcm4pKVxuICAgICAgICAgICAgcmV0dXJuIFBhcnNlKEluR3JvdXAocGF0dGVybikpO1xuICAgICAgICBpZiAoSXNQcmVjZWRlbmNlT3IocGF0dGVybikpXG4gICAgICAgICAgICByZXR1cm4gT3IocGF0dGVybik7XG4gICAgICAgIGlmIChJc1ByZWNlZGVuY2VBbmQocGF0dGVybikpXG4gICAgICAgICAgICByZXR1cm4gQW5kKHBhdHRlcm4pO1xuICAgICAgICByZXR1cm4geyB0eXBlOiAnY29uc3QnLCBjb25zdDogcGF0dGVybiB9O1xuICAgIH1cbiAgICBUZW1wbGF0ZUxpdGVyYWxQYXJzZXIuUGFyc2UgPSBQYXJzZTtcbiAgICAvKiogUGFyc2VzIGEgcGF0dGVybiBhbmQgc3RyaXBzIGZvcndhcmQgYW5kIHRyYWlsaW5nIF4gYW5kICQgKi9cbiAgICBmdW5jdGlvbiBQYXJzZUV4YWN0KHBhdHRlcm4pIHtcbiAgICAgICAgcmV0dXJuIFBhcnNlKHBhdHRlcm4uc2xpY2UoMSwgcGF0dGVybi5sZW5ndGggLSAxKSk7XG4gICAgfVxuICAgIFRlbXBsYXRlTGl0ZXJhbFBhcnNlci5QYXJzZUV4YWN0ID0gUGFyc2VFeGFjdDtcbn0pKFRlbXBsYXRlTGl0ZXJhbFBhcnNlciB8fCAoZXhwb3J0cy5UZW1wbGF0ZUxpdGVyYWxQYXJzZXIgPSBUZW1wbGF0ZUxpdGVyYWxQYXJzZXIgPSB7fSkpO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFRlbXBsYXRlTGl0ZXJhbEZpbml0ZVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbnZhciBUZW1wbGF0ZUxpdGVyYWxGaW5pdGU7XG4oZnVuY3Rpb24gKFRlbXBsYXRlTGl0ZXJhbEZpbml0ZSkge1xuICAgIGZ1bmN0aW9uIElzTnVtYmVyKGV4cHJlc3Npb24pIHtcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIHJldHVybiAoZXhwcmVzc2lvbi50eXBlID09PSAnb3InICYmXG4gICAgICAgICAgICBleHByZXNzaW9uLmV4cHIubGVuZ3RoID09PSAyICYmXG4gICAgICAgICAgICBleHByZXNzaW9uLmV4cHJbMF0udHlwZSA9PT0gJ2NvbnN0JyAmJlxuICAgICAgICAgICAgZXhwcmVzc2lvbi5leHByWzBdLmNvbnN0ID09PSAnMCcgJiZcbiAgICAgICAgICAgIGV4cHJlc3Npb24uZXhwclsxXS50eXBlID09PSAnY29uc3QnICYmXG4gICAgICAgICAgICBleHByZXNzaW9uLmV4cHJbMV0uY29uc3QgPT09ICdbMS05XVswLTldKicpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBJc0Jvb2xlYW4oZXhwcmVzc2lvbikge1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgcmV0dXJuIChleHByZXNzaW9uLnR5cGUgPT09ICdvcicgJiZcbiAgICAgICAgICAgIGV4cHJlc3Npb24uZXhwci5sZW5ndGggPT09IDIgJiZcbiAgICAgICAgICAgIGV4cHJlc3Npb24uZXhwclswXS50eXBlID09PSAnY29uc3QnICYmXG4gICAgICAgICAgICBleHByZXNzaW9uLmV4cHJbMF0uY29uc3QgPT09ICd0cnVlJyAmJlxuICAgICAgICAgICAgZXhwcmVzc2lvbi5leHByWzFdLnR5cGUgPT09ICdjb25zdCcgJiZcbiAgICAgICAgICAgIGV4cHJlc3Npb24uZXhwclsxXS5jb25zdCA9PT0gJ2ZhbHNlJyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIElzU3RyaW5nKGV4cHJlc3Npb24pIHtcbiAgICAgICAgcmV0dXJuIGV4cHJlc3Npb24udHlwZSA9PT0gJ2NvbnN0JyAmJiBleHByZXNzaW9uLmNvbnN0ID09PSAnLionO1xuICAgIH1cbiAgICBmdW5jdGlvbiBDaGVjayhleHByZXNzaW9uKSB7XG4gICAgICAgIGlmIChJc0Jvb2xlYW4oZXhwcmVzc2lvbikpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKElzTnVtYmVyKGV4cHJlc3Npb24pIHx8IElzU3RyaW5nKGV4cHJlc3Npb24pKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoZXhwcmVzc2lvbi50eXBlID09PSAnYW5kJylcbiAgICAgICAgICAgIHJldHVybiBleHByZXNzaW9uLmV4cHIuZXZlcnkoKGV4cHIpID0+IENoZWNrKGV4cHIpKTtcbiAgICAgICAgaWYgKGV4cHJlc3Npb24udHlwZSA9PT0gJ29yJylcbiAgICAgICAgICAgIHJldHVybiBleHByZXNzaW9uLmV4cHIuZXZlcnkoKGV4cHIpID0+IENoZWNrKGV4cHIpKTtcbiAgICAgICAgaWYgKGV4cHJlc3Npb24udHlwZSA9PT0gJ2NvbnN0JylcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB0aHJvdyBFcnJvcihgVGVtcGxhdGVMaXRlcmFsRmluaXRlOiBVbmtub3duIGV4cHJlc3Npb24gdHlwZWApO1xuICAgIH1cbiAgICBUZW1wbGF0ZUxpdGVyYWxGaW5pdGUuQ2hlY2sgPSBDaGVjaztcbn0pKFRlbXBsYXRlTGl0ZXJhbEZpbml0ZSB8fCAoZXhwb3J0cy5UZW1wbGF0ZUxpdGVyYWxGaW5pdGUgPSBUZW1wbGF0ZUxpdGVyYWxGaW5pdGUgPSB7fSkpO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFRlbXBsYXRlTGl0ZXJhbEdlbmVyYXRvclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbnZhciBUZW1wbGF0ZUxpdGVyYWxHZW5lcmF0b3I7XG4oZnVuY3Rpb24gKFRlbXBsYXRlTGl0ZXJhbEdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uKiBSZWR1Y2UoYnVmZmVyKSB7XG4gICAgICAgIGlmIChidWZmZXIubGVuZ3RoID09PSAxKVxuICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiBidWZmZXJbMF07XG4gICAgICAgIGZvciAoY29uc3QgbGVmdCBvZiBidWZmZXJbMF0pIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcmlnaHQgb2YgUmVkdWNlKGJ1ZmZlci5zbGljZSgxKSkpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCBgJHtsZWZ0fSR7cmlnaHR9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiogQW5kKGV4cHJlc3Npb24pIHtcbiAgICAgICAgcmV0dXJuIHlpZWxkKiBSZWR1Y2UoZXhwcmVzc2lvbi5leHByLm1hcCgoZXhwcikgPT4gWy4uLkdlbmVyYXRlKGV4cHIpXSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiogT3IoZXhwcmVzc2lvbikge1xuICAgICAgICBmb3IgKGNvbnN0IGV4cHIgb2YgZXhwcmVzc2lvbi5leHByKVxuICAgICAgICAgICAgeWllbGQqIEdlbmVyYXRlKGV4cHIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiogQ29uc3QoZXhwcmVzc2lvbikge1xuICAgICAgICByZXR1cm4geWllbGQgZXhwcmVzc2lvbi5jb25zdDtcbiAgICB9XG4gICAgZnVuY3Rpb24qIEdlbmVyYXRlKGV4cHJlc3Npb24pIHtcbiAgICAgICAgaWYgKGV4cHJlc3Npb24udHlwZSA9PT0gJ2FuZCcpXG4gICAgICAgICAgICByZXR1cm4geWllbGQqIEFuZChleHByZXNzaW9uKTtcbiAgICAgICAgaWYgKGV4cHJlc3Npb24udHlwZSA9PT0gJ29yJylcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCogT3IoZXhwcmVzc2lvbik7XG4gICAgICAgIGlmIChleHByZXNzaW9uLnR5cGUgPT09ICdjb25zdCcpXG4gICAgICAgICAgICByZXR1cm4geWllbGQqIENvbnN0KGV4cHJlc3Npb24pO1xuICAgICAgICB0aHJvdyBFcnJvcignVGVtcGxhdGVMaXRlcmFsR2VuZXJhdG9yOiBVbmtub3duIGV4cHJlc3Npb24nKTtcbiAgICB9XG4gICAgVGVtcGxhdGVMaXRlcmFsR2VuZXJhdG9yLkdlbmVyYXRlID0gR2VuZXJhdGU7XG59KShUZW1wbGF0ZUxpdGVyYWxHZW5lcmF0b3IgfHwgKGV4cG9ydHMuVGVtcGxhdGVMaXRlcmFsR2VuZXJhdG9yID0gVGVtcGxhdGVMaXRlcmFsR2VuZXJhdG9yID0ge30pKTtcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gVGVtcGxhdGVMaXRlcmFsRHNsUGFyc2VyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbnZhciBUZW1wbGF0ZUxpdGVyYWxEc2xQYXJzZXI7XG4oZnVuY3Rpb24gKFRlbXBsYXRlTGl0ZXJhbERzbFBhcnNlcikge1xuICAgIGZ1bmN0aW9uKiBQYXJzZVVuaW9uKHRlbXBsYXRlKSB7XG4gICAgICAgIGNvbnN0IHRyaW0gPSB0ZW1wbGF0ZS50cmltKCkucmVwbGFjZSgvXCJ8Jy9nLCAnJyk7XG4gICAgICAgIGlmICh0cmltID09PSAnYm9vbGVhbicpXG4gICAgICAgICAgICByZXR1cm4geWllbGQgZXhwb3J0cy5UeXBlLkJvb2xlYW4oKTtcbiAgICAgICAgaWYgKHRyaW0gPT09ICdudW1iZXInKVxuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIGV4cG9ydHMuVHlwZS5OdW1iZXIoKTtcbiAgICAgICAgaWYgKHRyaW0gPT09ICdiaWdpbnQnKVxuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIGV4cG9ydHMuVHlwZS5CaWdJbnQoKTtcbiAgICAgICAgaWYgKHRyaW0gPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIGV4cG9ydHMuVHlwZS5TdHJpbmcoKTtcbiAgICAgICAgY29uc3QgbGl0ZXJhbHMgPSB0cmltLnNwbGl0KCd8JykubWFwKChsaXRlcmFsKSA9PiBleHBvcnRzLlR5cGUuTGl0ZXJhbChsaXRlcmFsLnRyaW0oKSkpO1xuICAgICAgICByZXR1cm4geWllbGQgbGl0ZXJhbHMubGVuZ3RoID09PSAwID8gZXhwb3J0cy5UeXBlLk5ldmVyKCkgOiBsaXRlcmFscy5sZW5ndGggPT09IDEgPyBsaXRlcmFsc1swXSA6IGV4cG9ydHMuVHlwZS5VbmlvbihsaXRlcmFscyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uKiBQYXJzZVRlcm1pbmFsKHRlbXBsYXRlKSB7XG4gICAgICAgIGlmICh0ZW1wbGF0ZVsxXSAhPT0gJ3snKSB7XG4gICAgICAgICAgICBjb25zdCBMID0gZXhwb3J0cy5UeXBlLkxpdGVyYWwoJyQnKTtcbiAgICAgICAgICAgIGNvbnN0IFIgPSBQYXJzZUxpdGVyYWwodGVtcGxhdGUuc2xpY2UoMSkpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiBbTCwgLi4uUl07XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDI7IGkgPCB0ZW1wbGF0ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRlbXBsYXRlW2ldID09PSAnfScpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBMID0gUGFyc2VVbmlvbih0ZW1wbGF0ZS5zbGljZSgyLCBpKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgUiA9IFBhcnNlTGl0ZXJhbCh0ZW1wbGF0ZS5zbGljZShpICsgMSkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCogWy4uLkwsIC4uLlJdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHlpZWxkIGV4cG9ydHMuVHlwZS5MaXRlcmFsKHRlbXBsYXRlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24qIFBhcnNlTGl0ZXJhbCh0ZW1wbGF0ZSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRlbXBsYXRlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGVtcGxhdGVbaV0gPT09ICckJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IEwgPSBleHBvcnRzLlR5cGUuTGl0ZXJhbCh0ZW1wbGF0ZS5zbGljZSgwLCBpKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgUiA9IFBhcnNlVGVybWluYWwodGVtcGxhdGUuc2xpY2UoaSkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCogW0wsIC4uLlJdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHlpZWxkIGV4cG9ydHMuVHlwZS5MaXRlcmFsKHRlbXBsYXRlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gUGFyc2UodGVtcGxhdGVfZHNsKSB7XG4gICAgICAgIHJldHVybiBbLi4uUGFyc2VMaXRlcmFsKHRlbXBsYXRlX2RzbCldO1xuICAgIH1cbiAgICBUZW1wbGF0ZUxpdGVyYWxEc2xQYXJzZXIuUGFyc2UgPSBQYXJzZTtcbn0pKFRlbXBsYXRlTGl0ZXJhbERzbFBhcnNlciB8fCAoZXhwb3J0cy5UZW1wbGF0ZUxpdGVyYWxEc2xQYXJzZXIgPSBUZW1wbGF0ZUxpdGVyYWxEc2xQYXJzZXIgPSB7fSkpO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFR5cGVPcmRpbmFsOiBVc2VkIGZvciBhdXRvICRpZCBnZW5lcmF0aW9uXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxubGV0IFR5cGVPcmRpbmFsID0gMDtcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBUeXBlQnVpbGRlclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmNsYXNzIFR5cGVCdWlsZGVyIHtcbiAgICAvKiogYFtVdGlsaXR5XWAgQ3JlYXRlcyBhIHNjaGVtYSB3aXRob3V0IGBzdGF0aWNgIGFuZCBgcGFyYW1zYCB0eXBlcyAqL1xuICAgIENyZWF0ZShzY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIHNjaGVtYTtcbiAgICB9XG4gICAgLyoqIGBbU3RhbmRhcmRdYCBPbWl0cyBjb21wb3NpdGluZyBzeW1ib2xzIGZyb20gdGhpcyBzY2hlbWEgKi9cbiAgICBTdHJpY3Qoc2NoZW1hKSB7XG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHNjaGVtYSkpO1xuICAgIH1cbn1cbmV4cG9ydHMuVHlwZUJ1aWxkZXIgPSBUeXBlQnVpbGRlcjtcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBTdGFuZGFyZFR5cGVCdWlsZGVyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuY2xhc3MgU3RhbmRhcmRUeXBlQnVpbGRlciBleHRlbmRzIFR5cGVCdWlsZGVyIHtcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBNb2RpZmllcnNcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvKiogYFtNb2RpZmllcl1gIENyZWF0ZXMgYSBPcHRpb25hbCBwcm9wZXJ0eSAqL1xuICAgIE9wdGlvbmFsKHNjaGVtYSkge1xuICAgICAgICByZXR1cm4geyBbZXhwb3J0cy5Nb2RpZmllcl06ICdPcHRpb25hbCcsIC4uLlR5cGVDbG9uZS5DbG9uZShzY2hlbWEsIHt9KSB9O1xuICAgIH1cbiAgICAvKiogYFtNb2RpZmllcl1gIENyZWF0ZXMgYSBSZWFkb25seU9wdGlvbmFsIHByb3BlcnR5ICovXG4gICAgUmVhZG9ubHlPcHRpb25hbChzY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIHsgW2V4cG9ydHMuTW9kaWZpZXJdOiAnUmVhZG9ubHlPcHRpb25hbCcsIC4uLlR5cGVDbG9uZS5DbG9uZShzY2hlbWEsIHt9KSB9O1xuICAgIH1cbiAgICAvKiogYFtNb2RpZmllcl1gIENyZWF0ZXMgYSBSZWFkb25seSBvYmplY3Qgb3IgcHJvcGVydHkgKi9cbiAgICBSZWFkb25seShzY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIHsgW2V4cG9ydHMuTW9kaWZpZXJdOiAnUmVhZG9ubHknLCAuLi5zY2hlbWEgfTtcbiAgICB9XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gVHlwZXNcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvKiogYFtTdGFuZGFyZF1gIENyZWF0ZXMgYW4gQW55IHR5cGUgKi9cbiAgICBBbnkob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHJldHVybiB0aGlzLkNyZWF0ZSh7IC4uLm9wdGlvbnMsIFtleHBvcnRzLktpbmRdOiAnQW55JyB9KTtcbiAgICB9XG4gICAgLyoqIGBbU3RhbmRhcmRdYCBDcmVhdGVzIGFuIEFycmF5IHR5cGUgKi9cbiAgICBBcnJheShpdGVtcywgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHJldHVybiB0aGlzLkNyZWF0ZSh7IC4uLm9wdGlvbnMsIFtleHBvcnRzLktpbmRdOiAnQXJyYXknLCB0eXBlOiAnYXJyYXknLCBpdGVtczogVHlwZUNsb25lLkNsb25lKGl0ZW1zLCB7fSkgfSk7XG4gICAgfVxuICAgIC8qKiBgW1N0YW5kYXJkXWAgQ3JlYXRlcyBhIEJvb2xlYW4gdHlwZSAqL1xuICAgIEJvb2xlYW4ob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHJldHVybiB0aGlzLkNyZWF0ZSh7IC4uLm9wdGlvbnMsIFtleHBvcnRzLktpbmRdOiAnQm9vbGVhbicsIHR5cGU6ICdib29sZWFuJyB9KTtcbiAgICB9XG4gICAgLyoqIGBbU3RhbmRhcmRdYCBDcmVhdGVzIGEgQ29tcG9zaXRlIG9iamVjdCB0eXBlLiAqL1xuICAgIENvbXBvc2l0ZShvYmplY3RzLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGludGVyc2VjdCA9IGV4cG9ydHMuVHlwZS5JbnRlcnNlY3Qob2JqZWN0cywge30pO1xuICAgICAgICBjb25zdCBrZXlzID0gS2V5UmVzb2x2ZXIuUmVzb2x2ZUtleXMoaW50ZXJzZWN0LCB7IGluY2x1ZGVQYXR0ZXJuczogZmFsc2UgfSk7XG4gICAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSBrZXlzLnJlZHVjZSgoYWNjLCBrZXkpID0+ICh7IC4uLmFjYywgW2tleV06IGV4cG9ydHMuVHlwZS5JbmRleChpbnRlcnNlY3QsIFtrZXldKSB9KSwge30pO1xuICAgICAgICByZXR1cm4gZXhwb3J0cy5UeXBlLk9iamVjdChwcm9wZXJ0aWVzLCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqIGBbU3RhbmRhcmRdYCBDcmVhdGVzIGEgRW51bSB0eXBlICovXG4gICAgRW51bShpdGVtLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IGdsb2JhbFRoaXMuT2JqZWN0LmtleXMoaXRlbSkuZmlsdGVyKChrZXkpID0+IGlzTmFOKGtleSkpLm1hcCgoa2V5KSA9PiBpdGVtW2tleV0pO1xuICAgICAgICBjb25zdCBhbnlPZiA9IHZhbHVlcy5tYXAoKHZhbHVlKSA9PiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyA/IHsgW2V4cG9ydHMuS2luZF06ICdMaXRlcmFsJywgdHlwZTogJ3N0cmluZycsIGNvbnN0OiB2YWx1ZSB9IDogeyBbZXhwb3J0cy5LaW5kXTogJ0xpdGVyYWwnLCB0eXBlOiAnbnVtYmVyJywgY29uc3Q6IHZhbHVlIH0pKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuQ3JlYXRlKHsgLi4ub3B0aW9ucywgW2V4cG9ydHMuS2luZF06ICdVbmlvbicsIGFueU9mIH0pO1xuICAgIH1cbiAgICAvKiogYFtTdGFuZGFyZF1gIEEgY29uZGl0aW9uYWwgdHlwZSBleHByZXNzaW9uIHRoYXQgd2lsbCByZXR1cm4gdGhlIHRydWUgdHlwZSBpZiB0aGUgbGVmdCB0eXBlIGV4dGVuZHMgdGhlIHJpZ2h0ICovXG4gICAgRXh0ZW5kcyhsZWZ0LCByaWdodCwgdHJ1ZVR5cGUsIGZhbHNlVHlwZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHN3aXRjaCAoVHlwZUV4dGVuZHMuRXh0ZW5kcyhsZWZ0LCByaWdodCkpIHtcbiAgICAgICAgICAgIGNhc2UgVHlwZUV4dGVuZHNSZXN1bHQuVW5pb246XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuVW5pb24oW1R5cGVDbG9uZS5DbG9uZSh0cnVlVHlwZSwgb3B0aW9ucyksIFR5cGVDbG9uZS5DbG9uZShmYWxzZVR5cGUsIG9wdGlvbnMpXSk7XG4gICAgICAgICAgICBjYXNlIFR5cGVFeHRlbmRzUmVzdWx0LlRydWU6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFR5cGVDbG9uZS5DbG9uZSh0cnVlVHlwZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjYXNlIFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlOlxuICAgICAgICAgICAgICAgIHJldHVybiBUeXBlQ2xvbmUuQ2xvbmUoZmFsc2VUeXBlLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogYFtTdGFuZGFyZF1gIEV4Y2x1ZGVzIGZyb20gdGhlIGxlZnQgdHlwZSBhbnkgdHlwZSB0aGF0IGlzIG5vdCBhc3NpZ25hYmxlIHRvIHRoZSByaWdodCAqL1xuICAgIEV4Y2x1ZGUobGVmdCwgcmlnaHQsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRUZW1wbGF0ZUxpdGVyYWwobGVmdCkpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5FeGNsdWRlKFRlbXBsYXRlTGl0ZXJhbFJlc29sdmVyLlJlc29sdmUobGVmdCksIHJpZ2h0LCBvcHRpb25zKTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVGVtcGxhdGVMaXRlcmFsKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLkV4Y2x1ZGUobGVmdCwgVGVtcGxhdGVMaXRlcmFsUmVzb2x2ZXIuUmVzb2x2ZShyaWdodCksIG9wdGlvbnMpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRVbmlvbihsZWZ0KSkge1xuICAgICAgICAgICAgY29uc3QgbmFycm93ZWQgPSBsZWZ0LmFueU9mLmZpbHRlcigoaW5uZXIpID0+IFR5cGVFeHRlbmRzLkV4dGVuZHMoaW5uZXIsIHJpZ2h0KSA9PT0gVHlwZUV4dGVuZHNSZXN1bHQuRmFsc2UpO1xuICAgICAgICAgICAgcmV0dXJuIChuYXJyb3dlZC5sZW5ndGggPT09IDEgPyBUeXBlQ2xvbmUuQ2xvbmUobmFycm93ZWRbMF0sIG9wdGlvbnMpIDogdGhpcy5VbmlvbihuYXJyb3dlZCwgb3B0aW9ucykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIChUeXBlRXh0ZW5kcy5FeHRlbmRzKGxlZnQsIHJpZ2h0KSAhPT0gVHlwZUV4dGVuZHNSZXN1bHQuRmFsc2UgPyB0aGlzLk5ldmVyKG9wdGlvbnMpIDogVHlwZUNsb25lLkNsb25lKGxlZnQsIG9wdGlvbnMpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogYFtTdGFuZGFyZF1gIEV4dHJhY3RzIGZyb20gdGhlIGxlZnQgdHlwZSBhbnkgdHlwZSB0aGF0IGlzIGFzc2lnbmFibGUgdG8gdGhlIHJpZ2h0ICovXG4gICAgRXh0cmFjdChsZWZ0LCByaWdodCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFRlbXBsYXRlTGl0ZXJhbChsZWZ0KSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLkV4dHJhY3QoVGVtcGxhdGVMaXRlcmFsUmVzb2x2ZXIuUmVzb2x2ZShsZWZ0KSwgcmlnaHQsIG9wdGlvbnMpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRUZW1wbGF0ZUxpdGVyYWwocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuRXh0cmFjdChsZWZ0LCBUZW1wbGF0ZUxpdGVyYWxSZXNvbHZlci5SZXNvbHZlKHJpZ2h0KSwgb3B0aW9ucyk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFVuaW9uKGxlZnQpKSB7XG4gICAgICAgICAgICBjb25zdCBuYXJyb3dlZCA9IGxlZnQuYW55T2YuZmlsdGVyKChpbm5lcikgPT4gVHlwZUV4dGVuZHMuRXh0ZW5kcyhpbm5lciwgcmlnaHQpICE9PSBUeXBlRXh0ZW5kc1Jlc3VsdC5GYWxzZSk7XG4gICAgICAgICAgICByZXR1cm4gKG5hcnJvd2VkLmxlbmd0aCA9PT0gMSA/IFR5cGVDbG9uZS5DbG9uZShuYXJyb3dlZFswXSwgb3B0aW9ucykgOiB0aGlzLlVuaW9uKG5hcnJvd2VkLCBvcHRpb25zKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gKFR5cGVFeHRlbmRzLkV4dGVuZHMobGVmdCwgcmlnaHQpICE9PSBUeXBlRXh0ZW5kc1Jlc3VsdC5GYWxzZSA/IFR5cGVDbG9uZS5DbG9uZShsZWZ0LCBvcHRpb25zKSA6IHRoaXMuTmV2ZXIob3B0aW9ucykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBgW1N0YW5kYXJkXWAgUmV0dXJucyBpbmRleGVkIHByb3BlcnR5IHR5cGVzIGZvciB0aGUgZ2l2ZW4ga2V5cyAqL1xuICAgIEluZGV4KHNjaGVtYSwgdW5yZXNvbHZlZCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVEFycmF5KHNjaGVtYSkgJiYgVHlwZUd1YXJkLlROdW1iZXIodW5yZXNvbHZlZCkpIHtcbiAgICAgICAgICAgIHJldHVybiBUeXBlQ2xvbmUuQ2xvbmUoc2NoZW1hLml0ZW1zLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChUeXBlR3VhcmQuVFR1cGxlKHNjaGVtYSkgJiYgVHlwZUd1YXJkLlROdW1iZXIodW5yZXNvbHZlZCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW1zID0gc2NoZW1hLml0ZW1zID09PSB1bmRlZmluZWQgPyBbXSA6IHNjaGVtYS5pdGVtcztcbiAgICAgICAgICAgIGNvbnN0IGNsb25lZCA9IGl0ZW1zLm1hcCgoc2NoZW1hKSA9PiBUeXBlQ2xvbmUuQ2xvbmUoc2NoZW1hLCB7fSkpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuVW5pb24oY2xvbmVkLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGtleXMgPSBLZXlBcnJheVJlc29sdmVyLlJlc29sdmUodW5yZXNvbHZlZCk7XG4gICAgICAgICAgICBjb25zdCBjbG9uZSA9IFR5cGVDbG9uZS5DbG9uZShzY2hlbWEsIHt9KTtcbiAgICAgICAgICAgIHJldHVybiBJbmRleGVkQWNjZXNzb3IuUmVzb2x2ZShjbG9uZSwga2V5cywgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIGBbU3RhbmRhcmRdYCBDcmVhdGVzIGFuIEludGVnZXIgdHlwZSAqL1xuICAgIEludGVnZXIob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHJldHVybiB0aGlzLkNyZWF0ZSh7IC4uLm9wdGlvbnMsIFtleHBvcnRzLktpbmRdOiAnSW50ZWdlcicsIHR5cGU6ICdpbnRlZ2VyJyB9KTtcbiAgICB9XG4gICAgSW50ZXJzZWN0KGFsbE9mLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgaWYgKGFsbE9mLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLlR5cGUuTmV2ZXIoKTtcbiAgICAgICAgaWYgKGFsbE9mLmxlbmd0aCA9PT0gMSlcbiAgICAgICAgICAgIHJldHVybiBUeXBlQ2xvbmUuQ2xvbmUoYWxsT2ZbMF0sIG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBvYmplY3RzID0gYWxsT2YuZXZlcnkoKHNjaGVtYSkgPT4gVHlwZUd1YXJkLlRPYmplY3Qoc2NoZW1hKSk7XG4gICAgICAgIGNvbnN0IGNsb25lZCA9IGFsbE9mLm1hcCgoc2NoZW1hKSA9PiBUeXBlQ2xvbmUuQ2xvbmUoc2NoZW1hLCB7fSkpO1xuICAgICAgICBjb25zdCBjbG9uZWRVbmV2YWx1YXRlZFByb3BlcnRpZXMgPSBUeXBlR3VhcmQuVFNjaGVtYShvcHRpb25zLnVuZXZhbHVhdGVkUHJvcGVydGllcykgPyB7IHVuZXZhbHVhdGVkUHJvcGVydGllczogVHlwZUNsb25lLkNsb25lKG9wdGlvbnMudW5ldmFsdWF0ZWRQcm9wZXJ0aWVzLCB7fSkgfSA6IHt9O1xuICAgICAgICBpZiAob3B0aW9ucy51bmV2YWx1YXRlZFByb3BlcnRpZXMgPT09IGZhbHNlIHx8IFR5cGVHdWFyZC5UU2NoZW1hKG9wdGlvbnMudW5ldmFsdWF0ZWRQcm9wZXJ0aWVzKSB8fCBvYmplY3RzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5DcmVhdGUoeyAuLi5vcHRpb25zLCAuLi5jbG9uZWRVbmV2YWx1YXRlZFByb3BlcnRpZXMsIFtleHBvcnRzLktpbmRdOiAnSW50ZXJzZWN0JywgdHlwZTogJ29iamVjdCcsIGFsbE9mOiBjbG9uZWQgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5DcmVhdGUoeyAuLi5vcHRpb25zLCAuLi5jbG9uZWRVbmV2YWx1YXRlZFByb3BlcnRpZXMsIFtleHBvcnRzLktpbmRdOiAnSW50ZXJzZWN0JywgYWxsT2Y6IGNsb25lZCB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogYFtTdGFuZGFyZF1gIENyZWF0ZXMgYSBLZXlPZiB0eXBlICovXG4gICAgS2V5T2Yoc2NoZW1hLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UUmVjb3JkKHNjaGVtYSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhdHRlcm4gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhzY2hlbWEucGF0dGVyblByb3BlcnRpZXMpWzBdO1xuICAgICAgICAgICAgaWYgKHBhdHRlcm4gPT09IGV4cG9ydHMuUGF0dGVybk51bWJlckV4YWN0KVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLk51bWJlcihvcHRpb25zKTtcbiAgICAgICAgICAgIGlmIChwYXR0ZXJuID09PSBleHBvcnRzLlBhdHRlcm5TdHJpbmdFeGFjdClcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5TdHJpbmcob3B0aW9ucyk7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcignU3RhbmRhcmRUeXBlQnVpbGRlcjogVW5hYmxlIHRvIHJlc29sdmUga2V5IHR5cGUgZnJvbSBSZWNvcmQga2V5IHBhdHRlcm4nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChUeXBlR3VhcmQuVFR1cGxlKHNjaGVtYSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW1zID0gc2NoZW1hLml0ZW1zID09PSB1bmRlZmluZWQgPyBbXSA6IHNjaGVtYS5pdGVtcztcbiAgICAgICAgICAgIGNvbnN0IGxpdGVyYWxzID0gaXRlbXMubWFwKChfLCBpbmRleCkgPT4gZXhwb3J0cy5UeXBlLkxpdGVyYWwoaW5kZXgpKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLlVuaW9uKGxpdGVyYWxzLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChUeXBlR3VhcmQuVEFycmF5KHNjaGVtYSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLk51bWJlcihvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGtleXMgPSBLZXlSZXNvbHZlci5SZXNvbHZlS2V5cyhzY2hlbWEsIHsgaW5jbHVkZVBhdHRlcm5zOiBmYWxzZSB9KTtcbiAgICAgICAgICAgIGlmIChrZXlzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5OZXZlcihvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxpdGVyYWxzID0ga2V5cy5tYXAoKGtleSkgPT4gdGhpcy5MaXRlcmFsKGtleSkpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuVW5pb24obGl0ZXJhbHMsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBgW1N0YW5kYXJkXWAgQ3JlYXRlcyBhIExpdGVyYWwgdHlwZSAqL1xuICAgIExpdGVyYWwodmFsdWUsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICByZXR1cm4gdGhpcy5DcmVhdGUoeyAuLi5vcHRpb25zLCBbZXhwb3J0cy5LaW5kXTogJ0xpdGVyYWwnLCBjb25zdDogdmFsdWUsIHR5cGU6IHR5cGVvZiB2YWx1ZSB9KTtcbiAgICB9XG4gICAgLyoqIGBbU3RhbmRhcmRdYCBDcmVhdGVzIGEgTmV2ZXIgdHlwZSAqL1xuICAgIE5ldmVyKG9wdGlvbnMgPSB7fSkge1xuICAgICAgICByZXR1cm4gdGhpcy5DcmVhdGUoeyAuLi5vcHRpb25zLCBbZXhwb3J0cy5LaW5kXTogJ05ldmVyJywgbm90OiB7fSB9KTtcbiAgICB9XG4gICAgLyoqIGBbU3RhbmRhcmRdYCBDcmVhdGVzIGEgTm90IHR5cGUuIFRoZSBmaXJzdCBhcmd1bWVudCBpcyB0aGUgZGlzYWxsb3dlZCB0eXBlLCB0aGUgc2Vjb25kIGlzIHRoZSBhbGxvd2VkLiAqL1xuICAgIE5vdChub3QsIHNjaGVtYSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5DcmVhdGUoeyAuLi5vcHRpb25zLCBbZXhwb3J0cy5LaW5kXTogJ05vdCcsIGFsbE9mOiBbeyBub3Q6IFR5cGVDbG9uZS5DbG9uZShub3QsIHt9KSB9LCBUeXBlQ2xvbmUuQ2xvbmUoc2NoZW1hLCB7fSldIH0pO1xuICAgIH1cbiAgICAvKiogYFtTdGFuZGFyZF1gIENyZWF0ZXMgYSBOdWxsIHR5cGUgKi9cbiAgICBOdWxsKG9wdGlvbnMgPSB7fSkge1xuICAgICAgICByZXR1cm4gdGhpcy5DcmVhdGUoeyAuLi5vcHRpb25zLCBbZXhwb3J0cy5LaW5kXTogJ051bGwnLCB0eXBlOiAnbnVsbCcgfSk7XG4gICAgfVxuICAgIC8qKiBgW1N0YW5kYXJkXWAgQ3JlYXRlcyBhIE51bWJlciB0eXBlICovXG4gICAgTnVtYmVyKG9wdGlvbnMgPSB7fSkge1xuICAgICAgICByZXR1cm4gdGhpcy5DcmVhdGUoeyAuLi5vcHRpb25zLCBbZXhwb3J0cy5LaW5kXTogJ051bWJlcicsIHR5cGU6ICdudW1iZXInIH0pO1xuICAgIH1cbiAgICAvKiogYFtTdGFuZGFyZF1gIENyZWF0ZXMgYW4gT2JqZWN0IHR5cGUgKi9cbiAgICBPYmplY3QocHJvcGVydGllcywgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHByb3BlcnR5S2V5cyA9IGdsb2JhbFRoaXMuT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocHJvcGVydGllcyk7XG4gICAgICAgIGNvbnN0IG9wdGlvbmFsS2V5cyA9IHByb3BlcnR5S2V5cy5maWx0ZXIoKGtleSkgPT4gVHlwZUd1YXJkLlRPcHRpb25hbChwcm9wZXJ0aWVzW2tleV0pIHx8IFR5cGVHdWFyZC5UUmVhZG9ubHlPcHRpb25hbChwcm9wZXJ0aWVzW2tleV0pKTtcbiAgICAgICAgY29uc3QgcmVxdWlyZWRLZXlzID0gcHJvcGVydHlLZXlzLmZpbHRlcigobmFtZSkgPT4gIW9wdGlvbmFsS2V5cy5pbmNsdWRlcyhuYW1lKSk7XG4gICAgICAgIGNvbnN0IGNsb25lZEFkZGl0aW9uYWxQcm9wZXJ0aWVzID0gVHlwZUd1YXJkLlRTY2hlbWEob3B0aW9ucy5hZGRpdGlvbmFsUHJvcGVydGllcykgPyB7IGFkZGl0aW9uYWxQcm9wZXJ0aWVzOiBUeXBlQ2xvbmUuQ2xvbmUob3B0aW9ucy5hZGRpdGlvbmFsUHJvcGVydGllcywge30pIH0gOiB7fTtcbiAgICAgICAgY29uc3QgY2xvbmVkUHJvcGVydGllcyA9IHByb3BlcnR5S2V5cy5yZWR1Y2UoKGFjYywga2V5KSA9PiAoeyAuLi5hY2MsIFtrZXldOiBUeXBlQ2xvbmUuQ2xvbmUocHJvcGVydGllc1trZXldLCB7fSkgfSksIHt9KTtcbiAgICAgICAgaWYgKHJlcXVpcmVkS2V5cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5DcmVhdGUoeyAuLi5vcHRpb25zLCAuLi5jbG9uZWRBZGRpdGlvbmFsUHJvcGVydGllcywgW2V4cG9ydHMuS2luZF06ICdPYmplY3QnLCB0eXBlOiAnb2JqZWN0JywgcHJvcGVydGllczogY2xvbmVkUHJvcGVydGllcywgcmVxdWlyZWQ6IHJlcXVpcmVkS2V5cyB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLkNyZWF0ZSh7IC4uLm9wdGlvbnMsIC4uLmNsb25lZEFkZGl0aW9uYWxQcm9wZXJ0aWVzLCBbZXhwb3J0cy5LaW5kXTogJ09iamVjdCcsIHR5cGU6ICdvYmplY3QnLCBwcm9wZXJ0aWVzOiBjbG9uZWRQcm9wZXJ0aWVzIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIE9taXQoc2NoZW1hLCB1bnJlc29sdmVkLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgY29uc3Qga2V5cyA9IEtleUFycmF5UmVzb2x2ZXIuUmVzb2x2ZSh1bnJlc29sdmVkKTtcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIHJldHVybiBPYmplY3RNYXAuTWFwKFR5cGVDbG9uZS5DbG9uZShzY2hlbWEsIHt9KSwgKHNjaGVtYSkgPT4ge1xuICAgICAgICAgICAgaWYgKHNjaGVtYS5yZXF1aXJlZCkge1xuICAgICAgICAgICAgICAgIHNjaGVtYS5yZXF1aXJlZCA9IHNjaGVtYS5yZXF1aXJlZC5maWx0ZXIoKGtleSkgPT4gIWtleXMuaW5jbHVkZXMoa2V5KSk7XG4gICAgICAgICAgICAgICAgaWYgKHNjaGVtYS5yZXF1aXJlZC5sZW5ndGggPT09IDApXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBzY2hlbWEucmVxdWlyZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBnbG9iYWxUaGlzLk9iamVjdC5rZXlzKHNjaGVtYS5wcm9wZXJ0aWVzKSkge1xuICAgICAgICAgICAgICAgIGlmIChrZXlzLmluY2x1ZGVzKGtleSkpXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBzY2hlbWEucHJvcGVydGllc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuQ3JlYXRlKHNjaGVtYSk7XG4gICAgICAgIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKiogYFtTdGFuZGFyZF1gIENyZWF0ZXMgYSBtYXBwZWQgdHlwZSB3aGVyZSBhbGwgcHJvcGVydGllcyBhcmUgT3B0aW9uYWwgKi9cbiAgICBQYXJ0aWFsKHNjaGVtYSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGZ1bmN0aW9uIEFwcGx5KHNjaGVtYSkge1xuICAgICAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgICAgICBzd2l0Y2ggKHNjaGVtYVtleHBvcnRzLk1vZGlmaWVyXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ1JlYWRvbmx5T3B0aW9uYWwnOlxuICAgICAgICAgICAgICAgICAgICBzY2hlbWFbZXhwb3J0cy5Nb2RpZmllcl0gPSAnUmVhZG9ubHlPcHRpb25hbCc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ1JlYWRvbmx5JzpcbiAgICAgICAgICAgICAgICAgICAgc2NoZW1hW2V4cG9ydHMuTW9kaWZpZXJdID0gJ1JlYWRvbmx5T3B0aW9uYWwnO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdPcHRpb25hbCc6XG4gICAgICAgICAgICAgICAgICAgIHNjaGVtYVtleHBvcnRzLk1vZGlmaWVyXSA9ICdPcHRpb25hbCc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHNjaGVtYVtleHBvcnRzLk1vZGlmaWVyXSA9ICdPcHRpb25hbCc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICByZXR1cm4gT2JqZWN0TWFwLk1hcChUeXBlQ2xvbmUuQ2xvbmUoc2NoZW1hLCB7fSksIChzY2hlbWEpID0+IHtcbiAgICAgICAgICAgIGRlbGV0ZSBzY2hlbWEucmVxdWlyZWQ7XG4gICAgICAgICAgICBnbG9iYWxUaGlzLk9iamVjdC5rZXlzKHNjaGVtYS5wcm9wZXJ0aWVzKS5mb3JFYWNoKGtleSA9PiBBcHBseShzY2hlbWEucHJvcGVydGllc1trZXldKSk7XG4gICAgICAgICAgICByZXR1cm4gc2NoZW1hO1xuICAgICAgICB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgUGljayhzY2hlbWEsIHVucmVzb2x2ZWQsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBjb25zdCBrZXlzID0gS2V5QXJyYXlSZXNvbHZlci5SZXNvbHZlKHVucmVzb2x2ZWQpO1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgcmV0dXJuIE9iamVjdE1hcC5NYXAoVHlwZUNsb25lLkNsb25lKHNjaGVtYSwge30pLCAoc2NoZW1hKSA9PiB7XG4gICAgICAgICAgICBpZiAoc2NoZW1hLnJlcXVpcmVkKSB7XG4gICAgICAgICAgICAgICAgc2NoZW1hLnJlcXVpcmVkID0gc2NoZW1hLnJlcXVpcmVkLmZpbHRlcigoa2V5KSA9PiBrZXlzLmluY2x1ZGVzKGtleSkpO1xuICAgICAgICAgICAgICAgIGlmIChzY2hlbWEucmVxdWlyZWQubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgc2NoZW1hLnJlcXVpcmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgZ2xvYmFsVGhpcy5PYmplY3Qua2V5cyhzY2hlbWEucHJvcGVydGllcykpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWtleXMuaW5jbHVkZXMoa2V5KSlcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHNjaGVtYS5wcm9wZXJ0aWVzW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5DcmVhdGUoc2NoZW1hKTtcbiAgICAgICAgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKiBgW1N0YW5kYXJkXWAgQ3JlYXRlcyBhIFJlY29yZCB0eXBlICovXG4gICAgUmVjb3JkKGtleSwgc2NoZW1hLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVGVtcGxhdGVMaXRlcmFsKGtleSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSBUZW1wbGF0ZUxpdGVyYWxQYXJzZXIuUGFyc2VFeGFjdChrZXkucGF0dGVybik7XG4gICAgICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgICAgIHJldHVybiBUZW1wbGF0ZUxpdGVyYWxGaW5pdGUuQ2hlY2soZXhwcmVzc2lvbilcbiAgICAgICAgICAgICAgICA/ICh0aGlzLk9iamVjdChbLi4uVGVtcGxhdGVMaXRlcmFsR2VuZXJhdG9yLkdlbmVyYXRlKGV4cHJlc3Npb24pXS5yZWR1Y2UoKGFjYywga2V5KSA9PiAoeyAuLi5hY2MsIFtrZXldOiBUeXBlQ2xvbmUuQ2xvbmUoc2NoZW1hLCB7fSkgfSksIHt9KSwgb3B0aW9ucykpXG4gICAgICAgICAgICAgICAgOiB0aGlzLkNyZWF0ZSh7IC4uLm9wdGlvbnMsIFtleHBvcnRzLktpbmRdOiAnUmVjb3JkJywgdHlwZTogJ29iamVjdCcsIHBhdHRlcm5Qcm9wZXJ0aWVzOiB7IFtrZXkucGF0dGVybl06IFR5cGVDbG9uZS5DbG9uZShzY2hlbWEsIHt9KSB9IH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFR5cGVHdWFyZC5UVW5pb24oa2V5KSkge1xuICAgICAgICAgICAgY29uc3QgdW5pb24gPSBVbmlvblJlc29sdmVyLlJlc29sdmUoa2V5KTtcbiAgICAgICAgICAgIGlmIChUeXBlR3VhcmQuVFVuaW9uTGl0ZXJhbCh1bmlvbikpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9wZXJ0aWVzID0gdW5pb24uYW55T2YucmVkdWNlKChhY2MsIGxpdGVyYWwpID0+ICh7IC4uLmFjYywgW2xpdGVyYWwuY29uc3RdOiBUeXBlQ2xvbmUuQ2xvbmUoc2NoZW1hLCB7fSkgfSksIHt9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5PYmplY3QocHJvcGVydGllcywgeyAuLi5vcHRpb25zLCBbZXhwb3J0cy5IaW50XTogJ1JlY29yZCcgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ1R5cGVCdWlsZGVyOiBSZWNvcmQga2V5IG9mIHR5cGUgdW5pb24gY29udGFpbnMgbm9uLWxpdGVyYWwgdHlwZXMnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChUeXBlR3VhcmQuVExpdGVyYWwoa2V5KSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXkuY29uc3QgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBrZXkuY29uc3QgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuT2JqZWN0KHsgW2tleS5jb25zdF06IFR5cGVDbG9uZS5DbG9uZShzY2hlbWEsIHt9KSB9LCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcignVHlwZUJ1aWxkZXI6IFJlY29yZCBrZXkgb2YgdHlwZSBsaXRlcmFsIGlzIG5vdCBvZiB0eXBlIHN0cmluZyBvciBudW1iZXInKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChUeXBlR3VhcmQuVEludGVnZXIoa2V5KSB8fCBUeXBlR3VhcmQuVE51bWJlcihrZXkpKSB7XG4gICAgICAgICAgICBjb25zdCBwYXR0ZXJuID0gZXhwb3J0cy5QYXR0ZXJuTnVtYmVyRXhhY3Q7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5DcmVhdGUoeyAuLi5vcHRpb25zLCBbZXhwb3J0cy5LaW5kXTogJ1JlY29yZCcsIHR5cGU6ICdvYmplY3QnLCBwYXR0ZXJuUHJvcGVydGllczogeyBbcGF0dGVybl06IFR5cGVDbG9uZS5DbG9uZShzY2hlbWEsIHt9KSB9IH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFR5cGVHdWFyZC5UU3RyaW5nKGtleSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhdHRlcm4gPSBrZXkucGF0dGVybiA9PT0gdW5kZWZpbmVkID8gZXhwb3J0cy5QYXR0ZXJuU3RyaW5nRXhhY3QgOiBrZXkucGF0dGVybjtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLkNyZWF0ZSh7IC4uLm9wdGlvbnMsIFtleHBvcnRzLktpbmRdOiAnUmVjb3JkJywgdHlwZTogJ29iamVjdCcsIHBhdHRlcm5Qcm9wZXJ0aWVzOiB7IFtwYXR0ZXJuXTogVHlwZUNsb25lLkNsb25lKHNjaGVtYSwge30pIH0gfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihgU3RhbmRhcmRUeXBlQnVpbGRlcjogUmVjb3JkIGtleSBpcyBhbiBpbnZhbGlkIHR5cGVgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogYFtTdGFuZGFyZF1gIENyZWF0ZXMgYSBSZWN1cnNpdmUgdHlwZSAqL1xuICAgIFJlY3Vyc2l2ZShjYWxsYmFjaywgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGlmIChvcHRpb25zLiRpZCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgb3B0aW9ucy4kaWQgPSBgVCR7VHlwZU9yZGluYWwrK31gO1xuICAgICAgICBjb25zdCB0aGlzVHlwZSA9IGNhbGxiYWNrKHsgW2V4cG9ydHMuS2luZF06ICdUaGlzJywgJHJlZjogYCR7b3B0aW9ucy4kaWR9YCB9KTtcbiAgICAgICAgdGhpc1R5cGUuJGlkID0gb3B0aW9ucy4kaWQ7XG4gICAgICAgIHJldHVybiB0aGlzLkNyZWF0ZSh7IC4uLm9wdGlvbnMsIFtleHBvcnRzLkhpbnRdOiAnUmVjdXJzaXZlJywgLi4udGhpc1R5cGUgfSk7XG4gICAgfVxuICAgIC8qKiBgW1N0YW5kYXJkXWAgQ3JlYXRlcyBhIFJlZiB0eXBlLiBUaGUgcmVmZXJlbmNlZCB0eXBlIG11c3QgY29udGFpbiBhICRpZCAqL1xuICAgIFJlZihzY2hlbWEsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBpZiAoc2NoZW1hLiRpZCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ1N0YW5kYXJkVHlwZUJ1aWxkZXIuUmVmOiBUYXJnZXQgdHlwZSBtdXN0IHNwZWNpZnkgYW4gJGlkJyk7XG4gICAgICAgIHJldHVybiB0aGlzLkNyZWF0ZSh7IC4uLm9wdGlvbnMsIFtleHBvcnRzLktpbmRdOiAnUmVmJywgJHJlZjogc2NoZW1hLiRpZCB9KTtcbiAgICB9XG4gICAgLyoqIGBbU3RhbmRhcmRdYCBDcmVhdGVzIGEgbWFwcGVkIHR5cGUgd2hlcmUgYWxsIHByb3BlcnRpZXMgYXJlIFJlcXVpcmVkICovXG4gICAgUmVxdWlyZWQoc2NoZW1hLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgZnVuY3Rpb24gQXBwbHkoc2NoZW1hKSB7XG4gICAgICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgICAgIHN3aXRjaCAoc2NoZW1hW2V4cG9ydHMuTW9kaWZpZXJdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnUmVhZG9ubHlPcHRpb25hbCc6XG4gICAgICAgICAgICAgICAgICAgIHNjaGVtYVtleHBvcnRzLk1vZGlmaWVyXSA9ICdSZWFkb25seSc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ1JlYWRvbmx5JzpcbiAgICAgICAgICAgICAgICAgICAgc2NoZW1hW2V4cG9ydHMuTW9kaWZpZXJdID0gJ1JlYWRvbmx5JztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnT3B0aW9uYWwnOlxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgc2NoZW1hW2V4cG9ydHMuTW9kaWZpZXJdO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgc2NoZW1hW2V4cG9ydHMuTW9kaWZpZXJdO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgcmV0dXJuIE9iamVjdE1hcC5NYXAoVHlwZUNsb25lLkNsb25lKHNjaGVtYSwge30pLCAoc2NoZW1hKSA9PiB7XG4gICAgICAgICAgICBzY2hlbWEucmVxdWlyZWQgPSBnbG9iYWxUaGlzLk9iamVjdC5rZXlzKHNjaGVtYS5wcm9wZXJ0aWVzKTtcbiAgICAgICAgICAgIGdsb2JhbFRoaXMuT2JqZWN0LmtleXMoc2NoZW1hLnByb3BlcnRpZXMpLmZvckVhY2goa2V5ID0+IEFwcGx5KHNjaGVtYS5wcm9wZXJ0aWVzW2tleV0pKTtcbiAgICAgICAgICAgIHJldHVybiBzY2hlbWE7XG4gICAgICAgIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKiogYFtTdGFuZGFyZF1gIFJldHVybnMgYSBzY2hlbWEgYXJyYXkgd2hpY2ggYWxsb3dzIHR5cGVzIHRvIGNvbXBvc2Ugd2l0aCB0aGUgSmF2YVNjcmlwdCBzcHJlYWQgb3BlcmF0b3IgKi9cbiAgICBSZXN0KHNjaGVtYSkge1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRUdXBsZShzY2hlbWEpKSB7XG4gICAgICAgICAgICBpZiAoc2NoZW1hLml0ZW1zID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgcmV0dXJuIHNjaGVtYS5pdGVtcy5tYXAoKHNjaGVtYSkgPT4gVHlwZUNsb25lLkNsb25lKHNjaGVtYSwge30pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBbVHlwZUNsb25lLkNsb25lKHNjaGVtYSwge30pXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogYFtTdGFuZGFyZF1gIENyZWF0ZXMgYSBTdHJpbmcgdHlwZSAqL1xuICAgIFN0cmluZyhvcHRpb25zID0ge30pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuQ3JlYXRlKHsgLi4ub3B0aW9ucywgW2V4cG9ydHMuS2luZF06ICdTdHJpbmcnLCB0eXBlOiAnc3RyaW5nJyB9KTtcbiAgICB9XG4gICAgLyoqIGBbU3RhbmRhcmRdYCBDcmVhdGVzIGEgdGVtcGxhdGUgbGl0ZXJhbCB0eXBlICovXG4gICAgVGVtcGxhdGVMaXRlcmFsKHVucmVzb2x2ZWQsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgY29uc3QgcGF0dGVybiA9ICh0eXBlb2YgdW5yZXNvbHZlZCA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICA/IFRlbXBsYXRlTGl0ZXJhbFBhdHRlcm4uQ3JlYXRlKFRlbXBsYXRlTGl0ZXJhbERzbFBhcnNlci5QYXJzZSh1bnJlc29sdmVkKSlcbiAgICAgICAgICAgIDogVGVtcGxhdGVMaXRlcmFsUGF0dGVybi5DcmVhdGUodW5yZXNvbHZlZCk7XG4gICAgICAgIHJldHVybiB0aGlzLkNyZWF0ZSh7IC4uLm9wdGlvbnMsIFtleHBvcnRzLktpbmRdOiAnVGVtcGxhdGVMaXRlcmFsJywgdHlwZTogJ3N0cmluZycsIHBhdHRlcm4gfSk7XG4gICAgfVxuICAgIC8qKiBgW1N0YW5kYXJkXWAgQ3JlYXRlcyBhIFR1cGxlIHR5cGUgKi9cbiAgICBUdXBsZShpdGVtcywgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IFthZGRpdGlvbmFsSXRlbXMsIG1pbkl0ZW1zLCBtYXhJdGVtc10gPSBbZmFsc2UsIGl0ZW1zLmxlbmd0aCwgaXRlbXMubGVuZ3RoXTtcbiAgICAgICAgY29uc3QgY2xvbmVkSXRlbXMgPSBpdGVtcy5tYXAoKGl0ZW0pID0+IFR5cGVDbG9uZS5DbG9uZShpdGVtLCB7fSkpO1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgY29uc3Qgc2NoZW1hID0gKGl0ZW1zLmxlbmd0aCA+IDAgP1xuICAgICAgICAgICAgeyAuLi5vcHRpb25zLCBbZXhwb3J0cy5LaW5kXTogJ1R1cGxlJywgdHlwZTogJ2FycmF5JywgaXRlbXM6IGNsb25lZEl0ZW1zLCBhZGRpdGlvbmFsSXRlbXMsIG1pbkl0ZW1zLCBtYXhJdGVtcyB9IDpcbiAgICAgICAgICAgIHsgLi4ub3B0aW9ucywgW2V4cG9ydHMuS2luZF06ICdUdXBsZScsIHR5cGU6ICdhcnJheScsIG1pbkl0ZW1zLCBtYXhJdGVtcyB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuQ3JlYXRlKHNjaGVtYSk7XG4gICAgfVxuICAgIFVuaW9uKHVuaW9uLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVGVtcGxhdGVMaXRlcmFsKHVuaW9uKSkge1xuICAgICAgICAgICAgcmV0dXJuIFRlbXBsYXRlTGl0ZXJhbFJlc29sdmVyLlJlc29sdmUodW5pb24pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYW55T2YgPSB1bmlvbjtcbiAgICAgICAgICAgIGlmIChhbnlPZi5sZW5ndGggPT09IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuTmV2ZXIob3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAoYW55T2YubGVuZ3RoID09PSAxKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLkNyZWF0ZShUeXBlQ2xvbmUuQ2xvbmUoYW55T2ZbMF0sIG9wdGlvbnMpKTtcbiAgICAgICAgICAgIGNvbnN0IGNsb25lZEFueU9mID0gYW55T2YubWFwKChzY2hlbWEpID0+IFR5cGVDbG9uZS5DbG9uZShzY2hlbWEsIHt9KSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5DcmVhdGUoeyAuLi5vcHRpb25zLCBbZXhwb3J0cy5LaW5kXTogJ1VuaW9uJywgYW55T2Y6IGNsb25lZEFueU9mIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBgW1N0YW5kYXJkXWAgQ3JlYXRlcyBhbiBVbmtub3duIHR5cGUgKi9cbiAgICBVbmtub3duKG9wdGlvbnMgPSB7fSkge1xuICAgICAgICByZXR1cm4gdGhpcy5DcmVhdGUoeyAuLi5vcHRpb25zLCBbZXhwb3J0cy5LaW5kXTogJ1Vua25vd24nIH0pO1xuICAgIH1cbiAgICAvKiogYFtTdGFuZGFyZF1gIENyZWF0ZXMgYSBVbnNhZmUgdHlwZSB0aGF0IGluZmVycyBmb3IgdGhlIGdlbmVyaWMgYXJndW1lbnQgKi9cbiAgICBVbnNhZmUob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHJldHVybiB0aGlzLkNyZWF0ZSh7IC4uLm9wdGlvbnMsIFtleHBvcnRzLktpbmRdOiBvcHRpb25zW2V4cG9ydHMuS2luZF0gfHwgJ1Vuc2FmZScgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5TdGFuZGFyZFR5cGVCdWlsZGVyID0gU3RhbmRhcmRUeXBlQnVpbGRlcjtcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBFeHRlbmRlZFR5cGVCdWlsZGVyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuY2xhc3MgRXh0ZW5kZWRUeXBlQnVpbGRlciBleHRlbmRzIFN0YW5kYXJkVHlwZUJ1aWxkZXIge1xuICAgIC8qKiBgW0V4dGVuZGVkXWAgQ3JlYXRlcyBhIEJpZ0ludCB0eXBlICovXG4gICAgQmlnSW50KG9wdGlvbnMgPSB7fSkge1xuICAgICAgICByZXR1cm4gdGhpcy5DcmVhdGUoeyAuLi5vcHRpb25zLCBbZXhwb3J0cy5LaW5kXTogJ0JpZ0ludCcsIHR5cGU6ICdudWxsJywgdHlwZU9mOiAnQmlnSW50JyB9KTtcbiAgICB9XG4gICAgLyoqIGBbRXh0ZW5kZWRdYCBFeHRyYWN0cyB0aGUgQ29uc3RydWN0b3JQYXJhbWV0ZXJzIGZyb20gdGhlIGdpdmVuIENvbnN0cnVjdG9yIHR5cGUgKi9cbiAgICBDb25zdHJ1Y3RvclBhcmFtZXRlcnMoc2NoZW1hLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuVHVwbGUoWy4uLnNjaGVtYS5wYXJhbWV0ZXJzXSwgeyAuLi5vcHRpb25zIH0pO1xuICAgIH1cbiAgICAvKiogYFtFeHRlbmRlZF1gIENyZWF0ZXMgYSBDb25zdHJ1Y3RvciB0eXBlICovXG4gICAgQ29uc3RydWN0b3IocGFyYW1ldGVycywgcmV0dXJucywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBjbG9uZWRSZXR1cm5zID0gVHlwZUNsb25lLkNsb25lKHJldHVybnMsIHt9KTtcbiAgICAgICAgY29uc3QgY2xvbmVkUGFyYW1ldGVycyA9IHBhcmFtZXRlcnMubWFwKChwYXJhbWV0ZXIpID0+IFR5cGVDbG9uZS5DbG9uZShwYXJhbWV0ZXIsIHt9KSk7XG4gICAgICAgIHJldHVybiB0aGlzLkNyZWF0ZSh7IC4uLm9wdGlvbnMsIFtleHBvcnRzLktpbmRdOiAnQ29uc3RydWN0b3InLCB0eXBlOiAnb2JqZWN0JywgaW5zdGFuY2VPZjogJ0NvbnN0cnVjdG9yJywgcGFyYW1ldGVyczogY2xvbmVkUGFyYW1ldGVycywgcmV0dXJuczogY2xvbmVkUmV0dXJucyB9KTtcbiAgICB9XG4gICAgLyoqIGBbRXh0ZW5kZWRdYCBDcmVhdGVzIGEgRGF0ZSB0eXBlICovXG4gICAgRGF0ZShvcHRpb25zID0ge30pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuQ3JlYXRlKHsgLi4ub3B0aW9ucywgW2V4cG9ydHMuS2luZF06ICdEYXRlJywgdHlwZTogJ29iamVjdCcsIGluc3RhbmNlT2Y6ICdEYXRlJyB9KTtcbiAgICB9XG4gICAgLyoqIGBbRXh0ZW5kZWRdYCBDcmVhdGVzIGEgRnVuY3Rpb24gdHlwZSAqL1xuICAgIEZ1bmN0aW9uKHBhcmFtZXRlcnMsIHJldHVybnMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgY2xvbmVkUmV0dXJucyA9IFR5cGVDbG9uZS5DbG9uZShyZXR1cm5zLCB7fSk7XG4gICAgICAgIGNvbnN0IGNsb25lZFBhcmFtZXRlcnMgPSBwYXJhbWV0ZXJzLm1hcCgocGFyYW1ldGVyKSA9PiBUeXBlQ2xvbmUuQ2xvbmUocGFyYW1ldGVyLCB7fSkpO1xuICAgICAgICByZXR1cm4gdGhpcy5DcmVhdGUoeyAuLi5vcHRpb25zLCBbZXhwb3J0cy5LaW5kXTogJ0Z1bmN0aW9uJywgdHlwZTogJ29iamVjdCcsIGluc3RhbmNlT2Y6ICdGdW5jdGlvbicsIHBhcmFtZXRlcnM6IGNsb25lZFBhcmFtZXRlcnMsIHJldHVybnM6IGNsb25lZFJldHVybnMgfSk7XG4gICAgfVxuICAgIC8qKiBgW0V4dGVuZGVkXWAgRXh0cmFjdHMgdGhlIEluc3RhbmNlVHlwZSBmcm9tIHRoZSBnaXZlbiBDb25zdHJ1Y3RvciAqL1xuICAgIEluc3RhbmNlVHlwZShzY2hlbWEsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICByZXR1cm4gVHlwZUNsb25lLkNsb25lKHNjaGVtYS5yZXR1cm5zLCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqIGBbRXh0ZW5kZWRdYCBFeHRyYWN0cyB0aGUgUGFyYW1ldGVycyBmcm9tIHRoZSBnaXZlbiBGdW5jdGlvbiB0eXBlICovXG4gICAgUGFyYW1ldGVycyhzY2hlbWEsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICByZXR1cm4gdGhpcy5UdXBsZShzY2hlbWEucGFyYW1ldGVycywgeyAuLi5vcHRpb25zIH0pO1xuICAgIH1cbiAgICAvKiogYFtFeHRlbmRlZF1gIENyZWF0ZXMgYSBQcm9taXNlIHR5cGUgKi9cbiAgICBQcm9taXNlKGl0ZW0sIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICByZXR1cm4gdGhpcy5DcmVhdGUoeyAuLi5vcHRpb25zLCBbZXhwb3J0cy5LaW5kXTogJ1Byb21pc2UnLCB0eXBlOiAnb2JqZWN0JywgaW5zdGFuY2VPZjogJ1Byb21pc2UnLCBpdGVtOiBUeXBlQ2xvbmUuQ2xvbmUoaXRlbSwge30pIH0pO1xuICAgIH1cbiAgICAvKiogYFtFeHRlbmRlZF1gIENyZWF0ZXMgYSByZWd1bGFyIGV4cHJlc3Npb24gdHlwZSAqL1xuICAgIFJlZ0V4KHJlZ2V4LCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuQ3JlYXRlKHsgLi4ub3B0aW9ucywgW2V4cG9ydHMuS2luZF06ICdTdHJpbmcnLCB0eXBlOiAnc3RyaW5nJywgcGF0dGVybjogcmVnZXguc291cmNlIH0pO1xuICAgIH1cbiAgICAvKiogYFtFeHRlbmRlZF1gIEV4dHJhY3RzIHRoZSBSZXR1cm5UeXBlIGZyb20gdGhlIGdpdmVuIEZ1bmN0aW9uICovXG4gICAgUmV0dXJuVHlwZShzY2hlbWEsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICByZXR1cm4gVHlwZUNsb25lLkNsb25lKHNjaGVtYS5yZXR1cm5zLCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqIGBbRXh0ZW5kZWRdYCBDcmVhdGVzIGEgU3ltYm9sIHR5cGUgKi9cbiAgICBTeW1ib2wob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5DcmVhdGUoeyAuLi5vcHRpb25zLCBbZXhwb3J0cy5LaW5kXTogJ1N5bWJvbCcsIHR5cGU6ICdudWxsJywgdHlwZU9mOiAnU3ltYm9sJyB9KTtcbiAgICB9XG4gICAgLyoqIGBbRXh0ZW5kZWRdYCBDcmVhdGVzIGEgVW5kZWZpbmVkIHR5cGUgKi9cbiAgICBVbmRlZmluZWQob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHJldHVybiB0aGlzLkNyZWF0ZSh7IC4uLm9wdGlvbnMsIFtleHBvcnRzLktpbmRdOiAnVW5kZWZpbmVkJywgdHlwZTogJ251bGwnLCB0eXBlT2Y6ICdVbmRlZmluZWQnIH0pO1xuICAgIH1cbiAgICAvKiogYFtFeHRlbmRlZF1gIENyZWF0ZXMgYSBVaW50OEFycmF5IHR5cGUgKi9cbiAgICBVaW50OEFycmF5KG9wdGlvbnMgPSB7fSkge1xuICAgICAgICByZXR1cm4gdGhpcy5DcmVhdGUoeyAuLi5vcHRpb25zLCBbZXhwb3J0cy5LaW5kXTogJ1VpbnQ4QXJyYXknLCB0eXBlOiAnb2JqZWN0JywgaW5zdGFuY2VPZjogJ1VpbnQ4QXJyYXknIH0pO1xuICAgIH1cbiAgICAvKiogYFtFeHRlbmRlZF1gIENyZWF0ZXMgYSBWb2lkIHR5cGUgKi9cbiAgICBWb2lkKG9wdGlvbnMgPSB7fSkge1xuICAgICAgICByZXR1cm4gdGhpcy5DcmVhdGUoeyAuLi5vcHRpb25zLCBbZXhwb3J0cy5LaW5kXTogJ1ZvaWQnLCB0eXBlOiAnbnVsbCcsIHR5cGVPZjogJ1ZvaWQnIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuRXh0ZW5kZWRUeXBlQnVpbGRlciA9IEV4dGVuZGVkVHlwZUJ1aWxkZXI7XG4vKiogSlNPTiBTY2hlbWEgVHlwZUJ1aWxkZXIgd2l0aCBTdGF0aWMgUmVzb2x1dGlvbiBmb3IgVHlwZVNjcmlwdCAqL1xuZXhwb3J0cy5TdGFuZGFyZFR5cGUgPSBuZXcgU3RhbmRhcmRUeXBlQnVpbGRlcigpO1xuLyoqIEpTT04gU2NoZW1hIFR5cGVCdWlsZGVyIHdpdGggU3RhdGljIFJlc29sdXRpb24gZm9yIFR5cGVTY3JpcHQgKi9cbmV4cG9ydHMuVHlwZSA9IG5ldyBFeHRlbmRlZFR5cGVCdWlsZGVyKCk7XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJUeXBlIiwiU3RhbmRhcmRUeXBlIiwiRXh0ZW5kZWRUeXBlQnVpbGRlciIsIlN0YW5kYXJkVHlwZUJ1aWxkZXIiLCJUeXBlQnVpbGRlciIsIlRlbXBsYXRlTGl0ZXJhbERzbFBhcnNlciIsIlRlbXBsYXRlTGl0ZXJhbEdlbmVyYXRvciIsIlRlbXBsYXRlTGl0ZXJhbEZpbml0ZSIsIlRlbXBsYXRlTGl0ZXJhbFBhcnNlciIsIlRlbXBsYXRlTGl0ZXJhbFBhcnNlckVycm9yIiwiVGVtcGxhdGVMaXRlcmFsUmVzb2x2ZXIiLCJUZW1wbGF0ZUxpdGVyYWxQYXR0ZXJuIiwiVW5pb25SZXNvbHZlciIsIktleUFycmF5UmVzb2x2ZXIiLCJLZXlSZXNvbHZlciIsIk9iamVjdE1hcCIsIkluZGV4ZWRBY2Nlc3NvciIsIlR5cGVDbG9uZSIsIlR5cGVFeHRlbmRzIiwiVHlwZUV4dGVuZHNSZXN1bHQiLCJFeHRlbmRzVW5kZWZpbmVkIiwiVHlwZUd1YXJkIiwiVHlwZUd1YXJkVW5rbm93blR5cGVFcnJvciIsIkZvcm1hdFJlZ2lzdHJ5IiwiVHlwZVJlZ2lzdHJ5IiwiUGF0dGVyblN0cmluZ0V4YWN0IiwiUGF0dGVybk51bWJlckV4YWN0IiwiUGF0dGVybkJvb2xlYW5FeGFjdCIsIlBhdHRlcm5TdHJpbmciLCJQYXR0ZXJuTnVtYmVyIiwiUGF0dGVybkJvb2xlYW4iLCJLaW5kIiwiSGludCIsIk1vZGlmaWVyIiwiU3ltYm9sIiwiZm9yIiwibWFwIiwiTWFwIiwiRW50cmllcyIsIkNsZWFyIiwiY2xlYXIiLCJIYXMiLCJraW5kIiwiaGFzIiwiU2V0IiwiZnVuYyIsInNldCIsIkdldCIsImdldCIsImZvcm1hdCIsIkVycm9yIiwiY29uc3RydWN0b3IiLCJzY2hlbWEiLCJJc09iamVjdCIsIkFycmF5IiwiaXNBcnJheSIsIklzQXJyYXkiLCJJc1BhdHRlcm4iLCJSZWdFeHAiLCJJc0NvbnRyb2xDaGFyYWN0ZXJGcmVlIiwiaSIsImxlbmd0aCIsImNvZGUiLCJjaGFyQ29kZUF0IiwiSXNBZGRpdGlvbmFsUHJvcGVydGllcyIsIklzT3B0aW9uYWxCb29sZWFuIiwiVFNjaGVtYSIsIklzQmlnSW50IiwiSXNTdHJpbmciLCJJc051bWJlciIsImdsb2JhbFRoaXMiLCJOdW1iZXIiLCJpc0Zpbml0ZSIsIklzQm9vbGVhbiIsIklzT3B0aW9uYWxCaWdJbnQiLCJ1bmRlZmluZWQiLCJJc09wdGlvbmFsTnVtYmVyIiwiSXNPcHRpb25hbFN0cmluZyIsIklzT3B0aW9uYWxQYXR0ZXJuIiwiSXNPcHRpb25hbEZvcm1hdCIsIklzT3B0aW9uYWxTY2hlbWEiLCJUQW55IiwiVEtpbmQiLCIkaWQiLCJUQXJyYXkiLCJ0eXBlIiwiaXRlbXMiLCJtaW5JdGVtcyIsIm1heEl0ZW1zIiwidW5pcXVlSXRlbXMiLCJUQmlnSW50IiwidHlwZU9mIiwibXVsdGlwbGVPZiIsIm1pbmltdW0iLCJtYXhpbXVtIiwiZXhjbHVzaXZlTWluaW11bSIsImV4Y2x1c2l2ZU1heGltdW0iLCJUQm9vbGVhbiIsIlRDb25zdHJ1Y3RvciIsImluc3RhbmNlT2YiLCJwYXJhbWV0ZXJzIiwicmV0dXJucyIsInBhcmFtZXRlciIsIlREYXRlIiwibWluaW11bVRpbWVzdGFtcCIsIm1heGltdW1UaW1lc3RhbXAiLCJleGNsdXNpdmVNaW5pbXVtVGltZXN0YW1wIiwiZXhjbHVzaXZlTWF4aW11bVRpbWVzdGFtcCIsIlRGdW5jdGlvbiIsIlRJbnRlZ2VyIiwiVEludGVyc2VjdCIsImFsbE9mIiwidW5ldmFsdWF0ZWRQcm9wZXJ0aWVzIiwiaW5uZXIiLCJUTGl0ZXJhbFN0cmluZyIsImNvbnN0IiwiVExpdGVyYWxOdW1iZXIiLCJUTGl0ZXJhbEJvb2xlYW4iLCJUTGl0ZXJhbCIsIlROZXZlciIsIm5vdCIsImdldE93blByb3BlcnR5TmFtZXMiLCJUTm90IiwiVE51bGwiLCJUTnVtYmVyIiwiVE9iamVjdCIsInByb3BlcnRpZXMiLCJhZGRpdGlvbmFsUHJvcGVydGllcyIsIm1pblByb3BlcnRpZXMiLCJtYXhQcm9wZXJ0aWVzIiwia2V5IiwiZW50cmllcyIsIlRQcm9taXNlIiwiaXRlbSIsIlRSZWNvcmQiLCJwYXR0ZXJuUHJvcGVydGllcyIsImtleXMiLCJUUmVmIiwiJHJlZiIsIlRTdHJpbmciLCJtaW5MZW5ndGgiLCJtYXhMZW5ndGgiLCJwYXR0ZXJuIiwiVFN5bWJvbCIsIlRUZW1wbGF0ZUxpdGVyYWwiLCJUVGhpcyIsIlRUdXBsZSIsImFkZGl0aW9uYWxJdGVtcyIsIlRVbmRlZmluZWQiLCJUVW5pb25MaXRlcmFsIiwiVFVuaW9uIiwiYW55T2YiLCJldmVyeSIsIlRVaW50OEFycmF5IiwibWluQnl0ZUxlbmd0aCIsIm1heEJ5dGVMZW5ndGgiLCJUVW5rbm93biIsIlRVbnNhZmUiLCJUVm9pZCIsIlRSZWFkb25seU9wdGlvbmFsIiwiVFJlYWRvbmx5IiwiVE9wdGlvbmFsIiwiQ2hlY2siLCJpbnRlcnNlY3QiLCJ1bmlvbiIsInNvbWUiLCJJbnRvQm9vbGVhblJlc3VsdCIsInJlc3VsdCIsIkZhbHNlIiwiVHJ1ZSIsIkFueVJpZ2h0IiwibGVmdCIsInJpZ2h0IiwiQW55IiwiSW50ZXJzZWN0UmlnaHQiLCJVbmlvbiIsIkFycmF5UmlnaHQiLCJVbmlvblJpZ2h0IiwiVW5rbm93blJpZ2h0IiwiSXNPYmplY3RBcnJheUxpa2UiLCJWaXNpdCIsIkJpZ0ludCIsIk5ldmVyUmlnaHQiLCJPYmplY3RSaWdodCIsIlJlY29yZFJpZ2h0IiwiQm9vbGVhblJpZ2h0IiwiQm9vbGVhbiIsIkNvbnN0cnVjdG9yIiwiaW5kZXgiLCJEYXRlIiwiRnVuY3Rpb24iLCJJbnRlZ2VyUmlnaHQiLCJJbnRlZ2VyIiwiSW50ZXJzZWN0IiwiSXNMaXRlcmFsU3RyaW5nIiwiSXNMaXRlcmFsTnVtYmVyIiwiSXNMaXRlcmFsQm9vbGVhbiIsIkxpdGVyYWwiLCJTdHJpbmdSaWdodCIsIk51bWJlclJpZ2h0IiwiTmV2ZXIiLCJOdWxsIiwiSXNPYmplY3RQcm9wZXJ0eUNvdW50IiwiY291bnQiLCJJc09iamVjdFN0cmluZ0xpa2UiLCJJc09iamVjdFN5bWJvbExpa2UiLCJkZXNjcmlwdGlvbiIsIklzT2JqZWN0TnVtYmVyTGlrZSIsIklzT2JqZWN0Qm9vbGVhbkxpa2UiLCJJc09iamVjdEJpZ0ludExpa2UiLCJJc09iamVjdERhdGVMaWtlIiwiSXNPYmplY3RVaW50OEFycmF5TGlrZSIsIklzT2JqZWN0RnVuY3Rpb25MaWtlIiwiSXNPYmplY3RDb25zdHJ1Y3Rvckxpa2UiLCJJc09iamVjdFByb21pc2VMaWtlIiwidGhlbiIsIlByb3BlcnR5IiwiUmVjb3JkS2V5IiwiUHJvbWlzZSIsIlN0cmluZyIsIlJlY29yZFZhbHVlIiwiS2V5IiwiVmFsdWUiLCJSZWNvcmQiLCJUdXBsZVJpZ2h0IiwiSXNBcnJheU9mVHVwbGUiLCJUdXBsZSIsIlVpbnQ4QXJyYXkiLCJVbmRlZmluZWQiLCJWb2lkUmlnaHQiLCJVbmtub3duIiwiVm9pZCIsIlJlc29sdmUiLCJFeHRlbmRzIiwiY2xvbmVkUHJvcGVydGllcyIsInJlZHVjZSIsImFjYyIsImNsb25lZFN5bWJvbHMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJDbG9uZSIsIm9wdGlvbnMiLCJzY2hlbWFzIiwiaW5kZXhlZCIsInByb3BlcnR5IiwiZWxlbWVudCIsInRvU3RyaW5nIiwiY2FsbGJhY2siLCJVbndyYXBQYXR0ZXJuIiwic2xpY2UiLCJzZXRzIiwib3V0ZXIiLCJpbmNsdWRlcyIsImFkZCIsImluY2x1ZGVQYXR0ZXJucyIsIlJlc29sdmVLZXlzIiwiUmVzb2x2ZVBhdHRlcm4iLCJqb2luIiwiZXhwcmVzc2lvbiIsIlBhcnNlRXhhY3QiLCJHZW5lcmF0ZSIsIkVzY2FwZSIsInJlcGxhY2UiLCJ0b2tlbnMiLCJDcmVhdGUiLCJraW5kcyIsInRlbXBsYXRlIiwibGl0ZXJhbHMiLCJtZXNzYWdlIiwiSXNOb25Fc2NhcGVkIiwiY2hhciIsIklzT3BlblBhcmVuIiwiSXNDbG9zZVBhcmVuIiwiSXNTZXBhcmF0b3IiLCJJc0dyb3VwIiwiSW5Hcm91cCIsIklzUHJlY2VkZW5jZU9yIiwiSXNQcmVjZWRlbmNlQW5kIiwiT3IiLCJzdGFydCIsImV4cHJlc3Npb25zIiwicmFuZ2UiLCJwdXNoIiwiUGFyc2UiLCJleHByIiwiQW5kIiwiR3JvdXAiLCJzY2FuIiwiUmFuZ2UiLCJlbmQiLCJSZWR1Y2UiLCJidWZmZXIiLCJDb25zdCIsIlBhcnNlVW5pb24iLCJ0cmltIiwic3BsaXQiLCJsaXRlcmFsIiwiUGFyc2VUZXJtaW5hbCIsIkwiLCJSIiwiUGFyc2VMaXRlcmFsIiwidGVtcGxhdGVfZHNsIiwiVHlwZU9yZGluYWwiLCJTdHJpY3QiLCJKU09OIiwicGFyc2UiLCJzdHJpbmdpZnkiLCJPcHRpb25hbCIsIlJlYWRvbmx5T3B0aW9uYWwiLCJSZWFkb25seSIsIkNvbXBvc2l0ZSIsIm9iamVjdHMiLCJJbmRleCIsIkVudW0iLCJ2YWx1ZXMiLCJmaWx0ZXIiLCJpc05hTiIsInRydWVUeXBlIiwiZmFsc2VUeXBlIiwiRXhjbHVkZSIsIm5hcnJvd2VkIiwiRXh0cmFjdCIsInVucmVzb2x2ZWQiLCJjbG9uZWQiLCJjbG9uZSIsImNsb25lZFVuZXZhbHVhdGVkUHJvcGVydGllcyIsIktleU9mIiwiXyIsIk5vdCIsInByb3BlcnR5S2V5cyIsIm9wdGlvbmFsS2V5cyIsInJlcXVpcmVkS2V5cyIsIm5hbWUiLCJjbG9uZWRBZGRpdGlvbmFsUHJvcGVydGllcyIsInJlcXVpcmVkIiwiT21pdCIsIlBhcnRpYWwiLCJBcHBseSIsImZvckVhY2giLCJQaWNrIiwiUmVjdXJzaXZlIiwidGhpc1R5cGUiLCJSZWYiLCJSZXF1aXJlZCIsIlJlc3QiLCJUZW1wbGF0ZUxpdGVyYWwiLCJjbG9uZWRJdGVtcyIsImNsb25lZEFueU9mIiwiVW5zYWZlIiwiQ29uc3RydWN0b3JQYXJhbWV0ZXJzIiwiY2xvbmVkUmV0dXJucyIsImNsb25lZFBhcmFtZXRlcnMiLCJJbnN0YW5jZVR5cGUiLCJQYXJhbWV0ZXJzIiwiUmVnRXgiLCJyZWdleCIsInNvdXJjZSIsIlJldHVyblR5cGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@sinclair+typebox@0.28.20/node_modules/@sinclair/typebox/typebox.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/@sinclair+typebox@0.28.20/node_modules/@sinclair/typebox/value/hash.js":
/*!*******************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@sinclair+typebox@0.28.20/node_modules/@sinclair/typebox/value/hash.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*--------------------------------------------------------------------------\n\n@sinclair/typebox/hash\n\nThe MIT License (MIT)\n\nCopyright (c) 2017-2023 Haydn Paterson (sinclair) <haydn.developer@gmail.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n---------------------------------------------------------------------------*/ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.ValueHash = exports.ValueHashError = void 0;\nclass ValueHashError extends Error {\n    constructor(value){\n        super(`Hash: Unable to hash value`);\n        this.value = value;\n    }\n}\nexports.ValueHashError = ValueHashError;\nvar ValueHash;\n(function(ValueHash) {\n    let ByteMarker;\n    (function(ByteMarker) {\n        ByteMarker[ByteMarker[\"Undefined\"] = 0] = \"Undefined\";\n        ByteMarker[ByteMarker[\"Null\"] = 1] = \"Null\";\n        ByteMarker[ByteMarker[\"Boolean\"] = 2] = \"Boolean\";\n        ByteMarker[ByteMarker[\"Number\"] = 3] = \"Number\";\n        ByteMarker[ByteMarker[\"String\"] = 4] = \"String\";\n        ByteMarker[ByteMarker[\"Object\"] = 5] = \"Object\";\n        ByteMarker[ByteMarker[\"Array\"] = 6] = \"Array\";\n        ByteMarker[ByteMarker[\"Date\"] = 7] = \"Date\";\n        ByteMarker[ByteMarker[\"Uint8Array\"] = 8] = \"Uint8Array\";\n        ByteMarker[ByteMarker[\"Symbol\"] = 9] = \"Symbol\";\n        ByteMarker[ByteMarker[\"BigInt\"] = 10] = \"BigInt\";\n    })(ByteMarker || (ByteMarker = {}));\n    // ----------------------------------------------------\n    // State\n    // ----------------------------------------------------\n    let Hash = globalThis.BigInt(\"14695981039346656037\");\n    const [Prime, Size] = [\n        globalThis.BigInt(\"1099511628211\"),\n        globalThis.BigInt(\"2\") ** globalThis.BigInt(\"64\")\n    ];\n    const Bytes = globalThis.Array.from({\n        length: 256\n    }).map((_, i)=>globalThis.BigInt(i));\n    const F64 = new globalThis.Float64Array(1);\n    const F64In = new globalThis.DataView(F64.buffer);\n    const F64Out = new globalThis.Uint8Array(F64.buffer);\n    // ----------------------------------------------------\n    // Guards\n    // ----------------------------------------------------\n    function IsDate(value) {\n        return value instanceof globalThis.Date;\n    }\n    function IsUint8Array(value) {\n        return value instanceof globalThis.Uint8Array;\n    }\n    function IsArray(value) {\n        return globalThis.Array.isArray(value);\n    }\n    function IsBoolean(value) {\n        return typeof value === \"boolean\";\n    }\n    function IsNull(value) {\n        return value === null;\n    }\n    function IsNumber(value) {\n        return typeof value === \"number\";\n    }\n    function IsSymbol(value) {\n        return typeof value === \"symbol\";\n    }\n    function IsBigInt(value) {\n        return typeof value === \"bigint\";\n    }\n    function IsObject(value) {\n        return typeof value === \"object\" && value !== null && !IsArray(value) && !IsDate(value) && !IsUint8Array(value);\n    }\n    function IsString(value) {\n        return typeof value === \"string\";\n    }\n    function IsUndefined(value) {\n        return value === undefined;\n    }\n    // ----------------------------------------------------\n    // Encoding\n    // ----------------------------------------------------\n    function Array(value) {\n        FNV1A64(ByteMarker.Array);\n        for (const item of value){\n            Visit(item);\n        }\n    }\n    function Boolean(value) {\n        FNV1A64(ByteMarker.Boolean);\n        FNV1A64(value ? 1 : 0);\n    }\n    function BigInt(value) {\n        FNV1A64(ByteMarker.BigInt);\n        F64In.setBigInt64(0, value);\n        for (const byte of F64Out){\n            FNV1A64(byte);\n        }\n    }\n    function Date(value) {\n        FNV1A64(ByteMarker.Date);\n        Visit(value.getTime());\n    }\n    function Null(value) {\n        FNV1A64(ByteMarker.Null);\n    }\n    function Number(value) {\n        FNV1A64(ByteMarker.Number);\n        F64In.setFloat64(0, value);\n        for (const byte of F64Out){\n            FNV1A64(byte);\n        }\n    }\n    function Object1(value) {\n        FNV1A64(ByteMarker.Object);\n        for (const key of globalThis.Object.keys(value).sort()){\n            Visit(key);\n            Visit(value[key]);\n        }\n    }\n    function String(value) {\n        FNV1A64(ByteMarker.String);\n        for(let i = 0; i < value.length; i++){\n            FNV1A64(value.charCodeAt(i));\n        }\n    }\n    function Symbol(value) {\n        FNV1A64(ByteMarker.Symbol);\n        Visit(value.description);\n    }\n    function Uint8Array(value) {\n        FNV1A64(ByteMarker.Uint8Array);\n        for(let i = 0; i < value.length; i++){\n            FNV1A64(value[i]);\n        }\n    }\n    function Undefined(value) {\n        return FNV1A64(ByteMarker.Undefined);\n    }\n    function Visit(value) {\n        if (IsArray(value)) {\n            Array(value);\n        } else if (IsBoolean(value)) {\n            Boolean(value);\n        } else if (IsBigInt(value)) {\n            BigInt(value);\n        } else if (IsDate(value)) {\n            Date(value);\n        } else if (IsNull(value)) {\n            Null(value);\n        } else if (IsNumber(value)) {\n            Number(value);\n        } else if (IsObject(value)) {\n            Object1(value);\n        } else if (IsString(value)) {\n            String(value);\n        } else if (IsSymbol(value)) {\n            Symbol(value);\n        } else if (IsUint8Array(value)) {\n            Uint8Array(value);\n        } else if (IsUndefined(value)) {\n            Undefined(value);\n        } else {\n            throw new ValueHashError(value);\n        }\n    }\n    function FNV1A64(byte) {\n        Hash = Hash ^ Bytes[byte];\n        Hash = Hash * Prime % Size;\n    }\n    /** Creates a FNV1A-64 non cryptographic hash of the given value */ function Create(value) {\n        Hash = globalThis.BigInt(\"14695981039346656037\");\n        Visit(value);\n        return Hash;\n    }\n    ValueHash.Create = Create;\n})(ValueHash || (exports.ValueHash = ValueHash = {}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BzaW5jbGFpcit0eXBlYm94QDAuMjguMjAvbm9kZV9tb2R1bGVzL0BzaW5jbGFpci90eXBlYm94L3ZhbHVlL2hhc2guanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7MkVBMEIyRSxHQUMzRUEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGlCQUFpQixHQUFHQSxzQkFBc0IsR0FBRyxLQUFLO0FBQ2xELE1BQU1HLHVCQUF1QkM7SUFDekJDLFlBQVlKLEtBQUssQ0FBRTtRQUNmLEtBQUssQ0FBQyxDQUFDLDBCQUEwQixDQUFDO1FBQ2xDLElBQUksQ0FBQ0EsS0FBSyxHQUFHQTtJQUNqQjtBQUNKO0FBQ0FELHNCQUFzQixHQUFHRztBQUN6QixJQUFJRDtBQUNILFVBQVVBLFNBQVM7SUFDaEIsSUFBSUk7SUFDSCxVQUFVQSxVQUFVO1FBQ2pCQSxVQUFVLENBQUNBLFVBQVUsQ0FBQyxZQUFZLEdBQUcsRUFBRSxHQUFHO1FBQzFDQSxVQUFVLENBQUNBLFVBQVUsQ0FBQyxPQUFPLEdBQUcsRUFBRSxHQUFHO1FBQ3JDQSxVQUFVLENBQUNBLFVBQVUsQ0FBQyxVQUFVLEdBQUcsRUFBRSxHQUFHO1FBQ3hDQSxVQUFVLENBQUNBLFVBQVUsQ0FBQyxTQUFTLEdBQUcsRUFBRSxHQUFHO1FBQ3ZDQSxVQUFVLENBQUNBLFVBQVUsQ0FBQyxTQUFTLEdBQUcsRUFBRSxHQUFHO1FBQ3ZDQSxVQUFVLENBQUNBLFVBQVUsQ0FBQyxTQUFTLEdBQUcsRUFBRSxHQUFHO1FBQ3ZDQSxVQUFVLENBQUNBLFVBQVUsQ0FBQyxRQUFRLEdBQUcsRUFBRSxHQUFHO1FBQ3RDQSxVQUFVLENBQUNBLFVBQVUsQ0FBQyxPQUFPLEdBQUcsRUFBRSxHQUFHO1FBQ3JDQSxVQUFVLENBQUNBLFVBQVUsQ0FBQyxhQUFhLEdBQUcsRUFBRSxHQUFHO1FBQzNDQSxVQUFVLENBQUNBLFVBQVUs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T0FBTy9CLFFBQVE7WUFDcEI4QyxLQUFLOUM7UUFDVCxPQUNLLElBQUlnQyxTQUFTaEMsUUFBUTtZQUN0QitDLE9BQU8vQztRQUNYLE9BQ0ssSUFBSW1DLFNBQVNuQyxRQUFRO1lBQ3RCSCxRQUFPRztRQUNYLE9BQ0ssSUFBSW9DLFNBQVNwQyxRQUFRO1lBQ3RCb0QsT0FBT3BEO1FBQ1gsT0FDSyxJQUFJaUMsU0FBU2pDLFFBQVE7WUFDdEJzRCxPQUFPdEQ7UUFDWCxPQUNLLElBQUkyQixhQUFhM0IsUUFBUTtZQUMxQndCLFdBQVd4QjtRQUNmLE9BQ0ssSUFBSXFDLFlBQVlyQyxRQUFRO1lBQ3pCd0QsVUFBVXhEO1FBQ2QsT0FDSztZQUNELE1BQU0sSUFBSUUsZUFBZUY7UUFDN0I7SUFDSjtJQUNBLFNBQVN1QyxRQUFRSyxJQUFJO1FBQ2pCdEMsT0FBT0EsT0FBT0ssS0FBSyxDQUFDaUMsS0FBSztRQUN6QnRDLE9BQU8sT0FBUUcsUUFBU0M7SUFDNUI7SUFDQSxpRUFBaUUsR0FDakUsU0FBUytDLE9BQU96RCxLQUFLO1FBQ2pCTSxPQUFPQyxXQUFXQyxNQUFNLENBQUM7UUFDekJpQyxNQUFNekM7UUFDTixPQUFPTTtJQUNYO0lBQ0FMLFVBQVV3RCxNQUFNLEdBQUdBO0FBQ3ZCLEdBQUd4RCxhQUFjRixDQUFBQSxpQkFBaUIsR0FBR0UsWUFBWSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ac2luY2xhaXIrdHlwZWJveEAwLjI4LjIwL25vZGVfbW9kdWxlcy9Ac2luY2xhaXIvdHlwZWJveC92YWx1ZS9oYXNoLmpzPzdlMjgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbkBzaW5jbGFpci90eXBlYm94L2hhc2hcblxuVGhlIE1JVCBMaWNlbnNlIChNSVQpXG5cbkNvcHlyaWdodCAoYykgMjAxNy0yMDIzIEhheWRuIFBhdGVyc29uIChzaW5jbGFpcikgPGhheWRuLmRldmVsb3BlckBnbWFpbC5jb20+XG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbm9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbmluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbnRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbmNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbmFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG5JTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbkZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbk9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cblRIRSBTT0ZUV0FSRS5cblxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVmFsdWVIYXNoID0gZXhwb3J0cy5WYWx1ZUhhc2hFcnJvciA9IHZvaWQgMDtcbmNsYXNzIFZhbHVlSGFzaEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHZhbHVlKSB7XG4gICAgICAgIHN1cGVyKGBIYXNoOiBVbmFibGUgdG8gaGFzaCB2YWx1ZWApO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxufVxuZXhwb3J0cy5WYWx1ZUhhc2hFcnJvciA9IFZhbHVlSGFzaEVycm9yO1xudmFyIFZhbHVlSGFzaDtcbihmdW5jdGlvbiAoVmFsdWVIYXNoKSB7XG4gICAgbGV0IEJ5dGVNYXJrZXI7XG4gICAgKGZ1bmN0aW9uIChCeXRlTWFya2VyKSB7XG4gICAgICAgIEJ5dGVNYXJrZXJbQnl0ZU1hcmtlcltcIlVuZGVmaW5lZFwiXSA9IDBdID0gXCJVbmRlZmluZWRcIjtcbiAgICAgICAgQnl0ZU1hcmtlcltCeXRlTWFya2VyW1wiTnVsbFwiXSA9IDFdID0gXCJOdWxsXCI7XG4gICAgICAgIEJ5dGVNYXJrZXJbQnl0ZU1hcmtlcltcIkJvb2xlYW5cIl0gPSAyXSA9IFwiQm9vbGVhblwiO1xuICAgICAgICBCeXRlTWFya2VyW0J5dGVNYXJrZXJbXCJOdW1iZXJcIl0gPSAzXSA9IFwiTnVtYmVyXCI7XG4gICAgICAgIEJ5dGVNYXJrZXJbQnl0ZU1hcmtlcltcIlN0cmluZ1wiXSA9IDRdID0gXCJTdHJpbmdcIjtcbiAgICAgICAgQnl0ZU1hcmtlcltCeXRlTWFya2VyW1wiT2JqZWN0XCJdID0gNV0gPSBcIk9iamVjdFwiO1xuICAgICAgICBCeXRlTWFya2VyW0J5dGVNYXJrZXJbXCJBcnJheVwiXSA9IDZdID0gXCJBcnJheVwiO1xuICAgICAgICBCeXRlTWFya2VyW0J5dGVNYXJrZXJbXCJEYXRlXCJdID0gN10gPSBcIkRhdGVcIjtcbiAgICAgICAgQnl0ZU1hcmtlcltCeXRlTWFya2VyW1wiVWludDhBcnJheVwiXSA9IDhdID0gXCJVaW50OEFycmF5XCI7XG4gICAgICAgIEJ5dGVNYXJrZXJbQnl0ZU1hcmtlcltcIlN5bWJvbFwiXSA9IDldID0gXCJTeW1ib2xcIjtcbiAgICAgICAgQnl0ZU1hcmtlcltCeXRlTWFya2VyW1wiQmlnSW50XCJdID0gMTBdID0gXCJCaWdJbnRcIjtcbiAgICB9KShCeXRlTWFya2VyIHx8IChCeXRlTWFya2VyID0ge30pKTtcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gU3RhdGVcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgbGV0IEhhc2ggPSBnbG9iYWxUaGlzLkJpZ0ludCgnMTQ2OTU5ODEwMzkzNDY2NTYwMzcnKTtcbiAgICBjb25zdCBbUHJpbWUsIFNpemVdID0gW2dsb2JhbFRoaXMuQmlnSW50KCcxMDk5NTExNjI4MjExJyksIGdsb2JhbFRoaXMuQmlnSW50KCcyJykgKiogZ2xvYmFsVGhpcy5CaWdJbnQoJzY0JyldO1xuICAgIGNvbnN0IEJ5dGVzID0gZ2xvYmFsVGhpcy5BcnJheS5mcm9tKHsgbGVuZ3RoOiAyNTYgfSkubWFwKChfLCBpKSA9PiBnbG9iYWxUaGlzLkJpZ0ludChpKSk7XG4gICAgY29uc3QgRjY0ID0gbmV3IGdsb2JhbFRoaXMuRmxvYXQ2NEFycmF5KDEpO1xuICAgIGNvbnN0IEY2NEluID0gbmV3IGdsb2JhbFRoaXMuRGF0YVZpZXcoRjY0LmJ1ZmZlcik7XG4gICAgY29uc3QgRjY0T3V0ID0gbmV3IGdsb2JhbFRoaXMuVWludDhBcnJheShGNjQuYnVmZmVyKTtcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gR3VhcmRzXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGZ1bmN0aW9uIElzRGF0ZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBnbG9iYWxUaGlzLkRhdGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIElzVWludDhBcnJheSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBnbG9iYWxUaGlzLlVpbnQ4QXJyYXk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIElzQXJyYXkodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGdsb2JhbFRoaXMuQXJyYXkuaXNBcnJheSh2YWx1ZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIElzQm9vbGVhbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbic7XG4gICAgfVxuICAgIGZ1bmN0aW9uIElzTnVsbCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIElzTnVtYmVyKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInO1xuICAgIH1cbiAgICBmdW5jdGlvbiBJc1N5bWJvbCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3ltYm9sJztcbiAgICB9XG4gICAgZnVuY3Rpb24gSXNCaWdJbnQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2JpZ2ludCc7XG4gICAgfVxuICAgIGZ1bmN0aW9uIElzT2JqZWN0KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsICYmICFJc0FycmF5KHZhbHVlKSAmJiAhSXNEYXRlKHZhbHVlKSAmJiAhSXNVaW50OEFycmF5KHZhbHVlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gSXNTdHJpbmcodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZyc7XG4gICAgfVxuICAgIGZ1bmN0aW9uIElzVW5kZWZpbmVkKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gRW5jb2RpbmdcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZnVuY3Rpb24gQXJyYXkodmFsdWUpIHtcbiAgICAgICAgRk5WMUE2NChCeXRlTWFya2VyLkFycmF5KTtcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHZhbHVlKSB7XG4gICAgICAgICAgICBWaXNpdChpdGVtKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBCb29sZWFuKHZhbHVlKSB7XG4gICAgICAgIEZOVjFBNjQoQnl0ZU1hcmtlci5Cb29sZWFuKTtcbiAgICAgICAgRk5WMUE2NCh2YWx1ZSA/IDEgOiAwKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gQmlnSW50KHZhbHVlKSB7XG4gICAgICAgIEZOVjFBNjQoQnl0ZU1hcmtlci5CaWdJbnQpO1xuICAgICAgICBGNjRJbi5zZXRCaWdJbnQ2NCgwLCB2YWx1ZSk7XG4gICAgICAgIGZvciAoY29uc3QgYnl0ZSBvZiBGNjRPdXQpIHtcbiAgICAgICAgICAgIEZOVjFBNjQoYnl0ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gRGF0ZSh2YWx1ZSkge1xuICAgICAgICBGTlYxQTY0KEJ5dGVNYXJrZXIuRGF0ZSk7XG4gICAgICAgIFZpc2l0KHZhbHVlLmdldFRpbWUoKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIE51bGwodmFsdWUpIHtcbiAgICAgICAgRk5WMUE2NChCeXRlTWFya2VyLk51bGwpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBOdW1iZXIodmFsdWUpIHtcbiAgICAgICAgRk5WMUE2NChCeXRlTWFya2VyLk51bWJlcik7XG4gICAgICAgIEY2NEluLnNldEZsb2F0NjQoMCwgdmFsdWUpO1xuICAgICAgICBmb3IgKGNvbnN0IGJ5dGUgb2YgRjY0T3V0KSB7XG4gICAgICAgICAgICBGTlYxQTY0KGJ5dGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIE9iamVjdCh2YWx1ZSkge1xuICAgICAgICBGTlYxQTY0KEJ5dGVNYXJrZXIuT2JqZWN0KTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgZ2xvYmFsVGhpcy5PYmplY3Qua2V5cyh2YWx1ZSkuc29ydCgpKSB7XG4gICAgICAgICAgICBWaXNpdChrZXkpO1xuICAgICAgICAgICAgVmlzaXQodmFsdWVba2V5XSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gU3RyaW5nKHZhbHVlKSB7XG4gICAgICAgIEZOVjFBNjQoQnl0ZU1hcmtlci5TdHJpbmcpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBGTlYxQTY0KHZhbHVlLmNoYXJDb2RlQXQoaSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIFN5bWJvbCh2YWx1ZSkge1xuICAgICAgICBGTlYxQTY0KEJ5dGVNYXJrZXIuU3ltYm9sKTtcbiAgICAgICAgVmlzaXQodmFsdWUuZGVzY3JpcHRpb24pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBVaW50OEFycmF5KHZhbHVlKSB7XG4gICAgICAgIEZOVjFBNjQoQnl0ZU1hcmtlci5VaW50OEFycmF5KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgRk5WMUE2NCh2YWx1ZVtpXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gVW5kZWZpbmVkKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBGTlYxQTY0KEJ5dGVNYXJrZXIuVW5kZWZpbmVkKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gVmlzaXQodmFsdWUpIHtcbiAgICAgICAgaWYgKElzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICBBcnJheSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoSXNCb29sZWFuKHZhbHVlKSkge1xuICAgICAgICAgICAgQm9vbGVhbih2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoSXNCaWdJbnQodmFsdWUpKSB7XG4gICAgICAgICAgICBCaWdJbnQodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKElzRGF0ZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIERhdGUodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKElzTnVsbCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIE51bGwodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKElzTnVtYmVyKHZhbHVlKSkge1xuICAgICAgICAgICAgTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChJc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIE9iamVjdCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoSXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgICAgICBTdHJpbmcodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKElzU3ltYm9sKHZhbHVlKSkge1xuICAgICAgICAgICAgU3ltYm9sKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChJc1VpbnQ4QXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICBVaW50OEFycmF5KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChJc1VuZGVmaW5lZCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIFVuZGVmaW5lZCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVmFsdWVIYXNoRXJyb3IodmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIEZOVjFBNjQoYnl0ZSkge1xuICAgICAgICBIYXNoID0gSGFzaCBeIEJ5dGVzW2J5dGVdO1xuICAgICAgICBIYXNoID0gKEhhc2ggKiBQcmltZSkgJSBTaXplO1xuICAgIH1cbiAgICAvKiogQ3JlYXRlcyBhIEZOVjFBLTY0IG5vbiBjcnlwdG9ncmFwaGljIGhhc2ggb2YgdGhlIGdpdmVuIHZhbHVlICovXG4gICAgZnVuY3Rpb24gQ3JlYXRlKHZhbHVlKSB7XG4gICAgICAgIEhhc2ggPSBnbG9iYWxUaGlzLkJpZ0ludCgnMTQ2OTU5ODEwMzkzNDY2NTYwMzcnKTtcbiAgICAgICAgVmlzaXQodmFsdWUpO1xuICAgICAgICByZXR1cm4gSGFzaDtcbiAgICB9XG4gICAgVmFsdWVIYXNoLkNyZWF0ZSA9IENyZWF0ZTtcbn0pKFZhbHVlSGFzaCB8fCAoZXhwb3J0cy5WYWx1ZUhhc2ggPSBWYWx1ZUhhc2ggPSB7fSkpO1xuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiVmFsdWVIYXNoIiwiVmFsdWVIYXNoRXJyb3IiLCJFcnJvciIsImNvbnN0cnVjdG9yIiwiQnl0ZU1hcmtlciIsIkhhc2giLCJnbG9iYWxUaGlzIiwiQmlnSW50IiwiUHJpbWUiLCJTaXplIiwiQnl0ZXMiLCJBcnJheSIsImZyb20iLCJsZW5ndGgiLCJtYXAiLCJfIiwiaSIsIkY2NCIsIkZsb2F0NjRBcnJheSIsIkY2NEluIiwiRGF0YVZpZXciLCJidWZmZXIiLCJGNjRPdXQiLCJVaW50OEFycmF5IiwiSXNEYXRlIiwiRGF0ZSIsIklzVWludDhBcnJheSIsIklzQXJyYXkiLCJpc0FycmF5IiwiSXNCb29sZWFuIiwiSXNOdWxsIiwiSXNOdW1iZXIiLCJJc1N5bWJvbCIsIklzQmlnSW50IiwiSXNPYmplY3QiLCJJc1N0cmluZyIsIklzVW5kZWZpbmVkIiwidW5kZWZpbmVkIiwiRk5WMUE2NCIsIml0ZW0iLCJWaXNpdCIsIkJvb2xlYW4iLCJzZXRCaWdJbnQ2NCIsImJ5dGUiLCJnZXRUaW1lIiwiTnVsbCIsIk51bWJlciIsInNldEZsb2F0NjQiLCJrZXkiLCJrZXlzIiwic29ydCIsIlN0cmluZyIsImNoYXJDb2RlQXQiLCJTeW1ib2wiLCJkZXNjcmlwdGlvbiIsIlVuZGVmaW5lZCIsIkNyZWF0ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@sinclair+typebox@0.28.20/node_modules/@sinclair/typebox/value/hash.js\n");

/***/ })

};
;