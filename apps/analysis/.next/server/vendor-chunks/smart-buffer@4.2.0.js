"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/smart-buffer@4.2.0";
exports.ids = ["vendor-chunks/smart-buffer@4.2.0"];
exports.modules = {

/***/ "(rsc)/../../node_modules/.pnpm/smart-buffer@4.2.0/node_modules/smart-buffer/build/smartbuffer.js":
/*!**************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/smart-buffer@4.2.0/node_modules/smart-buffer/build/smartbuffer.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(rsc)/../../node_modules/.pnpm/smart-buffer@4.2.0/node_modules/smart-buffer/build/utils.js\");\n// The default Buffer size if one is not provided.\nconst DEFAULT_SMARTBUFFER_SIZE = 4096;\n// The default string encoding to use for reading/writing strings.\nconst DEFAULT_SMARTBUFFER_ENCODING = \"utf8\";\nclass SmartBuffer {\n    /**\n     * Creates a new SmartBuffer instance.\n     *\n     * @param options { SmartBufferOptions } The SmartBufferOptions to apply to this instance.\n     */ constructor(options){\n        this.length = 0;\n        this._encoding = DEFAULT_SMARTBUFFER_ENCODING;\n        this._writeOffset = 0;\n        this._readOffset = 0;\n        if (SmartBuffer.isSmartBufferOptions(options)) {\n            // Checks for encoding\n            if (options.encoding) {\n                utils_1.checkEncoding(options.encoding);\n                this._encoding = options.encoding;\n            }\n            // Checks for initial size length\n            if (options.size) {\n                if (utils_1.isFiniteInteger(options.size) && options.size > 0) {\n                    this._buff = Buffer.allocUnsafe(options.size);\n                } else {\n                    throw new Error(utils_1.ERRORS.INVALID_SMARTBUFFER_SIZE);\n                }\n            // Check for initial Buffer\n            } else if (options.buff) {\n                if (Buffer.isBuffer(options.buff)) {\n                    this._buff = options.buff;\n                    this.length = options.buff.length;\n                } else {\n                    throw new Error(utils_1.ERRORS.INVALID_SMARTBUFFER_BUFFER);\n                }\n            } else {\n                this._buff = Buffer.allocUnsafe(DEFAULT_SMARTBUFFER_SIZE);\n            }\n        } else {\n            // If something was passed but it's not a SmartBufferOptions object\n            if (typeof options !== \"undefined\") {\n                throw new Error(utils_1.ERRORS.INVALID_SMARTBUFFER_OBJECT);\n            }\n            // Otherwise default to sane options\n            this._buff = Buffer.allocUnsafe(DEFAULT_SMARTBUFFER_SIZE);\n        }\n    }\n    /**\n     * Creates a new SmartBuffer instance with the provided internal Buffer size and optional encoding.\n     *\n     * @param size { Number } The size of the internal Buffer.\n     * @param encoding { String } The BufferEncoding to use for strings.\n     *\n     * @return { SmartBuffer }\n     */ static fromSize(size, encoding) {\n        return new this({\n            size: size,\n            encoding: encoding\n        });\n    }\n    /**\n     * Creates a new SmartBuffer instance with the provided Buffer and optional encoding.\n     *\n     * @param buffer { Buffer } The Buffer to use as the internal Buffer value.\n     * @param encoding { String } The BufferEncoding to use for strings.\n     *\n     * @return { SmartBuffer }\n     */ static fromBuffer(buff, encoding) {\n        return new this({\n            buff: buff,\n            encoding: encoding\n        });\n    }\n    /**\n     * Creates a new SmartBuffer instance with the provided SmartBufferOptions options.\n     *\n     * @param options { SmartBufferOptions } The options to use when creating the SmartBuffer instance.\n     */ static fromOptions(options) {\n        return new this(options);\n    }\n    /**\n     * Type checking function that determines if an object is a SmartBufferOptions object.\n     */ static isSmartBufferOptions(options) {\n        const castOptions = options;\n        return castOptions && (castOptions.encoding !== undefined || castOptions.size !== undefined || castOptions.buff !== undefined);\n    }\n    // Signed integers\n    /**\n     * Reads an Int8 value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */ readInt8(offset) {\n        return this._readNumberValue(Buffer.prototype.readInt8, 1, offset);\n    }\n    /**\n     * Reads an Int16BE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */ readInt16BE(offset) {\n        return this._readNumberValue(Buffer.prototype.readInt16BE, 2, offset);\n    }\n    /**\n     * Reads an Int16LE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */ readInt16LE(offset) {\n        return this._readNumberValue(Buffer.prototype.readInt16LE, 2, offset);\n    }\n    /**\n     * Reads an Int32BE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */ readInt32BE(offset) {\n        return this._readNumberValue(Buffer.prototype.readInt32BE, 4, offset);\n    }\n    /**\n     * Reads an Int32LE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */ readInt32LE(offset) {\n        return this._readNumberValue(Buffer.prototype.readInt32LE, 4, offset);\n    }\n    /**\n     * Reads a BigInt64BE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { BigInt }\n     */ readBigInt64BE(offset) {\n        utils_1.bigIntAndBufferInt64Check(\"readBigInt64BE\");\n        return this._readNumberValue(Buffer.prototype.readBigInt64BE, 8, offset);\n    }\n    /**\n     * Reads a BigInt64LE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { BigInt }\n     */ readBigInt64LE(offset) {\n        utils_1.bigIntAndBufferInt64Check(\"readBigInt64LE\");\n        return this._readNumberValue(Buffer.prototype.readBigInt64LE, 8, offset);\n    }\n    /**\n     * Writes an Int8 value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */ writeInt8(value, offset) {\n        this._writeNumberValue(Buffer.prototype.writeInt8, 1, value, offset);\n        return this;\n    }\n    /**\n     * Inserts an Int8 value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */ insertInt8(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeInt8, 1, value, offset);\n    }\n    /**\n     * Writes an Int16BE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */ writeInt16BE(value, offset) {\n        return this._writeNumberValue(Buffer.prototype.writeInt16BE, 2, value, offset);\n    }\n    /**\n     * Inserts an Int16BE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */ insertInt16BE(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeInt16BE, 2, value, offset);\n    }\n    /**\n     * Writes an Int16LE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */ writeInt16LE(value, offset) {\n        return this._writeNumberValue(Buffer.prototype.writeInt16LE, 2, value, offset);\n    }\n    /**\n     * Inserts an Int16LE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */ insertInt16LE(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeInt16LE, 2, value, offset);\n    }\n    /**\n     * Writes an Int32BE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */ writeInt32BE(value, offset) {\n        return this._writeNumberValue(Buffer.prototype.writeInt32BE, 4, value, offset);\n    }\n    /**\n     * Inserts an Int32BE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */ insertInt32BE(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeInt32BE, 4, value, offset);\n    }\n    /**\n     * Writes an Int32LE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */ writeInt32LE(value, offset) {\n        return this._writeNumberValue(Buffer.prototype.writeInt32LE, 4, value, offset);\n    }\n    /**\n     * Inserts an Int32LE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */ insertInt32LE(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeInt32LE, 4, value, offset);\n    }\n    /**\n     * Writes a BigInt64BE value to the current write position (or at optional offset).\n     *\n     * @param value { BigInt } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */ writeBigInt64BE(value, offset) {\n        utils_1.bigIntAndBufferInt64Check(\"writeBigInt64BE\");\n        return this._writeNumberValue(Buffer.prototype.writeBigInt64BE, 8, value, offset);\n    }\n    /**\n     * Inserts a BigInt64BE value at the given offset value.\n     *\n     * @param value { BigInt } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */ insertBigInt64BE(value, offset) {\n        utils_1.bigIntAndBufferInt64Check(\"writeBigInt64BE\");\n        return this._insertNumberValue(Buffer.prototype.writeBigInt64BE, 8, value, offset);\n    }\n    /**\n     * Writes a BigInt64LE value to the current write position (or at optional offset).\n     *\n     * @param value { BigInt } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */ writeBigInt64LE(value, offset) {\n        utils_1.bigIntAndBufferInt64Check(\"writeBigInt64LE\");\n        return this._writeNumberValue(Buffer.prototype.writeBigInt64LE, 8, value, offset);\n    }\n    /**\n     * Inserts a Int64LE value at the given offset value.\n     *\n     * @param value { BigInt } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */ insertBigInt64LE(value, offset) {\n        utils_1.bigIntAndBufferInt64Check(\"writeBigInt64LE\");\n        return this._insertNumberValue(Buffer.prototype.writeBigInt64LE, 8, value, offset);\n    }\n    // Unsigned Integers\n    /**\n     * Reads an UInt8 value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */ readUInt8(offset) {\n        return this._readNumberValue(Buffer.prototype.readUInt8, 1, offset);\n    }\n    /**\n     * Reads an UInt16BE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */ readUInt16BE(offset) {\n        return this._readNumberValue(Buffer.prototype.readUInt16BE, 2, offset);\n    }\n    /**\n     * Reads an UInt16LE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */ readUInt16LE(offset) {\n        return this._readNumberValue(Buffer.prototype.readUInt16LE, 2, offset);\n    }\n    /**\n     * Reads an UInt32BE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */ readUInt32BE(offset) {\n        return this._readNumberValue(Buffer.prototype.readUInt32BE, 4, offset);\n    }\n    /**\n     * Reads an UInt32LE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */ readUInt32LE(offset) {\n        return this._readNumberValue(Buffer.prototype.readUInt32LE, 4, offset);\n    }\n    /**\n     * Reads a BigUInt64BE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { BigInt }\n     */ readBigUInt64BE(offset) {\n        utils_1.bigIntAndBufferInt64Check(\"readBigUInt64BE\");\n        return this._readNumberValue(Buffer.prototype.readBigUInt64BE, 8, offset);\n    }\n    /**\n     * Reads a BigUInt64LE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { BigInt }\n     */ readBigUInt64LE(offset) {\n        utils_1.bigIntAndBufferInt64Check(\"readBigUInt64LE\");\n        return this._readNumberValue(Buffer.prototype.readBigUInt64LE, 8, offset);\n    }\n    /**\n     * Writes an UInt8 value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */ writeUInt8(value, offset) {\n        return this._writeNumberValue(Buffer.prototype.writeUInt8, 1, value, offset);\n    }\n    /**\n     * Inserts an UInt8 value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */ insertUInt8(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeUInt8, 1, value, offset);\n    }\n    /**\n     * Writes an UInt16BE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */ writeUInt16BE(value, offset) {\n        return this._writeNumberValue(Buffer.prototype.writeUInt16BE, 2, value, offset);\n    }\n    /**\n     * Inserts an UInt16BE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */ insertUInt16BE(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeUInt16BE, 2, value, offset);\n    }\n    /**\n     * Writes an UInt16LE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */ writeUInt16LE(value, offset) {\n        return this._writeNumberValue(Buffer.prototype.writeUInt16LE, 2, value, offset);\n    }\n    /**\n     * Inserts an UInt16LE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */ insertUInt16LE(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeUInt16LE, 2, value, offset);\n    }\n    /**\n     * Writes an UInt32BE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */ writeUInt32BE(value, offset) {\n        return this._writeNumberValue(Buffer.prototype.writeUInt32BE, 4, value, offset);\n    }\n    /**\n     * Inserts an UInt32BE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */ insertUInt32BE(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeUInt32BE, 4, value, offset);\n    }\n    /**\n     * Writes an UInt32LE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */ writeUInt32LE(value, offset) {\n        return this._writeNumberValue(Buffer.prototype.writeUInt32LE, 4, value, offset);\n    }\n    /**\n     * Inserts an UInt32LE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */ insertUInt32LE(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeUInt32LE, 4, value, offset);\n    }\n    /**\n     * Writes a BigUInt64BE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */ writeBigUInt64BE(value, offset) {\n        utils_1.bigIntAndBufferInt64Check(\"writeBigUInt64BE\");\n        return this._writeNumberValue(Buffer.prototype.writeBigUInt64BE, 8, value, offset);\n    }\n    /**\n     * Inserts a BigUInt64BE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */ insertBigUInt64BE(value, offset) {\n        utils_1.bigIntAndBufferInt64Check(\"writeBigUInt64BE\");\n        return this._insertNumberValue(Buffer.prototype.writeBigUInt64BE, 8, value, offset);\n    }\n    /**\n     * Writes a BigUInt64LE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */ writeBigUInt64LE(value, offset) {\n        utils_1.bigIntAndBufferInt64Check(\"writeBigUInt64LE\");\n        return this._writeNumberValue(Buffer.prototype.writeBigUInt64LE, 8, value, offset);\n    }\n    /**\n     * Inserts a BigUInt64LE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */ insertBigUInt64LE(value, offset) {\n        utils_1.bigIntAndBufferInt64Check(\"writeBigUInt64LE\");\n        return this._insertNumberValue(Buffer.prototype.writeBigUInt64LE, 8, value, offset);\n    }\n    // Floating Point\n    /**\n     * Reads an FloatBE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */ readFloatBE(offset) {\n        return this._readNumberValue(Buffer.prototype.readFloatBE, 4, offset);\n    }\n    /**\n     * Reads an FloatLE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */ readFloatLE(offset) {\n        return this._readNumberValue(Buffer.prototype.readFloatLE, 4, offset);\n    }\n    /**\n     * Writes a FloatBE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */ writeFloatBE(value, offset) {\n        return this._writeNumberValue(Buffer.prototype.writeFloatBE, 4, value, offset);\n    }\n    /**\n     * Inserts a FloatBE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */ insertFloatBE(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeFloatBE, 4, value, offset);\n    }\n    /**\n     * Writes a FloatLE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */ writeFloatLE(value, offset) {\n        return this._writeNumberValue(Buffer.prototype.writeFloatLE, 4, value, offset);\n    }\n    /**\n     * Inserts a FloatLE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */ insertFloatLE(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeFloatLE, 4, value, offset);\n    }\n    // Double Floating Point\n    /**\n     * Reads an DoublEBE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */ readDoubleBE(offset) {\n        return this._readNumberValue(Buffer.prototype.readDoubleBE, 8, offset);\n    }\n    /**\n     * Reads an DoubleLE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */ readDoubleLE(offset) {\n        return this._readNumberValue(Buffer.prototype.readDoubleLE, 8, offset);\n    }\n    /**\n     * Writes a DoubleBE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */ writeDoubleBE(value, offset) {\n        return this._writeNumberValue(Buffer.prototype.writeDoubleBE, 8, value, offset);\n    }\n    /**\n     * Inserts a DoubleBE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */ insertDoubleBE(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeDoubleBE, 8, value, offset);\n    }\n    /**\n     * Writes a DoubleLE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */ writeDoubleLE(value, offset) {\n        return this._writeNumberValue(Buffer.prototype.writeDoubleLE, 8, value, offset);\n    }\n    /**\n     * Inserts a DoubleLE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */ insertDoubleLE(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeDoubleLE, 8, value, offset);\n    }\n    // Strings\n    /**\n     * Reads a String from the current read position.\n     *\n     * @param arg1 { Number | String } The number of bytes to read as a String, or the BufferEncoding to use for\n     *             the string (Defaults to instance level encoding).\n     * @param encoding { String } The BufferEncoding to use for the string (Defaults to instance level encoding).\n     *\n     * @return { String }\n     */ readString(arg1, encoding) {\n        let lengthVal;\n        // Length provided\n        if (typeof arg1 === \"number\") {\n            utils_1.checkLengthValue(arg1);\n            lengthVal = Math.min(arg1, this.length - this._readOffset);\n        } else {\n            encoding = arg1;\n            lengthVal = this.length - this._readOffset;\n        }\n        // Check encoding\n        if (typeof encoding !== \"undefined\") {\n            utils_1.checkEncoding(encoding);\n        }\n        const value = this._buff.slice(this._readOffset, this._readOffset + lengthVal).toString(encoding || this._encoding);\n        this._readOffset += lengthVal;\n        return value;\n    }\n    /**\n     * Inserts a String\n     *\n     * @param value { String } The String value to insert.\n     * @param offset { Number } The offset to insert the string at.\n     * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).\n     *\n     * @return this\n     */ insertString(value, offset, encoding) {\n        utils_1.checkOffsetValue(offset);\n        return this._handleString(value, true, offset, encoding);\n    }\n    /**\n     * Writes a String\n     *\n     * @param value { String } The String value to write.\n     * @param arg2 { Number | String } The offset to write the string at, or the BufferEncoding to use.\n     * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).\n     *\n     * @return this\n     */ writeString(value, arg2, encoding) {\n        return this._handleString(value, false, arg2, encoding);\n    }\n    /**\n     * Reads a null-terminated String from the current read position.\n     *\n     * @param encoding { String } The BufferEncoding to use for the string (Defaults to instance level encoding).\n     *\n     * @return { String }\n     */ readStringNT(encoding) {\n        if (typeof encoding !== \"undefined\") {\n            utils_1.checkEncoding(encoding);\n        }\n        // Set null character position to the end SmartBuffer instance.\n        let nullPos = this.length;\n        // Find next null character (if one is not found, default from above is used)\n        for(let i = this._readOffset; i < this.length; i++){\n            if (this._buff[i] === 0x00) {\n                nullPos = i;\n                break;\n            }\n        }\n        // Read string value\n        const value = this._buff.slice(this._readOffset, nullPos);\n        // Increment internal Buffer read offset\n        this._readOffset = nullPos + 1;\n        return value.toString(encoding || this._encoding);\n    }\n    /**\n     * Inserts a null-terminated String.\n     *\n     * @param value { String } The String value to write.\n     * @param arg2 { Number | String } The offset to write the string to, or the BufferEncoding to use.\n     * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).\n     *\n     * @return this\n     */ insertStringNT(value, offset, encoding) {\n        utils_1.checkOffsetValue(offset);\n        // Write Values\n        this.insertString(value, offset, encoding);\n        this.insertUInt8(0x00, offset + value.length);\n        return this;\n    }\n    /**\n     * Writes a null-terminated String.\n     *\n     * @param value { String } The String value to write.\n     * @param arg2 { Number | String } The offset to write the string to, or the BufferEncoding to use.\n     * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).\n     *\n     * @return this\n     */ writeStringNT(value, arg2, encoding) {\n        // Write Values\n        this.writeString(value, arg2, encoding);\n        this.writeUInt8(0x00, typeof arg2 === \"number\" ? arg2 + value.length : this.writeOffset);\n        return this;\n    }\n    // Buffers\n    /**\n     * Reads a Buffer from the internal read position.\n     *\n     * @param length { Number } The length of data to read as a Buffer.\n     *\n     * @return { Buffer }\n     */ readBuffer(length) {\n        if (typeof length !== \"undefined\") {\n            utils_1.checkLengthValue(length);\n        }\n        const lengthVal = typeof length === \"number\" ? length : this.length;\n        const endPoint = Math.min(this.length, this._readOffset + lengthVal);\n        // Read buffer value\n        const value = this._buff.slice(this._readOffset, endPoint);\n        // Increment internal Buffer read offset\n        this._readOffset = endPoint;\n        return value;\n    }\n    /**\n     * Writes a Buffer to the current write position.\n     *\n     * @param value { Buffer } The Buffer to write.\n     * @param offset { Number } The offset to write the Buffer to.\n     *\n     * @return this\n     */ insertBuffer(value, offset) {\n        utils_1.checkOffsetValue(offset);\n        return this._handleBuffer(value, true, offset);\n    }\n    /**\n     * Writes a Buffer to the current write position.\n     *\n     * @param value { Buffer } The Buffer to write.\n     * @param offset { Number } The offset to write the Buffer to.\n     *\n     * @return this\n     */ writeBuffer(value, offset) {\n        return this._handleBuffer(value, false, offset);\n    }\n    /**\n     * Reads a null-terminated Buffer from the current read poisiton.\n     *\n     * @return { Buffer }\n     */ readBufferNT() {\n        // Set null character position to the end SmartBuffer instance.\n        let nullPos = this.length;\n        // Find next null character (if one is not found, default from above is used)\n        for(let i = this._readOffset; i < this.length; i++){\n            if (this._buff[i] === 0x00) {\n                nullPos = i;\n                break;\n            }\n        }\n        // Read value\n        const value = this._buff.slice(this._readOffset, nullPos);\n        // Increment internal Buffer read offset\n        this._readOffset = nullPos + 1;\n        return value;\n    }\n    /**\n     * Inserts a null-terminated Buffer.\n     *\n     * @param value { Buffer } The Buffer to write.\n     * @param offset { Number } The offset to write the Buffer to.\n     *\n     * @return this\n     */ insertBufferNT(value, offset) {\n        utils_1.checkOffsetValue(offset);\n        // Write Values\n        this.insertBuffer(value, offset);\n        this.insertUInt8(0x00, offset + value.length);\n        return this;\n    }\n    /**\n     * Writes a null-terminated Buffer.\n     *\n     * @param value { Buffer } The Buffer to write.\n     * @param offset { Number } The offset to write the Buffer to.\n     *\n     * @return this\n     */ writeBufferNT(value, offset) {\n        // Checks for valid numberic value;\n        if (typeof offset !== \"undefined\") {\n            utils_1.checkOffsetValue(offset);\n        }\n        // Write Values\n        this.writeBuffer(value, offset);\n        this.writeUInt8(0x00, typeof offset === \"number\" ? offset + value.length : this._writeOffset);\n        return this;\n    }\n    /**\n     * Clears the SmartBuffer instance to its original empty state.\n     */ clear() {\n        this._writeOffset = 0;\n        this._readOffset = 0;\n        this.length = 0;\n        return this;\n    }\n    /**\n     * Gets the remaining data left to be read from the SmartBuffer instance.\n     *\n     * @return { Number }\n     */ remaining() {\n        return this.length - this._readOffset;\n    }\n    /**\n     * Gets the current read offset value of the SmartBuffer instance.\n     *\n     * @return { Number }\n     */ get readOffset() {\n        return this._readOffset;\n    }\n    /**\n     * Sets the read offset value of the SmartBuffer instance.\n     *\n     * @param offset { Number } - The offset value to set.\n     */ set readOffset(offset) {\n        utils_1.checkOffsetValue(offset);\n        // Check for bounds.\n        utils_1.checkTargetOffset(offset, this);\n        this._readOffset = offset;\n    }\n    /**\n     * Gets the current write offset value of the SmartBuffer instance.\n     *\n     * @return { Number }\n     */ get writeOffset() {\n        return this._writeOffset;\n    }\n    /**\n     * Sets the write offset value of the SmartBuffer instance.\n     *\n     * @param offset { Number } - The offset value to set.\n     */ set writeOffset(offset) {\n        utils_1.checkOffsetValue(offset);\n        // Check for bounds.\n        utils_1.checkTargetOffset(offset, this);\n        this._writeOffset = offset;\n    }\n    /**\n     * Gets the currently set string encoding of the SmartBuffer instance.\n     *\n     * @return { BufferEncoding } The string Buffer encoding currently set.\n     */ get encoding() {\n        return this._encoding;\n    }\n    /**\n     * Sets the string encoding of the SmartBuffer instance.\n     *\n     * @param encoding { BufferEncoding } The string Buffer encoding to set.\n     */ set encoding(encoding) {\n        utils_1.checkEncoding(encoding);\n        this._encoding = encoding;\n    }\n    /**\n     * Gets the underlying internal Buffer. (This includes unmanaged data in the Buffer)\n     *\n     * @return { Buffer } The Buffer value.\n     */ get internalBuffer() {\n        return this._buff;\n    }\n    /**\n     * Gets the value of the internal managed Buffer (Includes managed data only)\n     *\n     * @param { Buffer }\n     */ toBuffer() {\n        return this._buff.slice(0, this.length);\n    }\n    /**\n     * Gets the String value of the internal managed Buffer\n     *\n     * @param encoding { String } The BufferEncoding to display the Buffer as (defaults to instance level encoding).\n     */ toString(encoding) {\n        const encodingVal = typeof encoding === \"string\" ? encoding : this._encoding;\n        // Check for invalid encoding.\n        utils_1.checkEncoding(encodingVal);\n        return this._buff.toString(encodingVal, 0, this.length);\n    }\n    /**\n     * Destroys the SmartBuffer instance.\n     */ destroy() {\n        this.clear();\n        return this;\n    }\n    /**\n     * Handles inserting and writing strings.\n     *\n     * @param value { String } The String value to insert.\n     * @param isInsert { Boolean } True if inserting a string, false if writing.\n     * @param arg2 { Number | String } The offset to insert the string at, or the BufferEncoding to use.\n     * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).\n     */ _handleString(value, isInsert, arg3, encoding) {\n        let offsetVal = this._writeOffset;\n        let encodingVal = this._encoding;\n        // Check for offset\n        if (typeof arg3 === \"number\") {\n            offsetVal = arg3;\n        // Check for encoding\n        } else if (typeof arg3 === \"string\") {\n            utils_1.checkEncoding(arg3);\n            encodingVal = arg3;\n        }\n        // Check for encoding (third param)\n        if (typeof encoding === \"string\") {\n            utils_1.checkEncoding(encoding);\n            encodingVal = encoding;\n        }\n        // Calculate bytelength of string.\n        const byteLength = Buffer.byteLength(value, encodingVal);\n        // Ensure there is enough internal Buffer capacity.\n        if (isInsert) {\n            this.ensureInsertable(byteLength, offsetVal);\n        } else {\n            this._ensureWriteable(byteLength, offsetVal);\n        }\n        // Write value\n        this._buff.write(value, offsetVal, byteLength, encodingVal);\n        // Increment internal Buffer write offset;\n        if (isInsert) {\n            this._writeOffset += byteLength;\n        } else {\n            // If an offset was given, check to see if we wrote beyond the current writeOffset.\n            if (typeof arg3 === \"number\") {\n                this._writeOffset = Math.max(this._writeOffset, offsetVal + byteLength);\n            } else {\n                // If no offset was given, we wrote to the end of the SmartBuffer so increment writeOffset.\n                this._writeOffset += byteLength;\n            }\n        }\n        return this;\n    }\n    /**\n     * Handles writing or insert of a Buffer.\n     *\n     * @param value { Buffer } The Buffer to write.\n     * @param offset { Number } The offset to write the Buffer to.\n     */ _handleBuffer(value, isInsert, offset) {\n        const offsetVal = typeof offset === \"number\" ? offset : this._writeOffset;\n        // Ensure there is enough internal Buffer capacity.\n        if (isInsert) {\n            this.ensureInsertable(value.length, offsetVal);\n        } else {\n            this._ensureWriteable(value.length, offsetVal);\n        }\n        // Write buffer value\n        value.copy(this._buff, offsetVal);\n        // Increment internal Buffer write offset;\n        if (isInsert) {\n            this._writeOffset += value.length;\n        } else {\n            // If an offset was given, check to see if we wrote beyond the current writeOffset.\n            if (typeof offset === \"number\") {\n                this._writeOffset = Math.max(this._writeOffset, offsetVal + value.length);\n            } else {\n                // If no offset was given, we wrote to the end of the SmartBuffer so increment writeOffset.\n                this._writeOffset += value.length;\n            }\n        }\n        return this;\n    }\n    /**\n     * Ensures that the internal Buffer is large enough to read data.\n     *\n     * @param length { Number } The length of the data that needs to be read.\n     * @param offset { Number } The offset of the data that needs to be read.\n     */ ensureReadable(length, offset) {\n        // Offset value defaults to managed read offset.\n        let offsetVal = this._readOffset;\n        // If an offset was provided, use it.\n        if (typeof offset !== \"undefined\") {\n            // Checks for valid numberic value;\n            utils_1.checkOffsetValue(offset);\n            // Overide with custom offset.\n            offsetVal = offset;\n        }\n        // Checks if offset is below zero, or the offset+length offset is beyond the total length of the managed data.\n        if (offsetVal < 0 || offsetVal + length > this.length) {\n            throw new Error(utils_1.ERRORS.INVALID_READ_BEYOND_BOUNDS);\n        }\n    }\n    /**\n     * Ensures that the internal Buffer is large enough to insert data.\n     *\n     * @param dataLength { Number } The length of the data that needs to be written.\n     * @param offset { Number } The offset of the data to be written.\n     */ ensureInsertable(dataLength, offset) {\n        // Checks for valid numberic value;\n        utils_1.checkOffsetValue(offset);\n        // Ensure there is enough internal Buffer capacity.\n        this._ensureCapacity(this.length + dataLength);\n        // If an offset was provided and its not the very end of the buffer, copy data into appropriate location in regards to the offset.\n        if (offset < this.length) {\n            this._buff.copy(this._buff, offset + dataLength, offset, this._buff.length);\n        }\n        // Adjust tracked smart buffer length\n        if (offset + dataLength > this.length) {\n            this.length = offset + dataLength;\n        } else {\n            this.length += dataLength;\n        }\n    }\n    /**\n     * Ensures that the internal Buffer is large enough to write data.\n     *\n     * @param dataLength { Number } The length of the data that needs to be written.\n     * @param offset { Number } The offset of the data to be written (defaults to writeOffset).\n     */ _ensureWriteable(dataLength, offset) {\n        const offsetVal = typeof offset === \"number\" ? offset : this._writeOffset;\n        // Ensure enough capacity to write data.\n        this._ensureCapacity(offsetVal + dataLength);\n        // Adjust SmartBuffer length (if offset + length is larger than managed length, adjust length)\n        if (offsetVal + dataLength > this.length) {\n            this.length = offsetVal + dataLength;\n        }\n    }\n    /**\n     * Ensures that the internal Buffer is large enough to write at least the given amount of data.\n     *\n     * @param minLength { Number } The minimum length of the data needs to be written.\n     */ _ensureCapacity(minLength) {\n        const oldLength = this._buff.length;\n        if (minLength > oldLength) {\n            let data = this._buff;\n            let newLength = oldLength * 3 / 2 + 1;\n            if (newLength < minLength) {\n                newLength = minLength;\n            }\n            this._buff = Buffer.allocUnsafe(newLength);\n            data.copy(this._buff, 0, 0, oldLength);\n        }\n    }\n    /**\n     * Reads a numeric number value using the provided function.\n     *\n     * @typeparam T { number | bigint } The type of the value to be read\n     *\n     * @param func { Function(offset: number) => number } The function to read data on the internal Buffer with.\n     * @param byteSize { Number } The number of bytes read.\n     * @param offset { Number } The offset to read from (optional). When this is not provided, the managed readOffset is used instead.\n     *\n     * @returns { T } the number value\n     */ _readNumberValue(func, byteSize, offset) {\n        this.ensureReadable(byteSize, offset);\n        // Call Buffer.readXXXX();\n        const value = func.call(this._buff, typeof offset === \"number\" ? offset : this._readOffset);\n        // Adjust internal read offset if an optional read offset was not provided.\n        if (typeof offset === \"undefined\") {\n            this._readOffset += byteSize;\n        }\n        return value;\n    }\n    /**\n     * Inserts a numeric number value based on the given offset and value.\n     *\n     * @typeparam T { number | bigint } The type of the value to be written\n     *\n     * @param func { Function(offset: T, offset?) => number} The function to write data on the internal Buffer with.\n     * @param byteSize { Number } The number of bytes written.\n     * @param value { T } The number value to write.\n     * @param offset { Number } the offset to write the number at (REQUIRED).\n     *\n     * @returns SmartBuffer this buffer\n     */ _insertNumberValue(func, byteSize, value, offset) {\n        // Check for invalid offset values.\n        utils_1.checkOffsetValue(offset);\n        // Ensure there is enough internal Buffer capacity. (raw offset is passed)\n        this.ensureInsertable(byteSize, offset);\n        // Call buffer.writeXXXX();\n        func.call(this._buff, value, offset);\n        // Adjusts internally managed write offset.\n        this._writeOffset += byteSize;\n        return this;\n    }\n    /**\n     * Writes a numeric number value based on the given offset and value.\n     *\n     * @typeparam T { number | bigint } The type of the value to be written\n     *\n     * @param func { Function(offset: T, offset?) => number} The function to write data on the internal Buffer with.\n     * @param byteSize { Number } The number of bytes written.\n     * @param value { T } The number value to write.\n     * @param offset { Number } the offset to write the number at (REQUIRED).\n     *\n     * @returns SmartBuffer this buffer\n     */ _writeNumberValue(func, byteSize, value, offset) {\n        // If an offset was provided, validate it.\n        if (typeof offset === \"number\") {\n            // Check if we're writing beyond the bounds of the managed data.\n            if (offset < 0) {\n                throw new Error(utils_1.ERRORS.INVALID_WRITE_BEYOND_BOUNDS);\n            }\n            utils_1.checkOffsetValue(offset);\n        }\n        // Default to writeOffset if no offset value was given.\n        const offsetVal = typeof offset === \"number\" ? offset : this._writeOffset;\n        // Ensure there is enough internal Buffer capacity. (raw offset is passed)\n        this._ensureWriteable(byteSize, offsetVal);\n        func.call(this._buff, value, offsetVal);\n        // If an offset was given, check to see if we wrote beyond the current writeOffset.\n        if (typeof offset === \"number\") {\n            this._writeOffset = Math.max(this._writeOffset, offsetVal + byteSize);\n        } else {\n            // If no numeric offset was given, we wrote to the end of the SmartBuffer so increment writeOffset.\n            this._writeOffset += byteSize;\n        }\n        return this;\n    }\n}\nexports.SmartBuffer = SmartBuffer; //# sourceMappingURL=smartbuffer.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3NtYXJ0LWJ1ZmZlckA0LjIuMC9ub2RlX21vZHVsZXMvc21hcnQtYnVmZmVyL2J1aWxkL3NtYXJ0YnVmZmVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdELE1BQU1DLFVBQVVDLG1CQUFPQSxDQUFDLDJHQUFTO0FBQ2pDLGtEQUFrRDtBQUNsRCxNQUFNQywyQkFBMkI7QUFDakMsa0VBQWtFO0FBQ2xFLE1BQU1DLCtCQUErQjtBQUNyQyxNQUFNQztJQUNGOzs7O0tBSUMsR0FDREMsWUFBWUMsT0FBTyxDQUFFO1FBQ2pCLElBQUksQ0FBQ0MsTUFBTSxHQUFHO1FBQ2QsSUFBSSxDQUFDQyxTQUFTLEdBQUdMO1FBQ2pCLElBQUksQ0FBQ00sWUFBWSxHQUFHO1FBQ3BCLElBQUksQ0FBQ0MsV0FBVyxHQUFHO1FBQ25CLElBQUlOLFlBQVlPLG9CQUFvQixDQUFDTCxVQUFVO1lBQzNDLHNCQUFzQjtZQUN0QixJQUFJQSxRQUFRTSxRQUFRLEVBQUU7Z0JBQ2xCWixRQUFRYSxhQUFhLENBQUNQLFFBQVFNLFFBQVE7Z0JBQ3RDLElBQUksQ0FBQ0osU0FBUyxHQUFHRixRQUFRTSxRQUFRO1lBQ3JDO1lBQ0EsaUNBQWlDO1lBQ2pDLElBQUlOLFFBQVFRLElBQUksRUFBRTtnQkFDZCxJQUFJZCxRQUFRZSxlQUFlLENBQUNULFFBQVFRLElBQUksS0FBS1IsUUFBUVEsSUFBSSxHQUFHLEdBQUc7b0JBQzNELElBQUksQ0FBQ0UsS0FBSyxHQUFHQyxPQUFPQyxXQUFXLENBQUNaLFFBQVFRLElBQUk7Z0JBQ2hELE9BQ0s7b0JBQ0QsTUFBTSxJQUFJSyxNQUFNbkIsUUFBUW9CLE1BQU0sQ0FBQ0Msd0JBQXdCO2dCQUMzRDtZQUNBLDJCQUEyQjtZQUMvQixPQUNLLElBQUlmLFFBQVFnQixJQUFJLEVBQUU7Z0JBQ25CLElBQUlMLE9BQU9NLFFBQVEsQ0FBQ2pCLFFB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QUksQ0FBQ2tHLGdCQUFnQixDQUFDYyxVQUFVaEg7UUFDaEMsMkJBQTJCO1FBQzNCK0csS0FBS0UsSUFBSSxDQUFDLElBQUksQ0FBQ2pJLEtBQUssRUFBRWpCLE9BQU9pQztRQUM3QiwyQ0FBMkM7UUFDM0MsSUFBSSxDQUFDdkIsWUFBWSxJQUFJdUk7UUFDckIsT0FBTyxJQUFJO0lBQ2Y7SUFDQTs7Ozs7Ozs7Ozs7S0FXQyxHQUNEckcsa0JBQWtCb0csSUFBSSxFQUFFQyxRQUFRLEVBQUVqSixLQUFLLEVBQUVpQyxNQUFNLEVBQUU7UUFDN0MsMENBQTBDO1FBQzFDLElBQUksT0FBT0EsV0FBVyxVQUFVO1lBQzVCLGdFQUFnRTtZQUNoRSxJQUFJQSxTQUFTLEdBQUc7Z0JBQ1osTUFBTSxJQUFJYixNQUFNbkIsUUFBUW9CLE1BQU0sQ0FBQzhILDJCQUEyQjtZQUM5RDtZQUNBbEosUUFBUW9HLGdCQUFnQixDQUFDcEU7UUFDN0I7UUFDQSx1REFBdUQ7UUFDdkQsTUFBTWdHLFlBQVksT0FBT2hHLFdBQVcsV0FBV0EsU0FBUyxJQUFJLENBQUN2QixZQUFZO1FBQ3pFLDBFQUEwRTtRQUMxRSxJQUFJLENBQUMwSCxnQkFBZ0IsQ0FBQ2EsVUFBVWhCO1FBQ2hDZSxLQUFLRSxJQUFJLENBQUMsSUFBSSxDQUFDakksS0FBSyxFQUFFakIsT0FBT2lJO1FBQzdCLG1GQUFtRjtRQUNuRixJQUFJLE9BQU9oRyxXQUFXLFVBQVU7WUFDNUIsSUFBSSxDQUFDdkIsWUFBWSxHQUFHc0YsS0FBS3NDLEdBQUcsQ0FBQyxJQUFJLENBQUM1SCxZQUFZLEVBQUV1SCxZQUFZZ0I7UUFDaEUsT0FDSztZQUNELG1HQUFtRztZQUNuRyxJQUFJLENBQUN2SSxZQUFZLElBQUl1STtRQUN6QjtRQUNBLE9BQU8sSUFBSTtJQUNmO0FBQ0o7QUFDQWxKLG1CQUFtQixHQUFHTSxhQUN0Qix1Q0FBdUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3NtYXJ0LWJ1ZmZlckA0LjIuMC9ub2RlX21vZHVsZXMvc21hcnQtYnVmZmVyL2J1aWxkL3NtYXJ0YnVmZmVyLmpzP2YxMjMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG4vLyBUaGUgZGVmYXVsdCBCdWZmZXIgc2l6ZSBpZiBvbmUgaXMgbm90IHByb3ZpZGVkLlxuY29uc3QgREVGQVVMVF9TTUFSVEJVRkZFUl9TSVpFID0gNDA5Njtcbi8vIFRoZSBkZWZhdWx0IHN0cmluZyBlbmNvZGluZyB0byB1c2UgZm9yIHJlYWRpbmcvd3JpdGluZyBzdHJpbmdzLlxuY29uc3QgREVGQVVMVF9TTUFSVEJVRkZFUl9FTkNPRElORyA9ICd1dGY4JztcbmNsYXNzIFNtYXJ0QnVmZmVyIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IFNtYXJ0QnVmZmVyIGluc3RhbmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgeyBTbWFydEJ1ZmZlck9wdGlvbnMgfSBUaGUgU21hcnRCdWZmZXJPcHRpb25zIHRvIGFwcGx5IHRvIHRoaXMgaW5zdGFuY2UuXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMuX2VuY29kaW5nID0gREVGQVVMVF9TTUFSVEJVRkZFUl9FTkNPRElORztcbiAgICAgICAgdGhpcy5fd3JpdGVPZmZzZXQgPSAwO1xuICAgICAgICB0aGlzLl9yZWFkT2Zmc2V0ID0gMDtcbiAgICAgICAgaWYgKFNtYXJ0QnVmZmVyLmlzU21hcnRCdWZmZXJPcHRpb25zKG9wdGlvbnMpKSB7XG4gICAgICAgICAgICAvLyBDaGVja3MgZm9yIGVuY29kaW5nXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5lbmNvZGluZykge1xuICAgICAgICAgICAgICAgIHV0aWxzXzEuY2hlY2tFbmNvZGluZyhvcHRpb25zLmVuY29kaW5nKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9lbmNvZGluZyA9IG9wdGlvbnMuZW5jb2Rpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDaGVja3MgZm9yIGluaXRpYWwgc2l6ZSBsZW5ndGhcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnNpemUpIHtcbiAgICAgICAgICAgICAgICBpZiAodXRpbHNfMS5pc0Zpbml0ZUludGVnZXIob3B0aW9ucy5zaXplKSAmJiBvcHRpb25zLnNpemUgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2J1ZmYgPSBCdWZmZXIuYWxsb2NVbnNhZmUob3B0aW9ucy5zaXplKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcih1dGlsc18xLkVSUk9SUy5JTlZBTElEX1NNQVJUQlVGRkVSX1NJWkUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBDaGVjayBmb3IgaW5pdGlhbCBCdWZmZXJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG9wdGlvbnMuYnVmZikge1xuICAgICAgICAgICAgICAgIGlmIChCdWZmZXIuaXNCdWZmZXIob3B0aW9ucy5idWZmKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9idWZmID0gb3B0aW9ucy5idWZmO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxlbmd0aCA9IG9wdGlvbnMuYnVmZi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IodXRpbHNfMS5FUlJPUlMuSU5WQUxJRF9TTUFSVEJVRkZFUl9CVUZGRVIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2J1ZmYgPSBCdWZmZXIuYWxsb2NVbnNhZmUoREVGQVVMVF9TTUFSVEJVRkZFUl9TSVpFKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIElmIHNvbWV0aGluZyB3YXMgcGFzc2VkIGJ1dCBpdCdzIG5vdCBhIFNtYXJ0QnVmZmVyT3B0aW9ucyBvYmplY3RcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IodXRpbHNfMS5FUlJPUlMuSU5WQUxJRF9TTUFSVEJVRkZFUl9PQkpFQ1QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIGRlZmF1bHQgdG8gc2FuZSBvcHRpb25zXG4gICAgICAgICAgICB0aGlzLl9idWZmID0gQnVmZmVyLmFsbG9jVW5zYWZlKERFRkFVTFRfU01BUlRCVUZGRVJfU0laRSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBTbWFydEJ1ZmZlciBpbnN0YW5jZSB3aXRoIHRoZSBwcm92aWRlZCBpbnRlcm5hbCBCdWZmZXIgc2l6ZSBhbmQgb3B0aW9uYWwgZW5jb2RpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc2l6ZSB7IE51bWJlciB9IFRoZSBzaXplIG9mIHRoZSBpbnRlcm5hbCBCdWZmZXIuXG4gICAgICogQHBhcmFtIGVuY29kaW5nIHsgU3RyaW5nIH0gVGhlIEJ1ZmZlckVuY29kaW5nIHRvIHVzZSBmb3Igc3RyaW5ncy5cbiAgICAgKlxuICAgICAqIEByZXR1cm4geyBTbWFydEJ1ZmZlciB9XG4gICAgICovXG4gICAgc3RhdGljIGZyb21TaXplKHNpemUsIGVuY29kaW5nKSB7XG4gICAgICAgIHJldHVybiBuZXcgdGhpcyh7XG4gICAgICAgICAgICBzaXplOiBzaXplLFxuICAgICAgICAgICAgZW5jb2Rpbmc6IGVuY29kaW5nXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IFNtYXJ0QnVmZmVyIGluc3RhbmNlIHdpdGggdGhlIHByb3ZpZGVkIEJ1ZmZlciBhbmQgb3B0aW9uYWwgZW5jb2RpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYnVmZmVyIHsgQnVmZmVyIH0gVGhlIEJ1ZmZlciB0byB1c2UgYXMgdGhlIGludGVybmFsIEJ1ZmZlciB2YWx1ZS5cbiAgICAgKiBAcGFyYW0gZW5jb2RpbmcgeyBTdHJpbmcgfSBUaGUgQnVmZmVyRW5jb2RpbmcgdG8gdXNlIGZvciBzdHJpbmdzLlxuICAgICAqXG4gICAgICogQHJldHVybiB7IFNtYXJ0QnVmZmVyIH1cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbUJ1ZmZlcihidWZmLCBlbmNvZGluZykge1xuICAgICAgICByZXR1cm4gbmV3IHRoaXMoe1xuICAgICAgICAgICAgYnVmZjogYnVmZixcbiAgICAgICAgICAgIGVuY29kaW5nOiBlbmNvZGluZ1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBTbWFydEJ1ZmZlciBpbnN0YW5jZSB3aXRoIHRoZSBwcm92aWRlZCBTbWFydEJ1ZmZlck9wdGlvbnMgb3B0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIHsgU21hcnRCdWZmZXJPcHRpb25zIH0gVGhlIG9wdGlvbnMgdG8gdXNlIHdoZW4gY3JlYXRpbmcgdGhlIFNtYXJ0QnVmZmVyIGluc3RhbmNlLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgdGhpcyhvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHlwZSBjaGVja2luZyBmdW5jdGlvbiB0aGF0IGRldGVybWluZXMgaWYgYW4gb2JqZWN0IGlzIGEgU21hcnRCdWZmZXJPcHRpb25zIG9iamVjdC5cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNTbWFydEJ1ZmZlck9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICBjb25zdCBjYXN0T3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHJldHVybiAoY2FzdE9wdGlvbnMgJiZcbiAgICAgICAgICAgIChjYXN0T3B0aW9ucy5lbmNvZGluZyAhPT0gdW5kZWZpbmVkIHx8IGNhc3RPcHRpb25zLnNpemUgIT09IHVuZGVmaW5lZCB8fCBjYXN0T3B0aW9ucy5idWZmICE9PSB1bmRlZmluZWQpKTtcbiAgICB9XG4gICAgLy8gU2lnbmVkIGludGVnZXJzXG4gICAgLyoqXG4gICAgICogUmVhZHMgYW4gSW50OCB2YWx1ZSBmcm9tIHRoZSBjdXJyZW50IHJlYWQgcG9zaXRpb24gb3IgYW4gb3B0aW9uYWxseSBwcm92aWRlZCBvZmZzZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb2Zmc2V0IHsgTnVtYmVyIH0gVGhlIG9mZnNldCB0byByZWFkIGRhdGEgZnJvbSAob3B0aW9uYWwpXG4gICAgICogQHJldHVybiB7IE51bWJlciB9XG4gICAgICovXG4gICAgcmVhZEludDgob2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWFkTnVtYmVyVmFsdWUoQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCwgMSwgb2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZHMgYW4gSW50MTZCRSB2YWx1ZSBmcm9tIHRoZSBjdXJyZW50IHJlYWQgcG9zaXRpb24gb3IgYW4gb3B0aW9uYWxseSBwcm92aWRlZCBvZmZzZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb2Zmc2V0IHsgTnVtYmVyIH0gVGhlIG9mZnNldCB0byByZWFkIGRhdGEgZnJvbSAob3B0aW9uYWwpXG4gICAgICogQHJldHVybiB7IE51bWJlciB9XG4gICAgICovXG4gICAgcmVhZEludDE2QkUob2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWFkTnVtYmVyVmFsdWUoQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSwgMiwgb2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZHMgYW4gSW50MTZMRSB2YWx1ZSBmcm9tIHRoZSBjdXJyZW50IHJlYWQgcG9zaXRpb24gb3IgYW4gb3B0aW9uYWxseSBwcm92aWRlZCBvZmZzZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb2Zmc2V0IHsgTnVtYmVyIH0gVGhlIG9mZnNldCB0byByZWFkIGRhdGEgZnJvbSAob3B0aW9uYWwpXG4gICAgICogQHJldHVybiB7IE51bWJlciB9XG4gICAgICovXG4gICAgcmVhZEludDE2TEUob2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWFkTnVtYmVyVmFsdWUoQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSwgMiwgb2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZHMgYW4gSW50MzJCRSB2YWx1ZSBmcm9tIHRoZSBjdXJyZW50IHJlYWQgcG9zaXRpb24gb3IgYW4gb3B0aW9uYWxseSBwcm92aWRlZCBvZmZzZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb2Zmc2V0IHsgTnVtYmVyIH0gVGhlIG9mZnNldCB0byByZWFkIGRhdGEgZnJvbSAob3B0aW9uYWwpXG4gICAgICogQHJldHVybiB7IE51bWJlciB9XG4gICAgICovXG4gICAgcmVhZEludDMyQkUob2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWFkTnVtYmVyVmFsdWUoQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSwgNCwgb2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZHMgYW4gSW50MzJMRSB2YWx1ZSBmcm9tIHRoZSBjdXJyZW50IHJlYWQgcG9zaXRpb24gb3IgYW4gb3B0aW9uYWxseSBwcm92aWRlZCBvZmZzZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb2Zmc2V0IHsgTnVtYmVyIH0gVGhlIG9mZnNldCB0byByZWFkIGRhdGEgZnJvbSAob3B0aW9uYWwpXG4gICAgICogQHJldHVybiB7IE51bWJlciB9XG4gICAgICovXG4gICAgcmVhZEludDMyTEUob2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWFkTnVtYmVyVmFsdWUoQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSwgNCwgb2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZHMgYSBCaWdJbnQ2NEJFIHZhbHVlIGZyb20gdGhlIGN1cnJlbnQgcmVhZCBwb3NpdGlvbiBvciBhbiBvcHRpb25hbGx5IHByb3ZpZGVkIG9mZnNldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IHRvIHJlYWQgZGF0YSBmcm9tIChvcHRpb25hbClcbiAgICAgKiBAcmV0dXJuIHsgQmlnSW50IH1cbiAgICAgKi9cbiAgICByZWFkQmlnSW50NjRCRShvZmZzZXQpIHtcbiAgICAgICAgdXRpbHNfMS5iaWdJbnRBbmRCdWZmZXJJbnQ2NENoZWNrKCdyZWFkQmlnSW50NjRCRScpO1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVhZE51bWJlclZhbHVlKEJ1ZmZlci5wcm90b3R5cGUucmVhZEJpZ0ludDY0QkUsIDgsIG9mZnNldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWRzIGEgQmlnSW50NjRMRSB2YWx1ZSBmcm9tIHRoZSBjdXJyZW50IHJlYWQgcG9zaXRpb24gb3IgYW4gb3B0aW9uYWxseSBwcm92aWRlZCBvZmZzZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb2Zmc2V0IHsgTnVtYmVyIH0gVGhlIG9mZnNldCB0byByZWFkIGRhdGEgZnJvbSAob3B0aW9uYWwpXG4gICAgICogQHJldHVybiB7IEJpZ0ludCB9XG4gICAgICovXG4gICAgcmVhZEJpZ0ludDY0TEUob2Zmc2V0KSB7XG4gICAgICAgIHV0aWxzXzEuYmlnSW50QW5kQnVmZmVySW50NjRDaGVjaygncmVhZEJpZ0ludDY0TEUnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWROdW1iZXJWYWx1ZShCdWZmZXIucHJvdG90eXBlLnJlYWRCaWdJbnQ2NExFLCA4LCBvZmZzZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZXMgYW4gSW50OCB2YWx1ZSB0byB0aGUgY3VycmVudCB3cml0ZSBwb3NpdGlvbiAob3IgYXQgb3B0aW9uYWwgb2Zmc2V0KS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSB7IE51bWJlciB9IFRoZSB2YWx1ZSB0byB3cml0ZS5cbiAgICAgKiBAcGFyYW0gb2Zmc2V0IHsgTnVtYmVyIH0gVGhlIG9mZnNldCB0byB3cml0ZSB0aGUgdmFsdWUgYXQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHRoaXNcbiAgICAgKi9cbiAgICB3cml0ZUludDgodmFsdWUsIG9mZnNldCkge1xuICAgICAgICB0aGlzLl93cml0ZU51bWJlclZhbHVlKEJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4LCAxLCB2YWx1ZSwgb2Zmc2V0KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluc2VydHMgYW4gSW50OCB2YWx1ZSBhdCB0aGUgZ2l2ZW4gb2Zmc2V0IHZhbHVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIHsgTnVtYmVyIH0gVGhlIHZhbHVlIHRvIGluc2VydC5cbiAgICAgKiBAcGFyYW0gb2Zmc2V0IHsgTnVtYmVyIH0gVGhlIG9mZnNldCB0byBpbnNlcnQgdGhlIHZhbHVlIGF0LlxuICAgICAqXG4gICAgICogQHJldHVybiB0aGlzXG4gICAgICovXG4gICAgaW5zZXJ0SW50OCh2YWx1ZSwgb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnNlcnROdW1iZXJWYWx1ZShCdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCwgMSwgdmFsdWUsIG9mZnNldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlcyBhbiBJbnQxNkJFIHZhbHVlIHRvIHRoZSBjdXJyZW50IHdyaXRlIHBvc2l0aW9uIChvciBhdCBvcHRpb25hbCBvZmZzZXQpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIHsgTnVtYmVyIH0gVGhlIHZhbHVlIHRvIHdyaXRlLlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IHRvIHdyaXRlIHRoZSB2YWx1ZSBhdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gdGhpc1xuICAgICAqL1xuICAgIHdyaXRlSW50MTZCRSh2YWx1ZSwgb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93cml0ZU51bWJlclZhbHVlKEJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFLCAyLCB2YWx1ZSwgb2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5zZXJ0cyBhbiBJbnQxNkJFIHZhbHVlIGF0IHRoZSBnaXZlbiBvZmZzZXQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgeyBOdW1iZXIgfSBUaGUgdmFsdWUgdG8gaW5zZXJ0LlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IHRvIGluc2VydCB0aGUgdmFsdWUgYXQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHRoaXNcbiAgICAgKi9cbiAgICBpbnNlcnRJbnQxNkJFKHZhbHVlLCBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luc2VydE51bWJlclZhbHVlKEJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFLCAyLCB2YWx1ZSwgb2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGVzIGFuIEludDE2TEUgdmFsdWUgdG8gdGhlIGN1cnJlbnQgd3JpdGUgcG9zaXRpb24gKG9yIGF0IG9wdGlvbmFsIG9mZnNldCkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgeyBOdW1iZXIgfSBUaGUgdmFsdWUgdG8gd3JpdGUuXG4gICAgICogQHBhcmFtIG9mZnNldCB7IE51bWJlciB9IFRoZSBvZmZzZXQgdG8gd3JpdGUgdGhlIHZhbHVlIGF0LlxuICAgICAqXG4gICAgICogQHJldHVybiB0aGlzXG4gICAgICovXG4gICAgd3JpdGVJbnQxNkxFKHZhbHVlLCBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dyaXRlTnVtYmVyVmFsdWUoQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUsIDIsIHZhbHVlLCBvZmZzZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnNlcnRzIGFuIEludDE2TEUgdmFsdWUgYXQgdGhlIGdpdmVuIG9mZnNldCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSB7IE51bWJlciB9IFRoZSB2YWx1ZSB0byBpbnNlcnQuXG4gICAgICogQHBhcmFtIG9mZnNldCB7IE51bWJlciB9IFRoZSBvZmZzZXQgdG8gaW5zZXJ0IHRoZSB2YWx1ZSBhdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gdGhpc1xuICAgICAqL1xuICAgIGluc2VydEludDE2TEUodmFsdWUsIG9mZnNldCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW5zZXJ0TnVtYmVyVmFsdWUoQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUsIDIsIHZhbHVlLCBvZmZzZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZXMgYW4gSW50MzJCRSB2YWx1ZSB0byB0aGUgY3VycmVudCB3cml0ZSBwb3NpdGlvbiAob3IgYXQgb3B0aW9uYWwgb2Zmc2V0KS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSB7IE51bWJlciB9IFRoZSB2YWx1ZSB0byB3cml0ZS5cbiAgICAgKiBAcGFyYW0gb2Zmc2V0IHsgTnVtYmVyIH0gVGhlIG9mZnNldCB0byB3cml0ZSB0aGUgdmFsdWUgYXQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHRoaXNcbiAgICAgKi9cbiAgICB3cml0ZUludDMyQkUodmFsdWUsIG9mZnNldCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd3JpdGVOdW1iZXJWYWx1ZShCdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSwgNCwgdmFsdWUsIG9mZnNldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluc2VydHMgYW4gSW50MzJCRSB2YWx1ZSBhdCB0aGUgZ2l2ZW4gb2Zmc2V0IHZhbHVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIHsgTnVtYmVyIH0gVGhlIHZhbHVlIHRvIGluc2VydC5cbiAgICAgKiBAcGFyYW0gb2Zmc2V0IHsgTnVtYmVyIH0gVGhlIG9mZnNldCB0byBpbnNlcnQgdGhlIHZhbHVlIGF0LlxuICAgICAqXG4gICAgICogQHJldHVybiB0aGlzXG4gICAgICovXG4gICAgaW5zZXJ0SW50MzJCRSh2YWx1ZSwgb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnNlcnROdW1iZXJWYWx1ZShCdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSwgNCwgdmFsdWUsIG9mZnNldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlcyBhbiBJbnQzMkxFIHZhbHVlIHRvIHRoZSBjdXJyZW50IHdyaXRlIHBvc2l0aW9uIChvciBhdCBvcHRpb25hbCBvZmZzZXQpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIHsgTnVtYmVyIH0gVGhlIHZhbHVlIHRvIHdyaXRlLlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IHRvIHdyaXRlIHRoZSB2YWx1ZSBhdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gdGhpc1xuICAgICAqL1xuICAgIHdyaXRlSW50MzJMRSh2YWx1ZSwgb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93cml0ZU51bWJlclZhbHVlKEJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFLCA0LCB2YWx1ZSwgb2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5zZXJ0cyBhbiBJbnQzMkxFIHZhbHVlIGF0IHRoZSBnaXZlbiBvZmZzZXQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgeyBOdW1iZXIgfSBUaGUgdmFsdWUgdG8gaW5zZXJ0LlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IHRvIGluc2VydCB0aGUgdmFsdWUgYXQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHRoaXNcbiAgICAgKi9cbiAgICBpbnNlcnRJbnQzMkxFKHZhbHVlLCBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luc2VydE51bWJlclZhbHVlKEJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFLCA0LCB2YWx1ZSwgb2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGVzIGEgQmlnSW50NjRCRSB2YWx1ZSB0byB0aGUgY3VycmVudCB3cml0ZSBwb3NpdGlvbiAob3IgYXQgb3B0aW9uYWwgb2Zmc2V0KS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSB7IEJpZ0ludCB9IFRoZSB2YWx1ZSB0byB3cml0ZS5cbiAgICAgKiBAcGFyYW0gb2Zmc2V0IHsgTnVtYmVyIH0gVGhlIG9mZnNldCB0byB3cml0ZSB0aGUgdmFsdWUgYXQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHRoaXNcbiAgICAgKi9cbiAgICB3cml0ZUJpZ0ludDY0QkUodmFsdWUsIG9mZnNldCkge1xuICAgICAgICB1dGlsc18xLmJpZ0ludEFuZEJ1ZmZlckludDY0Q2hlY2soJ3dyaXRlQmlnSW50NjRCRScpO1xuICAgICAgICByZXR1cm4gdGhpcy5fd3JpdGVOdW1iZXJWYWx1ZShCdWZmZXIucHJvdG90eXBlLndyaXRlQmlnSW50NjRCRSwgOCwgdmFsdWUsIG9mZnNldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluc2VydHMgYSBCaWdJbnQ2NEJFIHZhbHVlIGF0IHRoZSBnaXZlbiBvZmZzZXQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgeyBCaWdJbnQgfSBUaGUgdmFsdWUgdG8gaW5zZXJ0LlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IHRvIGluc2VydCB0aGUgdmFsdWUgYXQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHRoaXNcbiAgICAgKi9cbiAgICBpbnNlcnRCaWdJbnQ2NEJFKHZhbHVlLCBvZmZzZXQpIHtcbiAgICAgICAgdXRpbHNfMS5iaWdJbnRBbmRCdWZmZXJJbnQ2NENoZWNrKCd3cml0ZUJpZ0ludDY0QkUnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luc2VydE51bWJlclZhbHVlKEJ1ZmZlci5wcm90b3R5cGUud3JpdGVCaWdJbnQ2NEJFLCA4LCB2YWx1ZSwgb2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGVzIGEgQmlnSW50NjRMRSB2YWx1ZSB0byB0aGUgY3VycmVudCB3cml0ZSBwb3NpdGlvbiAob3IgYXQgb3B0aW9uYWwgb2Zmc2V0KS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSB7IEJpZ0ludCB9IFRoZSB2YWx1ZSB0byB3cml0ZS5cbiAgICAgKiBAcGFyYW0gb2Zmc2V0IHsgTnVtYmVyIH0gVGhlIG9mZnNldCB0byB3cml0ZSB0aGUgdmFsdWUgYXQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHRoaXNcbiAgICAgKi9cbiAgICB3cml0ZUJpZ0ludDY0TEUodmFsdWUsIG9mZnNldCkge1xuICAgICAgICB1dGlsc18xLmJpZ0ludEFuZEJ1ZmZlckludDY0Q2hlY2soJ3dyaXRlQmlnSW50NjRMRScpO1xuICAgICAgICByZXR1cm4gdGhpcy5fd3JpdGVOdW1iZXJWYWx1ZShCdWZmZXIucHJvdG90eXBlLndyaXRlQmlnSW50NjRMRSwgOCwgdmFsdWUsIG9mZnNldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluc2VydHMgYSBJbnQ2NExFIHZhbHVlIGF0IHRoZSBnaXZlbiBvZmZzZXQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgeyBCaWdJbnQgfSBUaGUgdmFsdWUgdG8gaW5zZXJ0LlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IHRvIGluc2VydCB0aGUgdmFsdWUgYXQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHRoaXNcbiAgICAgKi9cbiAgICBpbnNlcnRCaWdJbnQ2NExFKHZhbHVlLCBvZmZzZXQpIHtcbiAgICAgICAgdXRpbHNfMS5iaWdJbnRBbmRCdWZmZXJJbnQ2NENoZWNrKCd3cml0ZUJpZ0ludDY0TEUnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luc2VydE51bWJlclZhbHVlKEJ1ZmZlci5wcm90b3R5cGUud3JpdGVCaWdJbnQ2NExFLCA4LCB2YWx1ZSwgb2Zmc2V0KTtcbiAgICB9XG4gICAgLy8gVW5zaWduZWQgSW50ZWdlcnNcbiAgICAvKipcbiAgICAgKiBSZWFkcyBhbiBVSW50OCB2YWx1ZSBmcm9tIHRoZSBjdXJyZW50IHJlYWQgcG9zaXRpb24gb3IgYW4gb3B0aW9uYWxseSBwcm92aWRlZCBvZmZzZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb2Zmc2V0IHsgTnVtYmVyIH0gVGhlIG9mZnNldCB0byByZWFkIGRhdGEgZnJvbSAob3B0aW9uYWwpXG4gICAgICogQHJldHVybiB7IE51bWJlciB9XG4gICAgICovXG4gICAgcmVhZFVJbnQ4KG9mZnNldCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVhZE51bWJlclZhbHVlKEJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4LCAxLCBvZmZzZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkcyBhbiBVSW50MTZCRSB2YWx1ZSBmcm9tIHRoZSBjdXJyZW50IHJlYWQgcG9zaXRpb24gb3IgYW4gb3B0aW9uYWxseSBwcm92aWRlZCBvZmZzZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb2Zmc2V0IHsgTnVtYmVyIH0gVGhlIG9mZnNldCB0byByZWFkIGRhdGEgZnJvbSAob3B0aW9uYWwpXG4gICAgICogQHJldHVybiB7IE51bWJlciB9XG4gICAgICovXG4gICAgcmVhZFVJbnQxNkJFKG9mZnNldCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVhZE51bWJlclZhbHVlKEJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFLCAyLCBvZmZzZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkcyBhbiBVSW50MTZMRSB2YWx1ZSBmcm9tIHRoZSBjdXJyZW50IHJlYWQgcG9zaXRpb24gb3IgYW4gb3B0aW9uYWxseSBwcm92aWRlZCBvZmZzZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb2Zmc2V0IHsgTnVtYmVyIH0gVGhlIG9mZnNldCB0byByZWFkIGRhdGEgZnJvbSAob3B0aW9uYWwpXG4gICAgICogQHJldHVybiB7IE51bWJlciB9XG4gICAgICovXG4gICAgcmVhZFVJbnQxNkxFKG9mZnNldCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVhZE51bWJlclZhbHVlKEJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFLCAyLCBvZmZzZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkcyBhbiBVSW50MzJCRSB2YWx1ZSBmcm9tIHRoZSBjdXJyZW50IHJlYWQgcG9zaXRpb24gb3IgYW4gb3B0aW9uYWxseSBwcm92aWRlZCBvZmZzZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb2Zmc2V0IHsgTnVtYmVyIH0gVGhlIG9mZnNldCB0byByZWFkIGRhdGEgZnJvbSAob3B0aW9uYWwpXG4gICAgICogQHJldHVybiB7IE51bWJlciB9XG4gICAgICovXG4gICAgcmVhZFVJbnQzMkJFKG9mZnNldCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVhZE51bWJlclZhbHVlKEJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFLCA0LCBvZmZzZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkcyBhbiBVSW50MzJMRSB2YWx1ZSBmcm9tIHRoZSBjdXJyZW50IHJlYWQgcG9zaXRpb24gb3IgYW4gb3B0aW9uYWxseSBwcm92aWRlZCBvZmZzZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb2Zmc2V0IHsgTnVtYmVyIH0gVGhlIG9mZnNldCB0byByZWFkIGRhdGEgZnJvbSAob3B0aW9uYWwpXG4gICAgICogQHJldHVybiB7IE51bWJlciB9XG4gICAgICovXG4gICAgcmVhZFVJbnQzMkxFKG9mZnNldCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVhZE51bWJlclZhbHVlKEJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFLCA0LCBvZmZzZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkcyBhIEJpZ1VJbnQ2NEJFIHZhbHVlIGZyb20gdGhlIGN1cnJlbnQgcmVhZCBwb3NpdGlvbiBvciBhbiBvcHRpb25hbGx5IHByb3ZpZGVkIG9mZnNldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IHRvIHJlYWQgZGF0YSBmcm9tIChvcHRpb25hbClcbiAgICAgKiBAcmV0dXJuIHsgQmlnSW50IH1cbiAgICAgKi9cbiAgICByZWFkQmlnVUludDY0QkUob2Zmc2V0KSB7XG4gICAgICAgIHV0aWxzXzEuYmlnSW50QW5kQnVmZmVySW50NjRDaGVjaygncmVhZEJpZ1VJbnQ2NEJFJyk7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWFkTnVtYmVyVmFsdWUoQnVmZmVyLnByb3RvdHlwZS5yZWFkQmlnVUludDY0QkUsIDgsIG9mZnNldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWRzIGEgQmlnVUludDY0TEUgdmFsdWUgZnJvbSB0aGUgY3VycmVudCByZWFkIHBvc2l0aW9uIG9yIGFuIG9wdGlvbmFsbHkgcHJvdmlkZWQgb2Zmc2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIG9mZnNldCB7IE51bWJlciB9IFRoZSBvZmZzZXQgdG8gcmVhZCBkYXRhIGZyb20gKG9wdGlvbmFsKVxuICAgICAqIEByZXR1cm4geyBCaWdJbnQgfVxuICAgICAqL1xuICAgIHJlYWRCaWdVSW50NjRMRShvZmZzZXQpIHtcbiAgICAgICAgdXRpbHNfMS5iaWdJbnRBbmRCdWZmZXJJbnQ2NENoZWNrKCdyZWFkQmlnVUludDY0TEUnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWROdW1iZXJWYWx1ZShCdWZmZXIucHJvdG90eXBlLnJlYWRCaWdVSW50NjRMRSwgOCwgb2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGVzIGFuIFVJbnQ4IHZhbHVlIHRvIHRoZSBjdXJyZW50IHdyaXRlIHBvc2l0aW9uIChvciBhdCBvcHRpb25hbCBvZmZzZXQpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIHsgTnVtYmVyIH0gVGhlIHZhbHVlIHRvIHdyaXRlLlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IHRvIHdyaXRlIHRoZSB2YWx1ZSBhdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gdGhpc1xuICAgICAqL1xuICAgIHdyaXRlVUludDgodmFsdWUsIG9mZnNldCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd3JpdGVOdW1iZXJWYWx1ZShCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDgsIDEsIHZhbHVlLCBvZmZzZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnNlcnRzIGFuIFVJbnQ4IHZhbHVlIGF0IHRoZSBnaXZlbiBvZmZzZXQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgeyBOdW1iZXIgfSBUaGUgdmFsdWUgdG8gaW5zZXJ0LlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IHRvIGluc2VydCB0aGUgdmFsdWUgYXQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHRoaXNcbiAgICAgKi9cbiAgICBpbnNlcnRVSW50OCh2YWx1ZSwgb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnNlcnROdW1iZXJWYWx1ZShCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDgsIDEsIHZhbHVlLCBvZmZzZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZXMgYW4gVUludDE2QkUgdmFsdWUgdG8gdGhlIGN1cnJlbnQgd3JpdGUgcG9zaXRpb24gKG9yIGF0IG9wdGlvbmFsIG9mZnNldCkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgeyBOdW1iZXIgfSBUaGUgdmFsdWUgdG8gd3JpdGUuXG4gICAgICogQHBhcmFtIG9mZnNldCB7IE51bWJlciB9IFRoZSBvZmZzZXQgdG8gd3JpdGUgdGhlIHZhbHVlIGF0LlxuICAgICAqXG4gICAgICogQHJldHVybiB0aGlzXG4gICAgICovXG4gICAgd3JpdGVVSW50MTZCRSh2YWx1ZSwgb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93cml0ZU51bWJlclZhbHVlKEJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSwgMiwgdmFsdWUsIG9mZnNldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluc2VydHMgYW4gVUludDE2QkUgdmFsdWUgYXQgdGhlIGdpdmVuIG9mZnNldCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSB7IE51bWJlciB9IFRoZSB2YWx1ZSB0byBpbnNlcnQuXG4gICAgICogQHBhcmFtIG9mZnNldCB7IE51bWJlciB9IFRoZSBvZmZzZXQgdG8gaW5zZXJ0IHRoZSB2YWx1ZSBhdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gdGhpc1xuICAgICAqL1xuICAgIGluc2VydFVJbnQxNkJFKHZhbHVlLCBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luc2VydE51bWJlclZhbHVlKEJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSwgMiwgdmFsdWUsIG9mZnNldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlcyBhbiBVSW50MTZMRSB2YWx1ZSB0byB0aGUgY3VycmVudCB3cml0ZSBwb3NpdGlvbiAob3IgYXQgb3B0aW9uYWwgb2Zmc2V0KS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSB7IE51bWJlciB9IFRoZSB2YWx1ZSB0byB3cml0ZS5cbiAgICAgKiBAcGFyYW0gb2Zmc2V0IHsgTnVtYmVyIH0gVGhlIG9mZnNldCB0byB3cml0ZSB0aGUgdmFsdWUgYXQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHRoaXNcbiAgICAgKi9cbiAgICB3cml0ZVVJbnQxNkxFKHZhbHVlLCBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dyaXRlTnVtYmVyVmFsdWUoQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFLCAyLCB2YWx1ZSwgb2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5zZXJ0cyBhbiBVSW50MTZMRSB2YWx1ZSBhdCB0aGUgZ2l2ZW4gb2Zmc2V0IHZhbHVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIHsgTnVtYmVyIH0gVGhlIHZhbHVlIHRvIGluc2VydC5cbiAgICAgKiBAcGFyYW0gb2Zmc2V0IHsgTnVtYmVyIH0gVGhlIG9mZnNldCB0byBpbnNlcnQgdGhlIHZhbHVlIGF0LlxuICAgICAqXG4gICAgICogQHJldHVybiB0aGlzXG4gICAgICovXG4gICAgaW5zZXJ0VUludDE2TEUodmFsdWUsIG9mZnNldCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW5zZXJ0TnVtYmVyVmFsdWUoQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFLCAyLCB2YWx1ZSwgb2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGVzIGFuIFVJbnQzMkJFIHZhbHVlIHRvIHRoZSBjdXJyZW50IHdyaXRlIHBvc2l0aW9uIChvciBhdCBvcHRpb25hbCBvZmZzZXQpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIHsgTnVtYmVyIH0gVGhlIHZhbHVlIHRvIHdyaXRlLlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IHRvIHdyaXRlIHRoZSB2YWx1ZSBhdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gdGhpc1xuICAgICAqL1xuICAgIHdyaXRlVUludDMyQkUodmFsdWUsIG9mZnNldCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd3JpdGVOdW1iZXJWYWx1ZShCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUsIDQsIHZhbHVlLCBvZmZzZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnNlcnRzIGFuIFVJbnQzMkJFIHZhbHVlIGF0IHRoZSBnaXZlbiBvZmZzZXQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgeyBOdW1iZXIgfSBUaGUgdmFsdWUgdG8gaW5zZXJ0LlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IHRvIGluc2VydCB0aGUgdmFsdWUgYXQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHRoaXNcbiAgICAgKi9cbiAgICBpbnNlcnRVSW50MzJCRSh2YWx1ZSwgb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnNlcnROdW1iZXJWYWx1ZShCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUsIDQsIHZhbHVlLCBvZmZzZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZXMgYW4gVUludDMyTEUgdmFsdWUgdG8gdGhlIGN1cnJlbnQgd3JpdGUgcG9zaXRpb24gKG9yIGF0IG9wdGlvbmFsIG9mZnNldCkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgeyBOdW1iZXIgfSBUaGUgdmFsdWUgdG8gd3JpdGUuXG4gICAgICogQHBhcmFtIG9mZnNldCB7IE51bWJlciB9IFRoZSBvZmZzZXQgdG8gd3JpdGUgdGhlIHZhbHVlIGF0LlxuICAgICAqXG4gICAgICogQHJldHVybiB0aGlzXG4gICAgICovXG4gICAgd3JpdGVVSW50MzJMRSh2YWx1ZSwgb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93cml0ZU51bWJlclZhbHVlKEJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSwgNCwgdmFsdWUsIG9mZnNldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluc2VydHMgYW4gVUludDMyTEUgdmFsdWUgYXQgdGhlIGdpdmVuIG9mZnNldCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSB7IE51bWJlciB9IFRoZSB2YWx1ZSB0byBpbnNlcnQuXG4gICAgICogQHBhcmFtIG9mZnNldCB7IE51bWJlciB9IFRoZSBvZmZzZXQgdG8gaW5zZXJ0IHRoZSB2YWx1ZSBhdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gdGhpc1xuICAgICAqL1xuICAgIGluc2VydFVJbnQzMkxFKHZhbHVlLCBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luc2VydE51bWJlclZhbHVlKEJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSwgNCwgdmFsdWUsIG9mZnNldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlcyBhIEJpZ1VJbnQ2NEJFIHZhbHVlIHRvIHRoZSBjdXJyZW50IHdyaXRlIHBvc2l0aW9uIChvciBhdCBvcHRpb25hbCBvZmZzZXQpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIHsgTnVtYmVyIH0gVGhlIHZhbHVlIHRvIHdyaXRlLlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IHRvIHdyaXRlIHRoZSB2YWx1ZSBhdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gdGhpc1xuICAgICAqL1xuICAgIHdyaXRlQmlnVUludDY0QkUodmFsdWUsIG9mZnNldCkge1xuICAgICAgICB1dGlsc18xLmJpZ0ludEFuZEJ1ZmZlckludDY0Q2hlY2soJ3dyaXRlQmlnVUludDY0QkUnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dyaXRlTnVtYmVyVmFsdWUoQnVmZmVyLnByb3RvdHlwZS53cml0ZUJpZ1VJbnQ2NEJFLCA4LCB2YWx1ZSwgb2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5zZXJ0cyBhIEJpZ1VJbnQ2NEJFIHZhbHVlIGF0IHRoZSBnaXZlbiBvZmZzZXQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgeyBOdW1iZXIgfSBUaGUgdmFsdWUgdG8gaW5zZXJ0LlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IHRvIGluc2VydCB0aGUgdmFsdWUgYXQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHRoaXNcbiAgICAgKi9cbiAgICBpbnNlcnRCaWdVSW50NjRCRSh2YWx1ZSwgb2Zmc2V0KSB7XG4gICAgICAgIHV0aWxzXzEuYmlnSW50QW5kQnVmZmVySW50NjRDaGVjaygnd3JpdGVCaWdVSW50NjRCRScpO1xuICAgICAgICByZXR1cm4gdGhpcy5faW5zZXJ0TnVtYmVyVmFsdWUoQnVmZmVyLnByb3RvdHlwZS53cml0ZUJpZ1VJbnQ2NEJFLCA4LCB2YWx1ZSwgb2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGVzIGEgQmlnVUludDY0TEUgdmFsdWUgdG8gdGhlIGN1cnJlbnQgd3JpdGUgcG9zaXRpb24gKG9yIGF0IG9wdGlvbmFsIG9mZnNldCkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgeyBOdW1iZXIgfSBUaGUgdmFsdWUgdG8gd3JpdGUuXG4gICAgICogQHBhcmFtIG9mZnNldCB7IE51bWJlciB9IFRoZSBvZmZzZXQgdG8gd3JpdGUgdGhlIHZhbHVlIGF0LlxuICAgICAqXG4gICAgICogQHJldHVybiB0aGlzXG4gICAgICovXG4gICAgd3JpdGVCaWdVSW50NjRMRSh2YWx1ZSwgb2Zmc2V0KSB7XG4gICAgICAgIHV0aWxzXzEuYmlnSW50QW5kQnVmZmVySW50NjRDaGVjaygnd3JpdGVCaWdVSW50NjRMRScpO1xuICAgICAgICByZXR1cm4gdGhpcy5fd3JpdGVOdW1iZXJWYWx1ZShCdWZmZXIucHJvdG90eXBlLndyaXRlQmlnVUludDY0TEUsIDgsIHZhbHVlLCBvZmZzZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnNlcnRzIGEgQmlnVUludDY0TEUgdmFsdWUgYXQgdGhlIGdpdmVuIG9mZnNldCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSB7IE51bWJlciB9IFRoZSB2YWx1ZSB0byBpbnNlcnQuXG4gICAgICogQHBhcmFtIG9mZnNldCB7IE51bWJlciB9IFRoZSBvZmZzZXQgdG8gaW5zZXJ0IHRoZSB2YWx1ZSBhdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gdGhpc1xuICAgICAqL1xuICAgIGluc2VydEJpZ1VJbnQ2NExFKHZhbHVlLCBvZmZzZXQpIHtcbiAgICAgICAgdXRpbHNfMS5iaWdJbnRBbmRCdWZmZXJJbnQ2NENoZWNrKCd3cml0ZUJpZ1VJbnQ2NExFJyk7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnNlcnROdW1iZXJWYWx1ZShCdWZmZXIucHJvdG90eXBlLndyaXRlQmlnVUludDY0TEUsIDgsIHZhbHVlLCBvZmZzZXQpO1xuICAgIH1cbiAgICAvLyBGbG9hdGluZyBQb2ludFxuICAgIC8qKlxuICAgICAqIFJlYWRzIGFuIEZsb2F0QkUgdmFsdWUgZnJvbSB0aGUgY3VycmVudCByZWFkIHBvc2l0aW9uIG9yIGFuIG9wdGlvbmFsbHkgcHJvdmlkZWQgb2Zmc2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIG9mZnNldCB7IE51bWJlciB9IFRoZSBvZmZzZXQgdG8gcmVhZCBkYXRhIGZyb20gKG9wdGlvbmFsKVxuICAgICAqIEByZXR1cm4geyBOdW1iZXIgfVxuICAgICAqL1xuICAgIHJlYWRGbG9hdEJFKG9mZnNldCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVhZE51bWJlclZhbHVlKEJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUsIDQsIG9mZnNldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWRzIGFuIEZsb2F0TEUgdmFsdWUgZnJvbSB0aGUgY3VycmVudCByZWFkIHBvc2l0aW9uIG9yIGFuIG9wdGlvbmFsbHkgcHJvdmlkZWQgb2Zmc2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIG9mZnNldCB7IE51bWJlciB9IFRoZSBvZmZzZXQgdG8gcmVhZCBkYXRhIGZyb20gKG9wdGlvbmFsKVxuICAgICAqIEByZXR1cm4geyBOdW1iZXIgfVxuICAgICAqL1xuICAgIHJlYWRGbG9hdExFKG9mZnNldCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVhZE51bWJlclZhbHVlKEJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUsIDQsIG9mZnNldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlcyBhIEZsb2F0QkUgdmFsdWUgdG8gdGhlIGN1cnJlbnQgd3JpdGUgcG9zaXRpb24gKG9yIGF0IG9wdGlvbmFsIG9mZnNldCkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgeyBOdW1iZXIgfSBUaGUgdmFsdWUgdG8gd3JpdGUuXG4gICAgICogQHBhcmFtIG9mZnNldCB7IE51bWJlciB9IFRoZSBvZmZzZXQgdG8gd3JpdGUgdGhlIHZhbHVlIGF0LlxuICAgICAqXG4gICAgICogQHJldHVybiB0aGlzXG4gICAgICovXG4gICAgd3JpdGVGbG9hdEJFKHZhbHVlLCBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dyaXRlTnVtYmVyVmFsdWUoQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUsIDQsIHZhbHVlLCBvZmZzZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnNlcnRzIGEgRmxvYXRCRSB2YWx1ZSBhdCB0aGUgZ2l2ZW4gb2Zmc2V0IHZhbHVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIHsgTnVtYmVyIH0gVGhlIHZhbHVlIHRvIGluc2VydC5cbiAgICAgKiBAcGFyYW0gb2Zmc2V0IHsgTnVtYmVyIH0gVGhlIG9mZnNldCB0byBpbnNlcnQgdGhlIHZhbHVlIGF0LlxuICAgICAqXG4gICAgICogQHJldHVybiB0aGlzXG4gICAgICovXG4gICAgaW5zZXJ0RmxvYXRCRSh2YWx1ZSwgb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnNlcnROdW1iZXJWYWx1ZShCdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSwgNCwgdmFsdWUsIG9mZnNldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlcyBhIEZsb2F0TEUgdmFsdWUgdG8gdGhlIGN1cnJlbnQgd3JpdGUgcG9zaXRpb24gKG9yIGF0IG9wdGlvbmFsIG9mZnNldCkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgeyBOdW1iZXIgfSBUaGUgdmFsdWUgdG8gd3JpdGUuXG4gICAgICogQHBhcmFtIG9mZnNldCB7IE51bWJlciB9IFRoZSBvZmZzZXQgdG8gd3JpdGUgdGhlIHZhbHVlIGF0LlxuICAgICAqXG4gICAgICogQHJldHVybiB0aGlzXG4gICAgICovXG4gICAgd3JpdGVGbG9hdExFKHZhbHVlLCBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dyaXRlTnVtYmVyVmFsdWUoQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUsIDQsIHZhbHVlLCBvZmZzZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnNlcnRzIGEgRmxvYXRMRSB2YWx1ZSBhdCB0aGUgZ2l2ZW4gb2Zmc2V0IHZhbHVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIHsgTnVtYmVyIH0gVGhlIHZhbHVlIHRvIGluc2VydC5cbiAgICAgKiBAcGFyYW0gb2Zmc2V0IHsgTnVtYmVyIH0gVGhlIG9mZnNldCB0byBpbnNlcnQgdGhlIHZhbHVlIGF0LlxuICAgICAqXG4gICAgICogQHJldHVybiB0aGlzXG4gICAgICovXG4gICAgaW5zZXJ0RmxvYXRMRSh2YWx1ZSwgb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnNlcnROdW1iZXJWYWx1ZShCdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSwgNCwgdmFsdWUsIG9mZnNldCk7XG4gICAgfVxuICAgIC8vIERvdWJsZSBGbG9hdGluZyBQb2ludFxuICAgIC8qKlxuICAgICAqIFJlYWRzIGFuIERvdWJsRUJFIHZhbHVlIGZyb20gdGhlIGN1cnJlbnQgcmVhZCBwb3NpdGlvbiBvciBhbiBvcHRpb25hbGx5IHByb3ZpZGVkIG9mZnNldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IHRvIHJlYWQgZGF0YSBmcm9tIChvcHRpb25hbClcbiAgICAgKiBAcmV0dXJuIHsgTnVtYmVyIH1cbiAgICAgKi9cbiAgICByZWFkRG91YmxlQkUob2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWFkTnVtYmVyVmFsdWUoQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUsIDgsIG9mZnNldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWRzIGFuIERvdWJsZUxFIHZhbHVlIGZyb20gdGhlIGN1cnJlbnQgcmVhZCBwb3NpdGlvbiBvciBhbiBvcHRpb25hbGx5IHByb3ZpZGVkIG9mZnNldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IHRvIHJlYWQgZGF0YSBmcm9tIChvcHRpb25hbClcbiAgICAgKiBAcmV0dXJuIHsgTnVtYmVyIH1cbiAgICAgKi9cbiAgICByZWFkRG91YmxlTEUob2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWFkTnVtYmVyVmFsdWUoQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUsIDgsIG9mZnNldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlcyBhIERvdWJsZUJFIHZhbHVlIHRvIHRoZSBjdXJyZW50IHdyaXRlIHBvc2l0aW9uIChvciBhdCBvcHRpb25hbCBvZmZzZXQpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIHsgTnVtYmVyIH0gVGhlIHZhbHVlIHRvIHdyaXRlLlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IHRvIHdyaXRlIHRoZSB2YWx1ZSBhdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gdGhpc1xuICAgICAqL1xuICAgIHdyaXRlRG91YmxlQkUodmFsdWUsIG9mZnNldCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd3JpdGVOdW1iZXJWYWx1ZShCdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUsIDgsIHZhbHVlLCBvZmZzZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnNlcnRzIGEgRG91YmxlQkUgdmFsdWUgYXQgdGhlIGdpdmVuIG9mZnNldCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSB7IE51bWJlciB9IFRoZSB2YWx1ZSB0byBpbnNlcnQuXG4gICAgICogQHBhcmFtIG9mZnNldCB7IE51bWJlciB9IFRoZSBvZmZzZXQgdG8gaW5zZXJ0IHRoZSB2YWx1ZSBhdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gdGhpc1xuICAgICAqL1xuICAgIGluc2VydERvdWJsZUJFKHZhbHVlLCBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luc2VydE51bWJlclZhbHVlKEJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSwgOCwgdmFsdWUsIG9mZnNldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlcyBhIERvdWJsZUxFIHZhbHVlIHRvIHRoZSBjdXJyZW50IHdyaXRlIHBvc2l0aW9uIChvciBhdCBvcHRpb25hbCBvZmZzZXQpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIHsgTnVtYmVyIH0gVGhlIHZhbHVlIHRvIHdyaXRlLlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IHRvIHdyaXRlIHRoZSB2YWx1ZSBhdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gdGhpc1xuICAgICAqL1xuICAgIHdyaXRlRG91YmxlTEUodmFsdWUsIG9mZnNldCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd3JpdGVOdW1iZXJWYWx1ZShCdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUsIDgsIHZhbHVlLCBvZmZzZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnNlcnRzIGEgRG91YmxlTEUgdmFsdWUgYXQgdGhlIGdpdmVuIG9mZnNldCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSB7IE51bWJlciB9IFRoZSB2YWx1ZSB0byBpbnNlcnQuXG4gICAgICogQHBhcmFtIG9mZnNldCB7IE51bWJlciB9IFRoZSBvZmZzZXQgdG8gaW5zZXJ0IHRoZSB2YWx1ZSBhdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gdGhpc1xuICAgICAqL1xuICAgIGluc2VydERvdWJsZUxFKHZhbHVlLCBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luc2VydE51bWJlclZhbHVlKEJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSwgOCwgdmFsdWUsIG9mZnNldCk7XG4gICAgfVxuICAgIC8vIFN0cmluZ3NcbiAgICAvKipcbiAgICAgKiBSZWFkcyBhIFN0cmluZyBmcm9tIHRoZSBjdXJyZW50IHJlYWQgcG9zaXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYXJnMSB7IE51bWJlciB8IFN0cmluZyB9IFRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gcmVhZCBhcyBhIFN0cmluZywgb3IgdGhlIEJ1ZmZlckVuY29kaW5nIHRvIHVzZSBmb3JcbiAgICAgKiAgICAgICAgICAgICB0aGUgc3RyaW5nIChEZWZhdWx0cyB0byBpbnN0YW5jZSBsZXZlbCBlbmNvZGluZykuXG4gICAgICogQHBhcmFtIGVuY29kaW5nIHsgU3RyaW5nIH0gVGhlIEJ1ZmZlckVuY29kaW5nIHRvIHVzZSBmb3IgdGhlIHN0cmluZyAoRGVmYXVsdHMgdG8gaW5zdGFuY2UgbGV2ZWwgZW5jb2RpbmcpLlxuICAgICAqXG4gICAgICogQHJldHVybiB7IFN0cmluZyB9XG4gICAgICovXG4gICAgcmVhZFN0cmluZyhhcmcxLCBlbmNvZGluZykge1xuICAgICAgICBsZXQgbGVuZ3RoVmFsO1xuICAgICAgICAvLyBMZW5ndGggcHJvdmlkZWRcbiAgICAgICAgaWYgKHR5cGVvZiBhcmcxID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdXRpbHNfMS5jaGVja0xlbmd0aFZhbHVlKGFyZzEpO1xuICAgICAgICAgICAgbGVuZ3RoVmFsID0gTWF0aC5taW4oYXJnMSwgdGhpcy5sZW5ndGggLSB0aGlzLl9yZWFkT2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVuY29kaW5nID0gYXJnMTtcbiAgICAgICAgICAgIGxlbmd0aFZhbCA9IHRoaXMubGVuZ3RoIC0gdGhpcy5fcmVhZE9mZnNldDtcbiAgICAgICAgfVxuICAgICAgICAvLyBDaGVjayBlbmNvZGluZ1xuICAgICAgICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdXRpbHNfMS5jaGVja0VuY29kaW5nKGVuY29kaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuX2J1ZmYuc2xpY2UodGhpcy5fcmVhZE9mZnNldCwgdGhpcy5fcmVhZE9mZnNldCArIGxlbmd0aFZhbCkudG9TdHJpbmcoZW5jb2RpbmcgfHwgdGhpcy5fZW5jb2RpbmcpO1xuICAgICAgICB0aGlzLl9yZWFkT2Zmc2V0ICs9IGxlbmd0aFZhbDtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnNlcnRzIGEgU3RyaW5nXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgeyBTdHJpbmcgfSBUaGUgU3RyaW5nIHZhbHVlIHRvIGluc2VydC5cbiAgICAgKiBAcGFyYW0gb2Zmc2V0IHsgTnVtYmVyIH0gVGhlIG9mZnNldCB0byBpbnNlcnQgdGhlIHN0cmluZyBhdC5cbiAgICAgKiBAcGFyYW0gZW5jb2RpbmcgeyBTdHJpbmcgfSBUaGUgQnVmZmVyRW5jb2RpbmcgdG8gdXNlIGZvciB3cml0aW5nIHN0cmluZ3MgKGRlZmF1bHRzIHRvIGluc3RhbmNlIGVuY29kaW5nKS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gdGhpc1xuICAgICAqL1xuICAgIGluc2VydFN0cmluZyh2YWx1ZSwgb2Zmc2V0LCBlbmNvZGluZykge1xuICAgICAgICB1dGlsc18xLmNoZWNrT2Zmc2V0VmFsdWUob2Zmc2V0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hhbmRsZVN0cmluZyh2YWx1ZSwgdHJ1ZSwgb2Zmc2V0LCBlbmNvZGluZyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlcyBhIFN0cmluZ1xuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIHsgU3RyaW5nIH0gVGhlIFN0cmluZyB2YWx1ZSB0byB3cml0ZS5cbiAgICAgKiBAcGFyYW0gYXJnMiB7IE51bWJlciB8IFN0cmluZyB9IFRoZSBvZmZzZXQgdG8gd3JpdGUgdGhlIHN0cmluZyBhdCwgb3IgdGhlIEJ1ZmZlckVuY29kaW5nIHRvIHVzZS5cbiAgICAgKiBAcGFyYW0gZW5jb2RpbmcgeyBTdHJpbmcgfSBUaGUgQnVmZmVyRW5jb2RpbmcgdG8gdXNlIGZvciB3cml0aW5nIHN0cmluZ3MgKGRlZmF1bHRzIHRvIGluc3RhbmNlIGVuY29kaW5nKS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gdGhpc1xuICAgICAqL1xuICAgIHdyaXRlU3RyaW5nKHZhbHVlLCBhcmcyLCBlbmNvZGluZykge1xuICAgICAgICByZXR1cm4gdGhpcy5faGFuZGxlU3RyaW5nKHZhbHVlLCBmYWxzZSwgYXJnMiwgZW5jb2RpbmcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkcyBhIG51bGwtdGVybWluYXRlZCBTdHJpbmcgZnJvbSB0aGUgY3VycmVudCByZWFkIHBvc2l0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIGVuY29kaW5nIHsgU3RyaW5nIH0gVGhlIEJ1ZmZlckVuY29kaW5nIHRvIHVzZSBmb3IgdGhlIHN0cmluZyAoRGVmYXVsdHMgdG8gaW5zdGFuY2UgbGV2ZWwgZW5jb2RpbmcpLlxuICAgICAqXG4gICAgICogQHJldHVybiB7IFN0cmluZyB9XG4gICAgICovXG4gICAgcmVhZFN0cmluZ05UKGVuY29kaW5nKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB1dGlsc18xLmNoZWNrRW5jb2RpbmcoZW5jb2RpbmcpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNldCBudWxsIGNoYXJhY3RlciBwb3NpdGlvbiB0byB0aGUgZW5kIFNtYXJ0QnVmZmVyIGluc3RhbmNlLlxuICAgICAgICBsZXQgbnVsbFBvcyA9IHRoaXMubGVuZ3RoO1xuICAgICAgICAvLyBGaW5kIG5leHQgbnVsbCBjaGFyYWN0ZXIgKGlmIG9uZSBpcyBub3QgZm91bmQsIGRlZmF1bHQgZnJvbSBhYm92ZSBpcyB1c2VkKVxuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5fcmVhZE9mZnNldDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9idWZmW2ldID09PSAweDAwKSB7XG4gICAgICAgICAgICAgICAgbnVsbFBvcyA9IGk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVhZCBzdHJpbmcgdmFsdWVcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLl9idWZmLnNsaWNlKHRoaXMuX3JlYWRPZmZzZXQsIG51bGxQb3MpO1xuICAgICAgICAvLyBJbmNyZW1lbnQgaW50ZXJuYWwgQnVmZmVyIHJlYWQgb2Zmc2V0XG4gICAgICAgIHRoaXMuX3JlYWRPZmZzZXQgPSBudWxsUG9zICsgMTtcbiAgICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKGVuY29kaW5nIHx8IHRoaXMuX2VuY29kaW5nKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5zZXJ0cyBhIG51bGwtdGVybWluYXRlZCBTdHJpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgeyBTdHJpbmcgfSBUaGUgU3RyaW5nIHZhbHVlIHRvIHdyaXRlLlxuICAgICAqIEBwYXJhbSBhcmcyIHsgTnVtYmVyIHwgU3RyaW5nIH0gVGhlIG9mZnNldCB0byB3cml0ZSB0aGUgc3RyaW5nIHRvLCBvciB0aGUgQnVmZmVyRW5jb2RpbmcgdG8gdXNlLlxuICAgICAqIEBwYXJhbSBlbmNvZGluZyB7IFN0cmluZyB9IFRoZSBCdWZmZXJFbmNvZGluZyB0byB1c2UgZm9yIHdyaXRpbmcgc3RyaW5ncyAoZGVmYXVsdHMgdG8gaW5zdGFuY2UgZW5jb2RpbmcpLlxuICAgICAqXG4gICAgICogQHJldHVybiB0aGlzXG4gICAgICovXG4gICAgaW5zZXJ0U3RyaW5nTlQodmFsdWUsIG9mZnNldCwgZW5jb2RpbmcpIHtcbiAgICAgICAgdXRpbHNfMS5jaGVja09mZnNldFZhbHVlKG9mZnNldCk7XG4gICAgICAgIC8vIFdyaXRlIFZhbHVlc1xuICAgICAgICB0aGlzLmluc2VydFN0cmluZyh2YWx1ZSwgb2Zmc2V0LCBlbmNvZGluZyk7XG4gICAgICAgIHRoaXMuaW5zZXJ0VUludDgoMHgwMCwgb2Zmc2V0ICsgdmFsdWUubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlcyBhIG51bGwtdGVybWluYXRlZCBTdHJpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgeyBTdHJpbmcgfSBUaGUgU3RyaW5nIHZhbHVlIHRvIHdyaXRlLlxuICAgICAqIEBwYXJhbSBhcmcyIHsgTnVtYmVyIHwgU3RyaW5nIH0gVGhlIG9mZnNldCB0byB3cml0ZSB0aGUgc3RyaW5nIHRvLCBvciB0aGUgQnVmZmVyRW5jb2RpbmcgdG8gdXNlLlxuICAgICAqIEBwYXJhbSBlbmNvZGluZyB7IFN0cmluZyB9IFRoZSBCdWZmZXJFbmNvZGluZyB0byB1c2UgZm9yIHdyaXRpbmcgc3RyaW5ncyAoZGVmYXVsdHMgdG8gaW5zdGFuY2UgZW5jb2RpbmcpLlxuICAgICAqXG4gICAgICogQHJldHVybiB0aGlzXG4gICAgICovXG4gICAgd3JpdGVTdHJpbmdOVCh2YWx1ZSwgYXJnMiwgZW5jb2RpbmcpIHtcbiAgICAgICAgLy8gV3JpdGUgVmFsdWVzXG4gICAgICAgIHRoaXMud3JpdGVTdHJpbmcodmFsdWUsIGFyZzIsIGVuY29kaW5nKTtcbiAgICAgICAgdGhpcy53cml0ZVVJbnQ4KDB4MDAsIHR5cGVvZiBhcmcyID09PSAnbnVtYmVyJyA/IGFyZzIgKyB2YWx1ZS5sZW5ndGggOiB0aGlzLndyaXRlT2Zmc2V0KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vIEJ1ZmZlcnNcbiAgICAvKipcbiAgICAgKiBSZWFkcyBhIEJ1ZmZlciBmcm9tIHRoZSBpbnRlcm5hbCByZWFkIHBvc2l0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIGxlbmd0aCB7IE51bWJlciB9IFRoZSBsZW5ndGggb2YgZGF0YSB0byByZWFkIGFzIGEgQnVmZmVyLlxuICAgICAqXG4gICAgICogQHJldHVybiB7IEJ1ZmZlciB9XG4gICAgICovXG4gICAgcmVhZEJ1ZmZlcihsZW5ndGgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBsZW5ndGggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB1dGlsc18xLmNoZWNrTGVuZ3RoVmFsdWUobGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsZW5ndGhWYWwgPSB0eXBlb2YgbGVuZ3RoID09PSAnbnVtYmVyJyA/IGxlbmd0aCA6IHRoaXMubGVuZ3RoO1xuICAgICAgICBjb25zdCBlbmRQb2ludCA9IE1hdGgubWluKHRoaXMubGVuZ3RoLCB0aGlzLl9yZWFkT2Zmc2V0ICsgbGVuZ3RoVmFsKTtcbiAgICAgICAgLy8gUmVhZCBidWZmZXIgdmFsdWVcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLl9idWZmLnNsaWNlKHRoaXMuX3JlYWRPZmZzZXQsIGVuZFBvaW50KTtcbiAgICAgICAgLy8gSW5jcmVtZW50IGludGVybmFsIEJ1ZmZlciByZWFkIG9mZnNldFxuICAgICAgICB0aGlzLl9yZWFkT2Zmc2V0ID0gZW5kUG9pbnQ7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGVzIGEgQnVmZmVyIHRvIHRoZSBjdXJyZW50IHdyaXRlIHBvc2l0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIHsgQnVmZmVyIH0gVGhlIEJ1ZmZlciB0byB3cml0ZS5cbiAgICAgKiBAcGFyYW0gb2Zmc2V0IHsgTnVtYmVyIH0gVGhlIG9mZnNldCB0byB3cml0ZSB0aGUgQnVmZmVyIHRvLlxuICAgICAqXG4gICAgICogQHJldHVybiB0aGlzXG4gICAgICovXG4gICAgaW5zZXJ0QnVmZmVyKHZhbHVlLCBvZmZzZXQpIHtcbiAgICAgICAgdXRpbHNfMS5jaGVja09mZnNldFZhbHVlKG9mZnNldCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9oYW5kbGVCdWZmZXIodmFsdWUsIHRydWUsIG9mZnNldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlcyBhIEJ1ZmZlciB0byB0aGUgY3VycmVudCB3cml0ZSBwb3NpdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSB7IEJ1ZmZlciB9IFRoZSBCdWZmZXIgdG8gd3JpdGUuXG4gICAgICogQHBhcmFtIG9mZnNldCB7IE51bWJlciB9IFRoZSBvZmZzZXQgdG8gd3JpdGUgdGhlIEJ1ZmZlciB0by5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gdGhpc1xuICAgICAqL1xuICAgIHdyaXRlQnVmZmVyKHZhbHVlLCBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hhbmRsZUJ1ZmZlcih2YWx1ZSwgZmFsc2UsIG9mZnNldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWRzIGEgbnVsbC10ZXJtaW5hdGVkIEJ1ZmZlciBmcm9tIHRoZSBjdXJyZW50IHJlYWQgcG9pc2l0b24uXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHsgQnVmZmVyIH1cbiAgICAgKi9cbiAgICByZWFkQnVmZmVyTlQoKSB7XG4gICAgICAgIC8vIFNldCBudWxsIGNoYXJhY3RlciBwb3NpdGlvbiB0byB0aGUgZW5kIFNtYXJ0QnVmZmVyIGluc3RhbmNlLlxuICAgICAgICBsZXQgbnVsbFBvcyA9IHRoaXMubGVuZ3RoO1xuICAgICAgICAvLyBGaW5kIG5leHQgbnVsbCBjaGFyYWN0ZXIgKGlmIG9uZSBpcyBub3QgZm91bmQsIGRlZmF1bHQgZnJvbSBhYm92ZSBpcyB1c2VkKVxuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5fcmVhZE9mZnNldDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9idWZmW2ldID09PSAweDAwKSB7XG4gICAgICAgICAgICAgICAgbnVsbFBvcyA9IGk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVhZCB2YWx1ZVxuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuX2J1ZmYuc2xpY2UodGhpcy5fcmVhZE9mZnNldCwgbnVsbFBvcyk7XG4gICAgICAgIC8vIEluY3JlbWVudCBpbnRlcm5hbCBCdWZmZXIgcmVhZCBvZmZzZXRcbiAgICAgICAgdGhpcy5fcmVhZE9mZnNldCA9IG51bGxQb3MgKyAxO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluc2VydHMgYSBudWxsLXRlcm1pbmF0ZWQgQnVmZmVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIHsgQnVmZmVyIH0gVGhlIEJ1ZmZlciB0byB3cml0ZS5cbiAgICAgKiBAcGFyYW0gb2Zmc2V0IHsgTnVtYmVyIH0gVGhlIG9mZnNldCB0byB3cml0ZSB0aGUgQnVmZmVyIHRvLlxuICAgICAqXG4gICAgICogQHJldHVybiB0aGlzXG4gICAgICovXG4gICAgaW5zZXJ0QnVmZmVyTlQodmFsdWUsIG9mZnNldCkge1xuICAgICAgICB1dGlsc18xLmNoZWNrT2Zmc2V0VmFsdWUob2Zmc2V0KTtcbiAgICAgICAgLy8gV3JpdGUgVmFsdWVzXG4gICAgICAgIHRoaXMuaW5zZXJ0QnVmZmVyKHZhbHVlLCBvZmZzZXQpO1xuICAgICAgICB0aGlzLmluc2VydFVJbnQ4KDB4MDAsIG9mZnNldCArIHZhbHVlLmxlbmd0aCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZXMgYSBudWxsLXRlcm1pbmF0ZWQgQnVmZmVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIHsgQnVmZmVyIH0gVGhlIEJ1ZmZlciB0byB3cml0ZS5cbiAgICAgKiBAcGFyYW0gb2Zmc2V0IHsgTnVtYmVyIH0gVGhlIG9mZnNldCB0byB3cml0ZSB0aGUgQnVmZmVyIHRvLlxuICAgICAqXG4gICAgICogQHJldHVybiB0aGlzXG4gICAgICovXG4gICAgd3JpdGVCdWZmZXJOVCh2YWx1ZSwgb2Zmc2V0KSB7XG4gICAgICAgIC8vIENoZWNrcyBmb3IgdmFsaWQgbnVtYmVyaWMgdmFsdWU7XG4gICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdXRpbHNfMS5jaGVja09mZnNldFZhbHVlKG9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV3JpdGUgVmFsdWVzXG4gICAgICAgIHRoaXMud3JpdGVCdWZmZXIodmFsdWUsIG9mZnNldCk7XG4gICAgICAgIHRoaXMud3JpdGVVSW50OCgweDAwLCB0eXBlb2Ygb2Zmc2V0ID09PSAnbnVtYmVyJyA/IG9mZnNldCArIHZhbHVlLmxlbmd0aCA6IHRoaXMuX3dyaXRlT2Zmc2V0KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsZWFycyB0aGUgU21hcnRCdWZmZXIgaW5zdGFuY2UgdG8gaXRzIG9yaWdpbmFsIGVtcHR5IHN0YXRlLlxuICAgICAqL1xuICAgIGNsZWFyKCkge1xuICAgICAgICB0aGlzLl93cml0ZU9mZnNldCA9IDA7XG4gICAgICAgIHRoaXMuX3JlYWRPZmZzZXQgPSAwO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSByZW1haW5pbmcgZGF0YSBsZWZ0IHRvIGJlIHJlYWQgZnJvbSB0aGUgU21hcnRCdWZmZXIgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHsgTnVtYmVyIH1cbiAgICAgKi9cbiAgICByZW1haW5pbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxlbmd0aCAtIHRoaXMuX3JlYWRPZmZzZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGN1cnJlbnQgcmVhZCBvZmZzZXQgdmFsdWUgb2YgdGhlIFNtYXJ0QnVmZmVyIGluc3RhbmNlLlxuICAgICAqXG4gICAgICogQHJldHVybiB7IE51bWJlciB9XG4gICAgICovXG4gICAgZ2V0IHJlYWRPZmZzZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWFkT2Zmc2V0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSByZWFkIG9mZnNldCB2YWx1ZSBvZiB0aGUgU21hcnRCdWZmZXIgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb2Zmc2V0IHsgTnVtYmVyIH0gLSBUaGUgb2Zmc2V0IHZhbHVlIHRvIHNldC5cbiAgICAgKi9cbiAgICBzZXQgcmVhZE9mZnNldChvZmZzZXQpIHtcbiAgICAgICAgdXRpbHNfMS5jaGVja09mZnNldFZhbHVlKG9mZnNldCk7XG4gICAgICAgIC8vIENoZWNrIGZvciBib3VuZHMuXG4gICAgICAgIHV0aWxzXzEuY2hlY2tUYXJnZXRPZmZzZXQob2Zmc2V0LCB0aGlzKTtcbiAgICAgICAgdGhpcy5fcmVhZE9mZnNldCA9IG9mZnNldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgY3VycmVudCB3cml0ZSBvZmZzZXQgdmFsdWUgb2YgdGhlIFNtYXJ0QnVmZmVyIGluc3RhbmNlLlxuICAgICAqXG4gICAgICogQHJldHVybiB7IE51bWJlciB9XG4gICAgICovXG4gICAgZ2V0IHdyaXRlT2Zmc2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd3JpdGVPZmZzZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHdyaXRlIG9mZnNldCB2YWx1ZSBvZiB0aGUgU21hcnRCdWZmZXIgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb2Zmc2V0IHsgTnVtYmVyIH0gLSBUaGUgb2Zmc2V0IHZhbHVlIHRvIHNldC5cbiAgICAgKi9cbiAgICBzZXQgd3JpdGVPZmZzZXQob2Zmc2V0KSB7XG4gICAgICAgIHV0aWxzXzEuY2hlY2tPZmZzZXRWYWx1ZShvZmZzZXQpO1xuICAgICAgICAvLyBDaGVjayBmb3IgYm91bmRzLlxuICAgICAgICB1dGlsc18xLmNoZWNrVGFyZ2V0T2Zmc2V0KG9mZnNldCwgdGhpcyk7XG4gICAgICAgIHRoaXMuX3dyaXRlT2Zmc2V0ID0gb2Zmc2V0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjdXJyZW50bHkgc2V0IHN0cmluZyBlbmNvZGluZyBvZiB0aGUgU21hcnRCdWZmZXIgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHsgQnVmZmVyRW5jb2RpbmcgfSBUaGUgc3RyaW5nIEJ1ZmZlciBlbmNvZGluZyBjdXJyZW50bHkgc2V0LlxuICAgICAqL1xuICAgIGdldCBlbmNvZGluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VuY29kaW5nO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBzdHJpbmcgZW5jb2Rpbmcgb2YgdGhlIFNtYXJ0QnVmZmVyIGluc3RhbmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGVuY29kaW5nIHsgQnVmZmVyRW5jb2RpbmcgfSBUaGUgc3RyaW5nIEJ1ZmZlciBlbmNvZGluZyB0byBzZXQuXG4gICAgICovXG4gICAgc2V0IGVuY29kaW5nKGVuY29kaW5nKSB7XG4gICAgICAgIHV0aWxzXzEuY2hlY2tFbmNvZGluZyhlbmNvZGluZyk7XG4gICAgICAgIHRoaXMuX2VuY29kaW5nID0gZW5jb2Rpbmc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHVuZGVybHlpbmcgaW50ZXJuYWwgQnVmZmVyLiAoVGhpcyBpbmNsdWRlcyB1bm1hbmFnZWQgZGF0YSBpbiB0aGUgQnVmZmVyKVxuICAgICAqXG4gICAgICogQHJldHVybiB7IEJ1ZmZlciB9IFRoZSBCdWZmZXIgdmFsdWUuXG4gICAgICovXG4gICAgZ2V0IGludGVybmFsQnVmZmVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYnVmZjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgdmFsdWUgb2YgdGhlIGludGVybmFsIG1hbmFnZWQgQnVmZmVyIChJbmNsdWRlcyBtYW5hZ2VkIGRhdGEgb25seSlcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IEJ1ZmZlciB9XG4gICAgICovXG4gICAgdG9CdWZmZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9idWZmLnNsaWNlKDAsIHRoaXMubGVuZ3RoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgU3RyaW5nIHZhbHVlIG9mIHRoZSBpbnRlcm5hbCBtYW5hZ2VkIEJ1ZmZlclxuICAgICAqXG4gICAgICogQHBhcmFtIGVuY29kaW5nIHsgU3RyaW5nIH0gVGhlIEJ1ZmZlckVuY29kaW5nIHRvIGRpc3BsYXkgdGhlIEJ1ZmZlciBhcyAoZGVmYXVsdHMgdG8gaW5zdGFuY2UgbGV2ZWwgZW5jb2RpbmcpLlxuICAgICAqL1xuICAgIHRvU3RyaW5nKGVuY29kaW5nKSB7XG4gICAgICAgIGNvbnN0IGVuY29kaW5nVmFsID0gdHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJyA/IGVuY29kaW5nIDogdGhpcy5fZW5jb2Rpbmc7XG4gICAgICAgIC8vIENoZWNrIGZvciBpbnZhbGlkIGVuY29kaW5nLlxuICAgICAgICB1dGlsc18xLmNoZWNrRW5jb2RpbmcoZW5jb2RpbmdWYWwpO1xuICAgICAgICByZXR1cm4gdGhpcy5fYnVmZi50b1N0cmluZyhlbmNvZGluZ1ZhbCwgMCwgdGhpcy5sZW5ndGgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXN0cm95cyB0aGUgU21hcnRCdWZmZXIgaW5zdGFuY2UuXG4gICAgICovXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyBpbnNlcnRpbmcgYW5kIHdyaXRpbmcgc3RyaW5ncy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSB7IFN0cmluZyB9IFRoZSBTdHJpbmcgdmFsdWUgdG8gaW5zZXJ0LlxuICAgICAqIEBwYXJhbSBpc0luc2VydCB7IEJvb2xlYW4gfSBUcnVlIGlmIGluc2VydGluZyBhIHN0cmluZywgZmFsc2UgaWYgd3JpdGluZy5cbiAgICAgKiBAcGFyYW0gYXJnMiB7IE51bWJlciB8IFN0cmluZyB9IFRoZSBvZmZzZXQgdG8gaW5zZXJ0IHRoZSBzdHJpbmcgYXQsIG9yIHRoZSBCdWZmZXJFbmNvZGluZyB0byB1c2UuXG4gICAgICogQHBhcmFtIGVuY29kaW5nIHsgU3RyaW5nIH0gVGhlIEJ1ZmZlckVuY29kaW5nIHRvIHVzZSBmb3Igd3JpdGluZyBzdHJpbmdzIChkZWZhdWx0cyB0byBpbnN0YW5jZSBlbmNvZGluZykuXG4gICAgICovXG4gICAgX2hhbmRsZVN0cmluZyh2YWx1ZSwgaXNJbnNlcnQsIGFyZzMsIGVuY29kaW5nKSB7XG4gICAgICAgIGxldCBvZmZzZXRWYWwgPSB0aGlzLl93cml0ZU9mZnNldDtcbiAgICAgICAgbGV0IGVuY29kaW5nVmFsID0gdGhpcy5fZW5jb2Rpbmc7XG4gICAgICAgIC8vIENoZWNrIGZvciBvZmZzZXRcbiAgICAgICAgaWYgKHR5cGVvZiBhcmczID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgb2Zmc2V0VmFsID0gYXJnMztcbiAgICAgICAgICAgIC8vIENoZWNrIGZvciBlbmNvZGluZ1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBhcmczID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdXRpbHNfMS5jaGVja0VuY29kaW5nKGFyZzMpO1xuICAgICAgICAgICAgZW5jb2RpbmdWYWwgPSBhcmczO1xuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrIGZvciBlbmNvZGluZyAodGhpcmQgcGFyYW0pXG4gICAgICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB1dGlsc18xLmNoZWNrRW5jb2RpbmcoZW5jb2RpbmcpO1xuICAgICAgICAgICAgZW5jb2RpbmdWYWwgPSBlbmNvZGluZztcbiAgICAgICAgfVxuICAgICAgICAvLyBDYWxjdWxhdGUgYnl0ZWxlbmd0aCBvZiBzdHJpbmcuXG4gICAgICAgIGNvbnN0IGJ5dGVMZW5ndGggPSBCdWZmZXIuYnl0ZUxlbmd0aCh2YWx1ZSwgZW5jb2RpbmdWYWwpO1xuICAgICAgICAvLyBFbnN1cmUgdGhlcmUgaXMgZW5vdWdoIGludGVybmFsIEJ1ZmZlciBjYXBhY2l0eS5cbiAgICAgICAgaWYgKGlzSW5zZXJ0KSB7XG4gICAgICAgICAgICB0aGlzLmVuc3VyZUluc2VydGFibGUoYnl0ZUxlbmd0aCwgb2Zmc2V0VmFsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2Vuc3VyZVdyaXRlYWJsZShieXRlTGVuZ3RoLCBvZmZzZXRWYWwpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdyaXRlIHZhbHVlXG4gICAgICAgIHRoaXMuX2J1ZmYud3JpdGUodmFsdWUsIG9mZnNldFZhbCwgYnl0ZUxlbmd0aCwgZW5jb2RpbmdWYWwpO1xuICAgICAgICAvLyBJbmNyZW1lbnQgaW50ZXJuYWwgQnVmZmVyIHdyaXRlIG9mZnNldDtcbiAgICAgICAgaWYgKGlzSW5zZXJ0KSB7XG4gICAgICAgICAgICB0aGlzLl93cml0ZU9mZnNldCArPSBieXRlTGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gSWYgYW4gb2Zmc2V0IHdhcyBnaXZlbiwgY2hlY2sgdG8gc2VlIGlmIHdlIHdyb3RlIGJleW9uZCB0aGUgY3VycmVudCB3cml0ZU9mZnNldC5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgYXJnMyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl93cml0ZU9mZnNldCA9IE1hdGgubWF4KHRoaXMuX3dyaXRlT2Zmc2V0LCBvZmZzZXRWYWwgKyBieXRlTGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIElmIG5vIG9mZnNldCB3YXMgZ2l2ZW4sIHdlIHdyb3RlIHRvIHRoZSBlbmQgb2YgdGhlIFNtYXJ0QnVmZmVyIHNvIGluY3JlbWVudCB3cml0ZU9mZnNldC5cbiAgICAgICAgICAgICAgICB0aGlzLl93cml0ZU9mZnNldCArPSBieXRlTGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIHdyaXRpbmcgb3IgaW5zZXJ0IG9mIGEgQnVmZmVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIHsgQnVmZmVyIH0gVGhlIEJ1ZmZlciB0byB3cml0ZS5cbiAgICAgKiBAcGFyYW0gb2Zmc2V0IHsgTnVtYmVyIH0gVGhlIG9mZnNldCB0byB3cml0ZSB0aGUgQnVmZmVyIHRvLlxuICAgICAqL1xuICAgIF9oYW5kbGVCdWZmZXIodmFsdWUsIGlzSW5zZXJ0LCBvZmZzZXQpIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0VmFsID0gdHlwZW9mIG9mZnNldCA9PT0gJ251bWJlcicgPyBvZmZzZXQgOiB0aGlzLl93cml0ZU9mZnNldDtcbiAgICAgICAgLy8gRW5zdXJlIHRoZXJlIGlzIGVub3VnaCBpbnRlcm5hbCBCdWZmZXIgY2FwYWNpdHkuXG4gICAgICAgIGlmIChpc0luc2VydCkge1xuICAgICAgICAgICAgdGhpcy5lbnN1cmVJbnNlcnRhYmxlKHZhbHVlLmxlbmd0aCwgb2Zmc2V0VmFsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2Vuc3VyZVdyaXRlYWJsZSh2YWx1ZS5sZW5ndGgsIG9mZnNldFZhbCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV3JpdGUgYnVmZmVyIHZhbHVlXG4gICAgICAgIHZhbHVlLmNvcHkodGhpcy5fYnVmZiwgb2Zmc2V0VmFsKTtcbiAgICAgICAgLy8gSW5jcmVtZW50IGludGVybmFsIEJ1ZmZlciB3cml0ZSBvZmZzZXQ7XG4gICAgICAgIGlmIChpc0luc2VydCkge1xuICAgICAgICAgICAgdGhpcy5fd3JpdGVPZmZzZXQgKz0gdmFsdWUubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gSWYgYW4gb2Zmc2V0IHdhcyBnaXZlbiwgY2hlY2sgdG8gc2VlIGlmIHdlIHdyb3RlIGJleW9uZCB0aGUgY3VycmVudCB3cml0ZU9mZnNldC5cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3dyaXRlT2Zmc2V0ID0gTWF0aC5tYXgodGhpcy5fd3JpdGVPZmZzZXQsIG9mZnNldFZhbCArIHZhbHVlLmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBubyBvZmZzZXQgd2FzIGdpdmVuLCB3ZSB3cm90ZSB0byB0aGUgZW5kIG9mIHRoZSBTbWFydEJ1ZmZlciBzbyBpbmNyZW1lbnQgd3JpdGVPZmZzZXQuXG4gICAgICAgICAgICAgICAgdGhpcy5fd3JpdGVPZmZzZXQgKz0gdmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbnN1cmVzIHRoYXQgdGhlIGludGVybmFsIEJ1ZmZlciBpcyBsYXJnZSBlbm91Z2ggdG8gcmVhZCBkYXRhLlxuICAgICAqXG4gICAgICogQHBhcmFtIGxlbmd0aCB7IE51bWJlciB9IFRoZSBsZW5ndGggb2YgdGhlIGRhdGEgdGhhdCBuZWVkcyB0byBiZSByZWFkLlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IG9mIHRoZSBkYXRhIHRoYXQgbmVlZHMgdG8gYmUgcmVhZC5cbiAgICAgKi9cbiAgICBlbnN1cmVSZWFkYWJsZShsZW5ndGgsIG9mZnNldCkge1xuICAgICAgICAvLyBPZmZzZXQgdmFsdWUgZGVmYXVsdHMgdG8gbWFuYWdlZCByZWFkIG9mZnNldC5cbiAgICAgICAgbGV0IG9mZnNldFZhbCA9IHRoaXMuX3JlYWRPZmZzZXQ7XG4gICAgICAgIC8vIElmIGFuIG9mZnNldCB3YXMgcHJvdmlkZWQsIHVzZSBpdC5cbiAgICAgICAgaWYgKHR5cGVvZiBvZmZzZXQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAvLyBDaGVja3MgZm9yIHZhbGlkIG51bWJlcmljIHZhbHVlO1xuICAgICAgICAgICAgdXRpbHNfMS5jaGVja09mZnNldFZhbHVlKG9mZnNldCk7XG4gICAgICAgICAgICAvLyBPdmVyaWRlIHdpdGggY3VzdG9tIG9mZnNldC5cbiAgICAgICAgICAgIG9mZnNldFZhbCA9IG9mZnNldDtcbiAgICAgICAgfVxuICAgICAgICAvLyBDaGVja3MgaWYgb2Zmc2V0IGlzIGJlbG93IHplcm8sIG9yIHRoZSBvZmZzZXQrbGVuZ3RoIG9mZnNldCBpcyBiZXlvbmQgdGhlIHRvdGFsIGxlbmd0aCBvZiB0aGUgbWFuYWdlZCBkYXRhLlxuICAgICAgICBpZiAob2Zmc2V0VmFsIDwgMCB8fCBvZmZzZXRWYWwgKyBsZW5ndGggPiB0aGlzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHV0aWxzXzEuRVJST1JTLklOVkFMSURfUkVBRF9CRVlPTkRfQk9VTkRTKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbnN1cmVzIHRoYXQgdGhlIGludGVybmFsIEJ1ZmZlciBpcyBsYXJnZSBlbm91Z2ggdG8gaW5zZXJ0IGRhdGEuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZGF0YUxlbmd0aCB7IE51bWJlciB9IFRoZSBsZW5ndGggb2YgdGhlIGRhdGEgdGhhdCBuZWVkcyB0byBiZSB3cml0dGVuLlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IG9mIHRoZSBkYXRhIHRvIGJlIHdyaXR0ZW4uXG4gICAgICovXG4gICAgZW5zdXJlSW5zZXJ0YWJsZShkYXRhTGVuZ3RoLCBvZmZzZXQpIHtcbiAgICAgICAgLy8gQ2hlY2tzIGZvciB2YWxpZCBudW1iZXJpYyB2YWx1ZTtcbiAgICAgICAgdXRpbHNfMS5jaGVja09mZnNldFZhbHVlKG9mZnNldCk7XG4gICAgICAgIC8vIEVuc3VyZSB0aGVyZSBpcyBlbm91Z2ggaW50ZXJuYWwgQnVmZmVyIGNhcGFjaXR5LlxuICAgICAgICB0aGlzLl9lbnN1cmVDYXBhY2l0eSh0aGlzLmxlbmd0aCArIGRhdGFMZW5ndGgpO1xuICAgICAgICAvLyBJZiBhbiBvZmZzZXQgd2FzIHByb3ZpZGVkIGFuZCBpdHMgbm90IHRoZSB2ZXJ5IGVuZCBvZiB0aGUgYnVmZmVyLCBjb3B5IGRhdGEgaW50byBhcHByb3ByaWF0ZSBsb2NhdGlvbiBpbiByZWdhcmRzIHRvIHRoZSBvZmZzZXQuXG4gICAgICAgIGlmIChvZmZzZXQgPCB0aGlzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5fYnVmZi5jb3B5KHRoaXMuX2J1ZmYsIG9mZnNldCArIGRhdGFMZW5ndGgsIG9mZnNldCwgdGhpcy5fYnVmZi5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFkanVzdCB0cmFja2VkIHNtYXJ0IGJ1ZmZlciBsZW5ndGhcbiAgICAgICAgaWYgKG9mZnNldCArIGRhdGFMZW5ndGggPiB0aGlzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5sZW5ndGggPSBvZmZzZXQgKyBkYXRhTGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5sZW5ndGggKz0gZGF0YUxlbmd0aDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbnN1cmVzIHRoYXQgdGhlIGludGVybmFsIEJ1ZmZlciBpcyBsYXJnZSBlbm91Z2ggdG8gd3JpdGUgZGF0YS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkYXRhTGVuZ3RoIHsgTnVtYmVyIH0gVGhlIGxlbmd0aCBvZiB0aGUgZGF0YSB0aGF0IG5lZWRzIHRvIGJlIHdyaXR0ZW4uXG4gICAgICogQHBhcmFtIG9mZnNldCB7IE51bWJlciB9IFRoZSBvZmZzZXQgb2YgdGhlIGRhdGEgdG8gYmUgd3JpdHRlbiAoZGVmYXVsdHMgdG8gd3JpdGVPZmZzZXQpLlxuICAgICAqL1xuICAgIF9lbnN1cmVXcml0ZWFibGUoZGF0YUxlbmd0aCwgb2Zmc2V0KSB7XG4gICAgICAgIGNvbnN0IG9mZnNldFZhbCA9IHR5cGVvZiBvZmZzZXQgPT09ICdudW1iZXInID8gb2Zmc2V0IDogdGhpcy5fd3JpdGVPZmZzZXQ7XG4gICAgICAgIC8vIEVuc3VyZSBlbm91Z2ggY2FwYWNpdHkgdG8gd3JpdGUgZGF0YS5cbiAgICAgICAgdGhpcy5fZW5zdXJlQ2FwYWNpdHkob2Zmc2V0VmFsICsgZGF0YUxlbmd0aCk7XG4gICAgICAgIC8vIEFkanVzdCBTbWFydEJ1ZmZlciBsZW5ndGggKGlmIG9mZnNldCArIGxlbmd0aCBpcyBsYXJnZXIgdGhhbiBtYW5hZ2VkIGxlbmd0aCwgYWRqdXN0IGxlbmd0aClcbiAgICAgICAgaWYgKG9mZnNldFZhbCArIGRhdGFMZW5ndGggPiB0aGlzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5sZW5ndGggPSBvZmZzZXRWYWwgKyBkYXRhTGVuZ3RoO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuc3VyZXMgdGhhdCB0aGUgaW50ZXJuYWwgQnVmZmVyIGlzIGxhcmdlIGVub3VnaCB0byB3cml0ZSBhdCBsZWFzdCB0aGUgZ2l2ZW4gYW1vdW50IG9mIGRhdGEuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbWluTGVuZ3RoIHsgTnVtYmVyIH0gVGhlIG1pbmltdW0gbGVuZ3RoIG9mIHRoZSBkYXRhIG5lZWRzIHRvIGJlIHdyaXR0ZW4uXG4gICAgICovXG4gICAgX2Vuc3VyZUNhcGFjaXR5KG1pbkxlbmd0aCkge1xuICAgICAgICBjb25zdCBvbGRMZW5ndGggPSB0aGlzLl9idWZmLmxlbmd0aDtcbiAgICAgICAgaWYgKG1pbkxlbmd0aCA+IG9sZExlbmd0aCkge1xuICAgICAgICAgICAgbGV0IGRhdGEgPSB0aGlzLl9idWZmO1xuICAgICAgICAgICAgbGV0IG5ld0xlbmd0aCA9IChvbGRMZW5ndGggKiAzKSAvIDIgKyAxO1xuICAgICAgICAgICAgaWYgKG5ld0xlbmd0aCA8IG1pbkxlbmd0aCkge1xuICAgICAgICAgICAgICAgIG5ld0xlbmd0aCA9IG1pbkxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2J1ZmYgPSBCdWZmZXIuYWxsb2NVbnNhZmUobmV3TGVuZ3RoKTtcbiAgICAgICAgICAgIGRhdGEuY29weSh0aGlzLl9idWZmLCAwLCAwLCBvbGRMZW5ndGgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWRzIGEgbnVtZXJpYyBudW1iZXIgdmFsdWUgdXNpbmcgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHR5cGVwYXJhbSBUIHsgbnVtYmVyIHwgYmlnaW50IH0gVGhlIHR5cGUgb2YgdGhlIHZhbHVlIHRvIGJlIHJlYWRcbiAgICAgKlxuICAgICAqIEBwYXJhbSBmdW5jIHsgRnVuY3Rpb24ob2Zmc2V0OiBudW1iZXIpID0+IG51bWJlciB9IFRoZSBmdW5jdGlvbiB0byByZWFkIGRhdGEgb24gdGhlIGludGVybmFsIEJ1ZmZlciB3aXRoLlxuICAgICAqIEBwYXJhbSBieXRlU2l6ZSB7IE51bWJlciB9IFRoZSBudW1iZXIgb2YgYnl0ZXMgcmVhZC5cbiAgICAgKiBAcGFyYW0gb2Zmc2V0IHsgTnVtYmVyIH0gVGhlIG9mZnNldCB0byByZWFkIGZyb20gKG9wdGlvbmFsKS4gV2hlbiB0aGlzIGlzIG5vdCBwcm92aWRlZCwgdGhlIG1hbmFnZWQgcmVhZE9mZnNldCBpcyB1c2VkIGluc3RlYWQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7IFQgfSB0aGUgbnVtYmVyIHZhbHVlXG4gICAgICovXG4gICAgX3JlYWROdW1iZXJWYWx1ZShmdW5jLCBieXRlU2l6ZSwgb2Zmc2V0KSB7XG4gICAgICAgIHRoaXMuZW5zdXJlUmVhZGFibGUoYnl0ZVNpemUsIG9mZnNldCk7XG4gICAgICAgIC8vIENhbGwgQnVmZmVyLnJlYWRYWFhYKCk7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gZnVuYy5jYWxsKHRoaXMuX2J1ZmYsIHR5cGVvZiBvZmZzZXQgPT09ICdudW1iZXInID8gb2Zmc2V0IDogdGhpcy5fcmVhZE9mZnNldCk7XG4gICAgICAgIC8vIEFkanVzdCBpbnRlcm5hbCByZWFkIG9mZnNldCBpZiBhbiBvcHRpb25hbCByZWFkIG9mZnNldCB3YXMgbm90IHByb3ZpZGVkLlxuICAgICAgICBpZiAodHlwZW9mIG9mZnNldCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlYWRPZmZzZXQgKz0gYnl0ZVNpemU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnNlcnRzIGEgbnVtZXJpYyBudW1iZXIgdmFsdWUgYmFzZWQgb24gdGhlIGdpdmVuIG9mZnNldCBhbmQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAdHlwZXBhcmFtIFQgeyBudW1iZXIgfCBiaWdpbnQgfSBUaGUgdHlwZSBvZiB0aGUgdmFsdWUgdG8gYmUgd3JpdHRlblxuICAgICAqXG4gICAgICogQHBhcmFtIGZ1bmMgeyBGdW5jdGlvbihvZmZzZXQ6IFQsIG9mZnNldD8pID0+IG51bWJlcn0gVGhlIGZ1bmN0aW9uIHRvIHdyaXRlIGRhdGEgb24gdGhlIGludGVybmFsIEJ1ZmZlciB3aXRoLlxuICAgICAqIEBwYXJhbSBieXRlU2l6ZSB7IE51bWJlciB9IFRoZSBudW1iZXIgb2YgYnl0ZXMgd3JpdHRlbi5cbiAgICAgKiBAcGFyYW0gdmFsdWUgeyBUIH0gVGhlIG51bWJlciB2YWx1ZSB0byB3cml0ZS5cbiAgICAgKiBAcGFyYW0gb2Zmc2V0IHsgTnVtYmVyIH0gdGhlIG9mZnNldCB0byB3cml0ZSB0aGUgbnVtYmVyIGF0IChSRVFVSVJFRCkuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBTbWFydEJ1ZmZlciB0aGlzIGJ1ZmZlclxuICAgICAqL1xuICAgIF9pbnNlcnROdW1iZXJWYWx1ZShmdW5jLCBieXRlU2l6ZSwgdmFsdWUsIG9mZnNldCkge1xuICAgICAgICAvLyBDaGVjayBmb3IgaW52YWxpZCBvZmZzZXQgdmFsdWVzLlxuICAgICAgICB1dGlsc18xLmNoZWNrT2Zmc2V0VmFsdWUob2Zmc2V0KTtcbiAgICAgICAgLy8gRW5zdXJlIHRoZXJlIGlzIGVub3VnaCBpbnRlcm5hbCBCdWZmZXIgY2FwYWNpdHkuIChyYXcgb2Zmc2V0IGlzIHBhc3NlZClcbiAgICAgICAgdGhpcy5lbnN1cmVJbnNlcnRhYmxlKGJ5dGVTaXplLCBvZmZzZXQpO1xuICAgICAgICAvLyBDYWxsIGJ1ZmZlci53cml0ZVhYWFgoKTtcbiAgICAgICAgZnVuYy5jYWxsKHRoaXMuX2J1ZmYsIHZhbHVlLCBvZmZzZXQpO1xuICAgICAgICAvLyBBZGp1c3RzIGludGVybmFsbHkgbWFuYWdlZCB3cml0ZSBvZmZzZXQuXG4gICAgICAgIHRoaXMuX3dyaXRlT2Zmc2V0ICs9IGJ5dGVTaXplO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGVzIGEgbnVtZXJpYyBudW1iZXIgdmFsdWUgYmFzZWQgb24gdGhlIGdpdmVuIG9mZnNldCBhbmQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAdHlwZXBhcmFtIFQgeyBudW1iZXIgfCBiaWdpbnQgfSBUaGUgdHlwZSBvZiB0aGUgdmFsdWUgdG8gYmUgd3JpdHRlblxuICAgICAqXG4gICAgICogQHBhcmFtIGZ1bmMgeyBGdW5jdGlvbihvZmZzZXQ6IFQsIG9mZnNldD8pID0+IG51bWJlcn0gVGhlIGZ1bmN0aW9uIHRvIHdyaXRlIGRhdGEgb24gdGhlIGludGVybmFsIEJ1ZmZlciB3aXRoLlxuICAgICAqIEBwYXJhbSBieXRlU2l6ZSB7IE51bWJlciB9IFRoZSBudW1iZXIgb2YgYnl0ZXMgd3JpdHRlbi5cbiAgICAgKiBAcGFyYW0gdmFsdWUgeyBUIH0gVGhlIG51bWJlciB2YWx1ZSB0byB3cml0ZS5cbiAgICAgKiBAcGFyYW0gb2Zmc2V0IHsgTnVtYmVyIH0gdGhlIG9mZnNldCB0byB3cml0ZSB0aGUgbnVtYmVyIGF0IChSRVFVSVJFRCkuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBTbWFydEJ1ZmZlciB0aGlzIGJ1ZmZlclxuICAgICAqL1xuICAgIF93cml0ZU51bWJlclZhbHVlKGZ1bmMsIGJ5dGVTaXplLCB2YWx1ZSwgb2Zmc2V0KSB7XG4gICAgICAgIC8vIElmIGFuIG9mZnNldCB3YXMgcHJvdmlkZWQsIHZhbGlkYXRlIGl0LlxuICAgICAgICBpZiAodHlwZW9mIG9mZnNldCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHdlJ3JlIHdyaXRpbmcgYmV5b25kIHRoZSBib3VuZHMgb2YgdGhlIG1hbmFnZWQgZGF0YS5cbiAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHV0aWxzXzEuRVJST1JTLklOVkFMSURfV1JJVEVfQkVZT05EX0JPVU5EUyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1dGlsc18xLmNoZWNrT2Zmc2V0VmFsdWUob2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBEZWZhdWx0IHRvIHdyaXRlT2Zmc2V0IGlmIG5vIG9mZnNldCB2YWx1ZSB3YXMgZ2l2ZW4uXG4gICAgICAgIGNvbnN0IG9mZnNldFZhbCA9IHR5cGVvZiBvZmZzZXQgPT09ICdudW1iZXInID8gb2Zmc2V0IDogdGhpcy5fd3JpdGVPZmZzZXQ7XG4gICAgICAgIC8vIEVuc3VyZSB0aGVyZSBpcyBlbm91Z2ggaW50ZXJuYWwgQnVmZmVyIGNhcGFjaXR5LiAocmF3IG9mZnNldCBpcyBwYXNzZWQpXG4gICAgICAgIHRoaXMuX2Vuc3VyZVdyaXRlYWJsZShieXRlU2l6ZSwgb2Zmc2V0VmFsKTtcbiAgICAgICAgZnVuYy5jYWxsKHRoaXMuX2J1ZmYsIHZhbHVlLCBvZmZzZXRWYWwpO1xuICAgICAgICAvLyBJZiBhbiBvZmZzZXQgd2FzIGdpdmVuLCBjaGVjayB0byBzZWUgaWYgd2Ugd3JvdGUgYmV5b25kIHRoZSBjdXJyZW50IHdyaXRlT2Zmc2V0LlxuICAgICAgICBpZiAodHlwZW9mIG9mZnNldCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHRoaXMuX3dyaXRlT2Zmc2V0ID0gTWF0aC5tYXgodGhpcy5fd3JpdGVPZmZzZXQsIG9mZnNldFZhbCArIGJ5dGVTaXplKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIElmIG5vIG51bWVyaWMgb2Zmc2V0IHdhcyBnaXZlbiwgd2Ugd3JvdGUgdG8gdGhlIGVuZCBvZiB0aGUgU21hcnRCdWZmZXIgc28gaW5jcmVtZW50IHdyaXRlT2Zmc2V0LlxuICAgICAgICAgICAgdGhpcy5fd3JpdGVPZmZzZXQgKz0gYnl0ZVNpemU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuZXhwb3J0cy5TbWFydEJ1ZmZlciA9IFNtYXJ0QnVmZmVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c21hcnRidWZmZXIuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwidXRpbHNfMSIsInJlcXVpcmUiLCJERUZBVUxUX1NNQVJUQlVGRkVSX1NJWkUiLCJERUZBVUxUX1NNQVJUQlVGRkVSX0VOQ09ESU5HIiwiU21hcnRCdWZmZXIiLCJjb25zdHJ1Y3RvciIsIm9wdGlvbnMiLCJsZW5ndGgiLCJfZW5jb2RpbmciLCJfd3JpdGVPZmZzZXQiLCJfcmVhZE9mZnNldCIsImlzU21hcnRCdWZmZXJPcHRpb25zIiwiZW5jb2RpbmciLCJjaGVja0VuY29kaW5nIiwic2l6ZSIsImlzRmluaXRlSW50ZWdlciIsIl9idWZmIiwiQnVmZmVyIiwiYWxsb2NVbnNhZmUiLCJFcnJvciIsIkVSUk9SUyIsIklOVkFMSURfU01BUlRCVUZGRVJfU0laRSIsImJ1ZmYiLCJpc0J1ZmZlciIsIklOVkFMSURfU01BUlRCVUZGRVJfQlVGRkVSIiwiSU5WQUxJRF9TTUFSVEJVRkZFUl9PQkpFQ1QiLCJmcm9tU2l6ZSIsImZyb21CdWZmZXIiLCJmcm9tT3B0aW9ucyIsImNhc3RPcHRpb25zIiwidW5kZWZpbmVkIiwicmVhZEludDgiLCJvZmZzZXQiLCJfcmVhZE51bWJlclZhbHVlIiwicHJvdG90eXBlIiwicmVhZEludDE2QkUiLCJyZWFkSW50MTZMRSIsInJlYWRJbnQzMkJFIiwicmVhZEludDMyTEUiLCJyZWFkQmlnSW50NjRCRSIsImJpZ0ludEFuZEJ1ZmZlckludDY0Q2hlY2siLCJyZWFkQmlnSW50NjRMRSIsIndyaXRlSW50OCIsIl93cml0ZU51bWJlclZhbHVlIiwiaW5zZXJ0SW50OCIsIl9pbnNlcnROdW1iZXJWYWx1ZSIsIndyaXRlSW50MTZCRSIsImluc2VydEludDE2QkUiLCJ3cml0ZUludDE2TEUiLCJpbnNlcnRJbnQxNkxFIiwid3JpdGVJbnQzMkJFIiwiaW5zZXJ0SW50MzJCRSIsIndyaXRlSW50MzJMRSIsImluc2VydEludDMyTEUiLCJ3cml0ZUJpZ0ludDY0QkUiLCJpbnNlcnRCaWdJbnQ2NEJFIiwid3JpdGVCaWdJbnQ2NExFIiwiaW5zZXJ0QmlnSW50NjRMRSIsInJlYWRVSW50OCIsInJlYWRVSW50MTZCRSIsInJlYWRVSW50MTZMRSIsInJlYWRVSW50MzJCRSIsInJlYWRVSW50MzJMRSIsInJlYWRCaWdVSW50NjRCRSIsInJlYWRCaWdVSW50NjRMRSIsIndyaXRlVUludDgiLCJpbnNlcnRVSW50OCIsIndyaXRlVUludDE2QkUiLCJpbnNlcnRVSW50MTZCRSIsIndyaXRlVUludDE2TEUiLCJpbnNlcnRVSW50MTZMRSIsIndyaXRlVUludDMyQkUiLCJpbnNlcnRVSW50MzJCRSIsIndyaXRlVUludDMyTEUiLCJpbnNlcnRVSW50MzJMRSIsIndyaXRlQmlnVUludDY0QkUiLCJpbnNlcnRCaWdVSW50NjRCRSIsIndyaXRlQmlnVUludDY0TEUiLCJpbnNlcnRCaWdVSW50NjRMRSIsInJlYWRGbG9hdEJFIiwicmVhZEZsb2F0TEUiLCJ3cml0ZUZsb2F0QkUiLCJpbnNlcnRGbG9hdEJFIiwid3JpdGVGbG9hdExFIiwiaW5zZXJ0RmxvYXRMRSIsInJlYWREb3VibGVCRSIsInJlYWREb3VibGVMRSIsIndyaXRlRG91YmxlQkUiLCJpbnNlcnREb3VibGVCRSIsIndyaXRlRG91YmxlTEUiLCJpbnNlcnREb3VibGVMRSIsInJlYWRTdHJpbmciLCJhcmcxIiwibGVuZ3RoVmFsIiwiY2hlY2tMZW5ndGhWYWx1ZSIsIk1hdGgiLCJtaW4iLCJzbGljZSIsInRvU3RyaW5nIiwiaW5zZXJ0U3RyaW5nIiwiY2hlY2tPZmZzZXRWYWx1ZSIsIl9oYW5kbGVTdHJpbmciLCJ3cml0ZVN0cmluZyIsImFyZzIiLCJyZWFkU3RyaW5nTlQiLCJudWxsUG9zIiwiaSIsImluc2VydFN0cmluZ05UIiwid3JpdGVTdHJpbmdOVCIsIndyaXRlT2Zmc2V0IiwicmVhZEJ1ZmZlciIsImVuZFBvaW50IiwiaW5zZXJ0QnVmZmVyIiwiX2hhbmRsZUJ1ZmZlciIsIndyaXRlQnVmZmVyIiwicmVhZEJ1ZmZlck5UIiwiaW5zZXJ0QnVmZmVyTlQiLCJ3cml0ZUJ1ZmZlck5UIiwiY2xlYXIiLCJyZW1haW5pbmciLCJyZWFkT2Zmc2V0IiwiY2hlY2tUYXJnZXRPZmZzZXQiLCJpbnRlcm5hbEJ1ZmZlciIsInRvQnVmZmVyIiwiZW5jb2RpbmdWYWwiLCJkZXN0cm95IiwiaXNJbnNlcnQiLCJhcmczIiwib2Zmc2V0VmFsIiwiYnl0ZUxlbmd0aCIsImVuc3VyZUluc2VydGFibGUiLCJfZW5zdXJlV3JpdGVhYmxlIiwid3JpdGUiLCJtYXgiLCJjb3B5IiwiZW5zdXJlUmVhZGFibGUiLCJJTlZBTElEX1JFQURfQkVZT05EX0JPVU5EUyIsImRhdGFMZW5ndGgiLCJfZW5zdXJlQ2FwYWNpdHkiLCJtaW5MZW5ndGgiLCJvbGRMZW5ndGgiLCJkYXRhIiwibmV3TGVuZ3RoIiwiZnVuYyIsImJ5dGVTaXplIiwiY2FsbCIsIklOVkFMSURfV1JJVEVfQkVZT05EX0JPVU5EUyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/smart-buffer@4.2.0/node_modules/smart-buffer/build/smartbuffer.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/smart-buffer@4.2.0/node_modules/smart-buffer/build/utils.js":
/*!********************************************************************************************!*\
  !*** ../../node_modules/.pnpm/smart-buffer@4.2.0/node_modules/smart-buffer/build/utils.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst buffer_1 = __webpack_require__(/*! buffer */ \"buffer\");\n/**\n * Error strings\n */ const ERRORS = {\n    INVALID_ENCODING: \"Invalid encoding provided. Please specify a valid encoding the internal Node.js Buffer supports.\",\n    INVALID_SMARTBUFFER_SIZE: \"Invalid size provided. Size must be a valid integer greater than zero.\",\n    INVALID_SMARTBUFFER_BUFFER: \"Invalid Buffer provided in SmartBufferOptions.\",\n    INVALID_SMARTBUFFER_OBJECT: \"Invalid SmartBufferOptions object supplied to SmartBuffer constructor or factory methods.\",\n    INVALID_OFFSET: \"An invalid offset value was provided.\",\n    INVALID_OFFSET_NON_NUMBER: \"An invalid offset value was provided. A numeric value is required.\",\n    INVALID_LENGTH: \"An invalid length value was provided.\",\n    INVALID_LENGTH_NON_NUMBER: \"An invalid length value was provived. A numeric value is required.\",\n    INVALID_TARGET_OFFSET: \"Target offset is beyond the bounds of the internal SmartBuffer data.\",\n    INVALID_TARGET_LENGTH: \"Specified length value moves cursor beyong the bounds of the internal SmartBuffer data.\",\n    INVALID_READ_BEYOND_BOUNDS: \"Attempted to read beyond the bounds of the managed data.\",\n    INVALID_WRITE_BEYOND_BOUNDS: \"Attempted to write beyond the bounds of the managed data.\"\n};\nexports.ERRORS = ERRORS;\n/**\n * Checks if a given encoding is a valid Buffer encoding. (Throws an exception if check fails)\n *\n * @param { String } encoding The encoding string to check.\n */ function checkEncoding(encoding) {\n    if (!buffer_1.Buffer.isEncoding(encoding)) {\n        throw new Error(ERRORS.INVALID_ENCODING);\n    }\n}\nexports.checkEncoding = checkEncoding;\n/**\n * Checks if a given number is a finite integer. (Throws an exception if check fails)\n *\n * @param { Number } value The number value to check.\n */ function isFiniteInteger(value) {\n    return typeof value === \"number\" && isFinite(value) && isInteger(value);\n}\nexports.isFiniteInteger = isFiniteInteger;\n/**\n * Checks if an offset/length value is valid. (Throws an exception if check fails)\n *\n * @param value The value to check.\n * @param offset True if checking an offset, false if checking a length.\n */ function checkOffsetOrLengthValue(value, offset) {\n    if (typeof value === \"number\") {\n        // Check for non finite/non integers\n        if (!isFiniteInteger(value) || value < 0) {\n            throw new Error(offset ? ERRORS.INVALID_OFFSET : ERRORS.INVALID_LENGTH);\n        }\n    } else {\n        throw new Error(offset ? ERRORS.INVALID_OFFSET_NON_NUMBER : ERRORS.INVALID_LENGTH_NON_NUMBER);\n    }\n}\n/**\n * Checks if a length value is valid. (Throws an exception if check fails)\n *\n * @param { Number } length The value to check.\n */ function checkLengthValue(length) {\n    checkOffsetOrLengthValue(length, false);\n}\nexports.checkLengthValue = checkLengthValue;\n/**\n * Checks if a offset value is valid. (Throws an exception if check fails)\n *\n * @param { Number } offset The value to check.\n */ function checkOffsetValue(offset) {\n    checkOffsetOrLengthValue(offset, true);\n}\nexports.checkOffsetValue = checkOffsetValue;\n/**\n * Checks if a target offset value is out of bounds. (Throws an exception if check fails)\n *\n * @param { Number } offset The offset value to check.\n * @param { SmartBuffer } buff The SmartBuffer instance to check against.\n */ function checkTargetOffset(offset, buff) {\n    if (offset < 0 || offset > buff.length) {\n        throw new Error(ERRORS.INVALID_TARGET_OFFSET);\n    }\n}\nexports.checkTargetOffset = checkTargetOffset;\n/**\n * Determines whether a given number is a integer.\n * @param value The number to check.\n */ function isInteger(value) {\n    return typeof value === \"number\" && isFinite(value) && Math.floor(value) === value;\n}\n/**\n * Throws if Node.js version is too low to support bigint\n */ function bigIntAndBufferInt64Check(bufferMethod) {\n    if (typeof BigInt === \"undefined\") {\n        throw new Error(\"Platform does not support JS BigInt type.\");\n    }\n    if (typeof buffer_1.Buffer.prototype[bufferMethod] === \"undefined\") {\n        throw new Error(`Platform does not support Buffer.prototype.${bufferMethod}.`);\n    }\n}\nexports.bigIntAndBufferInt64Check = bigIntAndBufferInt64Check; //# sourceMappingURL=utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3NtYXJ0LWJ1ZmZlckA0LjIuMC9ub2RlX21vZHVsZXMvc21hcnQtYnVmZmVyL2J1aWxkL3V0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdELE1BQU1DLFdBQVdDLG1CQUFPQSxDQUFDLHNCQUFRO0FBQ2pDOztDQUVDLEdBQ0QsTUFBTUMsU0FBUztJQUNYQyxrQkFBa0I7SUFDbEJDLDBCQUEwQjtJQUMxQkMsNEJBQTRCO0lBQzVCQyw0QkFBNEI7SUFDNUJDLGdCQUFnQjtJQUNoQkMsMkJBQTJCO0lBQzNCQyxnQkFBZ0I7SUFDaEJDLDJCQUEyQjtJQUMzQkMsdUJBQXVCO0lBQ3ZCQyx1QkFBdUI7SUFDdkJDLDRCQUE0QjtJQUM1QkMsNkJBQTZCO0FBQ2pDO0FBQ0FoQixjQUFjLEdBQUdJO0FBQ2pCOzs7O0NBSUMsR0FDRCxTQUFTYSxjQUFjQyxRQUFRO0lBQzNCLElBQUksQ0FBQ2hCLFNBQVNpQixNQUFNLENBQUNDLFVBQVUsQ0FBQ0YsV0FBVztRQUN2QyxNQUFNLElBQUlHLE1BQU1qQixPQUFPQyxnQkFBZ0I7SUFDM0M7QUFDSjtBQUNBTCxxQkFBcUIsR0FBR2lCO0FBQ3hCOzs7O0NBSUMsR0FDRCxTQUFTSyxnQkFBZ0JyQixLQUFLO0lBQzFCLE9BQU8sT0FBT0EsVUFBVSxZQUFZc0IsU0FBU3RCLFVBQVV1QixVQUFVdkI7QUFDckU7QUFDQUQsdUJBQXVCLEdBQUdzQjtBQUMxQjs7Ozs7Q0FLQyxHQUNELFNBQVNHLHlCQUF5QnhCLEtBQUssRUFBRXlCLE1BQU07SUFDM0MsSUFBSSxPQUFPekIsVUFBVSxVQUFVO1FBQzNCLG9DQUFvQztRQUNwQyxJQUFJLENBQUNxQixnQkFBZ0JyQixVQUFVQSxRQUFRLEdBQUc7WUFDdEMsTUFBTSxJQUFJb0IsTUFBTUssU0FBU3RCLE9BQU9LLGNBQWMsR0FBR0wsT0FBT08sY0FBYztRQUMxRTtJQUNKLE9BQ0s7UUFDRCxNQUFNLElBQUlVLE1BQU1LLFNBQVN0QixPQUFPTSx5QkFBeUIsR0FBR04sT0FBT1EseUJBQXlCO0lBQ2hHO0FBQ0o7QUFDQTs7OztDQUlDLEdBQ0QsU0FBU2UsaUJBQWlCQyxNQUFNO0lBQzVCSCx5QkFBeUJHLFFBQVE7QUFDckM7QUFDQTVCLHdCQUF3QixHQUFHMkI7QUFDM0I7Ozs7Q0FJQyxHQUNELFNBQVNFLGlCQUFpQkgsTUFBTTtJQUM1QkQseUJBQXlCQyxRQUFRO0FBQ3JDO0FBQ0ExQix3QkFBd0IsR0FBRzZCO0FBQzNCOzs7OztDQUtDLEdBQ0QsU0FBU0Msa0JBQWtCSixNQUFNLEVBQUVLLElBQUk7SUFDbkMsSUFBSUwsU0FBUyxLQUFLQSxTQUFTSyxLQUFLSCxNQUFNLEVBQUU7UUFDcEMsTUFBTSxJQUFJUCxNQUFNakIsT0FBT1MscUJBQXFCO0lBQ2hEO0FBQ0o7QUFDQWIseUJBQXlCLEdBQUc4QjtBQUM1Qjs7O0NBR0MsR0FDRCxTQUFTTixVQUFVdkIsS0FBSztJQUNwQixPQUFPLE9BQU9BLFVBQVUsWUFBWXNCLFNBQVN0QixVQUFVK0IsS0FBS0MsS0FBSyxDQUFDaEMsV0FBV0E7QUFDakY7QUFDQTs7Q0FFQyxHQUNELFNBQVNpQywwQkFBMEJDLFlBQVk7SUFDM0MsSUFBSSxPQUFPQyxXQUFXLGFBQWE7UUFDL0IsTUFBTSxJQUFJZixNQUFNO0lBQ3BCO0lBQ0EsSUFBSSxPQUFPbkIsU0FBU2lCLE1BQU0sQ0FBQ2tCLFNBQVMsQ0FBQ0YsYUFBYSxLQUFLLGFBQWE7UUFDaEUsTUFBTSxJQUFJZCxNQUFNLENBQUMsMkNBQTJDLEVBQUVjLGFBQWEsQ0FBQyxDQUFDO0lBQ2pGO0FBQ0o7QUFDQW5DLGlDQUFpQyxHQUFHa0MsMkJBQ3BDLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vc21hcnQtYnVmZmVyQDQuMi4wL25vZGVfbW9kdWxlcy9zbWFydC1idWZmZXIvYnVpbGQvdXRpbHMuanM/YjM5YSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGJ1ZmZlcl8xID0gcmVxdWlyZShcImJ1ZmZlclwiKTtcbi8qKlxuICogRXJyb3Igc3RyaW5nc1xuICovXG5jb25zdCBFUlJPUlMgPSB7XG4gICAgSU5WQUxJRF9FTkNPRElORzogJ0ludmFsaWQgZW5jb2RpbmcgcHJvdmlkZWQuIFBsZWFzZSBzcGVjaWZ5IGEgdmFsaWQgZW5jb2RpbmcgdGhlIGludGVybmFsIE5vZGUuanMgQnVmZmVyIHN1cHBvcnRzLicsXG4gICAgSU5WQUxJRF9TTUFSVEJVRkZFUl9TSVpFOiAnSW52YWxpZCBzaXplIHByb3ZpZGVkLiBTaXplIG11c3QgYmUgYSB2YWxpZCBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiB6ZXJvLicsXG4gICAgSU5WQUxJRF9TTUFSVEJVRkZFUl9CVUZGRVI6ICdJbnZhbGlkIEJ1ZmZlciBwcm92aWRlZCBpbiBTbWFydEJ1ZmZlck9wdGlvbnMuJyxcbiAgICBJTlZBTElEX1NNQVJUQlVGRkVSX09CSkVDVDogJ0ludmFsaWQgU21hcnRCdWZmZXJPcHRpb25zIG9iamVjdCBzdXBwbGllZCB0byBTbWFydEJ1ZmZlciBjb25zdHJ1Y3RvciBvciBmYWN0b3J5IG1ldGhvZHMuJyxcbiAgICBJTlZBTElEX09GRlNFVDogJ0FuIGludmFsaWQgb2Zmc2V0IHZhbHVlIHdhcyBwcm92aWRlZC4nLFxuICAgIElOVkFMSURfT0ZGU0VUX05PTl9OVU1CRVI6ICdBbiBpbnZhbGlkIG9mZnNldCB2YWx1ZSB3YXMgcHJvdmlkZWQuIEEgbnVtZXJpYyB2YWx1ZSBpcyByZXF1aXJlZC4nLFxuICAgIElOVkFMSURfTEVOR1RIOiAnQW4gaW52YWxpZCBsZW5ndGggdmFsdWUgd2FzIHByb3ZpZGVkLicsXG4gICAgSU5WQUxJRF9MRU5HVEhfTk9OX05VTUJFUjogJ0FuIGludmFsaWQgbGVuZ3RoIHZhbHVlIHdhcyBwcm92aXZlZC4gQSBudW1lcmljIHZhbHVlIGlzIHJlcXVpcmVkLicsXG4gICAgSU5WQUxJRF9UQVJHRVRfT0ZGU0VUOiAnVGFyZ2V0IG9mZnNldCBpcyBiZXlvbmQgdGhlIGJvdW5kcyBvZiB0aGUgaW50ZXJuYWwgU21hcnRCdWZmZXIgZGF0YS4nLFxuICAgIElOVkFMSURfVEFSR0VUX0xFTkdUSDogJ1NwZWNpZmllZCBsZW5ndGggdmFsdWUgbW92ZXMgY3Vyc29yIGJleW9uZyB0aGUgYm91bmRzIG9mIHRoZSBpbnRlcm5hbCBTbWFydEJ1ZmZlciBkYXRhLicsXG4gICAgSU5WQUxJRF9SRUFEX0JFWU9ORF9CT1VORFM6ICdBdHRlbXB0ZWQgdG8gcmVhZCBiZXlvbmQgdGhlIGJvdW5kcyBvZiB0aGUgbWFuYWdlZCBkYXRhLicsXG4gICAgSU5WQUxJRF9XUklURV9CRVlPTkRfQk9VTkRTOiAnQXR0ZW1wdGVkIHRvIHdyaXRlIGJleW9uZCB0aGUgYm91bmRzIG9mIHRoZSBtYW5hZ2VkIGRhdGEuJ1xufTtcbmV4cG9ydHMuRVJST1JTID0gRVJST1JTO1xuLyoqXG4gKiBDaGVja3MgaWYgYSBnaXZlbiBlbmNvZGluZyBpcyBhIHZhbGlkIEJ1ZmZlciBlbmNvZGluZy4gKFRocm93cyBhbiBleGNlcHRpb24gaWYgY2hlY2sgZmFpbHMpXG4gKlxuICogQHBhcmFtIHsgU3RyaW5nIH0gZW5jb2RpbmcgVGhlIGVuY29kaW5nIHN0cmluZyB0byBjaGVjay5cbiAqL1xuZnVuY3Rpb24gY2hlY2tFbmNvZGluZyhlbmNvZGluZykge1xuICAgIGlmICghYnVmZmVyXzEuQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihFUlJPUlMuSU5WQUxJRF9FTkNPRElORyk7XG4gICAgfVxufVxuZXhwb3J0cy5jaGVja0VuY29kaW5nID0gY2hlY2tFbmNvZGluZztcbi8qKlxuICogQ2hlY2tzIGlmIGEgZ2l2ZW4gbnVtYmVyIGlzIGEgZmluaXRlIGludGVnZXIuIChUaHJvd3MgYW4gZXhjZXB0aW9uIGlmIGNoZWNrIGZhaWxzKVxuICpcbiAqIEBwYXJhbSB7IE51bWJlciB9IHZhbHVlIFRoZSBudW1iZXIgdmFsdWUgdG8gY2hlY2suXG4gKi9cbmZ1bmN0aW9uIGlzRmluaXRlSW50ZWdlcih2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIGlzRmluaXRlKHZhbHVlKSAmJiBpc0ludGVnZXIodmFsdWUpO1xufVxuZXhwb3J0cy5pc0Zpbml0ZUludGVnZXIgPSBpc0Zpbml0ZUludGVnZXI7XG4vKipcbiAqIENoZWNrcyBpZiBhbiBvZmZzZXQvbGVuZ3RoIHZhbHVlIGlzIHZhbGlkLiAoVGhyb3dzIGFuIGV4Y2VwdGlvbiBpZiBjaGVjayBmYWlscylcbiAqXG4gKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIG9mZnNldCBUcnVlIGlmIGNoZWNraW5nIGFuIG9mZnNldCwgZmFsc2UgaWYgY2hlY2tpbmcgYSBsZW5ndGguXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0T3JMZW5ndGhWYWx1ZSh2YWx1ZSwgb2Zmc2V0KSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgLy8gQ2hlY2sgZm9yIG5vbiBmaW5pdGUvbm9uIGludGVnZXJzXG4gICAgICAgIGlmICghaXNGaW5pdGVJbnRlZ2VyKHZhbHVlKSB8fCB2YWx1ZSA8IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihvZmZzZXQgPyBFUlJPUlMuSU5WQUxJRF9PRkZTRVQgOiBFUlJPUlMuSU5WQUxJRF9MRU5HVEgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3Iob2Zmc2V0ID8gRVJST1JTLklOVkFMSURfT0ZGU0VUX05PTl9OVU1CRVIgOiBFUlJPUlMuSU5WQUxJRF9MRU5HVEhfTk9OX05VTUJFUik7XG4gICAgfVxufVxuLyoqXG4gKiBDaGVja3MgaWYgYSBsZW5ndGggdmFsdWUgaXMgdmFsaWQuIChUaHJvd3MgYW4gZXhjZXB0aW9uIGlmIGNoZWNrIGZhaWxzKVxuICpcbiAqIEBwYXJhbSB7IE51bWJlciB9IGxlbmd0aCBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKi9cbmZ1bmN0aW9uIGNoZWNrTGVuZ3RoVmFsdWUobGVuZ3RoKSB7XG4gICAgY2hlY2tPZmZzZXRPckxlbmd0aFZhbHVlKGxlbmd0aCwgZmFsc2UpO1xufVxuZXhwb3J0cy5jaGVja0xlbmd0aFZhbHVlID0gY2hlY2tMZW5ndGhWYWx1ZTtcbi8qKlxuICogQ2hlY2tzIGlmIGEgb2Zmc2V0IHZhbHVlIGlzIHZhbGlkLiAoVGhyb3dzIGFuIGV4Y2VwdGlvbiBpZiBjaGVjayBmYWlscylcbiAqXG4gKiBAcGFyYW0geyBOdW1iZXIgfSBvZmZzZXQgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICovXG5mdW5jdGlvbiBjaGVja09mZnNldFZhbHVlKG9mZnNldCkge1xuICAgIGNoZWNrT2Zmc2V0T3JMZW5ndGhWYWx1ZShvZmZzZXQsIHRydWUpO1xufVxuZXhwb3J0cy5jaGVja09mZnNldFZhbHVlID0gY2hlY2tPZmZzZXRWYWx1ZTtcbi8qKlxuICogQ2hlY2tzIGlmIGEgdGFyZ2V0IG9mZnNldCB2YWx1ZSBpcyBvdXQgb2YgYm91bmRzLiAoVGhyb3dzIGFuIGV4Y2VwdGlvbiBpZiBjaGVjayBmYWlscylcbiAqXG4gKiBAcGFyYW0geyBOdW1iZXIgfSBvZmZzZXQgVGhlIG9mZnNldCB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSB7IFNtYXJ0QnVmZmVyIH0gYnVmZiBUaGUgU21hcnRCdWZmZXIgaW5zdGFuY2UgdG8gY2hlY2sgYWdhaW5zdC5cbiAqL1xuZnVuY3Rpb24gY2hlY2tUYXJnZXRPZmZzZXQob2Zmc2V0LCBidWZmKSB7XG4gICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ID4gYnVmZi5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKEVSUk9SUy5JTlZBTElEX1RBUkdFVF9PRkZTRVQpO1xuICAgIH1cbn1cbmV4cG9ydHMuY2hlY2tUYXJnZXRPZmZzZXQgPSBjaGVja1RhcmdldE9mZnNldDtcbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIGEgZ2l2ZW4gbnVtYmVyIGlzIGEgaW50ZWdlci5cbiAqIEBwYXJhbSB2YWx1ZSBUaGUgbnVtYmVyIHRvIGNoZWNrLlxuICovXG5mdW5jdGlvbiBpc0ludGVnZXIodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiBpc0Zpbml0ZSh2YWx1ZSkgJiYgTWF0aC5mbG9vcih2YWx1ZSkgPT09IHZhbHVlO1xufVxuLyoqXG4gKiBUaHJvd3MgaWYgTm9kZS5qcyB2ZXJzaW9uIGlzIHRvbyBsb3cgdG8gc3VwcG9ydCBiaWdpbnRcbiAqL1xuZnVuY3Rpb24gYmlnSW50QW5kQnVmZmVySW50NjRDaGVjayhidWZmZXJNZXRob2QpIHtcbiAgICBpZiAodHlwZW9mIEJpZ0ludCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQbGF0Zm9ybSBkb2VzIG5vdCBzdXBwb3J0IEpTIEJpZ0ludCB0eXBlLicpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGJ1ZmZlcl8xLkJ1ZmZlci5wcm90b3R5cGVbYnVmZmVyTWV0aG9kXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQbGF0Zm9ybSBkb2VzIG5vdCBzdXBwb3J0IEJ1ZmZlci5wcm90b3R5cGUuJHtidWZmZXJNZXRob2R9LmApO1xuICAgIH1cbn1cbmV4cG9ydHMuYmlnSW50QW5kQnVmZmVySW50NjRDaGVjayA9IGJpZ0ludEFuZEJ1ZmZlckludDY0Q2hlY2s7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJidWZmZXJfMSIsInJlcXVpcmUiLCJFUlJPUlMiLCJJTlZBTElEX0VOQ09ESU5HIiwiSU5WQUxJRF9TTUFSVEJVRkZFUl9TSVpFIiwiSU5WQUxJRF9TTUFSVEJVRkZFUl9CVUZGRVIiLCJJTlZBTElEX1NNQVJUQlVGRkVSX09CSkVDVCIsIklOVkFMSURfT0ZGU0VUIiwiSU5WQUxJRF9PRkZTRVRfTk9OX05VTUJFUiIsIklOVkFMSURfTEVOR1RIIiwiSU5WQUxJRF9MRU5HVEhfTk9OX05VTUJFUiIsIklOVkFMSURfVEFSR0VUX09GRlNFVCIsIklOVkFMSURfVEFSR0VUX0xFTkdUSCIsIklOVkFMSURfUkVBRF9CRVlPTkRfQk9VTkRTIiwiSU5WQUxJRF9XUklURV9CRVlPTkRfQk9VTkRTIiwiY2hlY2tFbmNvZGluZyIsImVuY29kaW5nIiwiQnVmZmVyIiwiaXNFbmNvZGluZyIsIkVycm9yIiwiaXNGaW5pdGVJbnRlZ2VyIiwiaXNGaW5pdGUiLCJpc0ludGVnZXIiLCJjaGVja09mZnNldE9yTGVuZ3RoVmFsdWUiLCJvZmZzZXQiLCJjaGVja0xlbmd0aFZhbHVlIiwibGVuZ3RoIiwiY2hlY2tPZmZzZXRWYWx1ZSIsImNoZWNrVGFyZ2V0T2Zmc2V0IiwiYnVmZiIsIk1hdGgiLCJmbG9vciIsImJpZ0ludEFuZEJ1ZmZlckludDY0Q2hlY2siLCJidWZmZXJNZXRob2QiLCJCaWdJbnQiLCJwcm90b3R5cGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/smart-buffer@4.2.0/node_modules/smart-buffer/build/utils.js\n");

/***/ })

};
;