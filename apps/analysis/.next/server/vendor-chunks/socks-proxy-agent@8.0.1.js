"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/socks-proxy-agent@8.0.1";
exports.ids = ["vendor-chunks/socks-proxy-agent@8.0.1"];
exports.modules = {

/***/ "(rsc)/../../node_modules/.pnpm/socks-proxy-agent@8.0.1/node_modules/socks-proxy-agent/dist/index.js":
/*!*****************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/socks-proxy-agent@8.0.1/node_modules/socks-proxy-agent/dist/index.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar __createBinding = (void 0) && (void 0).__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n        desc = {\n            enumerable: true,\n            get: function() {\n                return m[k];\n            }\n        };\n    }\n    Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar __setModuleDefault = (void 0) && (void 0).__setModuleDefault || (Object.create ? function(o, v) {\n    Object.defineProperty(o, \"default\", {\n        enumerable: true,\n        value: v\n    });\n} : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (void 0) && (void 0).__importStar || function(mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) {\n        for(var k in mod)if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    }\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (void 0) && (void 0).__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.SocksProxyAgent = void 0;\nconst socks_1 = __webpack_require__(/*! socks */ \"(rsc)/../../node_modules/.pnpm/socks@2.7.1/node_modules/socks/build/index.js\");\nconst agent_base_1 = __webpack_require__(/*! agent-base */ \"(rsc)/../../node_modules/.pnpm/agent-base@7.1.0/node_modules/agent-base/dist/index.js\");\nconst debug_1 = __importDefault(__webpack_require__(/*! debug */ \"(rsc)/../../node_modules/.pnpm/debug@4.3.4/node_modules/debug/src/index.js\"));\nconst dns = __importStar(__webpack_require__(/*! dns */ \"dns\"));\nconst net = __importStar(__webpack_require__(/*! net */ \"net\"));\nconst tls = __importStar(__webpack_require__(/*! tls */ \"tls\"));\nconst debug = (0, debug_1.default)(\"socks-proxy-agent\");\nfunction parseSocksURL(url) {\n    let lookup = false;\n    let type = 5;\n    const host = url.hostname;\n    // From RFC 1928, Section 3: https://tools.ietf.org/html/rfc1928#section-3\n    // \"The SOCKS service is conventionally located on TCP port 1080\"\n    const port = parseInt(url.port, 10) || 1080;\n    // figure out if we want socks v4 or v5, based on the \"protocol\" used.\n    // Defaults to 5.\n    switch(url.protocol.replace(\":\", \"\")){\n        case \"socks4\":\n            lookup = true;\n            type = 4;\n            break;\n        // pass through\n        case \"socks4a\":\n            type = 4;\n            break;\n        case \"socks5\":\n            lookup = true;\n            type = 5;\n            break;\n        // pass through\n        case \"socks\":\n            type = 5;\n            break;\n        case \"socks5h\":\n            type = 5;\n            break;\n        default:\n            throw new TypeError(`A \"socks\" protocol must be specified! Got: ${String(url.protocol)}`);\n    }\n    const proxy = {\n        host,\n        port,\n        type\n    };\n    if (url.username) {\n        Object.defineProperty(proxy, \"userId\", {\n            value: decodeURIComponent(url.username),\n            enumerable: false\n        });\n    }\n    if (url.password != null) {\n        Object.defineProperty(proxy, \"password\", {\n            value: decodeURIComponent(url.password),\n            enumerable: false\n        });\n    }\n    return {\n        lookup,\n        proxy\n    };\n}\nclass SocksProxyAgent extends agent_base_1.Agent {\n    constructor(uri, opts){\n        super(opts);\n        const url = typeof uri === \"string\" ? new URL(uri) : uri;\n        const { proxy, lookup } = parseSocksURL(url);\n        this.shouldLookup = lookup;\n        this.proxy = proxy;\n        this.timeout = opts?.timeout ?? null;\n    }\n    /**\n     * Initiates a SOCKS connection to the specified SOCKS proxy server,\n     * which in turn connects to the specified remote host and port.\n     */ async connect(req, opts) {\n        const { shouldLookup, proxy, timeout } = this;\n        if (!opts.host) {\n            throw new Error(\"No `host` defined!\");\n        }\n        let { host } = opts;\n        const { port, lookup: lookupFn = dns.lookup } = opts;\n        if (shouldLookup) {\n            // Client-side DNS resolution for \"4\" and \"5\" socks proxy versions.\n            host = await new Promise((resolve, reject)=>{\n                // Use the request's custom lookup, if one was configured:\n                lookupFn(host, {}, (err, res)=>{\n                    if (err) {\n                        reject(err);\n                    } else {\n                        resolve(res);\n                    }\n                });\n            });\n        }\n        const socksOpts = {\n            proxy,\n            destination: {\n                host,\n                port: typeof port === \"number\" ? port : parseInt(port, 10)\n            },\n            command: \"connect\",\n            timeout: timeout ?? undefined\n        };\n        const cleanup = (tlsSocket)=>{\n            req.destroy();\n            socket.destroy();\n            if (tlsSocket) tlsSocket.destroy();\n        };\n        debug(\"Creating socks proxy connection: %o\", socksOpts);\n        const { socket } = await socks_1.SocksClient.createConnection(socksOpts);\n        debug(\"Successfully created socks proxy connection\");\n        if (timeout !== null) {\n            socket.setTimeout(timeout);\n            socket.on(\"timeout\", ()=>cleanup());\n        }\n        if (opts.secureEndpoint) {\n            // The proxy is connecting to a TLS server, so upgrade\n            // this socket connection to a TLS connection.\n            debug(\"Upgrading socket connection to TLS\");\n            const servername = opts.servername || opts.host;\n            const tlsSocket = tls.connect({\n                ...omit(opts, \"host\", \"path\", \"port\"),\n                socket,\n                servername: net.isIP(servername) ? undefined : servername\n            });\n            tlsSocket.once(\"error\", (error)=>{\n                debug(\"Socket TLS error\", error.message);\n                cleanup(tlsSocket);\n            });\n            return tlsSocket;\n        }\n        return socket;\n    }\n}\nSocksProxyAgent.protocols = [\n    \"socks\",\n    \"socks4\",\n    \"socks4a\",\n    \"socks5\",\n    \"socks5h\"\n];\nexports.SocksProxyAgent = SocksProxyAgent;\nfunction omit(obj, ...keys) {\n    const ret = {};\n    let key;\n    for(key in obj){\n        if (!keys.includes(key)) {\n            ret[key] = obj[key];\n        }\n    }\n    return ret;\n} //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3NvY2tzLXByb3h5LWFnZW50QDguMC4xL25vZGVfbW9kdWxlcy9zb2Nrcy1wcm94eS1hZ2VudC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsSUFBSUEsa0JBQWtCLENBQUMsTUFBRyxLQUFLLE9BQUcsRUFBRUEsZUFBZSxJQUFNQyxDQUFBQSxPQUFPQyxNQUFNLEdBQUksU0FBU0MsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsRUFBRTtJQUMxRixJQUFJQSxPQUFPQyxXQUFXRCxLQUFLRDtJQUMzQixJQUFJRyxPQUFPUCxPQUFPUSx3QkFBd0IsQ0FBQ0wsR0FBR0M7SUFDOUMsSUFBSSxDQUFDRyxRQUFTLFVBQVNBLE9BQU8sQ0FBQ0osRUFBRU0sVUFBVSxHQUFHRixLQUFLRyxRQUFRLElBQUlILEtBQUtJLFlBQVksR0FBRztRQUNqRkosT0FBTztZQUFFSyxZQUFZO1lBQU1DLEtBQUs7Z0JBQWEsT0FBT1YsQ0FBQyxDQUFDQyxFQUFFO1lBQUU7UUFBRTtJQUM5RDtJQUNBSixPQUFPYyxjQUFjLENBQUNaLEdBQUdHLElBQUlFO0FBQ2pDLElBQU0sU0FBU0wsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsRUFBRTtJQUN0QixJQUFJQSxPQUFPQyxXQUFXRCxLQUFLRDtJQUMzQkYsQ0FBQyxDQUFDRyxHQUFHLEdBQUdGLENBQUMsQ0FBQ0MsRUFBRTtBQUNoQixDQUFDO0FBQ0QsSUFBSVcscUJBQXFCLENBQUMsTUFBRyxLQUFLLE9BQUcsRUFBRUEsa0JBQWtCLElBQU1mLENBQUFBLE9BQU9DLE1BQU0sR0FBSSxTQUFTQyxDQUFDLEVBQUVjLENBQUM7SUFDekZoQixPQUFPYyxjQUFjLENBQUNaLEdBQUcsV0FBVztRQUFFVSxZQUFZO1FBQU1LLE9BQU9EO0lBQUU7QUFDckUsSUFBSyxTQUFTZCxDQUFDLEVBQUVjLENBQUM7SUFDZGQsQ0FBQyxDQUFDLFVBQVUsR0FBR2M7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T0FBT0csVUFBVSxDQUFDbkI7WUFDbEJnQixPQUFPSSxFQUFFLENBQUMsV0FBVyxJQUFNUDtRQUMvQjtRQUNBLElBQUloQixLQUFLd0IsY0FBYyxFQUFFO1lBQ3JCLHNEQUFzRDtZQUN0RCw4Q0FBOEM7WUFDOUM3QyxNQUFNO1lBQ04sTUFBTThDLGFBQWF6QixLQUFLeUIsVUFBVSxJQUFJekIsS0FBS2YsSUFBSTtZQUMvQyxNQUFNZ0MsWUFBWXZDLElBQUkwQixPQUFPLENBQUM7Z0JBQzFCLEdBQUdzQixLQUFLMUIsTUFBTSxRQUFRLFFBQVEsT0FBTztnQkFDckNtQjtnQkFDQU0sWUFBWWhELElBQUlrRCxJQUFJLENBQUNGLGNBQWMxRSxZQUFZMEU7WUFDbkQ7WUFDQVIsVUFBVVcsSUFBSSxDQUFDLFNBQVMsQ0FBQ0M7Z0JBQ3JCbEQsTUFBTSxvQkFBb0JrRCxNQUFNQyxPQUFPO2dCQUN2Q2QsUUFBUUM7WUFDWjtZQUNBLE9BQU9BO1FBQ1g7UUFDQSxPQUFPRTtJQUNYO0FBQ0o7QUFDQWhELGdCQUFnQjRELFNBQVMsR0FBRztJQUN4QjtJQUNBO0lBQ0E7SUFDQTtJQUNBO0NBQ0g7QUFDRDdELHVCQUF1QixHQUFHQztBQUMxQixTQUFTdUQsS0FBS00sR0FBRyxFQUFFLEdBQUdDLElBQUk7SUFDdEIsTUFBTUMsTUFBTSxDQUFDO0lBQ2IsSUFBSUM7SUFDSixJQUFLQSxPQUFPSCxJQUFLO1FBQ2IsSUFBSSxDQUFDQyxLQUFLRyxRQUFRLENBQUNELE1BQU07WUFDckJELEdBQUcsQ0FBQ0MsSUFBSSxHQUFHSCxHQUFHLENBQUNHLElBQUk7UUFDdkI7SUFDSjtJQUNBLE9BQU9EO0FBQ1gsRUFDQSxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3NvY2tzLXByb3h5LWFnZW50QDguMC4xL25vZGVfbW9kdWxlcy9zb2Nrcy1wcm94eS1hZ2VudC9kaXN0L2luZGV4LmpzPzZjODkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU29ja3NQcm94eUFnZW50ID0gdm9pZCAwO1xuY29uc3Qgc29ja3NfMSA9IHJlcXVpcmUoXCJzb2Nrc1wiKTtcbmNvbnN0IGFnZW50X2Jhc2VfMSA9IHJlcXVpcmUoXCJhZ2VudC1iYXNlXCIpO1xuY29uc3QgZGVidWdfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiZGVidWdcIikpO1xuY29uc3QgZG5zID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJkbnNcIikpO1xuY29uc3QgbmV0ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJuZXRcIikpO1xuY29uc3QgdGxzID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJ0bHNcIikpO1xuY29uc3QgZGVidWcgPSAoMCwgZGVidWdfMS5kZWZhdWx0KSgnc29ja3MtcHJveHktYWdlbnQnKTtcbmZ1bmN0aW9uIHBhcnNlU29ja3NVUkwodXJsKSB7XG4gICAgbGV0IGxvb2t1cCA9IGZhbHNlO1xuICAgIGxldCB0eXBlID0gNTtcbiAgICBjb25zdCBob3N0ID0gdXJsLmhvc3RuYW1lO1xuICAgIC8vIEZyb20gUkZDIDE5MjgsIFNlY3Rpb24gMzogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzE5Mjgjc2VjdGlvbi0zXG4gICAgLy8gXCJUaGUgU09DS1Mgc2VydmljZSBpcyBjb252ZW50aW9uYWxseSBsb2NhdGVkIG9uIFRDUCBwb3J0IDEwODBcIlxuICAgIGNvbnN0IHBvcnQgPSBwYXJzZUludCh1cmwucG9ydCwgMTApIHx8IDEwODA7XG4gICAgLy8gZmlndXJlIG91dCBpZiB3ZSB3YW50IHNvY2tzIHY0IG9yIHY1LCBiYXNlZCBvbiB0aGUgXCJwcm90b2NvbFwiIHVzZWQuXG4gICAgLy8gRGVmYXVsdHMgdG8gNS5cbiAgICBzd2l0Y2ggKHVybC5wcm90b2NvbC5yZXBsYWNlKCc6JywgJycpKSB7XG4gICAgICAgIGNhc2UgJ3NvY2tzNCc6XG4gICAgICAgICAgICBsb29rdXAgPSB0cnVlO1xuICAgICAgICAgICAgdHlwZSA9IDQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gcGFzcyB0aHJvdWdoXG4gICAgICAgIGNhc2UgJ3NvY2tzNGEnOlxuICAgICAgICAgICAgdHlwZSA9IDQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnc29ja3M1JzpcbiAgICAgICAgICAgIGxvb2t1cCA9IHRydWU7XG4gICAgICAgICAgICB0eXBlID0gNTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBwYXNzIHRocm91Z2hcbiAgICAgICAgY2FzZSAnc29ja3MnOiAvLyBubyB2ZXJzaW9uIHNwZWNpZmllZCwgZGVmYXVsdCB0byA1aFxuICAgICAgICAgICAgdHlwZSA9IDU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnc29ja3M1aCc6XG4gICAgICAgICAgICB0eXBlID0gNTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgQSBcInNvY2tzXCIgcHJvdG9jb2wgbXVzdCBiZSBzcGVjaWZpZWQhIEdvdDogJHtTdHJpbmcodXJsLnByb3RvY29sKX1gKTtcbiAgICB9XG4gICAgY29uc3QgcHJveHkgPSB7XG4gICAgICAgIGhvc3QsXG4gICAgICAgIHBvcnQsXG4gICAgICAgIHR5cGUsXG4gICAgfTtcbiAgICBpZiAodXJsLnVzZXJuYW1lKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm94eSwgJ3VzZXJJZCcsIHtcbiAgICAgICAgICAgIHZhbHVlOiBkZWNvZGVVUklDb21wb25lbnQodXJsLnVzZXJuYW1lKSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHVybC5wYXNzd29yZCAhPSBudWxsKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm94eSwgJ3Bhc3N3b3JkJywge1xuICAgICAgICAgICAgdmFsdWU6IGRlY29kZVVSSUNvbXBvbmVudCh1cmwucGFzc3dvcmQpLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4geyBsb29rdXAsIHByb3h5IH07XG59XG5jbGFzcyBTb2Nrc1Byb3h5QWdlbnQgZXh0ZW5kcyBhZ2VudF9iYXNlXzEuQWdlbnQge1xuICAgIGNvbnN0cnVjdG9yKHVyaSwgb3B0cykge1xuICAgICAgICBzdXBlcihvcHRzKTtcbiAgICAgICAgY29uc3QgdXJsID0gdHlwZW9mIHVyaSA9PT0gJ3N0cmluZycgPyBuZXcgVVJMKHVyaSkgOiB1cmk7XG4gICAgICAgIGNvbnN0IHsgcHJveHksIGxvb2t1cCB9ID0gcGFyc2VTb2Nrc1VSTCh1cmwpO1xuICAgICAgICB0aGlzLnNob3VsZExvb2t1cCA9IGxvb2t1cDtcbiAgICAgICAgdGhpcy5wcm94eSA9IHByb3h5O1xuICAgICAgICB0aGlzLnRpbWVvdXQgPSBvcHRzPy50aW1lb3V0ID8/IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluaXRpYXRlcyBhIFNPQ0tTIGNvbm5lY3Rpb24gdG8gdGhlIHNwZWNpZmllZCBTT0NLUyBwcm94eSBzZXJ2ZXIsXG4gICAgICogd2hpY2ggaW4gdHVybiBjb25uZWN0cyB0byB0aGUgc3BlY2lmaWVkIHJlbW90ZSBob3N0IGFuZCBwb3J0LlxuICAgICAqL1xuICAgIGFzeW5jIGNvbm5lY3QocmVxLCBvcHRzKSB7XG4gICAgICAgIGNvbnN0IHsgc2hvdWxkTG9va3VwLCBwcm94eSwgdGltZW91dCB9ID0gdGhpcztcbiAgICAgICAgaWYgKCFvcHRzLmhvc3QpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gYGhvc3RgIGRlZmluZWQhJyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHsgaG9zdCB9ID0gb3B0cztcbiAgICAgICAgY29uc3QgeyBwb3J0LCBsb29rdXA6IGxvb2t1cEZuID0gZG5zLmxvb2t1cCB9ID0gb3B0cztcbiAgICAgICAgaWYgKHNob3VsZExvb2t1cCkge1xuICAgICAgICAgICAgLy8gQ2xpZW50LXNpZGUgRE5TIHJlc29sdXRpb24gZm9yIFwiNFwiIGFuZCBcIjVcIiBzb2NrcyBwcm94eSB2ZXJzaW9ucy5cbiAgICAgICAgICAgIGhvc3QgPSBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gVXNlIHRoZSByZXF1ZXN0J3MgY3VzdG9tIGxvb2t1cCwgaWYgb25lIHdhcyBjb25maWd1cmVkOlxuICAgICAgICAgICAgICAgIGxvb2t1cEZuKGhvc3QsIHt9LCAoZXJyLCByZXMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNvY2tzT3B0cyA9IHtcbiAgICAgICAgICAgIHByb3h5LFxuICAgICAgICAgICAgZGVzdGluYXRpb246IHtcbiAgICAgICAgICAgICAgICBob3N0LFxuICAgICAgICAgICAgICAgIHBvcnQ6IHR5cGVvZiBwb3J0ID09PSAnbnVtYmVyJyA/IHBvcnQgOiBwYXJzZUludChwb3J0LCAxMCksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29tbWFuZDogJ2Nvbm5lY3QnLFxuICAgICAgICAgICAgdGltZW91dDogdGltZW91dCA/PyB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNsZWFudXAgPSAodGxzU29ja2V0KSA9PiB7XG4gICAgICAgICAgICByZXEuZGVzdHJveSgpO1xuICAgICAgICAgICAgc29ja2V0LmRlc3Ryb3koKTtcbiAgICAgICAgICAgIGlmICh0bHNTb2NrZXQpXG4gICAgICAgICAgICAgICAgdGxzU29ja2V0LmRlc3Ryb3koKTtcbiAgICAgICAgfTtcbiAgICAgICAgZGVidWcoJ0NyZWF0aW5nIHNvY2tzIHByb3h5IGNvbm5lY3Rpb246ICVvJywgc29ja3NPcHRzKTtcbiAgICAgICAgY29uc3QgeyBzb2NrZXQgfSA9IGF3YWl0IHNvY2tzXzEuU29ja3NDbGllbnQuY3JlYXRlQ29ubmVjdGlvbihzb2Nrc09wdHMpO1xuICAgICAgICBkZWJ1ZygnU3VjY2Vzc2Z1bGx5IGNyZWF0ZWQgc29ja3MgcHJveHkgY29ubmVjdGlvbicpO1xuICAgICAgICBpZiAodGltZW91dCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgc29ja2V0LnNldFRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgICBzb2NrZXQub24oJ3RpbWVvdXQnLCAoKSA9PiBjbGVhbnVwKCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRzLnNlY3VyZUVuZHBvaW50KSB7XG4gICAgICAgICAgICAvLyBUaGUgcHJveHkgaXMgY29ubmVjdGluZyB0byBhIFRMUyBzZXJ2ZXIsIHNvIHVwZ3JhZGVcbiAgICAgICAgICAgIC8vIHRoaXMgc29ja2V0IGNvbm5lY3Rpb24gdG8gYSBUTFMgY29ubmVjdGlvbi5cbiAgICAgICAgICAgIGRlYnVnKCdVcGdyYWRpbmcgc29ja2V0IGNvbm5lY3Rpb24gdG8gVExTJyk7XG4gICAgICAgICAgICBjb25zdCBzZXJ2ZXJuYW1lID0gb3B0cy5zZXJ2ZXJuYW1lIHx8IG9wdHMuaG9zdDtcbiAgICAgICAgICAgIGNvbnN0IHRsc1NvY2tldCA9IHRscy5jb25uZWN0KHtcbiAgICAgICAgICAgICAgICAuLi5vbWl0KG9wdHMsICdob3N0JywgJ3BhdGgnLCAncG9ydCcpLFxuICAgICAgICAgICAgICAgIHNvY2tldCxcbiAgICAgICAgICAgICAgICBzZXJ2ZXJuYW1lOiBuZXQuaXNJUChzZXJ2ZXJuYW1lKSA/IHVuZGVmaW5lZCA6IHNlcnZlcm5hbWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRsc1NvY2tldC5vbmNlKCdlcnJvcicsIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgIGRlYnVnKCdTb2NrZXQgVExTIGVycm9yJywgZXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgY2xlYW51cCh0bHNTb2NrZXQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdGxzU29ja2V0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzb2NrZXQ7XG4gICAgfVxufVxuU29ja3NQcm94eUFnZW50LnByb3RvY29scyA9IFtcbiAgICAnc29ja3MnLFxuICAgICdzb2NrczQnLFxuICAgICdzb2NrczRhJyxcbiAgICAnc29ja3M1JyxcbiAgICAnc29ja3M1aCcsXG5dO1xuZXhwb3J0cy5Tb2Nrc1Byb3h5QWdlbnQgPSBTb2Nrc1Byb3h5QWdlbnQ7XG5mdW5jdGlvbiBvbWl0KG9iaiwgLi4ua2V5cykge1xuICAgIGNvbnN0IHJldCA9IHt9O1xuICAgIGxldCBrZXk7XG4gICAgZm9yIChrZXkgaW4gb2JqKSB7XG4gICAgICAgIGlmICgha2V5cy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICByZXRba2V5XSA9IG9ialtrZXldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOlsiX19jcmVhdGVCaW5kaW5nIiwiT2JqZWN0IiwiY3JlYXRlIiwibyIsIm0iLCJrIiwiazIiLCJ1bmRlZmluZWQiLCJkZXNjIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiX19lc01vZHVsZSIsIndyaXRhYmxlIiwiY29uZmlndXJhYmxlIiwiZW51bWVyYWJsZSIsImdldCIsImRlZmluZVByb3BlcnR5IiwiX19zZXRNb2R1bGVEZWZhdWx0IiwidiIsInZhbHVlIiwiX19pbXBvcnRTdGFyIiwibW9kIiwicmVzdWx0IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiX19pbXBvcnREZWZhdWx0IiwiZXhwb3J0cyIsIlNvY2tzUHJveHlBZ2VudCIsInNvY2tzXzEiLCJyZXF1aXJlIiwiYWdlbnRfYmFzZV8xIiwiZGVidWdfMSIsImRucyIsIm5ldCIsInRscyIsImRlYnVnIiwiZGVmYXVsdCIsInBhcnNlU29ja3NVUkwiLCJ1cmwiLCJsb29rdXAiLCJ0eXBlIiwiaG9zdCIsImhvc3RuYW1lIiwicG9ydCIsInBhcnNlSW50IiwicHJvdG9jb2wiLCJyZXBsYWNlIiwiVHlwZUVycm9yIiwiU3RyaW5nIiwicHJveHkiLCJ1c2VybmFtZSIsImRlY29kZVVSSUNvbXBvbmVudCIsInBhc3N3b3JkIiwiQWdlbnQiLCJjb25zdHJ1Y3RvciIsInVyaSIsIm9wdHMiLCJVUkwiLCJzaG91bGRMb29rdXAiLCJ0aW1lb3V0IiwiY29ubmVjdCIsInJlcSIsIkVycm9yIiwibG9va3VwRm4iLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsImVyciIsInJlcyIsInNvY2tzT3B0cyIsImRlc3RpbmF0aW9uIiwiY29tbWFuZCIsImNsZWFudXAiLCJ0bHNTb2NrZXQiLCJkZXN0cm95Iiwic29ja2V0IiwiU29ja3NDbGllbnQiLCJjcmVhdGVDb25uZWN0aW9uIiwic2V0VGltZW91dCIsIm9uIiwic2VjdXJlRW5kcG9pbnQiLCJzZXJ2ZXJuYW1lIiwib21pdCIsImlzSVAiLCJvbmNlIiwiZXJyb3IiLCJtZXNzYWdlIiwicHJvdG9jb2xzIiwib2JqIiwia2V5cyIsInJldCIsImtleSIsImluY2x1ZGVzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/socks-proxy-agent@8.0.1/node_modules/socks-proxy-agent/dist/index.js\n");

/***/ })

};
;