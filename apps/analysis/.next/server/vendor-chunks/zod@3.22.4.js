"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/zod@3.22.4";
exports.ids = ["vendor-chunks/zod@3.22.4"];
exports.modules = {

/***/ "(ssr)/../../node_modules/.pnpm/zod@3.22.4/node_modules/zod/lib/index.mjs":
/*!**************************************************************************!*\
  !*** ../../node_modules/.pnpm/zod@3.22.4/node_modules/zod/lib/index.mjs ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BRAND: () => (/* binding */ BRAND),\n/* harmony export */   DIRTY: () => (/* binding */ DIRTY),\n/* harmony export */   EMPTY_PATH: () => (/* binding */ EMPTY_PATH),\n/* harmony export */   INVALID: () => (/* binding */ INVALID),\n/* harmony export */   NEVER: () => (/* binding */ NEVER),\n/* harmony export */   OK: () => (/* binding */ OK),\n/* harmony export */   ParseStatus: () => (/* binding */ ParseStatus),\n/* harmony export */   Schema: () => (/* binding */ ZodType),\n/* harmony export */   ZodAny: () => (/* binding */ ZodAny),\n/* harmony export */   ZodArray: () => (/* binding */ ZodArray),\n/* harmony export */   ZodBigInt: () => (/* binding */ ZodBigInt),\n/* harmony export */   ZodBoolean: () => (/* binding */ ZodBoolean),\n/* harmony export */   ZodBranded: () => (/* binding */ ZodBranded),\n/* harmony export */   ZodCatch: () => (/* binding */ ZodCatch),\n/* harmony export */   ZodDate: () => (/* binding */ ZodDate),\n/* harmony export */   ZodDefault: () => (/* binding */ ZodDefault),\n/* harmony export */   ZodDiscriminatedUnion: () => (/* binding */ ZodDiscriminatedUnion),\n/* harmony export */   ZodEffects: () => (/* binding */ ZodEffects),\n/* harmony export */   ZodEnum: () => (/* binding */ ZodEnum),\n/* harmony export */   ZodError: () => (/* binding */ ZodError),\n/* harmony export */   ZodFirstPartyTypeKind: () => (/* binding */ ZodFirstPartyTypeKind),\n/* harmony export */   ZodFunction: () => (/* binding */ ZodFunction),\n/* harmony export */   ZodIntersection: () => (/* binding */ ZodIntersection),\n/* harmony export */   ZodIssueCode: () => (/* binding */ ZodIssueCode),\n/* harmony export */   ZodLazy: () => (/* binding */ ZodLazy),\n/* harmony export */   ZodLiteral: () => (/* binding */ ZodLiteral),\n/* harmony export */   ZodMap: () => (/* binding */ ZodMap),\n/* harmony export */   ZodNaN: () => (/* binding */ ZodNaN),\n/* harmony export */   ZodNativeEnum: () => (/* binding */ ZodNativeEnum),\n/* harmony export */   ZodNever: () => (/* binding */ ZodNever),\n/* harmony export */   ZodNull: () => (/* binding */ ZodNull),\n/* harmony export */   ZodNullable: () => (/* binding */ ZodNullable),\n/* harmony export */   ZodNumber: () => (/* binding */ ZodNumber),\n/* harmony export */   ZodObject: () => (/* binding */ ZodObject),\n/* harmony export */   ZodOptional: () => (/* binding */ ZodOptional),\n/* harmony export */   ZodParsedType: () => (/* binding */ ZodParsedType),\n/* harmony export */   ZodPipeline: () => (/* binding */ ZodPipeline),\n/* harmony export */   ZodPromise: () => (/* binding */ ZodPromise),\n/* harmony export */   ZodReadonly: () => (/* binding */ ZodReadonly),\n/* harmony export */   ZodRecord: () => (/* binding */ ZodRecord),\n/* harmony export */   ZodSchema: () => (/* binding */ ZodType),\n/* harmony export */   ZodSet: () => (/* binding */ ZodSet),\n/* harmony export */   ZodString: () => (/* binding */ ZodString),\n/* harmony export */   ZodSymbol: () => (/* binding */ ZodSymbol),\n/* harmony export */   ZodTransformer: () => (/* binding */ ZodEffects),\n/* harmony export */   ZodTuple: () => (/* binding */ ZodTuple),\n/* harmony export */   ZodType: () => (/* binding */ ZodType),\n/* harmony export */   ZodUndefined: () => (/* binding */ ZodUndefined),\n/* harmony export */   ZodUnion: () => (/* binding */ ZodUnion),\n/* harmony export */   ZodUnknown: () => (/* binding */ ZodUnknown),\n/* harmony export */   ZodVoid: () => (/* binding */ ZodVoid),\n/* harmony export */   addIssueToContext: () => (/* binding */ addIssueToContext),\n/* harmony export */   any: () => (/* binding */ anyType),\n/* harmony export */   array: () => (/* binding */ arrayType),\n/* harmony export */   bigint: () => (/* binding */ bigIntType),\n/* harmony export */   boolean: () => (/* binding */ booleanType),\n/* harmony export */   coerce: () => (/* binding */ coerce),\n/* harmony export */   custom: () => (/* binding */ custom),\n/* harmony export */   date: () => (/* binding */ dateType),\n/* harmony export */   \"default\": () => (/* binding */ z),\n/* harmony export */   defaultErrorMap: () => (/* binding */ errorMap),\n/* harmony export */   discriminatedUnion: () => (/* binding */ discriminatedUnionType),\n/* harmony export */   effect: () => (/* binding */ effectsType),\n/* harmony export */   \"enum\": () => (/* binding */ enumType),\n/* harmony export */   \"function\": () => (/* binding */ functionType),\n/* harmony export */   getErrorMap: () => (/* binding */ getErrorMap),\n/* harmony export */   getParsedType: () => (/* binding */ getParsedType),\n/* harmony export */   \"instanceof\": () => (/* binding */ instanceOfType),\n/* harmony export */   intersection: () => (/* binding */ intersectionType),\n/* harmony export */   isAborted: () => (/* binding */ isAborted),\n/* harmony export */   isAsync: () => (/* binding */ isAsync),\n/* harmony export */   isDirty: () => (/* binding */ isDirty),\n/* harmony export */   isValid: () => (/* binding */ isValid),\n/* harmony export */   late: () => (/* binding */ late),\n/* harmony export */   lazy: () => (/* binding */ lazyType),\n/* harmony export */   literal: () => (/* binding */ literalType),\n/* harmony export */   makeIssue: () => (/* binding */ makeIssue),\n/* harmony export */   map: () => (/* binding */ mapType),\n/* harmony export */   nan: () => (/* binding */ nanType),\n/* harmony export */   nativeEnum: () => (/* binding */ nativeEnumType),\n/* harmony export */   never: () => (/* binding */ neverType),\n/* harmony export */   \"null\": () => (/* binding */ nullType),\n/* harmony export */   nullable: () => (/* binding */ nullableType),\n/* harmony export */   number: () => (/* binding */ numberType),\n/* harmony export */   object: () => (/* binding */ objectType),\n/* harmony export */   objectUtil: () => (/* binding */ objectUtil),\n/* harmony export */   oboolean: () => (/* binding */ oboolean),\n/* harmony export */   onumber: () => (/* binding */ onumber),\n/* harmony export */   optional: () => (/* binding */ optionalType),\n/* harmony export */   ostring: () => (/* binding */ ostring),\n/* harmony export */   pipeline: () => (/* binding */ pipelineType),\n/* harmony export */   preprocess: () => (/* binding */ preprocessType),\n/* harmony export */   promise: () => (/* binding */ promiseType),\n/* harmony export */   quotelessJson: () => (/* binding */ quotelessJson),\n/* harmony export */   record: () => (/* binding */ recordType),\n/* harmony export */   set: () => (/* binding */ setType),\n/* harmony export */   setErrorMap: () => (/* binding */ setErrorMap),\n/* harmony export */   strictObject: () => (/* binding */ strictObjectType),\n/* harmony export */   string: () => (/* binding */ stringType),\n/* harmony export */   symbol: () => (/* binding */ symbolType),\n/* harmony export */   transformer: () => (/* binding */ effectsType),\n/* harmony export */   tuple: () => (/* binding */ tupleType),\n/* harmony export */   undefined: () => (/* binding */ undefinedType),\n/* harmony export */   union: () => (/* binding */ unionType),\n/* harmony export */   unknown: () => (/* binding */ unknownType),\n/* harmony export */   util: () => (/* binding */ util),\n/* harmony export */   \"void\": () => (/* binding */ voidType),\n/* harmony export */   z: () => (/* binding */ z)\n/* harmony export */ });\nvar util;\n(function(util) {\n    util.assertEqual = (val)=>val;\n    function assertIs(_arg) {}\n    util.assertIs = assertIs;\n    function assertNever(_x) {\n        throw new Error();\n    }\n    util.assertNever = assertNever;\n    util.arrayToEnum = (items)=>{\n        const obj = {};\n        for (const item of items){\n            obj[item] = item;\n        }\n        return obj;\n    };\n    util.getValidEnumValues = (obj)=>{\n        const validKeys = util.objectKeys(obj).filter((k)=>typeof obj[obj[k]] !== \"number\");\n        const filtered = {};\n        for (const k of validKeys){\n            filtered[k] = obj[k];\n        }\n        return util.objectValues(filtered);\n    };\n    util.objectValues = (obj)=>{\n        return util.objectKeys(obj).map(function(e) {\n            return obj[e];\n        });\n    };\n    util.objectKeys = typeof Object.keys === \"function\" // eslint-disable-line ban/ban\n     ? (obj)=>Object.keys(obj) // eslint-disable-line ban/ban\n     : (object)=>{\n        const keys = [];\n        for(const key in object){\n            if (Object.prototype.hasOwnProperty.call(object, key)) {\n                keys.push(key);\n            }\n        }\n        return keys;\n    };\n    util.find = (arr, checker)=>{\n        for (const item of arr){\n            if (checker(item)) return item;\n        }\n        return undefined;\n    };\n    util.isInteger = typeof Number.isInteger === \"function\" ? (val)=>Number.isInteger(val) // eslint-disable-line ban/ban\n     : (val)=>typeof val === \"number\" && isFinite(val) && Math.floor(val) === val;\n    function joinValues(array, separator = \" | \") {\n        return array.map((val)=>typeof val === \"string\" ? `'${val}'` : val).join(separator);\n    }\n    util.joinValues = joinValues;\n    util.jsonStringifyReplacer = (_, value)=>{\n        if (typeof value === \"bigint\") {\n            return value.toString();\n        }\n        return value;\n    };\n})(util || (util = {}));\nvar objectUtil;\n(function(objectUtil) {\n    objectUtil.mergeShapes = (first, second)=>{\n        return {\n            ...first,\n            ...second\n        };\n    };\n})(objectUtil || (objectUtil = {}));\nconst ZodParsedType = util.arrayToEnum([\n    \"string\",\n    \"nan\",\n    \"number\",\n    \"integer\",\n    \"float\",\n    \"boolean\",\n    \"date\",\n    \"bigint\",\n    \"symbol\",\n    \"function\",\n    \"undefined\",\n    \"null\",\n    \"array\",\n    \"object\",\n    \"unknown\",\n    \"promise\",\n    \"void\",\n    \"never\",\n    \"map\",\n    \"set\"\n]);\nconst getParsedType = (data)=>{\n    const t = typeof data;\n    switch(t){\n        case \"undefined\":\n            return ZodParsedType.undefined;\n        case \"string\":\n            return ZodParsedType.string;\n        case \"number\":\n            return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;\n        case \"boolean\":\n            return ZodParsedType.boolean;\n        case \"function\":\n            return ZodParsedType.function;\n        case \"bigint\":\n            return ZodParsedType.bigint;\n        case \"symbol\":\n            return ZodParsedType.symbol;\n        case \"object\":\n            if (Array.isArray(data)) {\n                return ZodParsedType.array;\n            }\n            if (data === null) {\n                return ZodParsedType.null;\n            }\n            if (data.then && typeof data.then === \"function\" && data.catch && typeof data.catch === \"function\") {\n                return ZodParsedType.promise;\n            }\n            if (typeof Map !== \"undefined\" && data instanceof Map) {\n                return ZodParsedType.map;\n            }\n            if (typeof Set !== \"undefined\" && data instanceof Set) {\n                return ZodParsedType.set;\n            }\n            if (typeof Date !== \"undefined\" && data instanceof Date) {\n                return ZodParsedType.date;\n            }\n            return ZodParsedType.object;\n        default:\n            return ZodParsedType.unknown;\n    }\n};\nconst ZodIssueCode = util.arrayToEnum([\n    \"invalid_type\",\n    \"invalid_literal\",\n    \"custom\",\n    \"invalid_union\",\n    \"invalid_union_discriminator\",\n    \"invalid_enum_value\",\n    \"unrecognized_keys\",\n    \"invalid_arguments\",\n    \"invalid_return_type\",\n    \"invalid_date\",\n    \"invalid_string\",\n    \"too_small\",\n    \"too_big\",\n    \"invalid_intersection_types\",\n    \"not_multiple_of\",\n    \"not_finite\"\n]);\nconst quotelessJson = (obj)=>{\n    const json = JSON.stringify(obj, null, 2);\n    return json.replace(/\"([^\"]+)\":/g, \"$1:\");\n};\nclass ZodError extends Error {\n    constructor(issues){\n        super();\n        this.issues = [];\n        this.addIssue = (sub)=>{\n            this.issues = [\n                ...this.issues,\n                sub\n            ];\n        };\n        this.addIssues = (subs = [])=>{\n            this.issues = [\n                ...this.issues,\n                ...subs\n            ];\n        };\n        const actualProto = new.target.prototype;\n        if (Object.setPrototypeOf) {\n            // eslint-disable-next-line ban/ban\n            Object.setPrototypeOf(this, actualProto);\n        } else {\n            this.__proto__ = actualProto;\n        }\n        this.name = \"ZodError\";\n        this.issues = issues;\n    }\n    get errors() {\n        return this.issues;\n    }\n    format(_mapper) {\n        const mapper = _mapper || function(issue) {\n            return issue.message;\n        };\n        const fieldErrors = {\n            _errors: []\n        };\n        const processError = (error)=>{\n            for (const issue of error.issues){\n                if (issue.code === \"invalid_union\") {\n                    issue.unionErrors.map(processError);\n                } else if (issue.code === \"invalid_return_type\") {\n                    processError(issue.returnTypeError);\n                } else if (issue.code === \"invalid_arguments\") {\n                    processError(issue.argumentsError);\n                } else if (issue.path.length === 0) {\n                    fieldErrors._errors.push(mapper(issue));\n                } else {\n                    let curr = fieldErrors;\n                    let i = 0;\n                    while(i < issue.path.length){\n                        const el = issue.path[i];\n                        const terminal = i === issue.path.length - 1;\n                        if (!terminal) {\n                            curr[el] = curr[el] || {\n                                _errors: []\n                            };\n                        // if (typeof el === \"string\") {\n                        //   curr[el] = curr[el] || { _errors: [] };\n                        // } else if (typeof el === \"number\") {\n                        //   const errorArray: any = [];\n                        //   errorArray._errors = [];\n                        //   curr[el] = curr[el] || errorArray;\n                        // }\n                        } else {\n                            curr[el] = curr[el] || {\n                                _errors: []\n                            };\n                            curr[el]._errors.push(mapper(issue));\n                        }\n                        curr = curr[el];\n                        i++;\n                    }\n                }\n            }\n        };\n        processError(this);\n        return fieldErrors;\n    }\n    toString() {\n        return this.message;\n    }\n    get message() {\n        return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);\n    }\n    get isEmpty() {\n        return this.issues.length === 0;\n    }\n    flatten(mapper = (issue)=>issue.message) {\n        const fieldErrors = {};\n        const formErrors = [];\n        for (const sub of this.issues){\n            if (sub.path.length > 0) {\n                fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];\n                fieldErrors[sub.path[0]].push(mapper(sub));\n            } else {\n                formErrors.push(mapper(sub));\n            }\n        }\n        return {\n            formErrors,\n            fieldErrors\n        };\n    }\n    get formErrors() {\n        return this.flatten();\n    }\n}\nZodError.create = (issues)=>{\n    const error = new ZodError(issues);\n    return error;\n};\nconst errorMap = (issue, _ctx)=>{\n    let message;\n    switch(issue.code){\n        case ZodIssueCode.invalid_type:\n            if (issue.received === ZodParsedType.undefined) {\n                message = \"Required\";\n            } else {\n                message = `Expected ${issue.expected}, received ${issue.received}`;\n            }\n            break;\n        case ZodIssueCode.invalid_literal:\n            message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;\n            break;\n        case ZodIssueCode.unrecognized_keys:\n            message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, \", \")}`;\n            break;\n        case ZodIssueCode.invalid_union:\n            message = `Invalid input`;\n            break;\n        case ZodIssueCode.invalid_union_discriminator:\n            message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;\n            break;\n        case ZodIssueCode.invalid_enum_value:\n            message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;\n            break;\n        case ZodIssueCode.invalid_arguments:\n            message = `Invalid function arguments`;\n            break;\n        case ZodIssueCode.invalid_return_type:\n            message = `Invalid function return type`;\n            break;\n        case ZodIssueCode.invalid_date:\n            message = `Invalid date`;\n            break;\n        case ZodIssueCode.invalid_string:\n            if (typeof issue.validation === \"object\") {\n                if (\"includes\" in issue.validation) {\n                    message = `Invalid input: must include \"${issue.validation.includes}\"`;\n                    if (typeof issue.validation.position === \"number\") {\n                        message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;\n                    }\n                } else if (\"startsWith\" in issue.validation) {\n                    message = `Invalid input: must start with \"${issue.validation.startsWith}\"`;\n                } else if (\"endsWith\" in issue.validation) {\n                    message = `Invalid input: must end with \"${issue.validation.endsWith}\"`;\n                } else {\n                    util.assertNever(issue.validation);\n                }\n            } else if (issue.validation !== \"regex\") {\n                message = `Invalid ${issue.validation}`;\n            } else {\n                message = \"Invalid\";\n            }\n            break;\n        case ZodIssueCode.too_small:\n            if (issue.type === \"array\") message = `Array must contain ${issue.exact ? \"exactly\" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;\n            else if (issue.type === \"string\") message = `String must contain ${issue.exact ? \"exactly\" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;\n            else if (issue.type === \"number\") message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;\n            else if (issue.type === \"date\") message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;\n            else message = \"Invalid input\";\n            break;\n        case ZodIssueCode.too_big:\n            if (issue.type === \"array\") message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;\n            else if (issue.type === \"string\") message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;\n            else if (issue.type === \"number\") message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;\n            else if (issue.type === \"bigint\") message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;\n            else if (issue.type === \"date\") message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;\n            else message = \"Invalid input\";\n            break;\n        case ZodIssueCode.custom:\n            message = `Invalid input`;\n            break;\n        case ZodIssueCode.invalid_intersection_types:\n            message = `Intersection results could not be merged`;\n            break;\n        case ZodIssueCode.not_multiple_of:\n            message = `Number must be a multiple of ${issue.multipleOf}`;\n            break;\n        case ZodIssueCode.not_finite:\n            message = \"Number must be finite\";\n            break;\n        default:\n            message = _ctx.defaultError;\n            util.assertNever(issue);\n    }\n    return {\n        message\n    };\n};\nlet overrideErrorMap = errorMap;\nfunction setErrorMap(map) {\n    overrideErrorMap = map;\n}\nfunction getErrorMap() {\n    return overrideErrorMap;\n}\nconst makeIssue = (params)=>{\n    const { data, path, errorMaps, issueData } = params;\n    const fullPath = [\n        ...path,\n        ...issueData.path || []\n    ];\n    const fullIssue = {\n        ...issueData,\n        path: fullPath\n    };\n    let errorMessage = \"\";\n    const maps = errorMaps.filter((m)=>!!m).slice().reverse();\n    for (const map of maps){\n        errorMessage = map(fullIssue, {\n            data,\n            defaultError: errorMessage\n        }).message;\n    }\n    return {\n        ...issueData,\n        path: fullPath,\n        message: issueData.message || errorMessage\n    };\n};\nconst EMPTY_PATH = [];\nfunction addIssueToContext(ctx, issueData) {\n    const issue = makeIssue({\n        issueData: issueData,\n        data: ctx.data,\n        path: ctx.path,\n        errorMaps: [\n            ctx.common.contextualErrorMap,\n            ctx.schemaErrorMap,\n            getErrorMap(),\n            errorMap\n        ].filter((x)=>!!x)\n    });\n    ctx.common.issues.push(issue);\n}\nclass ParseStatus {\n    constructor(){\n        this.value = \"valid\";\n    }\n    dirty() {\n        if (this.value === \"valid\") this.value = \"dirty\";\n    }\n    abort() {\n        if (this.value !== \"aborted\") this.value = \"aborted\";\n    }\n    static mergeArray(status, results) {\n        const arrayValue = [];\n        for (const s of results){\n            if (s.status === \"aborted\") return INVALID;\n            if (s.status === \"dirty\") status.dirty();\n            arrayValue.push(s.value);\n        }\n        return {\n            status: status.value,\n            value: arrayValue\n        };\n    }\n    static async mergeObjectAsync(status, pairs) {\n        const syncPairs = [];\n        for (const pair of pairs){\n            syncPairs.push({\n                key: await pair.key,\n                value: await pair.value\n            });\n        }\n        return ParseStatus.mergeObjectSync(status, syncPairs);\n    }\n    static mergeObjectSync(status, pairs) {\n        const finalObject = {};\n        for (const pair of pairs){\n            const { key, value } = pair;\n            if (key.status === \"aborted\") return INVALID;\n            if (value.status === \"aborted\") return INVALID;\n            if (key.status === \"dirty\") status.dirty();\n            if (value.status === \"dirty\") status.dirty();\n            if (key.value !== \"__proto__\" && (typeof value.value !== \"undefined\" || pair.alwaysSet)) {\n                finalObject[key.value] = value.value;\n            }\n        }\n        return {\n            status: status.value,\n            value: finalObject\n        };\n    }\n}\nconst INVALID = Object.freeze({\n    status: \"aborted\"\n});\nconst DIRTY = (value)=>({\n        status: \"dirty\",\n        value\n    });\nconst OK = (value)=>({\n        status: \"valid\",\n        value\n    });\nconst isAborted = (x)=>x.status === \"aborted\";\nconst isDirty = (x)=>x.status === \"dirty\";\nconst isValid = (x)=>x.status === \"valid\";\nconst isAsync = (x)=>typeof Promise !== \"undefined\" && x instanceof Promise;\nvar errorUtil;\n(function(errorUtil) {\n    errorUtil.errToObj = (message)=>typeof message === \"string\" ? {\n            message\n        } : message || {};\n    errorUtil.toString = (message)=>typeof message === \"string\" ? message : message === null || message === void 0 ? void 0 : message.message;\n})(errorUtil || (errorUtil = {}));\nclass ParseInputLazyPath {\n    constructor(parent, value, path, key){\n        this._cachedPath = [];\n        this.parent = parent;\n        this.data = value;\n        this._path = path;\n        this._key = key;\n    }\n    get path() {\n        if (!this._cachedPath.length) {\n            if (this._key instanceof Array) {\n                this._cachedPath.push(...this._path, ...this._key);\n            } else {\n                this._cachedPath.push(...this._path, this._key);\n            }\n        }\n        return this._cachedPath;\n    }\n}\nconst handleResult = (ctx, result)=>{\n    if (isValid(result)) {\n        return {\n            success: true,\n            data: result.value\n        };\n    } else {\n        if (!ctx.common.issues.length) {\n            throw new Error(\"Validation failed but no issues detected.\");\n        }\n        return {\n            success: false,\n            get error () {\n                if (this._error) return this._error;\n                const error = new ZodError(ctx.common.issues);\n                this._error = error;\n                return this._error;\n            }\n        };\n    }\n};\nfunction processCreateParams(params) {\n    if (!params) return {};\n    const { errorMap, invalid_type_error, required_error, description } = params;\n    if (errorMap && (invalid_type_error || required_error)) {\n        throw new Error(`Can't use \"invalid_type_error\" or \"required_error\" in conjunction with custom error map.`);\n    }\n    if (errorMap) return {\n        errorMap: errorMap,\n        description\n    };\n    const customMap = (iss, ctx)=>{\n        if (iss.code !== \"invalid_type\") return {\n            message: ctx.defaultError\n        };\n        if (typeof ctx.data === \"undefined\") {\n            return {\n                message: required_error !== null && required_error !== void 0 ? required_error : ctx.defaultError\n            };\n        }\n        return {\n            message: invalid_type_error !== null && invalid_type_error !== void 0 ? invalid_type_error : ctx.defaultError\n        };\n    };\n    return {\n        errorMap: customMap,\n        description\n    };\n}\nclass ZodType {\n    constructor(def){\n        /** Alias of safeParseAsync */ this.spa = this.safeParseAsync;\n        this._def = def;\n        this.parse = this.parse.bind(this);\n        this.safeParse = this.safeParse.bind(this);\n        this.parseAsync = this.parseAsync.bind(this);\n        this.safeParseAsync = this.safeParseAsync.bind(this);\n        this.spa = this.spa.bind(this);\n        this.refine = this.refine.bind(this);\n        this.refinement = this.refinement.bind(this);\n        this.superRefine = this.superRefine.bind(this);\n        this.optional = this.optional.bind(this);\n        this.nullable = this.nullable.bind(this);\n        this.nullish = this.nullish.bind(this);\n        this.array = this.array.bind(this);\n        this.promise = this.promise.bind(this);\n        this.or = this.or.bind(this);\n        this.and = this.and.bind(this);\n        this.transform = this.transform.bind(this);\n        this.brand = this.brand.bind(this);\n        this.default = this.default.bind(this);\n        this.catch = this.catch.bind(this);\n        this.describe = this.describe.bind(this);\n        this.pipe = this.pipe.bind(this);\n        this.readonly = this.readonly.bind(this);\n        this.isNullable = this.isNullable.bind(this);\n        this.isOptional = this.isOptional.bind(this);\n    }\n    get description() {\n        return this._def.description;\n    }\n    _getType(input) {\n        return getParsedType(input.data);\n    }\n    _getOrReturnCtx(input, ctx) {\n        return ctx || {\n            common: input.parent.common,\n            data: input.data,\n            parsedType: getParsedType(input.data),\n            schemaErrorMap: this._def.errorMap,\n            path: input.path,\n            parent: input.parent\n        };\n    }\n    _processInputParams(input) {\n        return {\n            status: new ParseStatus(),\n            ctx: {\n                common: input.parent.common,\n                data: input.data,\n                parsedType: getParsedType(input.data),\n                schemaErrorMap: this._def.errorMap,\n                path: input.path,\n                parent: input.parent\n            }\n        };\n    }\n    _parseSync(input) {\n        const result = this._parse(input);\n        if (isAsync(result)) {\n            throw new Error(\"Synchronous parse encountered promise.\");\n        }\n        return result;\n    }\n    _parseAsync(input) {\n        const result = this._parse(input);\n        return Promise.resolve(result);\n    }\n    parse(data, params) {\n        const result = this.safeParse(data, params);\n        if (result.success) return result.data;\n        throw result.error;\n    }\n    safeParse(data, params) {\n        var _a;\n        const ctx = {\n            common: {\n                issues: [],\n                async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,\n                contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap\n            },\n            path: (params === null || params === void 0 ? void 0 : params.path) || [],\n            schemaErrorMap: this._def.errorMap,\n            parent: null,\n            data,\n            parsedType: getParsedType(data)\n        };\n        const result = this._parseSync({\n            data,\n            path: ctx.path,\n            parent: ctx\n        });\n        return handleResult(ctx, result);\n    }\n    async parseAsync(data, params) {\n        const result = await this.safeParseAsync(data, params);\n        if (result.success) return result.data;\n        throw result.error;\n    }\n    async safeParseAsync(data, params) {\n        const ctx = {\n            common: {\n                issues: [],\n                contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,\n                async: true\n            },\n            path: (params === null || params === void 0 ? void 0 : params.path) || [],\n            schemaErrorMap: this._def.errorMap,\n            parent: null,\n            data,\n            parsedType: getParsedType(data)\n        };\n        const maybeAsyncResult = this._parse({\n            data,\n            path: ctx.path,\n            parent: ctx\n        });\n        const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));\n        return handleResult(ctx, result);\n    }\n    refine(check, message) {\n        const getIssueProperties = (val)=>{\n            if (typeof message === \"string\" || typeof message === \"undefined\") {\n                return {\n                    message\n                };\n            } else if (typeof message === \"function\") {\n                return message(val);\n            } else {\n                return message;\n            }\n        };\n        return this._refinement((val, ctx)=>{\n            const result = check(val);\n            const setError = ()=>ctx.addIssue({\n                    code: ZodIssueCode.custom,\n                    ...getIssueProperties(val)\n                });\n            if (typeof Promise !== \"undefined\" && result instanceof Promise) {\n                return result.then((data)=>{\n                    if (!data) {\n                        setError();\n                        return false;\n                    } else {\n                        return true;\n                    }\n                });\n            }\n            if (!result) {\n                setError();\n                return false;\n            } else {\n                return true;\n            }\n        });\n    }\n    refinement(check, refinementData) {\n        return this._refinement((val, ctx)=>{\n            if (!check(val)) {\n                ctx.addIssue(typeof refinementData === \"function\" ? refinementData(val, ctx) : refinementData);\n                return false;\n            } else {\n                return true;\n            }\n        });\n    }\n    _refinement(refinement) {\n        return new ZodEffects({\n            schema: this,\n            typeName: ZodFirstPartyTypeKind.ZodEffects,\n            effect: {\n                type: \"refinement\",\n                refinement\n            }\n        });\n    }\n    superRefine(refinement) {\n        return this._refinement(refinement);\n    }\n    optional() {\n        return ZodOptional.create(this, this._def);\n    }\n    nullable() {\n        return ZodNullable.create(this, this._def);\n    }\n    nullish() {\n        return this.nullable().optional();\n    }\n    array() {\n        return ZodArray.create(this, this._def);\n    }\n    promise() {\n        return ZodPromise.create(this, this._def);\n    }\n    or(option) {\n        return ZodUnion.create([\n            this,\n            option\n        ], this._def);\n    }\n    and(incoming) {\n        return ZodIntersection.create(this, incoming, this._def);\n    }\n    transform(transform) {\n        return new ZodEffects({\n            ...processCreateParams(this._def),\n            schema: this,\n            typeName: ZodFirstPartyTypeKind.ZodEffects,\n            effect: {\n                type: \"transform\",\n                transform\n            }\n        });\n    }\n    default(def) {\n        const defaultValueFunc = typeof def === \"function\" ? def : ()=>def;\n        return new ZodDefault({\n            ...processCreateParams(this._def),\n            innerType: this,\n            defaultValue: defaultValueFunc,\n            typeName: ZodFirstPartyTypeKind.ZodDefault\n        });\n    }\n    brand() {\n        return new ZodBranded({\n            typeName: ZodFirstPartyTypeKind.ZodBranded,\n            type: this,\n            ...processCreateParams(this._def)\n        });\n    }\n    catch(def) {\n        const catchValueFunc = typeof def === \"function\" ? def : ()=>def;\n        return new ZodCatch({\n            ...processCreateParams(this._def),\n            innerType: this,\n            catchValue: catchValueFunc,\n            typeName: ZodFirstPartyTypeKind.ZodCatch\n        });\n    }\n    describe(description) {\n        const This = this.constructor;\n        return new This({\n            ...this._def,\n            description\n        });\n    }\n    pipe(target) {\n        return ZodPipeline.create(this, target);\n    }\n    readonly() {\n        return ZodReadonly.create(this);\n    }\n    isOptional() {\n        return this.safeParse(undefined).success;\n    }\n    isNullable() {\n        return this.safeParse(null).success;\n    }\n}\nconst cuidRegex = /^c[^\\s-]{8,}$/i;\nconst cuid2Regex = /^[a-z][a-z0-9]*$/;\nconst ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/;\n// const uuidRegex =\n//   /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;\nconst uuidRegex = /^[0-9a-fA-F]{8}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{12}$/i;\n// from https://stackoverflow.com/a/46181/1550155\n// old version: too slow, didn't support unicode\n// const emailRegex = /^((([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+(\\.([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+)*)|((\\x22)((((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(([\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x7f]|\\x21|[\\x23-\\x5b]|[\\x5d-\\x7e]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(\\\\([\\x01-\\x09\\x0b\\x0c\\x0d-\\x7f]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]))))*(((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(\\x22)))@((([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.)+(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))$/i;\n//old email regex\n// const emailRegex = /^(([^<>()[\\].,;:\\s@\"]+(\\.[^<>()[\\].,;:\\s@\"]+)*)|(\".+\"))@((?!-)([^<>()[\\].,;:\\s@\"]+\\.)+[^<>()[\\].,;:\\s@\"]{1,})[^-<>()[\\].,;:\\s@\"]$/i;\n// eslint-disable-next-line\n// const emailRegex =\n//   /^(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\])|(\\[IPv6:(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))\\])|([A-Za-z0-9]([A-Za-z0-9-]*[A-Za-z0-9])*(\\.[A-Za-z]{2,})+))$/;\n// const emailRegex =\n//   /^[a-zA-Z0-9\\.\\!\\#\\$\\%\\&\\'\\*\\+\\/\\=\\?\\^\\_\\`\\{\\|\\}\\~\\-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;\n// const emailRegex =\n//   /^(?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|\"(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21\\x23-\\x5b\\x5d-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])*\")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21-\\x5a\\x53-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])+)\\])$/i;\nconst emailRegex = /^(?!\\.)(?!.*\\.\\.)([A-Z0-9_+-\\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\\-]*\\.)+[A-Z]{2,}$/i;\n// const emailRegex =\n//   /^[a-z0-9.!#$%&’*+/=?^_`{|}~-]+@[a-z0-9-]+(?:\\.[a-z0-9\\-]+)*$/i;\n// from https://thekevinscott.com/emojis-in-javascript/#writing-a-regular-expression\nconst _emojiRegex = `^(\\\\p{Extended_Pictographic}|\\\\p{Emoji_Component})+$`;\nlet emojiRegex;\nconst ipv4Regex = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/;\nconst ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;\n// Adapted from https://stackoverflow.com/a/3143231\nconst datetimeRegex = (args)=>{\n    if (args.precision) {\n        if (args.offset) {\n            return new RegExp(`^\\\\d{4}-\\\\d{2}-\\\\d{2}T\\\\d{2}:\\\\d{2}:\\\\d{2}\\\\.\\\\d{${args.precision}}(([+-]\\\\d{2}(:?\\\\d{2})?)|Z)$`);\n        } else {\n            return new RegExp(`^\\\\d{4}-\\\\d{2}-\\\\d{2}T\\\\d{2}:\\\\d{2}:\\\\d{2}\\\\.\\\\d{${args.precision}}Z$`);\n        }\n    } else if (args.precision === 0) {\n        if (args.offset) {\n            return new RegExp(`^\\\\d{4}-\\\\d{2}-\\\\d{2}T\\\\d{2}:\\\\d{2}:\\\\d{2}(([+-]\\\\d{2}(:?\\\\d{2})?)|Z)$`);\n        } else {\n            return new RegExp(`^\\\\d{4}-\\\\d{2}-\\\\d{2}T\\\\d{2}:\\\\d{2}:\\\\d{2}Z$`);\n        }\n    } else {\n        if (args.offset) {\n            return new RegExp(`^\\\\d{4}-\\\\d{2}-\\\\d{2}T\\\\d{2}:\\\\d{2}:\\\\d{2}(\\\\.\\\\d+)?(([+-]\\\\d{2}(:?\\\\d{2})?)|Z)$`);\n        } else {\n            return new RegExp(`^\\\\d{4}-\\\\d{2}-\\\\d{2}T\\\\d{2}:\\\\d{2}:\\\\d{2}(\\\\.\\\\d+)?Z$`);\n        }\n    }\n};\nfunction isValidIP(ip, version) {\n    if ((version === \"v4\" || !version) && ipv4Regex.test(ip)) {\n        return true;\n    }\n    if ((version === \"v6\" || !version) && ipv6Regex.test(ip)) {\n        return true;\n    }\n    return false;\n}\nclass ZodString extends ZodType {\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = String(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.string) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.string,\n                received: ctx.parsedType\n            });\n            return INVALID;\n        }\n        const status = new ParseStatus();\n        let ctx = undefined;\n        for (const check of this._def.checks){\n            if (check.kind === \"min\") {\n                if (input.data.length < check.value) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_small,\n                        minimum: check.value,\n                        type: \"string\",\n                        inclusive: true,\n                        exact: false,\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"max\") {\n                if (input.data.length > check.value) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_big,\n                        maximum: check.value,\n                        type: \"string\",\n                        inclusive: true,\n                        exact: false,\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"length\") {\n                const tooBig = input.data.length > check.value;\n                const tooSmall = input.data.length < check.value;\n                if (tooBig || tooSmall) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    if (tooBig) {\n                        addIssueToContext(ctx, {\n                            code: ZodIssueCode.too_big,\n                            maximum: check.value,\n                            type: \"string\",\n                            inclusive: true,\n                            exact: true,\n                            message: check.message\n                        });\n                    } else if (tooSmall) {\n                        addIssueToContext(ctx, {\n                            code: ZodIssueCode.too_small,\n                            minimum: check.value,\n                            type: \"string\",\n                            inclusive: true,\n                            exact: true,\n                            message: check.message\n                        });\n                    }\n                    status.dirty();\n                }\n            } else if (check.kind === \"email\") {\n                if (!emailRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"email\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"emoji\") {\n                if (!emojiRegex) {\n                    emojiRegex = new RegExp(_emojiRegex, \"u\");\n                }\n                if (!emojiRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"emoji\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"uuid\") {\n                if (!uuidRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"uuid\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"cuid\") {\n                if (!cuidRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"cuid\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"cuid2\") {\n                if (!cuid2Regex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"cuid2\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"ulid\") {\n                if (!ulidRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"ulid\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"url\") {\n                try {\n                    new URL(input.data);\n                } catch (_a) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"url\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"regex\") {\n                check.regex.lastIndex = 0;\n                const testResult = check.regex.test(input.data);\n                if (!testResult) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"regex\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"trim\") {\n                input.data = input.data.trim();\n            } else if (check.kind === \"includes\") {\n                if (!input.data.includes(check.value, check.position)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: {\n                            includes: check.value,\n                            position: check.position\n                        },\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"toLowerCase\") {\n                input.data = input.data.toLowerCase();\n            } else if (check.kind === \"toUpperCase\") {\n                input.data = input.data.toUpperCase();\n            } else if (check.kind === \"startsWith\") {\n                if (!input.data.startsWith(check.value)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: {\n                            startsWith: check.value\n                        },\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"endsWith\") {\n                if (!input.data.endsWith(check.value)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: {\n                            endsWith: check.value\n                        },\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"datetime\") {\n                const regex = datetimeRegex(check);\n                if (!regex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: \"datetime\",\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"ip\") {\n                if (!isValidIP(input.data, check.version)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"ip\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else {\n                util.assertNever(check);\n            }\n        }\n        return {\n            status: status.value,\n            value: input.data\n        };\n    }\n    _regex(regex, validation, message) {\n        return this.refinement((data)=>regex.test(data), {\n            validation,\n            code: ZodIssueCode.invalid_string,\n            ...errorUtil.errToObj(message)\n        });\n    }\n    _addCheck(check) {\n        return new ZodString({\n            ...this._def,\n            checks: [\n                ...this._def.checks,\n                check\n            ]\n        });\n    }\n    email(message) {\n        return this._addCheck({\n            kind: \"email\",\n            ...errorUtil.errToObj(message)\n        });\n    }\n    url(message) {\n        return this._addCheck({\n            kind: \"url\",\n            ...errorUtil.errToObj(message)\n        });\n    }\n    emoji(message) {\n        return this._addCheck({\n            kind: \"emoji\",\n            ...errorUtil.errToObj(message)\n        });\n    }\n    uuid(message) {\n        return this._addCheck({\n            kind: \"uuid\",\n            ...errorUtil.errToObj(message)\n        });\n    }\n    cuid(message) {\n        return this._addCheck({\n            kind: \"cuid\",\n            ...errorUtil.errToObj(message)\n        });\n    }\n    cuid2(message) {\n        return this._addCheck({\n            kind: \"cuid2\",\n            ...errorUtil.errToObj(message)\n        });\n    }\n    ulid(message) {\n        return this._addCheck({\n            kind: \"ulid\",\n            ...errorUtil.errToObj(message)\n        });\n    }\n    ip(options) {\n        return this._addCheck({\n            kind: \"ip\",\n            ...errorUtil.errToObj(options)\n        });\n    }\n    datetime(options) {\n        var _a;\n        if (typeof options === \"string\") {\n            return this._addCheck({\n                kind: \"datetime\",\n                precision: null,\n                offset: false,\n                message: options\n            });\n        }\n        return this._addCheck({\n            kind: \"datetime\",\n            precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === \"undefined\" ? null : options === null || options === void 0 ? void 0 : options.precision,\n            offset: (_a = options === null || options === void 0 ? void 0 : options.offset) !== null && _a !== void 0 ? _a : false,\n            ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)\n        });\n    }\n    regex(regex, message) {\n        return this._addCheck({\n            kind: \"regex\",\n            regex: regex,\n            ...errorUtil.errToObj(message)\n        });\n    }\n    includes(value, options) {\n        return this._addCheck({\n            kind: \"includes\",\n            value: value,\n            position: options === null || options === void 0 ? void 0 : options.position,\n            ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)\n        });\n    }\n    startsWith(value, message) {\n        return this._addCheck({\n            kind: \"startsWith\",\n            value: value,\n            ...errorUtil.errToObj(message)\n        });\n    }\n    endsWith(value, message) {\n        return this._addCheck({\n            kind: \"endsWith\",\n            value: value,\n            ...errorUtil.errToObj(message)\n        });\n    }\n    min(minLength, message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: minLength,\n            ...errorUtil.errToObj(message)\n        });\n    }\n    max(maxLength, message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: maxLength,\n            ...errorUtil.errToObj(message)\n        });\n    }\n    length(len, message) {\n        return this._addCheck({\n            kind: \"length\",\n            value: len,\n            ...errorUtil.errToObj(message)\n        });\n    }\n    /**\n     * @deprecated Use z.string().min(1) instead.\n     * @see {@link ZodString.min}\n     */ nonempty(message) {\n        return this.min(1, errorUtil.errToObj(message));\n    }\n    trim() {\n        return new ZodString({\n            ...this._def,\n            checks: [\n                ...this._def.checks,\n                {\n                    kind: \"trim\"\n                }\n            ]\n        });\n    }\n    toLowerCase() {\n        return new ZodString({\n            ...this._def,\n            checks: [\n                ...this._def.checks,\n                {\n                    kind: \"toLowerCase\"\n                }\n            ]\n        });\n    }\n    toUpperCase() {\n        return new ZodString({\n            ...this._def,\n            checks: [\n                ...this._def.checks,\n                {\n                    kind: \"toUpperCase\"\n                }\n            ]\n        });\n    }\n    get isDatetime() {\n        return !!this._def.checks.find((ch)=>ch.kind === \"datetime\");\n    }\n    get isEmail() {\n        return !!this._def.checks.find((ch)=>ch.kind === \"email\");\n    }\n    get isURL() {\n        return !!this._def.checks.find((ch)=>ch.kind === \"url\");\n    }\n    get isEmoji() {\n        return !!this._def.checks.find((ch)=>ch.kind === \"emoji\");\n    }\n    get isUUID() {\n        return !!this._def.checks.find((ch)=>ch.kind === \"uuid\");\n    }\n    get isCUID() {\n        return !!this._def.checks.find((ch)=>ch.kind === \"cuid\");\n    }\n    get isCUID2() {\n        return !!this._def.checks.find((ch)=>ch.kind === \"cuid2\");\n    }\n    get isULID() {\n        return !!this._def.checks.find((ch)=>ch.kind === \"ulid\");\n    }\n    get isIP() {\n        return !!this._def.checks.find((ch)=>ch.kind === \"ip\");\n    }\n    get minLength() {\n        let min = null;\n        for (const ch of this._def.checks){\n            if (ch.kind === \"min\") {\n                if (min === null || ch.value > min) min = ch.value;\n            }\n        }\n        return min;\n    }\n    get maxLength() {\n        let max = null;\n        for (const ch of this._def.checks){\n            if (ch.kind === \"max\") {\n                if (max === null || ch.value < max) max = ch.value;\n            }\n        }\n        return max;\n    }\n}\nZodString.create = (params)=>{\n    var _a;\n    return new ZodString({\n        checks: [],\n        typeName: ZodFirstPartyTypeKind.ZodString,\n        coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,\n        ...processCreateParams(params)\n    });\n};\n// https://stackoverflow.com/questions/3966484/why-does-modulus-operator-return-fractional-number-in-javascript/31711034#31711034\nfunction floatSafeRemainder(val, step) {\n    const valDecCount = (val.toString().split(\".\")[1] || \"\").length;\n    const stepDecCount = (step.toString().split(\".\")[1] || \"\").length;\n    const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;\n    const valInt = parseInt(val.toFixed(decCount).replace(\".\", \"\"));\n    const stepInt = parseInt(step.toFixed(decCount).replace(\".\", \"\"));\n    return valInt % stepInt / Math.pow(10, decCount);\n}\nclass ZodNumber extends ZodType {\n    constructor(){\n        super(...arguments);\n        this.min = this.gte;\n        this.max = this.lte;\n        this.step = this.multipleOf;\n    }\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = Number(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.number) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.number,\n                received: ctx.parsedType\n            });\n            return INVALID;\n        }\n        let ctx = undefined;\n        const status = new ParseStatus();\n        for (const check of this._def.checks){\n            if (check.kind === \"int\") {\n                if (!util.isInteger(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_type,\n                        expected: \"integer\",\n                        received: \"float\",\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"min\") {\n                const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;\n                if (tooSmall) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_small,\n                        minimum: check.value,\n                        type: \"number\",\n                        inclusive: check.inclusive,\n                        exact: false,\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"max\") {\n                const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;\n                if (tooBig) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_big,\n                        maximum: check.value,\n                        type: \"number\",\n                        inclusive: check.inclusive,\n                        exact: false,\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"multipleOf\") {\n                if (floatSafeRemainder(input.data, check.value) !== 0) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.not_multiple_of,\n                        multipleOf: check.value,\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"finite\") {\n                if (!Number.isFinite(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.not_finite,\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else {\n                util.assertNever(check);\n            }\n        }\n        return {\n            status: status.value,\n            value: input.data\n        };\n    }\n    gte(value, message) {\n        return this.setLimit(\"min\", value, true, errorUtil.toString(message));\n    }\n    gt(value, message) {\n        return this.setLimit(\"min\", value, false, errorUtil.toString(message));\n    }\n    lte(value, message) {\n        return this.setLimit(\"max\", value, true, errorUtil.toString(message));\n    }\n    lt(value, message) {\n        return this.setLimit(\"max\", value, false, errorUtil.toString(message));\n    }\n    setLimit(kind, value, inclusive, message) {\n        return new ZodNumber({\n            ...this._def,\n            checks: [\n                ...this._def.checks,\n                {\n                    kind,\n                    value,\n                    inclusive,\n                    message: errorUtil.toString(message)\n                }\n            ]\n        });\n    }\n    _addCheck(check) {\n        return new ZodNumber({\n            ...this._def,\n            checks: [\n                ...this._def.checks,\n                check\n            ]\n        });\n    }\n    int(message) {\n        return this._addCheck({\n            kind: \"int\",\n            message: errorUtil.toString(message)\n        });\n    }\n    positive(message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: 0,\n            inclusive: false,\n            message: errorUtil.toString(message)\n        });\n    }\n    negative(message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: 0,\n            inclusive: false,\n            message: errorUtil.toString(message)\n        });\n    }\n    nonpositive(message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: 0,\n            inclusive: true,\n            message: errorUtil.toString(message)\n        });\n    }\n    nonnegative(message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: 0,\n            inclusive: true,\n            message: errorUtil.toString(message)\n        });\n    }\n    multipleOf(value, message) {\n        return this._addCheck({\n            kind: \"multipleOf\",\n            value: value,\n            message: errorUtil.toString(message)\n        });\n    }\n    finite(message) {\n        return this._addCheck({\n            kind: \"finite\",\n            message: errorUtil.toString(message)\n        });\n    }\n    safe(message) {\n        return this._addCheck({\n            kind: \"min\",\n            inclusive: true,\n            value: Number.MIN_SAFE_INTEGER,\n            message: errorUtil.toString(message)\n        })._addCheck({\n            kind: \"max\",\n            inclusive: true,\n            value: Number.MAX_SAFE_INTEGER,\n            message: errorUtil.toString(message)\n        });\n    }\n    get minValue() {\n        let min = null;\n        for (const ch of this._def.checks){\n            if (ch.kind === \"min\") {\n                if (min === null || ch.value > min) min = ch.value;\n            }\n        }\n        return min;\n    }\n    get maxValue() {\n        let max = null;\n        for (const ch of this._def.checks){\n            if (ch.kind === \"max\") {\n                if (max === null || ch.value < max) max = ch.value;\n            }\n        }\n        return max;\n    }\n    get isInt() {\n        return !!this._def.checks.find((ch)=>ch.kind === \"int\" || ch.kind === \"multipleOf\" && util.isInteger(ch.value));\n    }\n    get isFinite() {\n        let max = null, min = null;\n        for (const ch of this._def.checks){\n            if (ch.kind === \"finite\" || ch.kind === \"int\" || ch.kind === \"multipleOf\") {\n                return true;\n            } else if (ch.kind === \"min\") {\n                if (min === null || ch.value > min) min = ch.value;\n            } else if (ch.kind === \"max\") {\n                if (max === null || ch.value < max) max = ch.value;\n            }\n        }\n        return Number.isFinite(min) && Number.isFinite(max);\n    }\n}\nZodNumber.create = (params)=>{\n    return new ZodNumber({\n        checks: [],\n        typeName: ZodFirstPartyTypeKind.ZodNumber,\n        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,\n        ...processCreateParams(params)\n    });\n};\nclass ZodBigInt extends ZodType {\n    constructor(){\n        super(...arguments);\n        this.min = this.gte;\n        this.max = this.lte;\n    }\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = BigInt(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.bigint) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.bigint,\n                received: ctx.parsedType\n            });\n            return INVALID;\n        }\n        let ctx = undefined;\n        const status = new ParseStatus();\n        for (const check of this._def.checks){\n            if (check.kind === \"min\") {\n                const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;\n                if (tooSmall) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_small,\n                        type: \"bigint\",\n                        minimum: check.value,\n                        inclusive: check.inclusive,\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"max\") {\n                const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;\n                if (tooBig) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_big,\n                        type: \"bigint\",\n                        maximum: check.value,\n                        inclusive: check.inclusive,\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"multipleOf\") {\n                if (input.data % check.value !== BigInt(0)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.not_multiple_of,\n                        multipleOf: check.value,\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else {\n                util.assertNever(check);\n            }\n        }\n        return {\n            status: status.value,\n            value: input.data\n        };\n    }\n    gte(value, message) {\n        return this.setLimit(\"min\", value, true, errorUtil.toString(message));\n    }\n    gt(value, message) {\n        return this.setLimit(\"min\", value, false, errorUtil.toString(message));\n    }\n    lte(value, message) {\n        return this.setLimit(\"max\", value, true, errorUtil.toString(message));\n    }\n    lt(value, message) {\n        return this.setLimit(\"max\", value, false, errorUtil.toString(message));\n    }\n    setLimit(kind, value, inclusive, message) {\n        return new ZodBigInt({\n            ...this._def,\n            checks: [\n                ...this._def.checks,\n                {\n                    kind,\n                    value,\n                    inclusive,\n                    message: errorUtil.toString(message)\n                }\n            ]\n        });\n    }\n    _addCheck(check) {\n        return new ZodBigInt({\n            ...this._def,\n            checks: [\n                ...this._def.checks,\n                check\n            ]\n        });\n    }\n    positive(message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: BigInt(0),\n            inclusive: false,\n            message: errorUtil.toString(message)\n        });\n    }\n    negative(message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: BigInt(0),\n            inclusive: false,\n            message: errorUtil.toString(message)\n        });\n    }\n    nonpositive(message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: BigInt(0),\n            inclusive: true,\n            message: errorUtil.toString(message)\n        });\n    }\n    nonnegative(message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: BigInt(0),\n            inclusive: true,\n            message: errorUtil.toString(message)\n        });\n    }\n    multipleOf(value, message) {\n        return this._addCheck({\n            kind: \"multipleOf\",\n            value,\n            message: errorUtil.toString(message)\n        });\n    }\n    get minValue() {\n        let min = null;\n        for (const ch of this._def.checks){\n            if (ch.kind === \"min\") {\n                if (min === null || ch.value > min) min = ch.value;\n            }\n        }\n        return min;\n    }\n    get maxValue() {\n        let max = null;\n        for (const ch of this._def.checks){\n            if (ch.kind === \"max\") {\n                if (max === null || ch.value < max) max = ch.value;\n            }\n        }\n        return max;\n    }\n}\nZodBigInt.create = (params)=>{\n    var _a;\n    return new ZodBigInt({\n        checks: [],\n        typeName: ZodFirstPartyTypeKind.ZodBigInt,\n        coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,\n        ...processCreateParams(params)\n    });\n};\nclass ZodBoolean extends ZodType {\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = Boolean(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.boolean) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.boolean,\n                received: ctx.parsedType\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n}\nZodBoolean.create = (params)=>{\n    return new ZodBoolean({\n        typeName: ZodFirstPartyTypeKind.ZodBoolean,\n        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,\n        ...processCreateParams(params)\n    });\n};\nclass ZodDate extends ZodType {\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = new Date(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.date) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.date,\n                received: ctx.parsedType\n            });\n            return INVALID;\n        }\n        if (isNaN(input.data.getTime())) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_date\n            });\n            return INVALID;\n        }\n        const status = new ParseStatus();\n        let ctx = undefined;\n        for (const check of this._def.checks){\n            if (check.kind === \"min\") {\n                if (input.data.getTime() < check.value) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_small,\n                        message: check.message,\n                        inclusive: true,\n                        exact: false,\n                        minimum: check.value,\n                        type: \"date\"\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"max\") {\n                if (input.data.getTime() > check.value) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_big,\n                        message: check.message,\n                        inclusive: true,\n                        exact: false,\n                        maximum: check.value,\n                        type: \"date\"\n                    });\n                    status.dirty();\n                }\n            } else {\n                util.assertNever(check);\n            }\n        }\n        return {\n            status: status.value,\n            value: new Date(input.data.getTime())\n        };\n    }\n    _addCheck(check) {\n        return new ZodDate({\n            ...this._def,\n            checks: [\n                ...this._def.checks,\n                check\n            ]\n        });\n    }\n    min(minDate, message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: minDate.getTime(),\n            message: errorUtil.toString(message)\n        });\n    }\n    max(maxDate, message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: maxDate.getTime(),\n            message: errorUtil.toString(message)\n        });\n    }\n    get minDate() {\n        let min = null;\n        for (const ch of this._def.checks){\n            if (ch.kind === \"min\") {\n                if (min === null || ch.value > min) min = ch.value;\n            }\n        }\n        return min != null ? new Date(min) : null;\n    }\n    get maxDate() {\n        let max = null;\n        for (const ch of this._def.checks){\n            if (ch.kind === \"max\") {\n                if (max === null || ch.value < max) max = ch.value;\n            }\n        }\n        return max != null ? new Date(max) : null;\n    }\n}\nZodDate.create = (params)=>{\n    return new ZodDate({\n        checks: [],\n        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,\n        typeName: ZodFirstPartyTypeKind.ZodDate,\n        ...processCreateParams(params)\n    });\n};\nclass ZodSymbol extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.symbol) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.symbol,\n                received: ctx.parsedType\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n}\nZodSymbol.create = (params)=>{\n    return new ZodSymbol({\n        typeName: ZodFirstPartyTypeKind.ZodSymbol,\n        ...processCreateParams(params)\n    });\n};\nclass ZodUndefined extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.undefined) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.undefined,\n                received: ctx.parsedType\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n}\nZodUndefined.create = (params)=>{\n    return new ZodUndefined({\n        typeName: ZodFirstPartyTypeKind.ZodUndefined,\n        ...processCreateParams(params)\n    });\n};\nclass ZodNull extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.null) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.null,\n                received: ctx.parsedType\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n}\nZodNull.create = (params)=>{\n    return new ZodNull({\n        typeName: ZodFirstPartyTypeKind.ZodNull,\n        ...processCreateParams(params)\n    });\n};\nclass ZodAny extends ZodType {\n    constructor(){\n        super(...arguments);\n        // to prevent instances of other classes from extending ZodAny. this causes issues with catchall in ZodObject.\n        this._any = true;\n    }\n    _parse(input) {\n        return OK(input.data);\n    }\n}\nZodAny.create = (params)=>{\n    return new ZodAny({\n        typeName: ZodFirstPartyTypeKind.ZodAny,\n        ...processCreateParams(params)\n    });\n};\nclass ZodUnknown extends ZodType {\n    constructor(){\n        super(...arguments);\n        // required\n        this._unknown = true;\n    }\n    _parse(input) {\n        return OK(input.data);\n    }\n}\nZodUnknown.create = (params)=>{\n    return new ZodUnknown({\n        typeName: ZodFirstPartyTypeKind.ZodUnknown,\n        ...processCreateParams(params)\n    });\n};\nclass ZodNever extends ZodType {\n    _parse(input) {\n        const ctx = this._getOrReturnCtx(input);\n        addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_type,\n            expected: ZodParsedType.never,\n            received: ctx.parsedType\n        });\n        return INVALID;\n    }\n}\nZodNever.create = (params)=>{\n    return new ZodNever({\n        typeName: ZodFirstPartyTypeKind.ZodNever,\n        ...processCreateParams(params)\n    });\n};\nclass ZodVoid extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.undefined) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.void,\n                received: ctx.parsedType\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n}\nZodVoid.create = (params)=>{\n    return new ZodVoid({\n        typeName: ZodFirstPartyTypeKind.ZodVoid,\n        ...processCreateParams(params)\n    });\n};\nclass ZodArray extends ZodType {\n    _parse(input) {\n        const { ctx, status } = this._processInputParams(input);\n        const def = this._def;\n        if (ctx.parsedType !== ZodParsedType.array) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.array,\n                received: ctx.parsedType\n            });\n            return INVALID;\n        }\n        if (def.exactLength !== null) {\n            const tooBig = ctx.data.length > def.exactLength.value;\n            const tooSmall = ctx.data.length < def.exactLength.value;\n            if (tooBig || tooSmall) {\n                addIssueToContext(ctx, {\n                    code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,\n                    minimum: tooSmall ? def.exactLength.value : undefined,\n                    maximum: tooBig ? def.exactLength.value : undefined,\n                    type: \"array\",\n                    inclusive: true,\n                    exact: true,\n                    message: def.exactLength.message\n                });\n                status.dirty();\n            }\n        }\n        if (def.minLength !== null) {\n            if (ctx.data.length < def.minLength.value) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.too_small,\n                    minimum: def.minLength.value,\n                    type: \"array\",\n                    inclusive: true,\n                    exact: false,\n                    message: def.minLength.message\n                });\n                status.dirty();\n            }\n        }\n        if (def.maxLength !== null) {\n            if (ctx.data.length > def.maxLength.value) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.too_big,\n                    maximum: def.maxLength.value,\n                    type: \"array\",\n                    inclusive: true,\n                    exact: false,\n                    message: def.maxLength.message\n                });\n                status.dirty();\n            }\n        }\n        if (ctx.common.async) {\n            return Promise.all([\n                ...ctx.data\n            ].map((item, i)=>{\n                return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));\n            })).then((result)=>{\n                return ParseStatus.mergeArray(status, result);\n            });\n        }\n        const result = [\n            ...ctx.data\n        ].map((item, i)=>{\n            return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));\n        });\n        return ParseStatus.mergeArray(status, result);\n    }\n    get element() {\n        return this._def.type;\n    }\n    min(minLength, message) {\n        return new ZodArray({\n            ...this._def,\n            minLength: {\n                value: minLength,\n                message: errorUtil.toString(message)\n            }\n        });\n    }\n    max(maxLength, message) {\n        return new ZodArray({\n            ...this._def,\n            maxLength: {\n                value: maxLength,\n                message: errorUtil.toString(message)\n            }\n        });\n    }\n    length(len, message) {\n        return new ZodArray({\n            ...this._def,\n            exactLength: {\n                value: len,\n                message: errorUtil.toString(message)\n            }\n        });\n    }\n    nonempty(message) {\n        return this.min(1, message);\n    }\n}\nZodArray.create = (schema, params)=>{\n    return new ZodArray({\n        type: schema,\n        minLength: null,\n        maxLength: null,\n        exactLength: null,\n        typeName: ZodFirstPartyTypeKind.ZodArray,\n        ...processCreateParams(params)\n    });\n};\nfunction deepPartialify(schema) {\n    if (schema instanceof ZodObject) {\n        const newShape = {};\n        for(const key in schema.shape){\n            const fieldSchema = schema.shape[key];\n            newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));\n        }\n        return new ZodObject({\n            ...schema._def,\n            shape: ()=>newShape\n        });\n    } else if (schema instanceof ZodArray) {\n        return new ZodArray({\n            ...schema._def,\n            type: deepPartialify(schema.element)\n        });\n    } else if (schema instanceof ZodOptional) {\n        return ZodOptional.create(deepPartialify(schema.unwrap()));\n    } else if (schema instanceof ZodNullable) {\n        return ZodNullable.create(deepPartialify(schema.unwrap()));\n    } else if (schema instanceof ZodTuple) {\n        return ZodTuple.create(schema.items.map((item)=>deepPartialify(item)));\n    } else {\n        return schema;\n    }\n}\nclass ZodObject extends ZodType {\n    constructor(){\n        super(...arguments);\n        this._cached = null;\n        /**\n         * @deprecated In most cases, this is no longer needed - unknown properties are now silently stripped.\n         * If you want to pass through unknown properties, use `.passthrough()` instead.\n         */ this.nonstrict = this.passthrough;\n        // extend<\n        //   Augmentation extends ZodRawShape,\n        //   NewOutput extends util.flatten<{\n        //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation\n        //       ? Augmentation[k][\"_output\"]\n        //       : k extends keyof Output\n        //       ? Output[k]\n        //       : never;\n        //   }>,\n        //   NewInput extends util.flatten<{\n        //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation\n        //       ? Augmentation[k][\"_input\"]\n        //       : k extends keyof Input\n        //       ? Input[k]\n        //       : never;\n        //   }>\n        // >(\n        //   augmentation: Augmentation\n        // ): ZodObject<\n        //   extendShape<T, Augmentation>,\n        //   UnknownKeys,\n        //   Catchall,\n        //   NewOutput,\n        //   NewInput\n        // > {\n        //   return new ZodObject({\n        //     ...this._def,\n        //     shape: () => ({\n        //       ...this._def.shape(),\n        //       ...augmentation,\n        //     }),\n        //   }) as any;\n        // }\n        /**\n         * @deprecated Use `.extend` instead\n         *  */ this.augment = this.extend;\n    }\n    _getCached() {\n        if (this._cached !== null) return this._cached;\n        const shape = this._def.shape();\n        const keys = util.objectKeys(shape);\n        return this._cached = {\n            shape,\n            keys\n        };\n    }\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.object) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.object,\n                received: ctx.parsedType\n            });\n            return INVALID;\n        }\n        const { status, ctx } = this._processInputParams(input);\n        const { shape, keys: shapeKeys } = this._getCached();\n        const extraKeys = [];\n        if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === \"strip\")) {\n            for(const key in ctx.data){\n                if (!shapeKeys.includes(key)) {\n                    extraKeys.push(key);\n                }\n            }\n        }\n        const pairs = [];\n        for (const key of shapeKeys){\n            const keyValidator = shape[key];\n            const value = ctx.data[key];\n            pairs.push({\n                key: {\n                    status: \"valid\",\n                    value: key\n                },\n                value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),\n                alwaysSet: key in ctx.data\n            });\n        }\n        if (this._def.catchall instanceof ZodNever) {\n            const unknownKeys = this._def.unknownKeys;\n            if (unknownKeys === \"passthrough\") {\n                for (const key of extraKeys){\n                    pairs.push({\n                        key: {\n                            status: \"valid\",\n                            value: key\n                        },\n                        value: {\n                            status: \"valid\",\n                            value: ctx.data[key]\n                        }\n                    });\n                }\n            } else if (unknownKeys === \"strict\") {\n                if (extraKeys.length > 0) {\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.unrecognized_keys,\n                        keys: extraKeys\n                    });\n                    status.dirty();\n                }\n            } else if (unknownKeys === \"strip\") ;\n            else {\n                throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);\n            }\n        } else {\n            // run catchall validation\n            const catchall = this._def.catchall;\n            for (const key of extraKeys){\n                const value = ctx.data[key];\n                pairs.push({\n                    key: {\n                        status: \"valid\",\n                        value: key\n                    },\n                    value: catchall._parse(new ParseInputLazyPath(ctx, value, ctx.path, key) //, ctx.child(key), value, getParsedType(value)\n                    ),\n                    alwaysSet: key in ctx.data\n                });\n            }\n        }\n        if (ctx.common.async) {\n            return Promise.resolve().then(async ()=>{\n                const syncPairs = [];\n                for (const pair of pairs){\n                    const key = await pair.key;\n                    syncPairs.push({\n                        key,\n                        value: await pair.value,\n                        alwaysSet: pair.alwaysSet\n                    });\n                }\n                return syncPairs;\n            }).then((syncPairs)=>{\n                return ParseStatus.mergeObjectSync(status, syncPairs);\n            });\n        } else {\n            return ParseStatus.mergeObjectSync(status, pairs);\n        }\n    }\n    get shape() {\n        return this._def.shape();\n    }\n    strict(message) {\n        errorUtil.errToObj;\n        return new ZodObject({\n            ...this._def,\n            unknownKeys: \"strict\",\n            ...message !== undefined ? {\n                errorMap: (issue, ctx)=>{\n                    var _a, _b, _c, _d;\n                    const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;\n                    if (issue.code === \"unrecognized_keys\") return {\n                        message: (_d = errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError\n                    };\n                    return {\n                        message: defaultError\n                    };\n                }\n            } : {}\n        });\n    }\n    strip() {\n        return new ZodObject({\n            ...this._def,\n            unknownKeys: \"strip\"\n        });\n    }\n    passthrough() {\n        return new ZodObject({\n            ...this._def,\n            unknownKeys: \"passthrough\"\n        });\n    }\n    // const AugmentFactory =\n    //   <Def extends ZodObjectDef>(def: Def) =>\n    //   <Augmentation extends ZodRawShape>(\n    //     augmentation: Augmentation\n    //   ): ZodObject<\n    //     extendShape<ReturnType<Def[\"shape\"]>, Augmentation>,\n    //     Def[\"unknownKeys\"],\n    //     Def[\"catchall\"]\n    //   > => {\n    //     return new ZodObject({\n    //       ...def,\n    //       shape: () => ({\n    //         ...def.shape(),\n    //         ...augmentation,\n    //       }),\n    //     }) as any;\n    //   };\n    extend(augmentation) {\n        return new ZodObject({\n            ...this._def,\n            shape: ()=>({\n                    ...this._def.shape(),\n                    ...augmentation\n                })\n        });\n    }\n    /**\n     * Prior to zod@1.0.12 there was a bug in the\n     * inferred type of merged objects. Please\n     * upgrade if you are experiencing issues.\n     */ merge(merging) {\n        const merged = new ZodObject({\n            unknownKeys: merging._def.unknownKeys,\n            catchall: merging._def.catchall,\n            shape: ()=>({\n                    ...this._def.shape(),\n                    ...merging._def.shape()\n                }),\n            typeName: ZodFirstPartyTypeKind.ZodObject\n        });\n        return merged;\n    }\n    // merge<\n    //   Incoming extends AnyZodObject,\n    //   Augmentation extends Incoming[\"shape\"],\n    //   NewOutput extends {\n    //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation\n    //       ? Augmentation[k][\"_output\"]\n    //       : k extends keyof Output\n    //       ? Output[k]\n    //       : never;\n    //   },\n    //   NewInput extends {\n    //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation\n    //       ? Augmentation[k][\"_input\"]\n    //       : k extends keyof Input\n    //       ? Input[k]\n    //       : never;\n    //   }\n    // >(\n    //   merging: Incoming\n    // ): ZodObject<\n    //   extendShape<T, ReturnType<Incoming[\"_def\"][\"shape\"]>>,\n    //   Incoming[\"_def\"][\"unknownKeys\"],\n    //   Incoming[\"_def\"][\"catchall\"],\n    //   NewOutput,\n    //   NewInput\n    // > {\n    //   const merged: any = new ZodObject({\n    //     unknownKeys: merging._def.unknownKeys,\n    //     catchall: merging._def.catchall,\n    //     shape: () =>\n    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),\n    //     typeName: ZodFirstPartyTypeKind.ZodObject,\n    //   }) as any;\n    //   return merged;\n    // }\n    setKey(key, schema) {\n        return this.augment({\n            [key]: schema\n        });\n    }\n    // merge<Incoming extends AnyZodObject>(\n    //   merging: Incoming\n    // ): //ZodObject<T & Incoming[\"_shape\"], UnknownKeys, Catchall> = (merging) => {\n    // ZodObject<\n    //   extendShape<T, ReturnType<Incoming[\"_def\"][\"shape\"]>>,\n    //   Incoming[\"_def\"][\"unknownKeys\"],\n    //   Incoming[\"_def\"][\"catchall\"]\n    // > {\n    //   // const mergedShape = objectUtil.mergeShapes(\n    //   //   this._def.shape(),\n    //   //   merging._def.shape()\n    //   // );\n    //   const merged: any = new ZodObject({\n    //     unknownKeys: merging._def.unknownKeys,\n    //     catchall: merging._def.catchall,\n    //     shape: () =>\n    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),\n    //     typeName: ZodFirstPartyTypeKind.ZodObject,\n    //   }) as any;\n    //   return merged;\n    // }\n    catchall(index) {\n        return new ZodObject({\n            ...this._def,\n            catchall: index\n        });\n    }\n    pick(mask) {\n        const shape = {};\n        util.objectKeys(mask).forEach((key)=>{\n            if (mask[key] && this.shape[key]) {\n                shape[key] = this.shape[key];\n            }\n        });\n        return new ZodObject({\n            ...this._def,\n            shape: ()=>shape\n        });\n    }\n    omit(mask) {\n        const shape = {};\n        util.objectKeys(this.shape).forEach((key)=>{\n            if (!mask[key]) {\n                shape[key] = this.shape[key];\n            }\n        });\n        return new ZodObject({\n            ...this._def,\n            shape: ()=>shape\n        });\n    }\n    /**\n     * @deprecated\n     */ deepPartial() {\n        return deepPartialify(this);\n    }\n    partial(mask) {\n        const newShape = {};\n        util.objectKeys(this.shape).forEach((key)=>{\n            const fieldSchema = this.shape[key];\n            if (mask && !mask[key]) {\n                newShape[key] = fieldSchema;\n            } else {\n                newShape[key] = fieldSchema.optional();\n            }\n        });\n        return new ZodObject({\n            ...this._def,\n            shape: ()=>newShape\n        });\n    }\n    required(mask) {\n        const newShape = {};\n        util.objectKeys(this.shape).forEach((key)=>{\n            if (mask && !mask[key]) {\n                newShape[key] = this.shape[key];\n            } else {\n                const fieldSchema = this.shape[key];\n                let newField = fieldSchema;\n                while(newField instanceof ZodOptional){\n                    newField = newField._def.innerType;\n                }\n                newShape[key] = newField;\n            }\n        });\n        return new ZodObject({\n            ...this._def,\n            shape: ()=>newShape\n        });\n    }\n    keyof() {\n        return createZodEnum(util.objectKeys(this.shape));\n    }\n}\nZodObject.create = (shape, params)=>{\n    return new ZodObject({\n        shape: ()=>shape,\n        unknownKeys: \"strip\",\n        catchall: ZodNever.create(),\n        typeName: ZodFirstPartyTypeKind.ZodObject,\n        ...processCreateParams(params)\n    });\n};\nZodObject.strictCreate = (shape, params)=>{\n    return new ZodObject({\n        shape: ()=>shape,\n        unknownKeys: \"strict\",\n        catchall: ZodNever.create(),\n        typeName: ZodFirstPartyTypeKind.ZodObject,\n        ...processCreateParams(params)\n    });\n};\nZodObject.lazycreate = (shape, params)=>{\n    return new ZodObject({\n        shape,\n        unknownKeys: \"strip\",\n        catchall: ZodNever.create(),\n        typeName: ZodFirstPartyTypeKind.ZodObject,\n        ...processCreateParams(params)\n    });\n};\nclass ZodUnion extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        const options = this._def.options;\n        function handleResults(results) {\n            // return first issue-free validation if it exists\n            for (const result of results){\n                if (result.result.status === \"valid\") {\n                    return result.result;\n                }\n            }\n            for (const result of results){\n                if (result.result.status === \"dirty\") {\n                    // add issues from dirty option\n                    ctx.common.issues.push(...result.ctx.common.issues);\n                    return result.result;\n                }\n            }\n            // return invalid\n            const unionErrors = results.map((result)=>new ZodError(result.ctx.common.issues));\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_union,\n                unionErrors\n            });\n            return INVALID;\n        }\n        if (ctx.common.async) {\n            return Promise.all(options.map(async (option)=>{\n                const childCtx = {\n                    ...ctx,\n                    common: {\n                        ...ctx.common,\n                        issues: []\n                    },\n                    parent: null\n                };\n                return {\n                    result: await option._parseAsync({\n                        data: ctx.data,\n                        path: ctx.path,\n                        parent: childCtx\n                    }),\n                    ctx: childCtx\n                };\n            })).then(handleResults);\n        } else {\n            let dirty = undefined;\n            const issues = [];\n            for (const option of options){\n                const childCtx = {\n                    ...ctx,\n                    common: {\n                        ...ctx.common,\n                        issues: []\n                    },\n                    parent: null\n                };\n                const result = option._parseSync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: childCtx\n                });\n                if (result.status === \"valid\") {\n                    return result;\n                } else if (result.status === \"dirty\" && !dirty) {\n                    dirty = {\n                        result,\n                        ctx: childCtx\n                    };\n                }\n                if (childCtx.common.issues.length) {\n                    issues.push(childCtx.common.issues);\n                }\n            }\n            if (dirty) {\n                ctx.common.issues.push(...dirty.ctx.common.issues);\n                return dirty.result;\n            }\n            const unionErrors = issues.map((issues)=>new ZodError(issues));\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_union,\n                unionErrors\n            });\n            return INVALID;\n        }\n    }\n    get options() {\n        return this._def.options;\n    }\n}\nZodUnion.create = (types, params)=>{\n    return new ZodUnion({\n        options: types,\n        typeName: ZodFirstPartyTypeKind.ZodUnion,\n        ...processCreateParams(params)\n    });\n};\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n//////////                                 //////////\n//////////      ZodDiscriminatedUnion      //////////\n//////////                                 //////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\nconst getDiscriminator = (type)=>{\n    if (type instanceof ZodLazy) {\n        return getDiscriminator(type.schema);\n    } else if (type instanceof ZodEffects) {\n        return getDiscriminator(type.innerType());\n    } else if (type instanceof ZodLiteral) {\n        return [\n            type.value\n        ];\n    } else if (type instanceof ZodEnum) {\n        return type.options;\n    } else if (type instanceof ZodNativeEnum) {\n        // eslint-disable-next-line ban/ban\n        return Object.keys(type.enum);\n    } else if (type instanceof ZodDefault) {\n        return getDiscriminator(type._def.innerType);\n    } else if (type instanceof ZodUndefined) {\n        return [\n            undefined\n        ];\n    } else if (type instanceof ZodNull) {\n        return [\n            null\n        ];\n    } else {\n        return null;\n    }\n};\nclass ZodDiscriminatedUnion extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.object) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.object,\n                received: ctx.parsedType\n            });\n            return INVALID;\n        }\n        const discriminator = this.discriminator;\n        const discriminatorValue = ctx.data[discriminator];\n        const option = this.optionsMap.get(discriminatorValue);\n        if (!option) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_union_discriminator,\n                options: Array.from(this.optionsMap.keys()),\n                path: [\n                    discriminator\n                ]\n            });\n            return INVALID;\n        }\n        if (ctx.common.async) {\n            return option._parseAsync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx\n            });\n        } else {\n            return option._parseSync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx\n            });\n        }\n    }\n    get discriminator() {\n        return this._def.discriminator;\n    }\n    get options() {\n        return this._def.options;\n    }\n    get optionsMap() {\n        return this._def.optionsMap;\n    }\n    /**\n     * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.\n     * However, it only allows a union of objects, all of which need to share a discriminator property. This property must\n     * have a different value for each object in the union.\n     * @param discriminator the name of the discriminator property\n     * @param types an array of object schemas\n     * @param params\n     */ static create(discriminator, options, params) {\n        // Get all the valid discriminator values\n        const optionsMap = new Map();\n        // try {\n        for (const type of options){\n            const discriminatorValues = getDiscriminator(type.shape[discriminator]);\n            if (!discriminatorValues) {\n                throw new Error(`A discriminator value for key \\`${discriminator}\\` could not be extracted from all schema options`);\n            }\n            for (const value of discriminatorValues){\n                if (optionsMap.has(value)) {\n                    throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);\n                }\n                optionsMap.set(value, type);\n            }\n        }\n        return new ZodDiscriminatedUnion({\n            typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,\n            discriminator,\n            options,\n            optionsMap,\n            ...processCreateParams(params)\n        });\n    }\n}\nfunction mergeValues(a, b) {\n    const aType = getParsedType(a);\n    const bType = getParsedType(b);\n    if (a === b) {\n        return {\n            valid: true,\n            data: a\n        };\n    } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {\n        const bKeys = util.objectKeys(b);\n        const sharedKeys = util.objectKeys(a).filter((key)=>bKeys.indexOf(key) !== -1);\n        const newObj = {\n            ...a,\n            ...b\n        };\n        for (const key of sharedKeys){\n            const sharedValue = mergeValues(a[key], b[key]);\n            if (!sharedValue.valid) {\n                return {\n                    valid: false\n                };\n            }\n            newObj[key] = sharedValue.data;\n        }\n        return {\n            valid: true,\n            data: newObj\n        };\n    } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {\n        if (a.length !== b.length) {\n            return {\n                valid: false\n            };\n        }\n        const newArray = [];\n        for(let index = 0; index < a.length; index++){\n            const itemA = a[index];\n            const itemB = b[index];\n            const sharedValue = mergeValues(itemA, itemB);\n            if (!sharedValue.valid) {\n                return {\n                    valid: false\n                };\n            }\n            newArray.push(sharedValue.data);\n        }\n        return {\n            valid: true,\n            data: newArray\n        };\n    } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {\n        return {\n            valid: true,\n            data: a\n        };\n    } else {\n        return {\n            valid: false\n        };\n    }\n}\nclass ZodIntersection extends ZodType {\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        const handleParsed = (parsedLeft, parsedRight)=>{\n            if (isAborted(parsedLeft) || isAborted(parsedRight)) {\n                return INVALID;\n            }\n            const merged = mergeValues(parsedLeft.value, parsedRight.value);\n            if (!merged.valid) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.invalid_intersection_types\n                });\n                return INVALID;\n            }\n            if (isDirty(parsedLeft) || isDirty(parsedRight)) {\n                status.dirty();\n            }\n            return {\n                status: status.value,\n                value: merged.data\n            };\n        };\n        if (ctx.common.async) {\n            return Promise.all([\n                this._def.left._parseAsync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx\n                }),\n                this._def.right._parseAsync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx\n                })\n            ]).then(([left, right])=>handleParsed(left, right));\n        } else {\n            return handleParsed(this._def.left._parseSync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx\n            }), this._def.right._parseSync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx\n            }));\n        }\n    }\n}\nZodIntersection.create = (left, right, params)=>{\n    return new ZodIntersection({\n        left: left,\n        right: right,\n        typeName: ZodFirstPartyTypeKind.ZodIntersection,\n        ...processCreateParams(params)\n    });\n};\nclass ZodTuple extends ZodType {\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.array) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.array,\n                received: ctx.parsedType\n            });\n            return INVALID;\n        }\n        if (ctx.data.length < this._def.items.length) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.too_small,\n                minimum: this._def.items.length,\n                inclusive: true,\n                exact: false,\n                type: \"array\"\n            });\n            return INVALID;\n        }\n        const rest = this._def.rest;\n        if (!rest && ctx.data.length > this._def.items.length) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.too_big,\n                maximum: this._def.items.length,\n                inclusive: true,\n                exact: false,\n                type: \"array\"\n            });\n            status.dirty();\n        }\n        const items = [\n            ...ctx.data\n        ].map((item, itemIndex)=>{\n            const schema = this._def.items[itemIndex] || this._def.rest;\n            if (!schema) return null;\n            return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));\n        }).filter((x)=>!!x); // filter nulls\n        if (ctx.common.async) {\n            return Promise.all(items).then((results)=>{\n                return ParseStatus.mergeArray(status, results);\n            });\n        } else {\n            return ParseStatus.mergeArray(status, items);\n        }\n    }\n    get items() {\n        return this._def.items;\n    }\n    rest(rest) {\n        return new ZodTuple({\n            ...this._def,\n            rest\n        });\n    }\n}\nZodTuple.create = (schemas, params)=>{\n    if (!Array.isArray(schemas)) {\n        throw new Error(\"You must pass an array of schemas to z.tuple([ ... ])\");\n    }\n    return new ZodTuple({\n        items: schemas,\n        typeName: ZodFirstPartyTypeKind.ZodTuple,\n        rest: null,\n        ...processCreateParams(params)\n    });\n};\nclass ZodRecord extends ZodType {\n    get keySchema() {\n        return this._def.keyType;\n    }\n    get valueSchema() {\n        return this._def.valueType;\n    }\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.object) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.object,\n                received: ctx.parsedType\n            });\n            return INVALID;\n        }\n        const pairs = [];\n        const keyType = this._def.keyType;\n        const valueType = this._def.valueType;\n        for(const key in ctx.data){\n            pairs.push({\n                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),\n                value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key))\n            });\n        }\n        if (ctx.common.async) {\n            return ParseStatus.mergeObjectAsync(status, pairs);\n        } else {\n            return ParseStatus.mergeObjectSync(status, pairs);\n        }\n    }\n    get element() {\n        return this._def.valueType;\n    }\n    static create(first, second, third) {\n        if (second instanceof ZodType) {\n            return new ZodRecord({\n                keyType: first,\n                valueType: second,\n                typeName: ZodFirstPartyTypeKind.ZodRecord,\n                ...processCreateParams(third)\n            });\n        }\n        return new ZodRecord({\n            keyType: ZodString.create(),\n            valueType: first,\n            typeName: ZodFirstPartyTypeKind.ZodRecord,\n            ...processCreateParams(second)\n        });\n    }\n}\nclass ZodMap extends ZodType {\n    get keySchema() {\n        return this._def.keyType;\n    }\n    get valueSchema() {\n        return this._def.valueType;\n    }\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.map) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.map,\n                received: ctx.parsedType\n            });\n            return INVALID;\n        }\n        const keyType = this._def.keyType;\n        const valueType = this._def.valueType;\n        const pairs = [\n            ...ctx.data.entries()\n        ].map(([key, value], index)=>{\n            return {\n                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [\n                    index,\n                    \"key\"\n                ])),\n                value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [\n                    index,\n                    \"value\"\n                ]))\n            };\n        });\n        if (ctx.common.async) {\n            const finalMap = new Map();\n            return Promise.resolve().then(async ()=>{\n                for (const pair of pairs){\n                    const key = await pair.key;\n                    const value = await pair.value;\n                    if (key.status === \"aborted\" || value.status === \"aborted\") {\n                        return INVALID;\n                    }\n                    if (key.status === \"dirty\" || value.status === \"dirty\") {\n                        status.dirty();\n                    }\n                    finalMap.set(key.value, value.value);\n                }\n                return {\n                    status: status.value,\n                    value: finalMap\n                };\n            });\n        } else {\n            const finalMap = new Map();\n            for (const pair of pairs){\n                const key = pair.key;\n                const value = pair.value;\n                if (key.status === \"aborted\" || value.status === \"aborted\") {\n                    return INVALID;\n                }\n                if (key.status === \"dirty\" || value.status === \"dirty\") {\n                    status.dirty();\n                }\n                finalMap.set(key.value, value.value);\n            }\n            return {\n                status: status.value,\n                value: finalMap\n            };\n        }\n    }\n}\nZodMap.create = (keyType, valueType, params)=>{\n    return new ZodMap({\n        valueType,\n        keyType,\n        typeName: ZodFirstPartyTypeKind.ZodMap,\n        ...processCreateParams(params)\n    });\n};\nclass ZodSet extends ZodType {\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.set) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.set,\n                received: ctx.parsedType\n            });\n            return INVALID;\n        }\n        const def = this._def;\n        if (def.minSize !== null) {\n            if (ctx.data.size < def.minSize.value) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.too_small,\n                    minimum: def.minSize.value,\n                    type: \"set\",\n                    inclusive: true,\n                    exact: false,\n                    message: def.minSize.message\n                });\n                status.dirty();\n            }\n        }\n        if (def.maxSize !== null) {\n            if (ctx.data.size > def.maxSize.value) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.too_big,\n                    maximum: def.maxSize.value,\n                    type: \"set\",\n                    inclusive: true,\n                    exact: false,\n                    message: def.maxSize.message\n                });\n                status.dirty();\n            }\n        }\n        const valueType = this._def.valueType;\n        function finalizeSet(elements) {\n            const parsedSet = new Set();\n            for (const element of elements){\n                if (element.status === \"aborted\") return INVALID;\n                if (element.status === \"dirty\") status.dirty();\n                parsedSet.add(element.value);\n            }\n            return {\n                status: status.value,\n                value: parsedSet\n            };\n        }\n        const elements = [\n            ...ctx.data.values()\n        ].map((item, i)=>valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));\n        if (ctx.common.async) {\n            return Promise.all(elements).then((elements)=>finalizeSet(elements));\n        } else {\n            return finalizeSet(elements);\n        }\n    }\n    min(minSize, message) {\n        return new ZodSet({\n            ...this._def,\n            minSize: {\n                value: minSize,\n                message: errorUtil.toString(message)\n            }\n        });\n    }\n    max(maxSize, message) {\n        return new ZodSet({\n            ...this._def,\n            maxSize: {\n                value: maxSize,\n                message: errorUtil.toString(message)\n            }\n        });\n    }\n    size(size, message) {\n        return this.min(size, message).max(size, message);\n    }\n    nonempty(message) {\n        return this.min(1, message);\n    }\n}\nZodSet.create = (valueType, params)=>{\n    return new ZodSet({\n        valueType,\n        minSize: null,\n        maxSize: null,\n        typeName: ZodFirstPartyTypeKind.ZodSet,\n        ...processCreateParams(params)\n    });\n};\nclass ZodFunction extends ZodType {\n    constructor(){\n        super(...arguments);\n        this.validate = this.implement;\n    }\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.function) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.function,\n                received: ctx.parsedType\n            });\n            return INVALID;\n        }\n        function makeArgsIssue(args, error) {\n            return makeIssue({\n                data: args,\n                path: ctx.path,\n                errorMaps: [\n                    ctx.common.contextualErrorMap,\n                    ctx.schemaErrorMap,\n                    getErrorMap(),\n                    errorMap\n                ].filter((x)=>!!x),\n                issueData: {\n                    code: ZodIssueCode.invalid_arguments,\n                    argumentsError: error\n                }\n            });\n        }\n        function makeReturnsIssue(returns, error) {\n            return makeIssue({\n                data: returns,\n                path: ctx.path,\n                errorMaps: [\n                    ctx.common.contextualErrorMap,\n                    ctx.schemaErrorMap,\n                    getErrorMap(),\n                    errorMap\n                ].filter((x)=>!!x),\n                issueData: {\n                    code: ZodIssueCode.invalid_return_type,\n                    returnTypeError: error\n                }\n            });\n        }\n        const params = {\n            errorMap: ctx.common.contextualErrorMap\n        };\n        const fn = ctx.data;\n        if (this._def.returns instanceof ZodPromise) {\n            // Would love a way to avoid disabling this rule, but we need\n            // an alias (using an arrow function was what caused 2651).\n            // eslint-disable-next-line @typescript-eslint/no-this-alias\n            const me = this;\n            return OK(async function(...args) {\n                const error = new ZodError([]);\n                const parsedArgs = await me._def.args.parseAsync(args, params).catch((e)=>{\n                    error.addIssue(makeArgsIssue(args, e));\n                    throw error;\n                });\n                const result = await Reflect.apply(fn, this, parsedArgs);\n                const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e)=>{\n                    error.addIssue(makeReturnsIssue(result, e));\n                    throw error;\n                });\n                return parsedReturns;\n            });\n        } else {\n            // Would love a way to avoid disabling this rule, but we need\n            // an alias (using an arrow function was what caused 2651).\n            // eslint-disable-next-line @typescript-eslint/no-this-alias\n            const me = this;\n            return OK(function(...args) {\n                const parsedArgs = me._def.args.safeParse(args, params);\n                if (!parsedArgs.success) {\n                    throw new ZodError([\n                        makeArgsIssue(args, parsedArgs.error)\n                    ]);\n                }\n                const result = Reflect.apply(fn, this, parsedArgs.data);\n                const parsedReturns = me._def.returns.safeParse(result, params);\n                if (!parsedReturns.success) {\n                    throw new ZodError([\n                        makeReturnsIssue(result, parsedReturns.error)\n                    ]);\n                }\n                return parsedReturns.data;\n            });\n        }\n    }\n    parameters() {\n        return this._def.args;\n    }\n    returnType() {\n        return this._def.returns;\n    }\n    args(...items) {\n        return new ZodFunction({\n            ...this._def,\n            args: ZodTuple.create(items).rest(ZodUnknown.create())\n        });\n    }\n    returns(returnType) {\n        return new ZodFunction({\n            ...this._def,\n            returns: returnType\n        });\n    }\n    implement(func) {\n        const validatedFunc = this.parse(func);\n        return validatedFunc;\n    }\n    strictImplement(func) {\n        const validatedFunc = this.parse(func);\n        return validatedFunc;\n    }\n    static create(args, returns, params) {\n        return new ZodFunction({\n            args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),\n            returns: returns || ZodUnknown.create(),\n            typeName: ZodFirstPartyTypeKind.ZodFunction,\n            ...processCreateParams(params)\n        });\n    }\n}\nclass ZodLazy extends ZodType {\n    get schema() {\n        return this._def.getter();\n    }\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        const lazySchema = this._def.getter();\n        return lazySchema._parse({\n            data: ctx.data,\n            path: ctx.path,\n            parent: ctx\n        });\n    }\n}\nZodLazy.create = (getter, params)=>{\n    return new ZodLazy({\n        getter: getter,\n        typeName: ZodFirstPartyTypeKind.ZodLazy,\n        ...processCreateParams(params)\n    });\n};\nclass ZodLiteral extends ZodType {\n    _parse(input) {\n        if (input.data !== this._def.value) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                received: ctx.data,\n                code: ZodIssueCode.invalid_literal,\n                expected: this._def.value\n            });\n            return INVALID;\n        }\n        return {\n            status: \"valid\",\n            value: input.data\n        };\n    }\n    get value() {\n        return this._def.value;\n    }\n}\nZodLiteral.create = (value, params)=>{\n    return new ZodLiteral({\n        value: value,\n        typeName: ZodFirstPartyTypeKind.ZodLiteral,\n        ...processCreateParams(params)\n    });\n};\nfunction createZodEnum(values, params) {\n    return new ZodEnum({\n        values,\n        typeName: ZodFirstPartyTypeKind.ZodEnum,\n        ...processCreateParams(params)\n    });\n}\nclass ZodEnum extends ZodType {\n    _parse(input) {\n        if (typeof input.data !== \"string\") {\n            const ctx = this._getOrReturnCtx(input);\n            const expectedValues = this._def.values;\n            addIssueToContext(ctx, {\n                expected: util.joinValues(expectedValues),\n                received: ctx.parsedType,\n                code: ZodIssueCode.invalid_type\n            });\n            return INVALID;\n        }\n        if (this._def.values.indexOf(input.data) === -1) {\n            const ctx = this._getOrReturnCtx(input);\n            const expectedValues = this._def.values;\n            addIssueToContext(ctx, {\n                received: ctx.data,\n                code: ZodIssueCode.invalid_enum_value,\n                options: expectedValues\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n    get options() {\n        return this._def.values;\n    }\n    get enum() {\n        const enumValues = {};\n        for (const val of this._def.values){\n            enumValues[val] = val;\n        }\n        return enumValues;\n    }\n    get Values() {\n        const enumValues = {};\n        for (const val of this._def.values){\n            enumValues[val] = val;\n        }\n        return enumValues;\n    }\n    get Enum() {\n        const enumValues = {};\n        for (const val of this._def.values){\n            enumValues[val] = val;\n        }\n        return enumValues;\n    }\n    extract(values) {\n        return ZodEnum.create(values);\n    }\n    exclude(values) {\n        return ZodEnum.create(this.options.filter((opt)=>!values.includes(opt)));\n    }\n}\nZodEnum.create = createZodEnum;\nclass ZodNativeEnum extends ZodType {\n    _parse(input) {\n        const nativeEnumValues = util.getValidEnumValues(this._def.values);\n        const ctx = this._getOrReturnCtx(input);\n        if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {\n            const expectedValues = util.objectValues(nativeEnumValues);\n            addIssueToContext(ctx, {\n                expected: util.joinValues(expectedValues),\n                received: ctx.parsedType,\n                code: ZodIssueCode.invalid_type\n            });\n            return INVALID;\n        }\n        if (nativeEnumValues.indexOf(input.data) === -1) {\n            const expectedValues = util.objectValues(nativeEnumValues);\n            addIssueToContext(ctx, {\n                received: ctx.data,\n                code: ZodIssueCode.invalid_enum_value,\n                options: expectedValues\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n    get enum() {\n        return this._def.values;\n    }\n}\nZodNativeEnum.create = (values, params)=>{\n    return new ZodNativeEnum({\n        values: values,\n        typeName: ZodFirstPartyTypeKind.ZodNativeEnum,\n        ...processCreateParams(params)\n    });\n};\nclass ZodPromise extends ZodType {\n    unwrap() {\n        return this._def.type;\n    }\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.promise,\n                received: ctx.parsedType\n            });\n            return INVALID;\n        }\n        const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);\n        return OK(promisified.then((data)=>{\n            return this._def.type.parseAsync(data, {\n                path: ctx.path,\n                errorMap: ctx.common.contextualErrorMap\n            });\n        }));\n    }\n}\nZodPromise.create = (schema, params)=>{\n    return new ZodPromise({\n        type: schema,\n        typeName: ZodFirstPartyTypeKind.ZodPromise,\n        ...processCreateParams(params)\n    });\n};\nclass ZodEffects extends ZodType {\n    innerType() {\n        return this._def.schema;\n    }\n    sourceType() {\n        return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;\n    }\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        const effect = this._def.effect || null;\n        const checkCtx = {\n            addIssue: (arg)=>{\n                addIssueToContext(ctx, arg);\n                if (arg.fatal) {\n                    status.abort();\n                } else {\n                    status.dirty();\n                }\n            },\n            get path () {\n                return ctx.path;\n            }\n        };\n        checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);\n        if (effect.type === \"preprocess\") {\n            const processed = effect.transform(ctx.data, checkCtx);\n            if (ctx.common.issues.length) {\n                return {\n                    status: \"dirty\",\n                    value: ctx.data\n                };\n            }\n            if (ctx.common.async) {\n                return Promise.resolve(processed).then((processed)=>{\n                    return this._def.schema._parseAsync({\n                        data: processed,\n                        path: ctx.path,\n                        parent: ctx\n                    });\n                });\n            } else {\n                return this._def.schema._parseSync({\n                    data: processed,\n                    path: ctx.path,\n                    parent: ctx\n                });\n            }\n        }\n        if (effect.type === \"refinement\") {\n            const executeRefinement = (acc)=>{\n                const result = effect.refinement(acc, checkCtx);\n                if (ctx.common.async) {\n                    return Promise.resolve(result);\n                }\n                if (result instanceof Promise) {\n                    throw new Error(\"Async refinement encountered during synchronous parse operation. Use .parseAsync instead.\");\n                }\n                return acc;\n            };\n            if (ctx.common.async === false) {\n                const inner = this._def.schema._parseSync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx\n                });\n                if (inner.status === \"aborted\") return INVALID;\n                if (inner.status === \"dirty\") status.dirty();\n                // return value is ignored\n                executeRefinement(inner.value);\n                return {\n                    status: status.value,\n                    value: inner.value\n                };\n            } else {\n                return this._def.schema._parseAsync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx\n                }).then((inner)=>{\n                    if (inner.status === \"aborted\") return INVALID;\n                    if (inner.status === \"dirty\") status.dirty();\n                    return executeRefinement(inner.value).then(()=>{\n                        return {\n                            status: status.value,\n                            value: inner.value\n                        };\n                    });\n                });\n            }\n        }\n        if (effect.type === \"transform\") {\n            if (ctx.common.async === false) {\n                const base = this._def.schema._parseSync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx\n                });\n                if (!isValid(base)) return base;\n                const result = effect.transform(base.value, checkCtx);\n                if (result instanceof Promise) {\n                    throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);\n                }\n                return {\n                    status: status.value,\n                    value: result\n                };\n            } else {\n                return this._def.schema._parseAsync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx\n                }).then((base)=>{\n                    if (!isValid(base)) return base;\n                    return Promise.resolve(effect.transform(base.value, checkCtx)).then((result)=>({\n                            status: status.value,\n                            value: result\n                        }));\n                });\n            }\n        }\n        util.assertNever(effect);\n    }\n}\nZodEffects.create = (schema, effect, params)=>{\n    return new ZodEffects({\n        schema,\n        typeName: ZodFirstPartyTypeKind.ZodEffects,\n        effect,\n        ...processCreateParams(params)\n    });\n};\nZodEffects.createWithPreprocess = (preprocess, schema, params)=>{\n    return new ZodEffects({\n        schema,\n        effect: {\n            type: \"preprocess\",\n            transform: preprocess\n        },\n        typeName: ZodFirstPartyTypeKind.ZodEffects,\n        ...processCreateParams(params)\n    });\n};\nclass ZodOptional extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType === ZodParsedType.undefined) {\n            return OK(undefined);\n        }\n        return this._def.innerType._parse(input);\n    }\n    unwrap() {\n        return this._def.innerType;\n    }\n}\nZodOptional.create = (type, params)=>{\n    return new ZodOptional({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodOptional,\n        ...processCreateParams(params)\n    });\n};\nclass ZodNullable extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType === ZodParsedType.null) {\n            return OK(null);\n        }\n        return this._def.innerType._parse(input);\n    }\n    unwrap() {\n        return this._def.innerType;\n    }\n}\nZodNullable.create = (type, params)=>{\n    return new ZodNullable({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodNullable,\n        ...processCreateParams(params)\n    });\n};\nclass ZodDefault extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        let data = ctx.data;\n        if (ctx.parsedType === ZodParsedType.undefined) {\n            data = this._def.defaultValue();\n        }\n        return this._def.innerType._parse({\n            data,\n            path: ctx.path,\n            parent: ctx\n        });\n    }\n    removeDefault() {\n        return this._def.innerType;\n    }\n}\nZodDefault.create = (type, params)=>{\n    return new ZodDefault({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodDefault,\n        defaultValue: typeof params.default === \"function\" ? params.default : ()=>params.default,\n        ...processCreateParams(params)\n    });\n};\nclass ZodCatch extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        // newCtx is used to not collect issues from inner types in ctx\n        const newCtx = {\n            ...ctx,\n            common: {\n                ...ctx.common,\n                issues: []\n            }\n        };\n        const result = this._def.innerType._parse({\n            data: newCtx.data,\n            path: newCtx.path,\n            parent: {\n                ...newCtx\n            }\n        });\n        if (isAsync(result)) {\n            return result.then((result)=>{\n                return {\n                    status: \"valid\",\n                    value: result.status === \"valid\" ? result.value : this._def.catchValue({\n                        get error () {\n                            return new ZodError(newCtx.common.issues);\n                        },\n                        input: newCtx.data\n                    })\n                };\n            });\n        } else {\n            return {\n                status: \"valid\",\n                value: result.status === \"valid\" ? result.value : this._def.catchValue({\n                    get error () {\n                        return new ZodError(newCtx.common.issues);\n                    },\n                    input: newCtx.data\n                })\n            };\n        }\n    }\n    removeCatch() {\n        return this._def.innerType;\n    }\n}\nZodCatch.create = (type, params)=>{\n    return new ZodCatch({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodCatch,\n        catchValue: typeof params.catch === \"function\" ? params.catch : ()=>params.catch,\n        ...processCreateParams(params)\n    });\n};\nclass ZodNaN extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.nan) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.nan,\n                received: ctx.parsedType\n            });\n            return INVALID;\n        }\n        return {\n            status: \"valid\",\n            value: input.data\n        };\n    }\n}\nZodNaN.create = (params)=>{\n    return new ZodNaN({\n        typeName: ZodFirstPartyTypeKind.ZodNaN,\n        ...processCreateParams(params)\n    });\n};\nconst BRAND = Symbol(\"zod_brand\");\nclass ZodBranded extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        const data = ctx.data;\n        return this._def.type._parse({\n            data,\n            path: ctx.path,\n            parent: ctx\n        });\n    }\n    unwrap() {\n        return this._def.type;\n    }\n}\nclass ZodPipeline extends ZodType {\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.common.async) {\n            const handleAsync = async ()=>{\n                const inResult = await this._def.in._parseAsync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx\n                });\n                if (inResult.status === \"aborted\") return INVALID;\n                if (inResult.status === \"dirty\") {\n                    status.dirty();\n                    return DIRTY(inResult.value);\n                } else {\n                    return this._def.out._parseAsync({\n                        data: inResult.value,\n                        path: ctx.path,\n                        parent: ctx\n                    });\n                }\n            };\n            return handleAsync();\n        } else {\n            const inResult = this._def.in._parseSync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx\n            });\n            if (inResult.status === \"aborted\") return INVALID;\n            if (inResult.status === \"dirty\") {\n                status.dirty();\n                return {\n                    status: \"dirty\",\n                    value: inResult.value\n                };\n            } else {\n                return this._def.out._parseSync({\n                    data: inResult.value,\n                    path: ctx.path,\n                    parent: ctx\n                });\n            }\n        }\n    }\n    static create(a, b) {\n        return new ZodPipeline({\n            in: a,\n            out: b,\n            typeName: ZodFirstPartyTypeKind.ZodPipeline\n        });\n    }\n}\nclass ZodReadonly extends ZodType {\n    _parse(input) {\n        const result = this._def.innerType._parse(input);\n        if (isValid(result)) {\n            result.value = Object.freeze(result.value);\n        }\n        return result;\n    }\n}\nZodReadonly.create = (type, params)=>{\n    return new ZodReadonly({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodReadonly,\n        ...processCreateParams(params)\n    });\n};\nconst custom = (check, params = {}, /**\n * @deprecated\n *\n * Pass `fatal` into the params object instead:\n *\n * ```ts\n * z.string().custom((val) => val.length > 5, { fatal: false })\n * ```\n *\n */ fatal)=>{\n    if (check) return ZodAny.create().superRefine((data, ctx)=>{\n        var _a, _b;\n        if (!check(data)) {\n            const p = typeof params === \"function\" ? params(data) : typeof params === \"string\" ? {\n                message: params\n            } : params;\n            const _fatal = (_b = (_a = p.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;\n            const p2 = typeof p === \"string\" ? {\n                message: p\n            } : p;\n            ctx.addIssue({\n                code: \"custom\",\n                ...p2,\n                fatal: _fatal\n            });\n        }\n    });\n    return ZodAny.create();\n};\nconst late = {\n    object: ZodObject.lazycreate\n};\nvar ZodFirstPartyTypeKind;\n(function(ZodFirstPartyTypeKind) {\n    ZodFirstPartyTypeKind[\"ZodString\"] = \"ZodString\";\n    ZodFirstPartyTypeKind[\"ZodNumber\"] = \"ZodNumber\";\n    ZodFirstPartyTypeKind[\"ZodNaN\"] = \"ZodNaN\";\n    ZodFirstPartyTypeKind[\"ZodBigInt\"] = \"ZodBigInt\";\n    ZodFirstPartyTypeKind[\"ZodBoolean\"] = \"ZodBoolean\";\n    ZodFirstPartyTypeKind[\"ZodDate\"] = \"ZodDate\";\n    ZodFirstPartyTypeKind[\"ZodSymbol\"] = \"ZodSymbol\";\n    ZodFirstPartyTypeKind[\"ZodUndefined\"] = \"ZodUndefined\";\n    ZodFirstPartyTypeKind[\"ZodNull\"] = \"ZodNull\";\n    ZodFirstPartyTypeKind[\"ZodAny\"] = \"ZodAny\";\n    ZodFirstPartyTypeKind[\"ZodUnknown\"] = \"ZodUnknown\";\n    ZodFirstPartyTypeKind[\"ZodNever\"] = \"ZodNever\";\n    ZodFirstPartyTypeKind[\"ZodVoid\"] = \"ZodVoid\";\n    ZodFirstPartyTypeKind[\"ZodArray\"] = \"ZodArray\";\n    ZodFirstPartyTypeKind[\"ZodObject\"] = \"ZodObject\";\n    ZodFirstPartyTypeKind[\"ZodUnion\"] = \"ZodUnion\";\n    ZodFirstPartyTypeKind[\"ZodDiscriminatedUnion\"] = \"ZodDiscriminatedUnion\";\n    ZodFirstPartyTypeKind[\"ZodIntersection\"] = \"ZodIntersection\";\n    ZodFirstPartyTypeKind[\"ZodTuple\"] = \"ZodTuple\";\n    ZodFirstPartyTypeKind[\"ZodRecord\"] = \"ZodRecord\";\n    ZodFirstPartyTypeKind[\"ZodMap\"] = \"ZodMap\";\n    ZodFirstPartyTypeKind[\"ZodSet\"] = \"ZodSet\";\n    ZodFirstPartyTypeKind[\"ZodFunction\"] = \"ZodFunction\";\n    ZodFirstPartyTypeKind[\"ZodLazy\"] = \"ZodLazy\";\n    ZodFirstPartyTypeKind[\"ZodLiteral\"] = \"ZodLiteral\";\n    ZodFirstPartyTypeKind[\"ZodEnum\"] = \"ZodEnum\";\n    ZodFirstPartyTypeKind[\"ZodEffects\"] = \"ZodEffects\";\n    ZodFirstPartyTypeKind[\"ZodNativeEnum\"] = \"ZodNativeEnum\";\n    ZodFirstPartyTypeKind[\"ZodOptional\"] = \"ZodOptional\";\n    ZodFirstPartyTypeKind[\"ZodNullable\"] = \"ZodNullable\";\n    ZodFirstPartyTypeKind[\"ZodDefault\"] = \"ZodDefault\";\n    ZodFirstPartyTypeKind[\"ZodCatch\"] = \"ZodCatch\";\n    ZodFirstPartyTypeKind[\"ZodPromise\"] = \"ZodPromise\";\n    ZodFirstPartyTypeKind[\"ZodBranded\"] = \"ZodBranded\";\n    ZodFirstPartyTypeKind[\"ZodPipeline\"] = \"ZodPipeline\";\n    ZodFirstPartyTypeKind[\"ZodReadonly\"] = \"ZodReadonly\";\n})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));\nconst instanceOfType = (// const instanceOfType = <T extends new (...args: any[]) => any>(\ncls, params = {\n    message: `Input not instance of ${cls.name}`\n})=>custom((data)=>data instanceof cls, params);\nconst stringType = ZodString.create;\nconst numberType = ZodNumber.create;\nconst nanType = ZodNaN.create;\nconst bigIntType = ZodBigInt.create;\nconst booleanType = ZodBoolean.create;\nconst dateType = ZodDate.create;\nconst symbolType = ZodSymbol.create;\nconst undefinedType = ZodUndefined.create;\nconst nullType = ZodNull.create;\nconst anyType = ZodAny.create;\nconst unknownType = ZodUnknown.create;\nconst neverType = ZodNever.create;\nconst voidType = ZodVoid.create;\nconst arrayType = ZodArray.create;\nconst objectType = ZodObject.create;\nconst strictObjectType = ZodObject.strictCreate;\nconst unionType = ZodUnion.create;\nconst discriminatedUnionType = ZodDiscriminatedUnion.create;\nconst intersectionType = ZodIntersection.create;\nconst tupleType = ZodTuple.create;\nconst recordType = ZodRecord.create;\nconst mapType = ZodMap.create;\nconst setType = ZodSet.create;\nconst functionType = ZodFunction.create;\nconst lazyType = ZodLazy.create;\nconst literalType = ZodLiteral.create;\nconst enumType = ZodEnum.create;\nconst nativeEnumType = ZodNativeEnum.create;\nconst promiseType = ZodPromise.create;\nconst effectsType = ZodEffects.create;\nconst optionalType = ZodOptional.create;\nconst nullableType = ZodNullable.create;\nconst preprocessType = ZodEffects.createWithPreprocess;\nconst pipelineType = ZodPipeline.create;\nconst ostring = ()=>stringType().optional();\nconst onumber = ()=>numberType().optional();\nconst oboolean = ()=>booleanType().optional();\nconst coerce = {\n    string: (arg)=>ZodString.create({\n            ...arg,\n            coerce: true\n        }),\n    number: (arg)=>ZodNumber.create({\n            ...arg,\n            coerce: true\n        }),\n    boolean: (arg)=>ZodBoolean.create({\n            ...arg,\n            coerce: true\n        }),\n    bigint: (arg)=>ZodBigInt.create({\n            ...arg,\n            coerce: true\n        }),\n    date: (arg)=>ZodDate.create({\n            ...arg,\n            coerce: true\n        })\n};\nconst NEVER = INVALID;\nvar z = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    defaultErrorMap: errorMap,\n    setErrorMap: setErrorMap,\n    getErrorMap: getErrorMap,\n    makeIssue: makeIssue,\n    EMPTY_PATH: EMPTY_PATH,\n    addIssueToContext: addIssueToContext,\n    ParseStatus: ParseStatus,\n    INVALID: INVALID,\n    DIRTY: DIRTY,\n    OK: OK,\n    isAborted: isAborted,\n    isDirty: isDirty,\n    isValid: isValid,\n    isAsync: isAsync,\n    get util () {\n        return util;\n    },\n    get objectUtil () {\n        return objectUtil;\n    },\n    ZodParsedType: ZodParsedType,\n    getParsedType: getParsedType,\n    ZodType: ZodType,\n    ZodString: ZodString,\n    ZodNumber: ZodNumber,\n    ZodBigInt: ZodBigInt,\n    ZodBoolean: ZodBoolean,\n    ZodDate: ZodDate,\n    ZodSymbol: ZodSymbol,\n    ZodUndefined: ZodUndefined,\n    ZodNull: ZodNull,\n    ZodAny: ZodAny,\n    ZodUnknown: ZodUnknown,\n    ZodNever: ZodNever,\n    ZodVoid: ZodVoid,\n    ZodArray: ZodArray,\n    ZodObject: ZodObject,\n    ZodUnion: ZodUnion,\n    ZodDiscriminatedUnion: ZodDiscriminatedUnion,\n    ZodIntersection: ZodIntersection,\n    ZodTuple: ZodTuple,\n    ZodRecord: ZodRecord,\n    ZodMap: ZodMap,\n    ZodSet: ZodSet,\n    ZodFunction: ZodFunction,\n    ZodLazy: ZodLazy,\n    ZodLiteral: ZodLiteral,\n    ZodEnum: ZodEnum,\n    ZodNativeEnum: ZodNativeEnum,\n    ZodPromise: ZodPromise,\n    ZodEffects: ZodEffects,\n    ZodTransformer: ZodEffects,\n    ZodOptional: ZodOptional,\n    ZodNullable: ZodNullable,\n    ZodDefault: ZodDefault,\n    ZodCatch: ZodCatch,\n    ZodNaN: ZodNaN,\n    BRAND: BRAND,\n    ZodBranded: ZodBranded,\n    ZodPipeline: ZodPipeline,\n    ZodReadonly: ZodReadonly,\n    custom: custom,\n    Schema: ZodType,\n    ZodSchema: ZodType,\n    late: late,\n    get ZodFirstPartyTypeKind () {\n        return ZodFirstPartyTypeKind;\n    },\n    coerce: coerce,\n    any: anyType,\n    array: arrayType,\n    bigint: bigIntType,\n    boolean: booleanType,\n    date: dateType,\n    discriminatedUnion: discriminatedUnionType,\n    effect: effectsType,\n    \"enum\": enumType,\n    \"function\": functionType,\n    \"instanceof\": instanceOfType,\n    intersection: intersectionType,\n    lazy: lazyType,\n    literal: literalType,\n    map: mapType,\n    nan: nanType,\n    nativeEnum: nativeEnumType,\n    never: neverType,\n    \"null\": nullType,\n    nullable: nullableType,\n    number: numberType,\n    object: objectType,\n    oboolean: oboolean,\n    onumber: onumber,\n    optional: optionalType,\n    ostring: ostring,\n    pipeline: pipelineType,\n    preprocess: preprocessType,\n    promise: promiseType,\n    record: recordType,\n    set: setType,\n    strictObject: strictObjectType,\n    string: stringType,\n    symbol: symbolType,\n    transformer: effectsType,\n    tuple: tupleType,\n    \"undefined\": undefinedType,\n    union: unionType,\n    unknown: unknownType,\n    \"void\": voidType,\n    NEVER: NEVER,\n    ZodIssueCode: ZodIssueCode,\n    quotelessJson: quotelessJson,\n    ZodError: ZodError\n});\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3pvZEAzLjIyLjQvbm9kZV9tb2R1bGVzL3pvZC9saWIvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLElBQUlBO0FBQ0gsVUFBVUEsSUFBSTtJQUNYQSxLQUFLQyxXQUFXLEdBQUcsQ0FBQ0MsTUFBUUE7SUFDNUIsU0FBU0MsU0FBU0MsSUFBSSxHQUFJO0lBQzFCSixLQUFLRyxRQUFRLEdBQUdBO0lBQ2hCLFNBQVNFLFlBQVlDLEVBQUU7UUFDbkIsTUFBTSxJQUFJQztJQUNkO0lBQ0FQLEtBQUtLLFdBQVcsR0FBR0E7SUFDbkJMLEtBQUtRLFdBQVcsR0FBRyxDQUFDQztRQUNoQixNQUFNQyxNQUFNLENBQUM7UUFDYixLQUFLLE1BQU1DLFFBQVFGLE1BQU87WUFDdEJDLEdBQUcsQ0FBQ0MsS0FBSyxHQUFHQTtRQUNoQjtRQUNBLE9BQU9EO0lBQ1g7SUFDQVYsS0FBS1ksa0JBQWtCLEdBQUcsQ0FBQ0Y7UUFDdkIsTUFBTUcsWUFBWWIsS0FBS2MsVUFBVSxDQUFDSixLQUFLSyxNQUFNLENBQUMsQ0FBQ0MsSUFBTSxPQUFPTixHQUFHLENBQUNBLEdBQUcsQ0FBQ00sRUFBRSxDQUFDLEtBQUs7UUFDNUUsTUFBTUMsV0FBVyxDQUFDO1FBQ2xCLEtBQUssTUFBTUQsS0FBS0gsVUFBVztZQUN2QkksUUFBUSxDQUFDRCxFQUFFLEdBQUdOLEdBQUcsQ0FBQ00sRUFBRTtRQUN4QjtRQUNBLE9BQU9oQixLQUFLa0IsWUFBWSxDQUFDRDtJQUM3QjtJQUNBakIsS0FBS2tCLFlBQVksR0FBRyxDQUFDUjtRQUNqQixPQUFPVixLQUFLYyxVQUFVLENBQUNKLEtBQUtTLEdBQUcsQ0FBQyxTQUFVQyxDQUFDO1lBQ3ZDLE9BQU9WLEdB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dEI7SUFDVGxpQixLQUFLOGhCO0lBQ0x6ZixLQUFLc2U7SUFDTDhDLFlBQVlyQjtJQUNaMUwsT0FBTzBLO0lBQ1AsUUFBUUg7SUFDUnJVLFVBQVU0VjtJQUNWbGdCLFFBQVFvZTtJQUNSdGdCLFFBQVFtaEI7SUFDUnNCLFVBQVVBO0lBQ1ZELFNBQVNBO0lBQ1RqVyxVQUFVNFY7SUFDVkksU0FBU0E7SUFDVGUsVUFBVWhCO0lBQ1ZsRCxZQUFZaUQ7SUFDWnpmLFNBQVNxZjtJQUNUc0IsUUFBUTlCO0lBQ1IxZSxLQUFLNGU7SUFDTDZCLGNBQWNwQztJQUNkcmYsUUFBUXNlO0lBQ1IvZCxRQUFRcWU7SUFDUjhDLGFBQWF2QjtJQUNid0IsT0FBT2xDO0lBQ1AsYUFBYVo7SUFDYitDLE9BQU90QztJQUNQbmUsU0FBUzZkO0lBQ1QsUUFBUUU7SUFDUnlCLE9BQU9BO0lBQ1B2ZixjQUFjQTtJQUNkQyxlQUFlQTtJQUNmSyxVQUFVQTtBQUNkO0FBRTZxRCIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vem9kQDMuMjIuNC9ub2RlX21vZHVsZXMvem9kL2xpYi9pbmRleC5tanM/NzM3OCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgdXRpbDtcbihmdW5jdGlvbiAodXRpbCkge1xuICAgIHV0aWwuYXNzZXJ0RXF1YWwgPSAodmFsKSA9PiB2YWw7XG4gICAgZnVuY3Rpb24gYXNzZXJ0SXMoX2FyZykgeyB9XG4gICAgdXRpbC5hc3NlcnRJcyA9IGFzc2VydElzO1xuICAgIGZ1bmN0aW9uIGFzc2VydE5ldmVyKF94KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgIH1cbiAgICB1dGlsLmFzc2VydE5ldmVyID0gYXNzZXJ0TmV2ZXI7XG4gICAgdXRpbC5hcnJheVRvRW51bSA9IChpdGVtcykgPT4ge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGl0ZW1zKSB7XG4gICAgICAgICAgICBvYmpbaXRlbV0gPSBpdGVtO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfTtcbiAgICB1dGlsLmdldFZhbGlkRW51bVZhbHVlcyA9IChvYmopID0+IHtcbiAgICAgICAgY29uc3QgdmFsaWRLZXlzID0gdXRpbC5vYmplY3RLZXlzKG9iaikuZmlsdGVyKChrKSA9PiB0eXBlb2Ygb2JqW29ialtrXV0gIT09IFwibnVtYmVyXCIpO1xuICAgICAgICBjb25zdCBmaWx0ZXJlZCA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGsgb2YgdmFsaWRLZXlzKSB7XG4gICAgICAgICAgICBmaWx0ZXJlZFtrXSA9IG9ialtrXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXRpbC5vYmplY3RWYWx1ZXMoZmlsdGVyZWQpO1xuICAgIH07XG4gICAgdXRpbC5vYmplY3RWYWx1ZXMgPSAob2JqKSA9PiB7XG4gICAgICAgIHJldHVybiB1dGlsLm9iamVjdEtleXMob2JqKS5tYXAoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmpbZV07XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgdXRpbC5vYmplY3RLZXlzID0gdHlwZW9mIE9iamVjdC5rZXlzID09PSBcImZ1bmN0aW9uXCIgLy8gZXNsaW50LWRpc2FibGUtbGluZSBiYW4vYmFuXG4gICAgICAgID8gKG9iaikgPT4gT2JqZWN0LmtleXMob2JqKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGJhbi9iYW5cbiAgICAgICAgOiAob2JqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBrZXlzID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ga2V5cztcbiAgICAgICAgfTtcbiAgICB1dGlsLmZpbmQgPSAoYXJyLCBjaGVja2VyKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBhcnIpIHtcbiAgICAgICAgICAgIGlmIChjaGVja2VyKGl0ZW0pKVxuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICB1dGlsLmlzSW50ZWdlciA9IHR5cGVvZiBOdW1iZXIuaXNJbnRlZ2VyID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgPyAodmFsKSA9PiBOdW1iZXIuaXNJbnRlZ2VyKHZhbCkgLy8gZXNsaW50LWRpc2FibGUtbGluZSBiYW4vYmFuXG4gICAgICAgIDogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gXCJudW1iZXJcIiAmJiBpc0Zpbml0ZSh2YWwpICYmIE1hdGguZmxvb3IodmFsKSA9PT0gdmFsO1xuICAgIGZ1bmN0aW9uIGpvaW5WYWx1ZXMoYXJyYXksIHNlcGFyYXRvciA9IFwiIHwgXCIpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5XG4gICAgICAgICAgICAubWFwKCh2YWwpID0+ICh0eXBlb2YgdmFsID09PSBcInN0cmluZ1wiID8gYCcke3ZhbH0nYCA6IHZhbCkpXG4gICAgICAgICAgICAuam9pbihzZXBhcmF0b3IpO1xuICAgIH1cbiAgICB1dGlsLmpvaW5WYWx1ZXMgPSBqb2luVmFsdWVzO1xuICAgIHV0aWwuanNvblN0cmluZ2lmeVJlcGxhY2VyID0gKF8sIHZhbHVlKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiYmlnaW50XCIpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xufSkodXRpbCB8fCAodXRpbCA9IHt9KSk7XG52YXIgb2JqZWN0VXRpbDtcbihmdW5jdGlvbiAob2JqZWN0VXRpbCkge1xuICAgIG9iamVjdFV0aWwubWVyZ2VTaGFwZXMgPSAoZmlyc3QsIHNlY29uZCkgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uZmlyc3QsXG4gICAgICAgICAgICAuLi5zZWNvbmQsIC8vIHNlY29uZCBvdmVyd3JpdGVzIGZpcnN0XG4gICAgICAgIH07XG4gICAgfTtcbn0pKG9iamVjdFV0aWwgfHwgKG9iamVjdFV0aWwgPSB7fSkpO1xuY29uc3QgWm9kUGFyc2VkVHlwZSA9IHV0aWwuYXJyYXlUb0VudW0oW1xuICAgIFwic3RyaW5nXCIsXG4gICAgXCJuYW5cIixcbiAgICBcIm51bWJlclwiLFxuICAgIFwiaW50ZWdlclwiLFxuICAgIFwiZmxvYXRcIixcbiAgICBcImJvb2xlYW5cIixcbiAgICBcImRhdGVcIixcbiAgICBcImJpZ2ludFwiLFxuICAgIFwic3ltYm9sXCIsXG4gICAgXCJmdW5jdGlvblwiLFxuICAgIFwidW5kZWZpbmVkXCIsXG4gICAgXCJudWxsXCIsXG4gICAgXCJhcnJheVwiLFxuICAgIFwib2JqZWN0XCIsXG4gICAgXCJ1bmtub3duXCIsXG4gICAgXCJwcm9taXNlXCIsXG4gICAgXCJ2b2lkXCIsXG4gICAgXCJuZXZlclwiLFxuICAgIFwibWFwXCIsXG4gICAgXCJzZXRcIixcbl0pO1xuY29uc3QgZ2V0UGFyc2VkVHlwZSA9IChkYXRhKSA9PiB7XG4gICAgY29uc3QgdCA9IHR5cGVvZiBkYXRhO1xuICAgIHN3aXRjaCAodCkge1xuICAgICAgICBjYXNlIFwidW5kZWZpbmVkXCI6XG4gICAgICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS51bmRlZmluZWQ7XG4gICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLnN0cmluZztcbiAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICAgICAgcmV0dXJuIGlzTmFOKGRhdGEpID8gWm9kUGFyc2VkVHlwZS5uYW4gOiBab2RQYXJzZWRUeXBlLm51bWJlcjtcbiAgICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLmJvb2xlYW47XG4gICAgICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUuZnVuY3Rpb247XG4gICAgICAgIGNhc2UgXCJiaWdpbnRcIjpcbiAgICAgICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLmJpZ2ludDtcbiAgICAgICAgY2FzZSBcInN5bWJvbFwiOlxuICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUuc3ltYm9sO1xuICAgICAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLmFycmF5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGEgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5udWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGEudGhlbiAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBkYXRhLnRoZW4gPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICAgICAgICAgIGRhdGEuY2F0Y2ggJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgZGF0YS5jYXRjaCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUucHJvbWlzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgTWFwICE9PSBcInVuZGVmaW5lZFwiICYmIGRhdGEgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5tYXA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIFNldCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkYXRhIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUuc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBEYXRlICE9PSBcInVuZGVmaW5lZFwiICYmIGRhdGEgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUuZGF0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLm9iamVjdDtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLnVua25vd247XG4gICAgfVxufTtcblxuY29uc3QgWm9kSXNzdWVDb2RlID0gdXRpbC5hcnJheVRvRW51bShbXG4gICAgXCJpbnZhbGlkX3R5cGVcIixcbiAgICBcImludmFsaWRfbGl0ZXJhbFwiLFxuICAgIFwiY3VzdG9tXCIsXG4gICAgXCJpbnZhbGlkX3VuaW9uXCIsXG4gICAgXCJpbnZhbGlkX3VuaW9uX2Rpc2NyaW1pbmF0b3JcIixcbiAgICBcImludmFsaWRfZW51bV92YWx1ZVwiLFxuICAgIFwidW5yZWNvZ25pemVkX2tleXNcIixcbiAgICBcImludmFsaWRfYXJndW1lbnRzXCIsXG4gICAgXCJpbnZhbGlkX3JldHVybl90eXBlXCIsXG4gICAgXCJpbnZhbGlkX2RhdGVcIixcbiAgICBcImludmFsaWRfc3RyaW5nXCIsXG4gICAgXCJ0b29fc21hbGxcIixcbiAgICBcInRvb19iaWdcIixcbiAgICBcImludmFsaWRfaW50ZXJzZWN0aW9uX3R5cGVzXCIsXG4gICAgXCJub3RfbXVsdGlwbGVfb2ZcIixcbiAgICBcIm5vdF9maW5pdGVcIixcbl0pO1xuY29uc3QgcXVvdGVsZXNzSnNvbiA9IChvYmopID0+IHtcbiAgICBjb25zdCBqc29uID0gSlNPTi5zdHJpbmdpZnkob2JqLCBudWxsLCAyKTtcbiAgICByZXR1cm4ganNvbi5yZXBsYWNlKC9cIihbXlwiXSspXCI6L2csIFwiJDE6XCIpO1xufTtcbmNsYXNzIFpvZEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGlzc3Vlcykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmlzc3VlcyA9IFtdO1xuICAgICAgICB0aGlzLmFkZElzc3VlID0gKHN1YikgPT4ge1xuICAgICAgICAgICAgdGhpcy5pc3N1ZXMgPSBbLi4udGhpcy5pc3N1ZXMsIHN1Yl07XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYWRkSXNzdWVzID0gKHN1YnMgPSBbXSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5pc3N1ZXMgPSBbLi4udGhpcy5pc3N1ZXMsIC4uLnN1YnNdO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBhY3R1YWxQcm90byA9IG5ldy50YXJnZXQucHJvdG90eXBlO1xuICAgICAgICBpZiAoT2JqZWN0LnNldFByb3RvdHlwZU9mKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgYmFuL2JhblxuICAgICAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIGFjdHVhbFByb3RvKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX19wcm90b19fID0gYWN0dWFsUHJvdG87XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5uYW1lID0gXCJab2RFcnJvclwiO1xuICAgICAgICB0aGlzLmlzc3VlcyA9IGlzc3VlcztcbiAgICB9XG4gICAgZ2V0IGVycm9ycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNzdWVzO1xuICAgIH1cbiAgICBmb3JtYXQoX21hcHBlcikge1xuICAgICAgICBjb25zdCBtYXBwZXIgPSBfbWFwcGVyIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoaXNzdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNzdWUubWVzc2FnZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNvbnN0IGZpZWxkRXJyb3JzID0geyBfZXJyb3JzOiBbXSB9O1xuICAgICAgICBjb25zdCBwcm9jZXNzRXJyb3IgPSAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaXNzdWUgb2YgZXJyb3IuaXNzdWVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzc3VlLmNvZGUgPT09IFwiaW52YWxpZF91bmlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlzc3VlLnVuaW9uRXJyb3JzLm1hcChwcm9jZXNzRXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc3N1ZS5jb2RlID09PSBcImludmFsaWRfcmV0dXJuX3R5cGVcIikge1xuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzRXJyb3IoaXNzdWUucmV0dXJuVHlwZUVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNzdWUuY29kZSA9PT0gXCJpbnZhbGlkX2FyZ3VtZW50c1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3NFcnJvcihpc3N1ZS5hcmd1bWVudHNFcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzc3VlLnBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkRXJyb3JzLl9lcnJvcnMucHVzaChtYXBwZXIoaXNzdWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjdXJyID0gZmllbGRFcnJvcnM7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGkgPCBpc3N1ZS5wYXRoLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZWwgPSBpc3N1ZS5wYXRoW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdGVybWluYWwgPSBpID09PSBpc3N1ZS5wYXRoLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRlcm1pbmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycltlbF0gPSBjdXJyW2VsXSB8fCB7IF9lcnJvcnM6IFtdIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgKHR5cGVvZiBlbCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgY3VycltlbF0gPSBjdXJyW2VsXSB8fCB7IF9lcnJvcnM6IFtdIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gfSBlbHNlIGlmICh0eXBlb2YgZWwgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgIGNvbnN0IGVycm9yQXJyYXk6IGFueSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgZXJyb3JBcnJheS5fZXJyb3JzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICBjdXJyW2VsXSA9IGN1cnJbZWxdIHx8IGVycm9yQXJyYXk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycltlbF0gPSBjdXJyW2VsXSB8fCB7IF9lcnJvcnM6IFtdIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycltlbF0uX2Vycm9ycy5wdXNoKG1hcHBlcihpc3N1ZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY3VyciA9IGN1cnJbZWxdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBwcm9jZXNzRXJyb3IodGhpcyk7XG4gICAgICAgIHJldHVybiBmaWVsZEVycm9ycztcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1lc3NhZ2U7XG4gICAgfVxuICAgIGdldCBtZXNzYWdlKCkge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcy5pc3N1ZXMsIHV0aWwuanNvblN0cmluZ2lmeVJlcGxhY2VyLCAyKTtcbiAgICB9XG4gICAgZ2V0IGlzRW1wdHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzc3Vlcy5sZW5ndGggPT09IDA7XG4gICAgfVxuICAgIGZsYXR0ZW4obWFwcGVyID0gKGlzc3VlKSA9PiBpc3N1ZS5tZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IGZpZWxkRXJyb3JzID0ge307XG4gICAgICAgIGNvbnN0IGZvcm1FcnJvcnMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBzdWIgb2YgdGhpcy5pc3N1ZXMpIHtcbiAgICAgICAgICAgIGlmIChzdWIucGF0aC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgZmllbGRFcnJvcnNbc3ViLnBhdGhbMF1dID0gZmllbGRFcnJvcnNbc3ViLnBhdGhbMF1dIHx8IFtdO1xuICAgICAgICAgICAgICAgIGZpZWxkRXJyb3JzW3N1Yi5wYXRoWzBdXS5wdXNoKG1hcHBlcihzdWIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvcm1FcnJvcnMucHVzaChtYXBwZXIoc3ViKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgZm9ybUVycm9ycywgZmllbGRFcnJvcnMgfTtcbiAgICB9XG4gICAgZ2V0IGZvcm1FcnJvcnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZsYXR0ZW4oKTtcbiAgICB9XG59XG5ab2RFcnJvci5jcmVhdGUgPSAoaXNzdWVzKSA9PiB7XG4gICAgY29uc3QgZXJyb3IgPSBuZXcgWm9kRXJyb3IoaXNzdWVzKTtcbiAgICByZXR1cm4gZXJyb3I7XG59O1xuXG5jb25zdCBlcnJvck1hcCA9IChpc3N1ZSwgX2N0eCkgPT4ge1xuICAgIGxldCBtZXNzYWdlO1xuICAgIHN3aXRjaCAoaXNzdWUuY29kZSkge1xuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGU6XG4gICAgICAgICAgICBpZiAoaXNzdWUucmVjZWl2ZWQgPT09IFpvZFBhcnNlZFR5cGUudW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IFwiUmVxdWlyZWRcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgRXhwZWN0ZWQgJHtpc3N1ZS5leHBlY3RlZH0sIHJlY2VpdmVkICR7aXNzdWUucmVjZWl2ZWR9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS5pbnZhbGlkX2xpdGVyYWw6XG4gICAgICAgICAgICBtZXNzYWdlID0gYEludmFsaWQgbGl0ZXJhbCB2YWx1ZSwgZXhwZWN0ZWQgJHtKU09OLnN0cmluZ2lmeShpc3N1ZS5leHBlY3RlZCwgdXRpbC5qc29uU3RyaW5naWZ5UmVwbGFjZXIpfWA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUudW5yZWNvZ25pemVkX2tleXM6XG4gICAgICAgICAgICBtZXNzYWdlID0gYFVucmVjb2duaXplZCBrZXkocykgaW4gb2JqZWN0OiAke3V0aWwuam9pblZhbHVlcyhpc3N1ZS5rZXlzLCBcIiwgXCIpfWA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUuaW52YWxpZF91bmlvbjpcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBpbnB1dGA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUuaW52YWxpZF91bmlvbl9kaXNjcmltaW5hdG9yOlxuICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGRpc2NyaW1pbmF0b3IgdmFsdWUuIEV4cGVjdGVkICR7dXRpbC5qb2luVmFsdWVzKGlzc3VlLm9wdGlvbnMpfWA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUuaW52YWxpZF9lbnVtX3ZhbHVlOlxuICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGVudW0gdmFsdWUuIEV4cGVjdGVkICR7dXRpbC5qb2luVmFsdWVzKGlzc3VlLm9wdGlvbnMpfSwgcmVjZWl2ZWQgJyR7aXNzdWUucmVjZWl2ZWR9J2A7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUuaW52YWxpZF9hcmd1bWVudHM6XG4gICAgICAgICAgICBtZXNzYWdlID0gYEludmFsaWQgZnVuY3Rpb24gYXJndW1lbnRzYDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS5pbnZhbGlkX3JldHVybl90eXBlOlxuICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGZ1bmN0aW9uIHJldHVybiB0eXBlYDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS5pbnZhbGlkX2RhdGU6XG4gICAgICAgICAgICBtZXNzYWdlID0gYEludmFsaWQgZGF0ZWA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmc6XG4gICAgICAgICAgICBpZiAodHlwZW9mIGlzc3VlLnZhbGlkYXRpb24gPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoXCJpbmNsdWRlc1wiIGluIGlzc3VlLnZhbGlkYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGlucHV0OiBtdXN0IGluY2x1ZGUgXCIke2lzc3VlLnZhbGlkYXRpb24uaW5jbHVkZXN9XCJgO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGlzc3VlLnZhbGlkYXRpb24ucG9zaXRpb24gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgJHttZXNzYWdlfSBhdCBvbmUgb3IgbW9yZSBwb3NpdGlvbnMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvICR7aXNzdWUudmFsaWRhdGlvbi5wb3NpdGlvbn1gO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKFwic3RhcnRzV2l0aFwiIGluIGlzc3VlLnZhbGlkYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGlucHV0OiBtdXN0IHN0YXJ0IHdpdGggXCIke2lzc3VlLnZhbGlkYXRpb24uc3RhcnRzV2l0aH1cImA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKFwiZW5kc1dpdGhcIiBpbiBpc3N1ZS52YWxpZGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBpbnB1dDogbXVzdCBlbmQgd2l0aCBcIiR7aXNzdWUudmFsaWRhdGlvbi5lbmRzV2l0aH1cImA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB1dGlsLmFzc2VydE5ldmVyKGlzc3VlLnZhbGlkYXRpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzc3VlLnZhbGlkYXRpb24gIT09IFwicmVnZXhcIikge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgSW52YWxpZCAke2lzc3VlLnZhbGlkYXRpb259YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBcIkludmFsaWRcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS50b29fc21hbGw6XG4gICAgICAgICAgICBpZiAoaXNzdWUudHlwZSA9PT0gXCJhcnJheVwiKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgQXJyYXkgbXVzdCBjb250YWluICR7aXNzdWUuZXhhY3QgPyBcImV4YWN0bHlcIiA6IGlzc3VlLmluY2x1c2l2ZSA/IGBhdCBsZWFzdGAgOiBgbW9yZSB0aGFuYH0gJHtpc3N1ZS5taW5pbXVtfSBlbGVtZW50KHMpYDtcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzc3VlLnR5cGUgPT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBTdHJpbmcgbXVzdCBjb250YWluICR7aXNzdWUuZXhhY3QgPyBcImV4YWN0bHlcIiA6IGlzc3VlLmluY2x1c2l2ZSA/IGBhdCBsZWFzdGAgOiBgb3ZlcmB9ICR7aXNzdWUubWluaW11bX0gY2hhcmFjdGVyKHMpYDtcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzc3VlLnR5cGUgPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBOdW1iZXIgbXVzdCBiZSAke2lzc3VlLmV4YWN0XG4gICAgICAgICAgICAgICAgICAgID8gYGV4YWN0bHkgZXF1YWwgdG8gYFxuICAgICAgICAgICAgICAgICAgICA6IGlzc3VlLmluY2x1c2l2ZVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIGBcbiAgICAgICAgICAgICAgICAgICAgICAgIDogYGdyZWF0ZXIgdGhhbiBgfSR7aXNzdWUubWluaW11bX1gO1xuICAgICAgICAgICAgZWxzZSBpZiAoaXNzdWUudHlwZSA9PT0gXCJkYXRlXCIpXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBEYXRlIG11c3QgYmUgJHtpc3N1ZS5leGFjdFxuICAgICAgICAgICAgICAgICAgICA/IGBleGFjdGx5IGVxdWFsIHRvIGBcbiAgICAgICAgICAgICAgICAgICAgOiBpc3N1ZS5pbmNsdXNpdmVcbiAgICAgICAgICAgICAgICAgICAgICAgID8gYGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byBgXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGBncmVhdGVyIHRoYW4gYH0ke25ldyBEYXRlKE51bWJlcihpc3N1ZS5taW5pbXVtKSl9YDtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gXCJJbnZhbGlkIGlucHV0XCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUudG9vX2JpZzpcbiAgICAgICAgICAgIGlmIChpc3N1ZS50eXBlID09PSBcImFycmF5XCIpXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBBcnJheSBtdXN0IGNvbnRhaW4gJHtpc3N1ZS5leGFjdCA/IGBleGFjdGx5YCA6IGlzc3VlLmluY2x1c2l2ZSA/IGBhdCBtb3N0YCA6IGBsZXNzIHRoYW5gfSAke2lzc3VlLm1heGltdW19IGVsZW1lbnQocylgO1xuICAgICAgICAgICAgZWxzZSBpZiAoaXNzdWUudHlwZSA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gYFN0cmluZyBtdXN0IGNvbnRhaW4gJHtpc3N1ZS5leGFjdCA/IGBleGFjdGx5YCA6IGlzc3VlLmluY2x1c2l2ZSA/IGBhdCBtb3N0YCA6IGB1bmRlcmB9ICR7aXNzdWUubWF4aW11bX0gY2hhcmFjdGVyKHMpYDtcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzc3VlLnR5cGUgPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBOdW1iZXIgbXVzdCBiZSAke2lzc3VlLmV4YWN0XG4gICAgICAgICAgICAgICAgICAgID8gYGV4YWN0bHlgXG4gICAgICAgICAgICAgICAgICAgIDogaXNzdWUuaW5jbHVzaXZlXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGBsZXNzIHRoYW4gb3IgZXF1YWwgdG9gXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGBsZXNzIHRoYW5gfSAke2lzc3VlLm1heGltdW19YDtcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzc3VlLnR5cGUgPT09IFwiYmlnaW50XCIpXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBCaWdJbnQgbXVzdCBiZSAke2lzc3VlLmV4YWN0XG4gICAgICAgICAgICAgICAgICAgID8gYGV4YWN0bHlgXG4gICAgICAgICAgICAgICAgICAgIDogaXNzdWUuaW5jbHVzaXZlXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGBsZXNzIHRoYW4gb3IgZXF1YWwgdG9gXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGBsZXNzIHRoYW5gfSAke2lzc3VlLm1heGltdW19YDtcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzc3VlLnR5cGUgPT09IFwiZGF0ZVwiKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgRGF0ZSBtdXN0IGJlICR7aXNzdWUuZXhhY3RcbiAgICAgICAgICAgICAgICAgICAgPyBgZXhhY3RseWBcbiAgICAgICAgICAgICAgICAgICAgOiBpc3N1ZS5pbmNsdXNpdmVcbiAgICAgICAgICAgICAgICAgICAgICAgID8gYHNtYWxsZXIgdGhhbiBvciBlcXVhbCB0b2BcbiAgICAgICAgICAgICAgICAgICAgICAgIDogYHNtYWxsZXIgdGhhbmB9ICR7bmV3IERhdGUoTnVtYmVyKGlzc3VlLm1heGltdW0pKX1gO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBcIkludmFsaWQgaW5wdXRcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS5jdXN0b206XG4gICAgICAgICAgICBtZXNzYWdlID0gYEludmFsaWQgaW5wdXRgO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLmludmFsaWRfaW50ZXJzZWN0aW9uX3R5cGVzOlxuICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnRlcnNlY3Rpb24gcmVzdWx0cyBjb3VsZCBub3QgYmUgbWVyZ2VkYDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS5ub3RfbXVsdGlwbGVfb2Y6XG4gICAgICAgICAgICBtZXNzYWdlID0gYE51bWJlciBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgJHtpc3N1ZS5tdWx0aXBsZU9mfWA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUubm90X2Zpbml0ZTpcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBcIk51bWJlciBtdXN0IGJlIGZpbml0ZVwiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBtZXNzYWdlID0gX2N0eC5kZWZhdWx0RXJyb3I7XG4gICAgICAgICAgICB1dGlsLmFzc2VydE5ldmVyKGlzc3VlKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgbWVzc2FnZSB9O1xufTtcblxubGV0IG92ZXJyaWRlRXJyb3JNYXAgPSBlcnJvck1hcDtcbmZ1bmN0aW9uIHNldEVycm9yTWFwKG1hcCkge1xuICAgIG92ZXJyaWRlRXJyb3JNYXAgPSBtYXA7XG59XG5mdW5jdGlvbiBnZXRFcnJvck1hcCgpIHtcbiAgICByZXR1cm4gb3ZlcnJpZGVFcnJvck1hcDtcbn1cblxuY29uc3QgbWFrZUlzc3VlID0gKHBhcmFtcykgPT4ge1xuICAgIGNvbnN0IHsgZGF0YSwgcGF0aCwgZXJyb3JNYXBzLCBpc3N1ZURhdGEgfSA9IHBhcmFtcztcbiAgICBjb25zdCBmdWxsUGF0aCA9IFsuLi5wYXRoLCAuLi4oaXNzdWVEYXRhLnBhdGggfHwgW10pXTtcbiAgICBjb25zdCBmdWxsSXNzdWUgPSB7XG4gICAgICAgIC4uLmlzc3VlRGF0YSxcbiAgICAgICAgcGF0aDogZnVsbFBhdGgsXG4gICAgfTtcbiAgICBsZXQgZXJyb3JNZXNzYWdlID0gXCJcIjtcbiAgICBjb25zdCBtYXBzID0gZXJyb3JNYXBzXG4gICAgICAgIC5maWx0ZXIoKG0pID0+ICEhbSlcbiAgICAgICAgLnNsaWNlKClcbiAgICAgICAgLnJldmVyc2UoKTtcbiAgICBmb3IgKGNvbnN0IG1hcCBvZiBtYXBzKSB7XG4gICAgICAgIGVycm9yTWVzc2FnZSA9IG1hcChmdWxsSXNzdWUsIHsgZGF0YSwgZGVmYXVsdEVycm9yOiBlcnJvck1lc3NhZ2UgfSkubWVzc2FnZTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4uaXNzdWVEYXRhLFxuICAgICAgICBwYXRoOiBmdWxsUGF0aCxcbiAgICAgICAgbWVzc2FnZTogaXNzdWVEYXRhLm1lc3NhZ2UgfHwgZXJyb3JNZXNzYWdlLFxuICAgIH07XG59O1xuY29uc3QgRU1QVFlfUEFUSCA9IFtdO1xuZnVuY3Rpb24gYWRkSXNzdWVUb0NvbnRleHQoY3R4LCBpc3N1ZURhdGEpIHtcbiAgICBjb25zdCBpc3N1ZSA9IG1ha2VJc3N1ZSh7XG4gICAgICAgIGlzc3VlRGF0YTogaXNzdWVEYXRhLFxuICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgIGVycm9yTWFwczogW1xuICAgICAgICAgICAgY3R4LmNvbW1vbi5jb250ZXh0dWFsRXJyb3JNYXAsXG4gICAgICAgICAgICBjdHguc2NoZW1hRXJyb3JNYXAsXG4gICAgICAgICAgICBnZXRFcnJvck1hcCgpLFxuICAgICAgICAgICAgZXJyb3JNYXAsIC8vIHRoZW4gZ2xvYmFsIGRlZmF1bHQgbWFwXG4gICAgICAgIF0uZmlsdGVyKCh4KSA9PiAhIXgpLFxuICAgIH0pO1xuICAgIGN0eC5jb21tb24uaXNzdWVzLnB1c2goaXNzdWUpO1xufVxuY2xhc3MgUGFyc2VTdGF0dXMge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnZhbHVlID0gXCJ2YWxpZFwiO1xuICAgIH1cbiAgICBkaXJ0eSgpIHtcbiAgICAgICAgaWYgKHRoaXMudmFsdWUgPT09IFwidmFsaWRcIilcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBcImRpcnR5XCI7XG4gICAgfVxuICAgIGFib3J0KCkge1xuICAgICAgICBpZiAodGhpcy52YWx1ZSAhPT0gXCJhYm9ydGVkXCIpXG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gXCJhYm9ydGVkXCI7XG4gICAgfVxuICAgIHN0YXRpYyBtZXJnZUFycmF5KHN0YXR1cywgcmVzdWx0cykge1xuICAgICAgICBjb25zdCBhcnJheVZhbHVlID0gW107XG4gICAgICAgIGZvciAoY29uc3QgcyBvZiByZXN1bHRzKSB7XG4gICAgICAgICAgICBpZiAocy5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgaWYgKHMuc3RhdHVzID09PSBcImRpcnR5XCIpXG4gICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICBhcnJheVZhbHVlLnB1c2gocy52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiBhcnJheVZhbHVlIH07XG4gICAgfVxuICAgIHN0YXRpYyBhc3luYyBtZXJnZU9iamVjdEFzeW5jKHN0YXR1cywgcGFpcnMpIHtcbiAgICAgICAgY29uc3Qgc3luY1BhaXJzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgcGFpciBvZiBwYWlycykge1xuICAgICAgICAgICAgc3luY1BhaXJzLnB1c2goe1xuICAgICAgICAgICAgICAgIGtleTogYXdhaXQgcGFpci5rZXksXG4gICAgICAgICAgICAgICAgdmFsdWU6IGF3YWl0IHBhaXIudmFsdWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUGFyc2VTdGF0dXMubWVyZ2VPYmplY3RTeW5jKHN0YXR1cywgc3luY1BhaXJzKTtcbiAgICB9XG4gICAgc3RhdGljIG1lcmdlT2JqZWN0U3luYyhzdGF0dXMsIHBhaXJzKSB7XG4gICAgICAgIGNvbnN0IGZpbmFsT2JqZWN0ID0ge307XG4gICAgICAgIGZvciAoY29uc3QgcGFpciBvZiBwYWlycykge1xuICAgICAgICAgICAgY29uc3QgeyBrZXksIHZhbHVlIH0gPSBwYWlyO1xuICAgICAgICAgICAgaWYgKGtleS5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgaWYgKHZhbHVlLnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgICBpZiAoa2V5LnN0YXR1cyA9PT0gXCJkaXJ0eVwiKVxuICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgaWYgKHZhbHVlLnN0YXR1cyA9PT0gXCJkaXJ0eVwiKVxuICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgaWYgKGtleS52YWx1ZSAhPT0gXCJfX3Byb3RvX19cIiAmJlxuICAgICAgICAgICAgICAgICh0eXBlb2YgdmFsdWUudmFsdWUgIT09IFwidW5kZWZpbmVkXCIgfHwgcGFpci5hbHdheXNTZXQpKSB7XG4gICAgICAgICAgICAgICAgZmluYWxPYmplY3Rba2V5LnZhbHVlXSA9IHZhbHVlLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogZmluYWxPYmplY3QgfTtcbiAgICB9XG59XG5jb25zdCBJTlZBTElEID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgc3RhdHVzOiBcImFib3J0ZWRcIixcbn0pO1xuY29uc3QgRElSVFkgPSAodmFsdWUpID0+ICh7IHN0YXR1czogXCJkaXJ0eVwiLCB2YWx1ZSB9KTtcbmNvbnN0IE9LID0gKHZhbHVlKSA9PiAoeyBzdGF0dXM6IFwidmFsaWRcIiwgdmFsdWUgfSk7XG5jb25zdCBpc0Fib3J0ZWQgPSAoeCkgPT4geC5zdGF0dXMgPT09IFwiYWJvcnRlZFwiO1xuY29uc3QgaXNEaXJ0eSA9ICh4KSA9PiB4LnN0YXR1cyA9PT0gXCJkaXJ0eVwiO1xuY29uc3QgaXNWYWxpZCA9ICh4KSA9PiB4LnN0YXR1cyA9PT0gXCJ2YWxpZFwiO1xuY29uc3QgaXNBc3luYyA9ICh4KSA9PiB0eXBlb2YgUHJvbWlzZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiB4IGluc3RhbmNlb2YgUHJvbWlzZTtcblxudmFyIGVycm9yVXRpbDtcbihmdW5jdGlvbiAoZXJyb3JVdGlsKSB7XG4gICAgZXJyb3JVdGlsLmVyclRvT2JqID0gKG1lc3NhZ2UpID0+IHR5cGVvZiBtZXNzYWdlID09PSBcInN0cmluZ1wiID8geyBtZXNzYWdlIH0gOiBtZXNzYWdlIHx8IHt9O1xuICAgIGVycm9yVXRpbC50b1N0cmluZyA9IChtZXNzYWdlKSA9PiB0eXBlb2YgbWVzc2FnZSA9PT0gXCJzdHJpbmdcIiA/IG1lc3NhZ2UgOiBtZXNzYWdlID09PSBudWxsIHx8IG1lc3NhZ2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1lc3NhZ2UubWVzc2FnZTtcbn0pKGVycm9yVXRpbCB8fCAoZXJyb3JVdGlsID0ge30pKTtcblxuY2xhc3MgUGFyc2VJbnB1dExhenlQYXRoIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQsIHZhbHVlLCBwYXRoLCBrZXkpIHtcbiAgICAgICAgdGhpcy5fY2FjaGVkUGF0aCA9IFtdO1xuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgdGhpcy5kYXRhID0gdmFsdWU7XG4gICAgICAgIHRoaXMuX3BhdGggPSBwYXRoO1xuICAgICAgICB0aGlzLl9rZXkgPSBrZXk7XG4gICAgfVxuICAgIGdldCBwYXRoKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2NhY2hlZFBhdGgubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fa2V5IGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZWRQYXRoLnB1c2goLi4udGhpcy5fcGF0aCwgLi4udGhpcy5fa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlZFBhdGgucHVzaCguLi50aGlzLl9wYXRoLCB0aGlzLl9rZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9jYWNoZWRQYXRoO1xuICAgIH1cbn1cbmNvbnN0IGhhbmRsZVJlc3VsdCA9IChjdHgsIHJlc3VsdCkgPT4ge1xuICAgIGlmIChpc1ZhbGlkKHJlc3VsdCkpIHtcbiAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSwgZGF0YTogcmVzdWx0LnZhbHVlIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoIWN0eC5jb21tb24uaXNzdWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVmFsaWRhdGlvbiBmYWlsZWQgYnV0IG5vIGlzc3VlcyBkZXRlY3RlZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgZ2V0IGVycm9yKCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9lcnJvcilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Vycm9yO1xuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IFpvZEVycm9yKGN0eC5jb21tb24uaXNzdWVzKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9lcnJvciA9IGVycm9yO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9lcnJvcjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxufTtcbmZ1bmN0aW9uIHByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSB7XG4gICAgaWYgKCFwYXJhbXMpXG4gICAgICAgIHJldHVybiB7fTtcbiAgICBjb25zdCB7IGVycm9yTWFwLCBpbnZhbGlkX3R5cGVfZXJyb3IsIHJlcXVpcmVkX2Vycm9yLCBkZXNjcmlwdGlvbiB9ID0gcGFyYW1zO1xuICAgIGlmIChlcnJvck1hcCAmJiAoaW52YWxpZF90eXBlX2Vycm9yIHx8IHJlcXVpcmVkX2Vycm9yKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbid0IHVzZSBcImludmFsaWRfdHlwZV9lcnJvclwiIG9yIFwicmVxdWlyZWRfZXJyb3JcIiBpbiBjb25qdW5jdGlvbiB3aXRoIGN1c3RvbSBlcnJvciBtYXAuYCk7XG4gICAgfVxuICAgIGlmIChlcnJvck1hcClcbiAgICAgICAgcmV0dXJuIHsgZXJyb3JNYXA6IGVycm9yTWFwLCBkZXNjcmlwdGlvbiB9O1xuICAgIGNvbnN0IGN1c3RvbU1hcCA9IChpc3MsIGN0eCkgPT4ge1xuICAgICAgICBpZiAoaXNzLmNvZGUgIT09IFwiaW52YWxpZF90eXBlXCIpXG4gICAgICAgICAgICByZXR1cm4geyBtZXNzYWdlOiBjdHguZGVmYXVsdEVycm9yIH07XG4gICAgICAgIGlmICh0eXBlb2YgY3R4LmRhdGEgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB7IG1lc3NhZ2U6IHJlcXVpcmVkX2Vycm9yICE9PSBudWxsICYmIHJlcXVpcmVkX2Vycm9yICE9PSB2b2lkIDAgPyByZXF1aXJlZF9lcnJvciA6IGN0eC5kZWZhdWx0RXJyb3IgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBtZXNzYWdlOiBpbnZhbGlkX3R5cGVfZXJyb3IgIT09IG51bGwgJiYgaW52YWxpZF90eXBlX2Vycm9yICE9PSB2b2lkIDAgPyBpbnZhbGlkX3R5cGVfZXJyb3IgOiBjdHguZGVmYXVsdEVycm9yIH07XG4gICAgfTtcbiAgICByZXR1cm4geyBlcnJvck1hcDogY3VzdG9tTWFwLCBkZXNjcmlwdGlvbiB9O1xufVxuY2xhc3MgWm9kVHlwZSB7XG4gICAgY29uc3RydWN0b3IoZGVmKSB7XG4gICAgICAgIC8qKiBBbGlhcyBvZiBzYWZlUGFyc2VBc3luYyAqL1xuICAgICAgICB0aGlzLnNwYSA9IHRoaXMuc2FmZVBhcnNlQXN5bmM7XG4gICAgICAgIHRoaXMuX2RlZiA9IGRlZjtcbiAgICAgICAgdGhpcy5wYXJzZSA9IHRoaXMucGFyc2UuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zYWZlUGFyc2UgPSB0aGlzLnNhZmVQYXJzZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnBhcnNlQXN5bmMgPSB0aGlzLnBhcnNlQXN5bmMuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zYWZlUGFyc2VBc3luYyA9IHRoaXMuc2FmZVBhcnNlQXN5bmMuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zcGEgPSB0aGlzLnNwYS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnJlZmluZSA9IHRoaXMucmVmaW5lLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMucmVmaW5lbWVudCA9IHRoaXMucmVmaW5lbWVudC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnN1cGVyUmVmaW5lID0gdGhpcy5zdXBlclJlZmluZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9wdGlvbmFsID0gdGhpcy5vcHRpb25hbC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm51bGxhYmxlID0gdGhpcy5udWxsYWJsZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm51bGxpc2ggPSB0aGlzLm51bGxpc2guYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5hcnJheSA9IHRoaXMuYXJyYXkuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5wcm9taXNlID0gdGhpcy5wcm9taXNlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub3IgPSB0aGlzLm9yLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuYW5kID0gdGhpcy5hbmQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0gPSB0aGlzLnRyYW5zZm9ybS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmJyYW5kID0gdGhpcy5icmFuZC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmRlZmF1bHQgPSB0aGlzLmRlZmF1bHQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5jYXRjaCA9IHRoaXMuY2F0Y2guYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5kZXNjcmliZSA9IHRoaXMuZGVzY3JpYmUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5waXBlID0gdGhpcy5waXBlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMucmVhZG9ubHkgPSB0aGlzLnJlYWRvbmx5LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuaXNOdWxsYWJsZSA9IHRoaXMuaXNOdWxsYWJsZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmlzT3B0aW9uYWwgPSB0aGlzLmlzT3B0aW9uYWwuYmluZCh0aGlzKTtcbiAgICB9XG4gICAgZ2V0IGRlc2NyaXB0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLmRlc2NyaXB0aW9uO1xuICAgIH1cbiAgICBfZ2V0VHlwZShpbnB1dCkge1xuICAgICAgICByZXR1cm4gZ2V0UGFyc2VkVHlwZShpbnB1dC5kYXRhKTtcbiAgICB9XG4gICAgX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpIHtcbiAgICAgICAgcmV0dXJuIChjdHggfHwge1xuICAgICAgICAgICAgY29tbW9uOiBpbnB1dC5wYXJlbnQuY29tbW9uLFxuICAgICAgICAgICAgZGF0YTogaW5wdXQuZGF0YSxcbiAgICAgICAgICAgIHBhcnNlZFR5cGU6IGdldFBhcnNlZFR5cGUoaW5wdXQuZGF0YSksXG4gICAgICAgICAgICBzY2hlbWFFcnJvck1hcDogdGhpcy5fZGVmLmVycm9yTWFwLFxuICAgICAgICAgICAgcGF0aDogaW5wdXQucGF0aCxcbiAgICAgICAgICAgIHBhcmVudDogaW5wdXQucGFyZW50LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3RhdHVzOiBuZXcgUGFyc2VTdGF0dXMoKSxcbiAgICAgICAgICAgIGN0eDoge1xuICAgICAgICAgICAgICAgIGNvbW1vbjogaW5wdXQucGFyZW50LmNvbW1vbixcbiAgICAgICAgICAgICAgICBkYXRhOiBpbnB1dC5kYXRhLFxuICAgICAgICAgICAgICAgIHBhcnNlZFR5cGU6IGdldFBhcnNlZFR5cGUoaW5wdXQuZGF0YSksXG4gICAgICAgICAgICAgICAgc2NoZW1hRXJyb3JNYXA6IHRoaXMuX2RlZi5lcnJvck1hcCxcbiAgICAgICAgICAgICAgICBwYXRoOiBpbnB1dC5wYXRoLFxuICAgICAgICAgICAgICAgIHBhcmVudDogaW5wdXQucGFyZW50LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgX3BhcnNlU3luYyhpbnB1dCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9wYXJzZShpbnB1dCk7XG4gICAgICAgIGlmIChpc0FzeW5jKHJlc3VsdCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlN5bmNocm9ub3VzIHBhcnNlIGVuY291bnRlcmVkIHByb21pc2UuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIF9wYXJzZUFzeW5jKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX3BhcnNlKGlucHV0KTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHQpO1xuICAgIH1cbiAgICBwYXJzZShkYXRhLCBwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5zYWZlUGFyc2UoZGF0YSwgcGFyYW1zKTtcbiAgICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzKVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5kYXRhO1xuICAgICAgICB0aHJvdyByZXN1bHQuZXJyb3I7XG4gICAgfVxuICAgIHNhZmVQYXJzZShkYXRhLCBwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBjdHggPSB7XG4gICAgICAgICAgICBjb21tb246IHtcbiAgICAgICAgICAgICAgICBpc3N1ZXM6IFtdLFxuICAgICAgICAgICAgICAgIGFzeW5jOiAoX2EgPSBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMuYXN5bmMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGNvbnRleHR1YWxFcnJvck1hcDogcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmVycm9yTWFwLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBhdGg6IChwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMucGF0aCkgfHwgW10sXG4gICAgICAgICAgICBzY2hlbWFFcnJvck1hcDogdGhpcy5fZGVmLmVycm9yTWFwLFxuICAgICAgICAgICAgcGFyZW50OiBudWxsLFxuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgIHBhcnNlZFR5cGU6IGdldFBhcnNlZFR5cGUoZGF0YSksXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX3BhcnNlU3luYyh7IGRhdGEsIHBhdGg6IGN0eC5wYXRoLCBwYXJlbnQ6IGN0eCB9KTtcbiAgICAgICAgcmV0dXJuIGhhbmRsZVJlc3VsdChjdHgsIHJlc3VsdCk7XG4gICAgfVxuICAgIGFzeW5jIHBhcnNlQXN5bmMoZGF0YSwgcGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuc2FmZVBhcnNlQXN5bmMoZGF0YSwgcGFyYW1zKTtcbiAgICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzKVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5kYXRhO1xuICAgICAgICB0aHJvdyByZXN1bHQuZXJyb3I7XG4gICAgfVxuICAgIGFzeW5jIHNhZmVQYXJzZUFzeW5jKGRhdGEsIHBhcmFtcykge1xuICAgICAgICBjb25zdCBjdHggPSB7XG4gICAgICAgICAgICBjb21tb246IHtcbiAgICAgICAgICAgICAgICBpc3N1ZXM6IFtdLFxuICAgICAgICAgICAgICAgIGNvbnRleHR1YWxFcnJvck1hcDogcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmVycm9yTWFwLFxuICAgICAgICAgICAgICAgIGFzeW5jOiB0cnVlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBhdGg6IChwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMucGF0aCkgfHwgW10sXG4gICAgICAgICAgICBzY2hlbWFFcnJvck1hcDogdGhpcy5fZGVmLmVycm9yTWFwLFxuICAgICAgICAgICAgcGFyZW50OiBudWxsLFxuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgIHBhcnNlZFR5cGU6IGdldFBhcnNlZFR5cGUoZGF0YSksXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG1heWJlQXN5bmNSZXN1bHQgPSB0aGlzLl9wYXJzZSh7IGRhdGEsIHBhdGg6IGN0eC5wYXRoLCBwYXJlbnQ6IGN0eCB9KTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgKGlzQXN5bmMobWF5YmVBc3luY1Jlc3VsdClcbiAgICAgICAgICAgID8gbWF5YmVBc3luY1Jlc3VsdFxuICAgICAgICAgICAgOiBQcm9taXNlLnJlc29sdmUobWF5YmVBc3luY1Jlc3VsdCkpO1xuICAgICAgICByZXR1cm4gaGFuZGxlUmVzdWx0KGN0eCwgcmVzdWx0KTtcbiAgICB9XG4gICAgcmVmaW5lKGNoZWNrLCBtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IGdldElzc3VlUHJvcGVydGllcyA9ICh2YWwpID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgbWVzc2FnZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IG1lc3NhZ2UgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBtZXNzYWdlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWVzc2FnZSh2YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWZpbmVtZW50KCh2YWwsIGN0eCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gY2hlY2sodmFsKTtcbiAgICAgICAgICAgIGNvbnN0IHNldEVycm9yID0gKCkgPT4gY3R4LmFkZElzc3VlKHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuY3VzdG9tLFxuICAgICAgICAgICAgICAgIC4uLmdldElzc3VlUHJvcGVydGllcyh2YWwpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIFByb21pc2UgIT09IFwidW5kZWZpbmVkXCIgJiYgcmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQudGhlbigoZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldEVycm9yKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBzZXRFcnJvcigpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVmaW5lbWVudChjaGVjaywgcmVmaW5lbWVudERhdGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlZmluZW1lbnQoKHZhbCwgY3R4KSA9PiB7XG4gICAgICAgICAgICBpZiAoIWNoZWNrKHZhbCkpIHtcbiAgICAgICAgICAgICAgICBjdHguYWRkSXNzdWUodHlwZW9mIHJlZmluZW1lbnREYXRhID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICAgICAgICAgICAgPyByZWZpbmVtZW50RGF0YSh2YWwsIGN0eClcbiAgICAgICAgICAgICAgICAgICAgOiByZWZpbmVtZW50RGF0YSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfcmVmaW5lbWVudChyZWZpbmVtZW50KSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kRWZmZWN0cyh7XG4gICAgICAgICAgICBzY2hlbWE6IHRoaXMsXG4gICAgICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEVmZmVjdHMsXG4gICAgICAgICAgICBlZmZlY3Q6IHsgdHlwZTogXCJyZWZpbmVtZW50XCIsIHJlZmluZW1lbnQgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN1cGVyUmVmaW5lKHJlZmluZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlZmluZW1lbnQocmVmaW5lbWVudCk7XG4gICAgfVxuICAgIG9wdGlvbmFsKCkge1xuICAgICAgICByZXR1cm4gWm9kT3B0aW9uYWwuY3JlYXRlKHRoaXMsIHRoaXMuX2RlZik7XG4gICAgfVxuICAgIG51bGxhYmxlKCkge1xuICAgICAgICByZXR1cm4gWm9kTnVsbGFibGUuY3JlYXRlKHRoaXMsIHRoaXMuX2RlZik7XG4gICAgfVxuICAgIG51bGxpc2goKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm51bGxhYmxlKCkub3B0aW9uYWwoKTtcbiAgICB9XG4gICAgYXJyYXkoKSB7XG4gICAgICAgIHJldHVybiBab2RBcnJheS5jcmVhdGUodGhpcywgdGhpcy5fZGVmKTtcbiAgICB9XG4gICAgcHJvbWlzZSgpIHtcbiAgICAgICAgcmV0dXJuIFpvZFByb21pc2UuY3JlYXRlKHRoaXMsIHRoaXMuX2RlZik7XG4gICAgfVxuICAgIG9yKG9wdGlvbikge1xuICAgICAgICByZXR1cm4gWm9kVW5pb24uY3JlYXRlKFt0aGlzLCBvcHRpb25dLCB0aGlzLl9kZWYpO1xuICAgIH1cbiAgICBhbmQoaW5jb21pbmcpIHtcbiAgICAgICAgcmV0dXJuIFpvZEludGVyc2VjdGlvbi5jcmVhdGUodGhpcywgaW5jb21pbmcsIHRoaXMuX2RlZik7XG4gICAgfVxuICAgIHRyYW5zZm9ybSh0cmFuc2Zvcm0pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RFZmZlY3RzKHtcbiAgICAgICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXModGhpcy5fZGVmKSxcbiAgICAgICAgICAgIHNjaGVtYTogdGhpcyxcbiAgICAgICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kRWZmZWN0cyxcbiAgICAgICAgICAgIGVmZmVjdDogeyB0eXBlOiBcInRyYW5zZm9ybVwiLCB0cmFuc2Zvcm0gfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGRlZmF1bHQoZGVmKSB7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRWYWx1ZUZ1bmMgPSB0eXBlb2YgZGVmID09PSBcImZ1bmN0aW9uXCIgPyBkZWYgOiAoKSA9PiBkZWY7XG4gICAgICAgIHJldHVybiBuZXcgWm9kRGVmYXVsdCh7XG4gICAgICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHRoaXMuX2RlZiksXG4gICAgICAgICAgICBpbm5lclR5cGU6IHRoaXMsXG4gICAgICAgICAgICBkZWZhdWx0VmFsdWU6IGRlZmF1bHRWYWx1ZUZ1bmMsXG4gICAgICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZERlZmF1bHQsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBicmFuZCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RCcmFuZGVkKHtcbiAgICAgICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kQnJhbmRlZCxcbiAgICAgICAgICAgIHR5cGU6IHRoaXMsXG4gICAgICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHRoaXMuX2RlZiksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjYXRjaChkZWYpIHtcbiAgICAgICAgY29uc3QgY2F0Y2hWYWx1ZUZ1bmMgPSB0eXBlb2YgZGVmID09PSBcImZ1bmN0aW9uXCIgPyBkZWYgOiAoKSA9PiBkZWY7XG4gICAgICAgIHJldHVybiBuZXcgWm9kQ2F0Y2goe1xuICAgICAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyh0aGlzLl9kZWYpLFxuICAgICAgICAgICAgaW5uZXJUeXBlOiB0aGlzLFxuICAgICAgICAgICAgY2F0Y2hWYWx1ZTogY2F0Y2hWYWx1ZUZ1bmMsXG4gICAgICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZENhdGNoLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZGVzY3JpYmUoZGVzY3JpcHRpb24pIHtcbiAgICAgICAgY29uc3QgVGhpcyA9IHRoaXMuY29uc3RydWN0b3I7XG4gICAgICAgIHJldHVybiBuZXcgVGhpcyh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHBpcGUodGFyZ2V0KSB7XG4gICAgICAgIHJldHVybiBab2RQaXBlbGluZS5jcmVhdGUodGhpcywgdGFyZ2V0KTtcbiAgICB9XG4gICAgcmVhZG9ubHkoKSB7XG4gICAgICAgIHJldHVybiBab2RSZWFkb25seS5jcmVhdGUodGhpcyk7XG4gICAgfVxuICAgIGlzT3B0aW9uYWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNhZmVQYXJzZSh1bmRlZmluZWQpLnN1Y2Nlc3M7XG4gICAgfVxuICAgIGlzTnVsbGFibGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNhZmVQYXJzZShudWxsKS5zdWNjZXNzO1xuICAgIH1cbn1cbmNvbnN0IGN1aWRSZWdleCA9IC9eY1teXFxzLV17OCx9JC9pO1xuY29uc3QgY3VpZDJSZWdleCA9IC9eW2Etel1bYS16MC05XSokLztcbmNvbnN0IHVsaWRSZWdleCA9IC9eWzAtOUEtSEpLTU5QLVRWLVpdezI2fSQvO1xuLy8gY29uc3QgdXVpZFJlZ2V4ID1cbi8vICAgL14oW2EtZjAtOV17OH0tW2EtZjAtOV17NH0tWzEtNV1bYS1mMC05XXszfS1bYS1mMC05XXs0fS1bYS1mMC05XXsxMn18MDAwMDAwMDAtMDAwMC0wMDAwLTAwMDAtMDAwMDAwMDAwMDAwKSQvaTtcbmNvbnN0IHV1aWRSZWdleCA9IC9eWzAtOWEtZkEtRl17OH1cXGItWzAtOWEtZkEtRl17NH1cXGItWzAtOWEtZkEtRl17NH1cXGItWzAtOWEtZkEtRl17NH1cXGItWzAtOWEtZkEtRl17MTJ9JC9pO1xuLy8gZnJvbSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNDYxODEvMTU1MDE1NVxuLy8gb2xkIHZlcnNpb246IHRvbyBzbG93LCBkaWRuJ3Qgc3VwcG9ydCB1bmljb2RlXG4vLyBjb25zdCBlbWFpbFJlZ2V4ID0gL14oKChbYS16XXxcXGR8WyEjXFwkJSYnXFwqXFwrXFwtXFwvPVxcP1xcXl9ge1xcfH1+XXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkrKFxcLihbYS16XXxcXGR8WyEjXFwkJSYnXFwqXFwrXFwtXFwvPVxcP1xcXl9ge1xcfH1+XXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkrKSopfCgoXFx4MjIpKCgoKFxceDIwfFxceDA5KSooXFx4MGRcXHgwYSkpPyhcXHgyMHxcXHgwOSkrKT8oKFtcXHgwMS1cXHgwOFxceDBiXFx4MGNcXHgwZS1cXHgxZlxceDdmXXxcXHgyMXxbXFx4MjMtXFx4NWJdfFtcXHg1ZC1cXHg3ZV18W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pfChcXFxcKFtcXHgwMS1cXHgwOVxceDBiXFx4MGNcXHgwZC1cXHg3Zl18W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKSkpKigoKFxceDIwfFxceDA5KSooXFx4MGRcXHgwYSkpPyhcXHgyMHxcXHgwOSkrKT8oXFx4MjIpKSlAKCgoW2Etel18XFxkfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKXwoKFthLXpdfFxcZHxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkoW2Etel18XFxkfC18XFwufF98fnxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkqKFthLXpdfFxcZHxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkpKVxcLikrKChbYS16XXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSl8KChbYS16XXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkoW2Etel18XFxkfC18XFwufF98fnxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkqKFthLXpdfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSkpJC9pO1xuLy9vbGQgZW1haWwgcmVnZXhcbi8vIGNvbnN0IGVtYWlsUmVnZXggPSAvXigoW148PigpW1xcXS4sOzpcXHNAXCJdKyhcXC5bXjw+KClbXFxdLiw7Olxcc0BcIl0rKSopfChcIi4rXCIpKUAoKD8hLSkoW148PigpW1xcXS4sOzpcXHNAXCJdK1xcLikrW148PigpW1xcXS4sOzpcXHNAXCJdezEsfSlbXi08PigpW1xcXS4sOzpcXHNAXCJdJC9pO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4vLyBjb25zdCBlbWFpbFJlZ2V4ID1cbi8vICAgL14oKFtePD4oKVtcXF1cXFxcLiw7Olxcc0BcXFwiXSsoXFwuW148PigpW1xcXVxcXFwuLDs6XFxzQFxcXCJdKykqKXwoXFxcIi4rXFxcIikpQCgoXFxbKCgoMjVbMC01XSl8KDJbMC00XVswLTldKXwoMVswLTldezJ9KXwoWzAtOV17MSwyfSkpXFwuKXszfSgoMjVbMC01XSl8KDJbMC00XVswLTldKXwoMVswLTldezJ9KXwoWzAtOV17MSwyfSkpXFxdKXwoXFxbSVB2NjooKFthLWYwLTldezEsNH06KXs3fXw6OihbYS1mMC05XXsxLDR9Oil7MCw2fXwoW2EtZjAtOV17MSw0fTopezF9OihbYS1mMC05XXsxLDR9Oil7MCw1fXwoW2EtZjAtOV17MSw0fTopezJ9OihbYS1mMC05XXsxLDR9Oil7MCw0fXwoW2EtZjAtOV17MSw0fTopezN9OihbYS1mMC05XXsxLDR9Oil7MCwzfXwoW2EtZjAtOV17MSw0fTopezR9OihbYS1mMC05XXsxLDR9Oil7MCwyfXwoW2EtZjAtOV17MSw0fTopezV9OihbYS1mMC05XXsxLDR9Oil7MCwxfSkoW2EtZjAtOV17MSw0fXwoKCgyNVswLTVdKXwoMlswLTRdWzAtOV0pfCgxWzAtOV17Mn0pfChbMC05XXsxLDJ9KSlcXC4pezN9KCgyNVswLTVdKXwoMlswLTRdWzAtOV0pfCgxWzAtOV17Mn0pfChbMC05XXsxLDJ9KSkpXFxdKXwoW0EtWmEtejAtOV0oW0EtWmEtejAtOS1dKltBLVphLXowLTldKSooXFwuW0EtWmEtel17Mix9KSspKSQvO1xuLy8gY29uc3QgZW1haWxSZWdleCA9XG4vLyAgIC9eW2EtekEtWjAtOVxcLlxcIVxcI1xcJFxcJVxcJlxcJ1xcKlxcK1xcL1xcPVxcP1xcXlxcX1xcYFxce1xcfFxcfVxcflxcLV0rQFthLXpBLVowLTldKD86W2EtekEtWjAtOS1dezAsNjF9W2EtekEtWjAtOV0pPyg/OlxcLlthLXpBLVowLTldKD86W2EtekEtWjAtOS1dezAsNjF9W2EtekEtWjAtOV0pPykqJC87XG4vLyBjb25zdCBlbWFpbFJlZ2V4ID1cbi8vICAgL14oPzpbYS16MC05ISMkJSYnKisvPT9eX2B7fH1+LV0rKD86XFwuW2EtejAtOSEjJCUmJyorLz0/Xl9ge3x9fi1dKykqfFwiKD86W1xceDAxLVxceDA4XFx4MGJcXHgwY1xceDBlLVxceDFmXFx4MjFcXHgyMy1cXHg1YlxceDVkLVxceDdmXXxcXFxcW1xceDAxLVxceDA5XFx4MGJcXHgwY1xceDBlLVxceDdmXSkqXCIpQCg/Oig/OlthLXowLTldKD86W2EtejAtOS1dKlthLXowLTldKT9cXC4pK1thLXowLTldKD86W2EtejAtOS1dKlthLXowLTldKT98XFxbKD86KD86MjVbMC01XXwyWzAtNF1bMC05XXxbMDFdP1swLTldWzAtOV0/KVxcLil7M30oPzoyNVswLTVdfDJbMC00XVswLTldfFswMV0/WzAtOV1bMC05XT98W2EtejAtOS1dKlthLXowLTldOig/OltcXHgwMS1cXHgwOFxceDBiXFx4MGNcXHgwZS1cXHgxZlxceDIxLVxceDVhXFx4NTMtXFx4N2ZdfFxcXFxbXFx4MDEtXFx4MDlcXHgwYlxceDBjXFx4MGUtXFx4N2ZdKSspXFxdKSQvaTtcbmNvbnN0IGVtYWlsUmVnZXggPSAvXig/IVxcLikoPyEuKlxcLlxcLikoW0EtWjAtOV8rLVxcLl0qKVtBLVowLTlfKy1dQChbQS1aMC05XVtBLVowLTlcXC1dKlxcLikrW0EtWl17Mix9JC9pO1xuLy8gY29uc3QgZW1haWxSZWdleCA9XG4vLyAgIC9eW2EtejAtOS4hIyQlJuKAmSorLz0/Xl9ge3x9fi1dK0BbYS16MC05LV0rKD86XFwuW2EtejAtOVxcLV0rKSokL2k7XG4vLyBmcm9tIGh0dHBzOi8vdGhla2V2aW5zY290dC5jb20vZW1vamlzLWluLWphdmFzY3JpcHQvI3dyaXRpbmctYS1yZWd1bGFyLWV4cHJlc3Npb25cbmNvbnN0IF9lbW9qaVJlZ2V4ID0gYF4oXFxcXHB7RXh0ZW5kZWRfUGljdG9ncmFwaGljfXxcXFxccHtFbW9qaV9Db21wb25lbnR9KSskYDtcbmxldCBlbW9qaVJlZ2V4O1xuY29uc3QgaXB2NFJlZ2V4ID0gL14oKCgyNVswLTVdKXwoMlswLTRdWzAtOV0pfCgxWzAtOV17Mn0pfChbMC05XXsxLDJ9KSlcXC4pezN9KCgyNVswLTVdKXwoMlswLTRdWzAtOV0pfCgxWzAtOV17Mn0pfChbMC05XXsxLDJ9KSkkLztcbmNvbnN0IGlwdjZSZWdleCA9IC9eKChbYS1mMC05XXsxLDR9Oil7N318OjooW2EtZjAtOV17MSw0fTopezAsNn18KFthLWYwLTldezEsNH06KXsxfTooW2EtZjAtOV17MSw0fTopezAsNX18KFthLWYwLTldezEsNH06KXsyfTooW2EtZjAtOV17MSw0fTopezAsNH18KFthLWYwLTldezEsNH06KXszfTooW2EtZjAtOV17MSw0fTopezAsM318KFthLWYwLTldezEsNH06KXs0fTooW2EtZjAtOV17MSw0fTopezAsMn18KFthLWYwLTldezEsNH06KXs1fTooW2EtZjAtOV17MSw0fTopezAsMX0pKFthLWYwLTldezEsNH18KCgoMjVbMC01XSl8KDJbMC00XVswLTldKXwoMVswLTldezJ9KXwoWzAtOV17MSwyfSkpXFwuKXszfSgoMjVbMC01XSl8KDJbMC00XVswLTldKXwoMVswLTldezJ9KXwoWzAtOV17MSwyfSkpKSQvO1xuLy8gQWRhcHRlZCBmcm9tIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zMTQzMjMxXG5jb25zdCBkYXRldGltZVJlZ2V4ID0gKGFyZ3MpID0+IHtcbiAgICBpZiAoYXJncy5wcmVjaXNpb24pIHtcbiAgICAgICAgaWYgKGFyZ3Mub2Zmc2V0KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChgXlxcXFxkezR9LVxcXFxkezJ9LVxcXFxkezJ9VFxcXFxkezJ9OlxcXFxkezJ9OlxcXFxkezJ9XFxcXC5cXFxcZHske2FyZ3MucHJlY2lzaW9ufX0oKFsrLV1cXFxcZHsyfSg6P1xcXFxkezJ9KT8pfFopJGApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAoYF5cXFxcZHs0fS1cXFxcZHsyfS1cXFxcZHsyfVRcXFxcZHsyfTpcXFxcZHsyfTpcXFxcZHsyfVxcXFwuXFxcXGR7JHthcmdzLnByZWNpc2lvbn19WiRgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChhcmdzLnByZWNpc2lvbiA9PT0gMCkge1xuICAgICAgICBpZiAoYXJncy5vZmZzZXQpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVnRXhwKGBeXFxcXGR7NH0tXFxcXGR7Mn0tXFxcXGR7Mn1UXFxcXGR7Mn06XFxcXGR7Mn06XFxcXGR7Mn0oKFsrLV1cXFxcZHsyfSg6P1xcXFxkezJ9KT8pfFopJGApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAoYF5cXFxcZHs0fS1cXFxcZHsyfS1cXFxcZHsyfVRcXFxcZHsyfTpcXFxcZHsyfTpcXFxcZHsyfVokYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChhcmdzLm9mZnNldCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAoYF5cXFxcZHs0fS1cXFxcZHsyfS1cXFxcZHsyfVRcXFxcZHsyfTpcXFxcZHsyfTpcXFxcZHsyfShcXFxcLlxcXFxkKyk/KChbKy1dXFxcXGR7Mn0oOj9cXFxcZHsyfSk/KXxaKSRgKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVnRXhwKGBeXFxcXGR7NH0tXFxcXGR7Mn0tXFxcXGR7Mn1UXFxcXGR7Mn06XFxcXGR7Mn06XFxcXGR7Mn0oXFxcXC5cXFxcZCspP1okYCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuZnVuY3Rpb24gaXNWYWxpZElQKGlwLCB2ZXJzaW9uKSB7XG4gICAgaWYgKCh2ZXJzaW9uID09PSBcInY0XCIgfHwgIXZlcnNpb24pICYmIGlwdjRSZWdleC50ZXN0KGlwKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCh2ZXJzaW9uID09PSBcInY2XCIgfHwgIXZlcnNpb24pICYmIGlwdjZSZWdleC50ZXN0KGlwKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuY2xhc3MgWm9kU3RyaW5nIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGlmICh0aGlzLl9kZWYuY29lcmNlKSB7XG4gICAgICAgICAgICBpbnB1dC5kYXRhID0gU3RyaW5nKGlucHV0LmRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICAgICAgaWYgKHBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUuc3RyaW5nKSB7XG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLnN0cmluZyxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0YXR1cyA9IG5ldyBQYXJzZVN0YXR1cygpO1xuICAgICAgICBsZXQgY3R4ID0gdW5kZWZpbmVkO1xuICAgICAgICBmb3IgKGNvbnN0IGNoZWNrIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcbiAgICAgICAgICAgIGlmIChjaGVjay5raW5kID09PSBcIm1pblwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0LmRhdGEubGVuZ3RoIDwgY2hlY2sudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19zbWFsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbmltdW06IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4YWN0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcIm1heFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0LmRhdGEubGVuZ3RoID4gY2hlY2sudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19iaWcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhpbXVtOiBjaGVjay52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBleGFjdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJsZW5ndGhcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvb0JpZyA9IGlucHV0LmRhdGEubGVuZ3RoID4gY2hlY2sudmFsdWU7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9vU21hbGwgPSBpbnB1dC5kYXRhLmxlbmd0aCA8IGNoZWNrLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmICh0b29CaWcgfHwgdG9vU21hbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b29CaWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fYmlnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heGltdW06IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4YWN0OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0b29TbWFsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19zbWFsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW5pbXVtOiBjaGVjay52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGFjdDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJlbWFpbFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFlbWFpbFJlZ2V4LnRlc3QoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJlbWFpbFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiZW1vamlcIikge1xuICAgICAgICAgICAgICAgIGlmICghZW1vamlSZWdleCkge1xuICAgICAgICAgICAgICAgICAgICBlbW9qaVJlZ2V4ID0gbmV3IFJlZ0V4cChfZW1vamlSZWdleCwgXCJ1XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWVtb2ppUmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcImVtb2ppXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJ1dWlkXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXV1aWRSZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwidXVpZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiY3VpZFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjdWlkUmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcImN1aWRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImN1aWQyXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWN1aWQyUmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcImN1aWQyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJ1bGlkXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXVsaWRSZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwidWxpZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwidXJsXCIpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBuZXcgVVJMKGlucHV0LmRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJ1cmxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcInJlZ2V4XCIpIHtcbiAgICAgICAgICAgICAgICBjaGVjay5yZWdleC5sYXN0SW5kZXggPSAwO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRlc3RSZXN1bHQgPSBjaGVjay5yZWdleC50ZXN0KGlucHV0LmRhdGEpO1xuICAgICAgICAgICAgICAgIGlmICghdGVzdFJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcInJlZ2V4XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJ0cmltXCIpIHtcbiAgICAgICAgICAgICAgICBpbnB1dC5kYXRhID0gaW5wdXQuZGF0YS50cmltKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImluY2x1ZGVzXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlucHV0LmRhdGEuaW5jbHVkZXMoY2hlY2sudmFsdWUsIGNoZWNrLnBvc2l0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiB7IGluY2x1ZGVzOiBjaGVjay52YWx1ZSwgcG9zaXRpb246IGNoZWNrLnBvc2l0aW9uIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJ0b0xvd2VyQ2FzZVwiKSB7XG4gICAgICAgICAgICAgICAgaW5wdXQuZGF0YSA9IGlucHV0LmRhdGEudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwidG9VcHBlckNhc2VcIikge1xuICAgICAgICAgICAgICAgIGlucHV0LmRhdGEgPSBpbnB1dC5kYXRhLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcInN0YXJ0c1dpdGhcIikge1xuICAgICAgICAgICAgICAgIGlmICghaW5wdXQuZGF0YS5zdGFydHNXaXRoKGNoZWNrLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiB7IHN0YXJ0c1dpdGg6IGNoZWNrLnZhbHVlIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJlbmRzV2l0aFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpbnB1dC5kYXRhLmVuZHNXaXRoKGNoZWNrLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiB7IGVuZHNXaXRoOiBjaGVjay52YWx1ZSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiZGF0ZXRpbWVcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlZ2V4ID0gZGF0ZXRpbWVSZWdleChjaGVjayk7XG4gICAgICAgICAgICAgICAgaWYgKCFyZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwiZGF0ZXRpbWVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImlwXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzVmFsaWRJUChpbnB1dC5kYXRhLCBjaGVjay52ZXJzaW9uKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcImlwXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdXRpbC5hc3NlcnROZXZlcihjaGVjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiBpbnB1dC5kYXRhIH07XG4gICAgfVxuICAgIF9yZWdleChyZWdleCwgdmFsaWRhdGlvbiwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWZpbmVtZW50KChkYXRhKSA9PiByZWdleC50ZXN0KGRhdGEpLCB7XG4gICAgICAgICAgICB2YWxpZGF0aW9uLFxuICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2FkZENoZWNrKGNoZWNrKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kU3RyaW5nKHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIGNoZWNrczogWy4uLnRoaXMuX2RlZi5jaGVja3MsIGNoZWNrXSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVtYWlsKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJlbWFpbFwiLCAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkgfSk7XG4gICAgfVxuICAgIHVybChtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwidXJsXCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSB9KTtcbiAgICB9XG4gICAgZW1vamkobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImVtb2ppXCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSB9KTtcbiAgICB9XG4gICAgdXVpZChtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwidXVpZFwiLCAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkgfSk7XG4gICAgfVxuICAgIGN1aWQobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImN1aWRcIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpIH0pO1xuICAgIH1cbiAgICBjdWlkMihtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwiY3VpZDJcIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpIH0pO1xuICAgIH1cbiAgICB1bGlkKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJ1bGlkXCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSB9KTtcbiAgICB9XG4gICAgaXAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImlwXCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihvcHRpb25zKSB9KTtcbiAgICB9XG4gICAgZGF0ZXRpbWUob3B0aW9ucykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgICAgICBraW5kOiBcImRhdGV0aW1lXCIsXG4gICAgICAgICAgICAgICAgcHJlY2lzaW9uOiBudWxsLFxuICAgICAgICAgICAgICAgIG9mZnNldDogZmFsc2UsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogb3B0aW9ucyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcImRhdGV0aW1lXCIsXG4gICAgICAgICAgICBwcmVjaXNpb246IHR5cGVvZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnByZWNpc2lvbikgPT09IFwidW5kZWZpbmVkXCIgPyBudWxsIDogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnByZWNpc2lvbixcbiAgICAgICAgICAgIG9mZnNldDogKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm9mZnNldCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZmFsc2UsXG4gICAgICAgICAgICAuLi5lcnJvclV0aWwuZXJyVG9PYmoob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVnZXgocmVnZXgsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwicmVnZXhcIixcbiAgICAgICAgICAgIHJlZ2V4OiByZWdleCxcbiAgICAgICAgICAgIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGluY2x1ZGVzKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcImluY2x1ZGVzXCIsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICBwb3NpdGlvbjogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnBvc2l0aW9uLFxuICAgICAgICAgICAgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5tZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXJ0c1dpdGgodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwic3RhcnRzV2l0aFwiLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZW5kc1dpdGgodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwiZW5kc1dpdGhcIixcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG1pbihtaW5MZW5ndGgsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibWluXCIsXG4gICAgICAgICAgICB2YWx1ZTogbWluTGVuZ3RoLFxuICAgICAgICAgICAgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbWF4KG1heExlbmd0aCwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJtYXhcIixcbiAgICAgICAgICAgIHZhbHVlOiBtYXhMZW5ndGgsXG4gICAgICAgICAgICAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBsZW5ndGgobGVuLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcImxlbmd0aFwiLFxuICAgICAgICAgICAgdmFsdWU6IGxlbixcbiAgICAgICAgICAgIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIFVzZSB6LnN0cmluZygpLm1pbigxKSBpbnN0ZWFkLlxuICAgICAqIEBzZWUge0BsaW5rIFpvZFN0cmluZy5taW59XG4gICAgICovXG4gICAgbm9uZW1wdHkobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5taW4oMSwgZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpKTtcbiAgICB9XG4gICAgdHJpbSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RTdHJpbmcoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgY2hlY2tzOiBbLi4udGhpcy5fZGVmLmNoZWNrcywgeyBraW5kOiBcInRyaW1cIiB9XSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHRvTG93ZXJDYXNlKCkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZFN0cmluZyh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBjaGVja3M6IFsuLi50aGlzLl9kZWYuY2hlY2tzLCB7IGtpbmQ6IFwidG9Mb3dlckNhc2VcIiB9XSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHRvVXBwZXJDYXNlKCkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZFN0cmluZyh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBjaGVja3M6IFsuLi50aGlzLl9kZWYuY2hlY2tzLCB7IGtpbmQ6IFwidG9VcHBlckNhc2VcIiB9XSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldCBpc0RhdGV0aW1lKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImRhdGV0aW1lXCIpO1xuICAgIH1cbiAgICBnZXQgaXNFbWFpbCgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJlbWFpbFwiKTtcbiAgICB9XG4gICAgZ2V0IGlzVVJMKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcInVybFwiKTtcbiAgICB9XG4gICAgZ2V0IGlzRW1vamkoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwiZW1vamlcIik7XG4gICAgfVxuICAgIGdldCBpc1VVSUQoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwidXVpZFwiKTtcbiAgICB9XG4gICAgZ2V0IGlzQ1VJRCgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJjdWlkXCIpO1xuICAgIH1cbiAgICBnZXQgaXNDVUlEMigpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJjdWlkMlwiKTtcbiAgICB9XG4gICAgZ2V0IGlzVUxJRCgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJ1bGlkXCIpO1xuICAgIH1cbiAgICBnZXQgaXNJUCgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJpcFwiKTtcbiAgICB9XG4gICAgZ2V0IG1pbkxlbmd0aCgpIHtcbiAgICAgICAgbGV0IG1pbiA9IG51bGw7XG4gICAgICAgIGZvciAoY29uc3QgY2ggb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgICAgICAgaWYgKGNoLmtpbmQgPT09IFwibWluXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAobWluID09PSBudWxsIHx8IGNoLnZhbHVlID4gbWluKVxuICAgICAgICAgICAgICAgICAgICBtaW4gPSBjaC52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWluO1xuICAgIH1cbiAgICBnZXQgbWF4TGVuZ3RoKCkge1xuICAgICAgICBsZXQgbWF4ID0gbnVsbDtcbiAgICAgICAgZm9yIChjb25zdCBjaCBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XG4gICAgICAgICAgICBpZiAoY2gua2luZCA9PT0gXCJtYXhcIikge1xuICAgICAgICAgICAgICAgIGlmIChtYXggPT09IG51bGwgfHwgY2gudmFsdWUgPCBtYXgpXG4gICAgICAgICAgICAgICAgICAgIG1heCA9IGNoLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXg7XG4gICAgfVxufVxuWm9kU3RyaW5nLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIG5ldyBab2RTdHJpbmcoe1xuICAgICAgICBjaGVja3M6IFtdLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFN0cmluZyxcbiAgICAgICAgY29lcmNlOiAoX2EgPSBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMuY29lcmNlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmYWxzZSxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbi8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzM5NjY0ODQvd2h5LWRvZXMtbW9kdWx1cy1vcGVyYXRvci1yZXR1cm4tZnJhY3Rpb25hbC1udW1iZXItaW4tamF2YXNjcmlwdC8zMTcxMTAzNCMzMTcxMTAzNFxuZnVuY3Rpb24gZmxvYXRTYWZlUmVtYWluZGVyKHZhbCwgc3RlcCkge1xuICAgIGNvbnN0IHZhbERlY0NvdW50ID0gKHZhbC50b1N0cmluZygpLnNwbGl0KFwiLlwiKVsxXSB8fCBcIlwiKS5sZW5ndGg7XG4gICAgY29uc3Qgc3RlcERlY0NvdW50ID0gKHN0ZXAudG9TdHJpbmcoKS5zcGxpdChcIi5cIilbMV0gfHwgXCJcIikubGVuZ3RoO1xuICAgIGNvbnN0IGRlY0NvdW50ID0gdmFsRGVjQ291bnQgPiBzdGVwRGVjQ291bnQgPyB2YWxEZWNDb3VudCA6IHN0ZXBEZWNDb3VudDtcbiAgICBjb25zdCB2YWxJbnQgPSBwYXJzZUludCh2YWwudG9GaXhlZChkZWNDb3VudCkucmVwbGFjZShcIi5cIiwgXCJcIikpO1xuICAgIGNvbnN0IHN0ZXBJbnQgPSBwYXJzZUludChzdGVwLnRvRml4ZWQoZGVjQ291bnQpLnJlcGxhY2UoXCIuXCIsIFwiXCIpKTtcbiAgICByZXR1cm4gKHZhbEludCAlIHN0ZXBJbnQpIC8gTWF0aC5wb3coMTAsIGRlY0NvdW50KTtcbn1cbmNsYXNzIFpvZE51bWJlciBleHRlbmRzIFpvZFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm1pbiA9IHRoaXMuZ3RlO1xuICAgICAgICB0aGlzLm1heCA9IHRoaXMubHRlO1xuICAgICAgICB0aGlzLnN0ZXAgPSB0aGlzLm11bHRpcGxlT2Y7XG4gICAgfVxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBpZiAodGhpcy5fZGVmLmNvZXJjZSkge1xuICAgICAgICAgICAgaW5wdXQuZGF0YSA9IE51bWJlcihpbnB1dC5kYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgICAgIGlmIChwYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLm51bWJlcikge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5udW1iZXIsXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY3R4ID0gdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBzdGF0dXMgPSBuZXcgUGFyc2VTdGF0dXMoKTtcbiAgICAgICAgZm9yIChjb25zdCBjaGVjayBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XG4gICAgICAgICAgICBpZiAoY2hlY2sua2luZCA9PT0gXCJpbnRcIikge1xuICAgICAgICAgICAgICAgIGlmICghdXRpbC5pc0ludGVnZXIoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBcImludGVnZXJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBcImZsb2F0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJtaW5cIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvb1NtYWxsID0gY2hlY2suaW5jbHVzaXZlXG4gICAgICAgICAgICAgICAgICAgID8gaW5wdXQuZGF0YSA8IGNoZWNrLnZhbHVlXG4gICAgICAgICAgICAgICAgICAgIDogaW5wdXQuZGF0YSA8PSBjaGVjay52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAodG9vU21hbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19zbWFsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbmltdW06IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogY2hlY2suaW5jbHVzaXZlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwibWF4XCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0b29CaWcgPSBjaGVjay5pbmNsdXNpdmVcbiAgICAgICAgICAgICAgICAgICAgPyBpbnB1dC5kYXRhID4gY2hlY2sudmFsdWVcbiAgICAgICAgICAgICAgICAgICAgOiBpbnB1dC5kYXRhID49IGNoZWNrLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmICh0b29CaWcpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19iaWcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhpbXVtOiBjaGVjay52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IGNoZWNrLmluY2x1c2l2ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4YWN0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcIm11bHRpcGxlT2ZcIikge1xuICAgICAgICAgICAgICAgIGlmIChmbG9hdFNhZmVSZW1haW5kZXIoaW5wdXQuZGF0YSwgY2hlY2sudmFsdWUpICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5ub3RfbXVsdGlwbGVfb2YsXG4gICAgICAgICAgICAgICAgICAgICAgICBtdWx0aXBsZU9mOiBjaGVjay52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImZpbml0ZVwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLm5vdF9maW5pdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdXRpbC5hc3NlcnROZXZlcihjaGVjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiBpbnB1dC5kYXRhIH07XG4gICAgfVxuICAgIGd0ZSh2YWx1ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRMaW1pdChcIm1pblwiLCB2YWx1ZSwgdHJ1ZSwgZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpKTtcbiAgICB9XG4gICAgZ3QodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0TGltaXQoXCJtaW5cIiwgdmFsdWUsIGZhbHNlLCBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkpO1xuICAgIH1cbiAgICBsdGUodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0TGltaXQoXCJtYXhcIiwgdmFsdWUsIHRydWUsIGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSk7XG4gICAgfVxuICAgIGx0KHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldExpbWl0KFwibWF4XCIsIHZhbHVlLCBmYWxzZSwgZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpKTtcbiAgICB9XG4gICAgc2V0TGltaXQoa2luZCwgdmFsdWUsIGluY2x1c2l2ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZE51bWJlcih7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBjaGVja3M6IFtcbiAgICAgICAgICAgICAgICAuLi50aGlzLl9kZWYuY2hlY2tzLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAga2luZCxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZSxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2FkZENoZWNrKGNoZWNrKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kTnVtYmVyKHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIGNoZWNrczogWy4uLnRoaXMuX2RlZi5jaGVja3MsIGNoZWNrXSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGludChtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcImludFwiLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcG9zaXRpdmUobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJtaW5cIixcbiAgICAgICAgICAgIHZhbHVlOiAwLFxuICAgICAgICAgICAgaW5jbHVzaXZlOiBmYWxzZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG5lZ2F0aXZlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibWF4XCIsXG4gICAgICAgICAgICB2YWx1ZTogMCxcbiAgICAgICAgICAgIGluY2x1c2l2ZTogZmFsc2UsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBub25wb3NpdGl2ZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcIm1heFwiLFxuICAgICAgICAgICAgdmFsdWU6IDAsXG4gICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBub25uZWdhdGl2ZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcIm1pblwiLFxuICAgICAgICAgICAgdmFsdWU6IDAsXG4gICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBtdWx0aXBsZU9mKHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcIm11bHRpcGxlT2ZcIixcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZpbml0ZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcImZpbml0ZVwiLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2FmZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcIm1pblwiLFxuICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IE51bWJlci5NSU5fU0FGRV9JTlRFR0VSLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICB9KS5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJtYXhcIixcbiAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUixcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldCBtaW5WYWx1ZSgpIHtcbiAgICAgICAgbGV0IG1pbiA9IG51bGw7XG4gICAgICAgIGZvciAoY29uc3QgY2ggb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgICAgICAgaWYgKGNoLmtpbmQgPT09IFwibWluXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAobWluID09PSBudWxsIHx8IGNoLnZhbHVlID4gbWluKVxuICAgICAgICAgICAgICAgICAgICBtaW4gPSBjaC52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWluO1xuICAgIH1cbiAgICBnZXQgbWF4VmFsdWUoKSB7XG4gICAgICAgIGxldCBtYXggPSBudWxsO1xuICAgICAgICBmb3IgKGNvbnN0IGNoIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcbiAgICAgICAgICAgIGlmIChjaC5raW5kID09PSBcIm1heFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1heCA9PT0gbnVsbCB8fCBjaC52YWx1ZSA8IG1heClcbiAgICAgICAgICAgICAgICAgICAgbWF4ID0gY2gudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1heDtcbiAgICB9XG4gICAgZ2V0IGlzSW50KCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImludFwiIHx8XG4gICAgICAgICAgICAoY2gua2luZCA9PT0gXCJtdWx0aXBsZU9mXCIgJiYgdXRpbC5pc0ludGVnZXIoY2gudmFsdWUpKSk7XG4gICAgfVxuICAgIGdldCBpc0Zpbml0ZSgpIHtcbiAgICAgICAgbGV0IG1heCA9IG51bGwsIG1pbiA9IG51bGw7XG4gICAgICAgIGZvciAoY29uc3QgY2ggb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgICAgICAgaWYgKGNoLmtpbmQgPT09IFwiZmluaXRlXCIgfHxcbiAgICAgICAgICAgICAgICBjaC5raW5kID09PSBcImludFwiIHx8XG4gICAgICAgICAgICAgICAgY2gua2luZCA9PT0gXCJtdWx0aXBsZU9mXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoLmtpbmQgPT09IFwibWluXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAobWluID09PSBudWxsIHx8IGNoLnZhbHVlID4gbWluKVxuICAgICAgICAgICAgICAgICAgICBtaW4gPSBjaC52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoLmtpbmQgPT09IFwibWF4XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAobWF4ID09PSBudWxsIHx8IGNoLnZhbHVlIDwgbWF4KVxuICAgICAgICAgICAgICAgICAgICBtYXggPSBjaC52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTnVtYmVyLmlzRmluaXRlKG1pbikgJiYgTnVtYmVyLmlzRmluaXRlKG1heCk7XG4gICAgfVxufVxuWm9kTnVtYmVyLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZE51bWJlcih7XG4gICAgICAgIGNoZWNrczogW10sXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kTnVtYmVyLFxuICAgICAgICBjb2VyY2U6IChwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMuY29lcmNlKSB8fCBmYWxzZSxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNsYXNzIFpvZEJpZ0ludCBleHRlbmRzIFpvZFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm1pbiA9IHRoaXMuZ3RlO1xuICAgICAgICB0aGlzLm1heCA9IHRoaXMubHRlO1xuICAgIH1cbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RlZi5jb2VyY2UpIHtcbiAgICAgICAgICAgIGlucHV0LmRhdGEgPSBCaWdJbnQoaW5wdXQuZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgICAgICBpZiAocGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5iaWdpbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUuYmlnaW50LFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGN0eCA9IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3Qgc3RhdHVzID0gbmV3IFBhcnNlU3RhdHVzKCk7XG4gICAgICAgIGZvciAoY29uc3QgY2hlY2sgb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgICAgICAgaWYgKGNoZWNrLmtpbmQgPT09IFwibWluXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0b29TbWFsbCA9IGNoZWNrLmluY2x1c2l2ZVxuICAgICAgICAgICAgICAgICAgICA/IGlucHV0LmRhdGEgPCBjaGVjay52YWx1ZVxuICAgICAgICAgICAgICAgICAgICA6IGlucHV0LmRhdGEgPD0gY2hlY2sudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKHRvb1NtYWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fc21hbGwsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImJpZ2ludFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWluaW11bTogY2hlY2sudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IGNoZWNrLmluY2x1c2l2ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcIm1heFwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9vQmlnID0gY2hlY2suaW5jbHVzaXZlXG4gICAgICAgICAgICAgICAgICAgID8gaW5wdXQuZGF0YSA+IGNoZWNrLnZhbHVlXG4gICAgICAgICAgICAgICAgICAgIDogaW5wdXQuZGF0YSA+PSBjaGVjay52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAodG9vQmlnKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fYmlnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJiaWdpbnRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heGltdW06IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiBjaGVjay5pbmNsdXNpdmUsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJtdWx0aXBsZU9mXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQuZGF0YSAlIGNoZWNrLnZhbHVlICE9PSBCaWdJbnQoMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLm5vdF9tdWx0aXBsZV9vZixcbiAgICAgICAgICAgICAgICAgICAgICAgIG11bHRpcGxlT2Y6IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHV0aWwuYXNzZXJ0TmV2ZXIoY2hlY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogaW5wdXQuZGF0YSB9O1xuICAgIH1cbiAgICBndGUodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0TGltaXQoXCJtaW5cIiwgdmFsdWUsIHRydWUsIGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSk7XG4gICAgfVxuICAgIGd0KHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldExpbWl0KFwibWluXCIsIHZhbHVlLCBmYWxzZSwgZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpKTtcbiAgICB9XG4gICAgbHRlKHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldExpbWl0KFwibWF4XCIsIHZhbHVlLCB0cnVlLCBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkpO1xuICAgIH1cbiAgICBsdCh2YWx1ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRMaW1pdChcIm1heFwiLCB2YWx1ZSwgZmFsc2UsIGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSk7XG4gICAgfVxuICAgIHNldExpbWl0KGtpbmQsIHZhbHVlLCBpbmNsdXNpdmUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RCaWdJbnQoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgY2hlY2tzOiBbXG4gICAgICAgICAgICAgICAgLi4udGhpcy5fZGVmLmNoZWNrcyxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGtpbmQsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmUsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9hZGRDaGVjayhjaGVjaykge1xuICAgICAgICByZXR1cm4gbmV3IFpvZEJpZ0ludCh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBjaGVja3M6IFsuLi50aGlzLl9kZWYuY2hlY2tzLCBjaGVja10sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBwb3NpdGl2ZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcIm1pblwiLFxuICAgICAgICAgICAgdmFsdWU6IEJpZ0ludCgwKSxcbiAgICAgICAgICAgIGluY2x1c2l2ZTogZmFsc2UsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBuZWdhdGl2ZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcIm1heFwiLFxuICAgICAgICAgICAgdmFsdWU6IEJpZ0ludCgwKSxcbiAgICAgICAgICAgIGluY2x1c2l2ZTogZmFsc2UsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBub25wb3NpdGl2ZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcIm1heFwiLFxuICAgICAgICAgICAgdmFsdWU6IEJpZ0ludCgwKSxcbiAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG5vbm5lZ2F0aXZlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibWluXCIsXG4gICAgICAgICAgICB2YWx1ZTogQmlnSW50KDApLFxuICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbXVsdGlwbGVPZih2YWx1ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJtdWx0aXBsZU9mXCIsXG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldCBtaW5WYWx1ZSgpIHtcbiAgICAgICAgbGV0IG1pbiA9IG51bGw7XG4gICAgICAgIGZvciAoY29uc3QgY2ggb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgICAgICAgaWYgKGNoLmtpbmQgPT09IFwibWluXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAobWluID09PSBudWxsIHx8IGNoLnZhbHVlID4gbWluKVxuICAgICAgICAgICAgICAgICAgICBtaW4gPSBjaC52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWluO1xuICAgIH1cbiAgICBnZXQgbWF4VmFsdWUoKSB7XG4gICAgICAgIGxldCBtYXggPSBudWxsO1xuICAgICAgICBmb3IgKGNvbnN0IGNoIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcbiAgICAgICAgICAgIGlmIChjaC5raW5kID09PSBcIm1heFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1heCA9PT0gbnVsbCB8fCBjaC52YWx1ZSA8IG1heClcbiAgICAgICAgICAgICAgICAgICAgbWF4ID0gY2gudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1heDtcbiAgICB9XG59XG5ab2RCaWdJbnQuY3JlYXRlID0gKHBhcmFtcykgPT4ge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gbmV3IFpvZEJpZ0ludCh7XG4gICAgICAgIGNoZWNrczogW10sXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kQmlnSW50LFxuICAgICAgICBjb2VyY2U6IChfYSA9IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5jb2VyY2UpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZhbHNlLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kQm9vbGVhbiBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBpZiAodGhpcy5fZGVmLmNvZXJjZSkge1xuICAgICAgICAgICAgaW5wdXQuZGF0YSA9IEJvb2xlYW4oaW5wdXQuZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgICAgICBpZiAocGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5ib29sZWFuKSB7XG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLmJvb2xlYW4sXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT0soaW5wdXQuZGF0YSk7XG4gICAgfVxufVxuWm9kQm9vbGVhbi5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RCb29sZWFuKHtcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RCb29sZWFuLFxuICAgICAgICBjb2VyY2U6IChwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMuY29lcmNlKSB8fCBmYWxzZSxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNsYXNzIFpvZERhdGUgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RlZi5jb2VyY2UpIHtcbiAgICAgICAgICAgIGlucHV0LmRhdGEgPSBuZXcgRGF0ZShpbnB1dC5kYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgICAgIGlmIChwYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLmRhdGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUuZGF0ZSxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc05hTihpbnB1dC5kYXRhLmdldFRpbWUoKSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX2RhdGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0YXR1cyA9IG5ldyBQYXJzZVN0YXR1cygpO1xuICAgICAgICBsZXQgY3R4ID0gdW5kZWZpbmVkO1xuICAgICAgICBmb3IgKGNvbnN0IGNoZWNrIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcbiAgICAgICAgICAgIGlmIChjaGVjay5raW5kID09PSBcIm1pblwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0LmRhdGEuZ2V0VGltZSgpIDwgY2hlY2sudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19zbWFsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBleGFjdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5pbXVtOiBjaGVjay52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiZGF0ZVwiLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJtYXhcIikge1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dC5kYXRhLmdldFRpbWUoKSA+IGNoZWNrLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fYmlnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4YWN0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heGltdW06IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJkYXRlXCIsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB1dGlsLmFzc2VydE5ldmVyKGNoZWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3RhdHVzOiBzdGF0dXMudmFsdWUsXG4gICAgICAgICAgICB2YWx1ZTogbmV3IERhdGUoaW5wdXQuZGF0YS5nZXRUaW1lKCkpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBfYWRkQ2hlY2soY2hlY2spIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2REYXRlKHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIGNoZWNrczogWy4uLnRoaXMuX2RlZi5jaGVja3MsIGNoZWNrXSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG1pbihtaW5EYXRlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcIm1pblwiLFxuICAgICAgICAgICAgdmFsdWU6IG1pbkRhdGUuZ2V0VGltZSgpLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbWF4KG1heERhdGUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibWF4XCIsXG4gICAgICAgICAgICB2YWx1ZTogbWF4RGF0ZS5nZXRUaW1lKCksXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXQgbWluRGF0ZSgpIHtcbiAgICAgICAgbGV0IG1pbiA9IG51bGw7XG4gICAgICAgIGZvciAoY29uc3QgY2ggb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgICAgICAgaWYgKGNoLmtpbmQgPT09IFwibWluXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAobWluID09PSBudWxsIHx8IGNoLnZhbHVlID4gbWluKVxuICAgICAgICAgICAgICAgICAgICBtaW4gPSBjaC52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWluICE9IG51bGwgPyBuZXcgRGF0ZShtaW4pIDogbnVsbDtcbiAgICB9XG4gICAgZ2V0IG1heERhdGUoKSB7XG4gICAgICAgIGxldCBtYXggPSBudWxsO1xuICAgICAgICBmb3IgKGNvbnN0IGNoIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcbiAgICAgICAgICAgIGlmIChjaC5raW5kID09PSBcIm1heFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1heCA9PT0gbnVsbCB8fCBjaC52YWx1ZSA8IG1heClcbiAgICAgICAgICAgICAgICAgICAgbWF4ID0gY2gudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1heCAhPSBudWxsID8gbmV3IERhdGUobWF4KSA6IG51bGw7XG4gICAgfVxufVxuWm9kRGF0ZS5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2REYXRlKHtcbiAgICAgICAgY2hlY2tzOiBbXSxcbiAgICAgICAgY29lcmNlOiAocGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmNvZXJjZSkgfHwgZmFsc2UsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kRGF0ZSxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNsYXNzIFpvZFN5bWJvbCBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgICAgIGlmIChwYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLnN5bWJvbCkge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5zeW1ib2wsXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT0soaW5wdXQuZGF0YSk7XG4gICAgfVxufVxuWm9kU3ltYm9sLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZFN5bWJvbCh7XG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kU3ltYm9sLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kVW5kZWZpbmVkIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICAgICAgaWYgKHBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUudW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLnVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPSyhpbnB1dC5kYXRhKTtcbiAgICB9XG59XG5ab2RVbmRlZmluZWQuY3JlYXRlID0gKHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kVW5kZWZpbmVkKHtcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RVbmRlZmluZWQsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5jbGFzcyBab2ROdWxsIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICAgICAgaWYgKHBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUubnVsbCkge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5udWxsLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE9LKGlucHV0LmRhdGEpO1xuICAgIH1cbn1cblpvZE51bGwuY3JlYXRlID0gKHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kTnVsbCh7XG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kTnVsbCxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNsYXNzIFpvZEFueSBleHRlbmRzIFpvZFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICAvLyB0byBwcmV2ZW50IGluc3RhbmNlcyBvZiBvdGhlciBjbGFzc2VzIGZyb20gZXh0ZW5kaW5nIFpvZEFueS4gdGhpcyBjYXVzZXMgaXNzdWVzIHdpdGggY2F0Y2hhbGwgaW4gWm9kT2JqZWN0LlxuICAgICAgICB0aGlzLl9hbnkgPSB0cnVlO1xuICAgIH1cbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIE9LKGlucHV0LmRhdGEpO1xuICAgIH1cbn1cblpvZEFueS5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RBbnkoe1xuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEFueSxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNsYXNzIFpvZFVua25vd24gZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgLy8gcmVxdWlyZWRcbiAgICAgICAgdGhpcy5fdW5rbm93biA9IHRydWU7XG4gICAgfVxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICByZXR1cm4gT0soaW5wdXQuZGF0YSk7XG4gICAgfVxufVxuWm9kVW5rbm93bi5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RVbmtub3duKHtcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RVbmtub3duLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kTmV2ZXIgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5uZXZlcixcbiAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgIH1cbn1cblpvZE5ldmVyLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZE5ldmVyKHtcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2ROZXZlcixcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNsYXNzIFpvZFZvaWQgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgICAgICBpZiAocGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS51bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUudm9pZCxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPSyhpbnB1dC5kYXRhKTtcbiAgICB9XG59XG5ab2RWb2lkLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZFZvaWQoe1xuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFZvaWQsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5jbGFzcyBab2RBcnJheSBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IGN0eCwgc3RhdHVzIH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBjb25zdCBkZWYgPSB0aGlzLl9kZWY7XG4gICAgICAgIGlmIChjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5hcnJheSkge1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5hcnJheSxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZWYuZXhhY3RMZW5ndGggIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IHRvb0JpZyA9IGN0eC5kYXRhLmxlbmd0aCA+IGRlZi5leGFjdExlbmd0aC52YWx1ZTtcbiAgICAgICAgICAgIGNvbnN0IHRvb1NtYWxsID0gY3R4LmRhdGEubGVuZ3RoIDwgZGVmLmV4YWN0TGVuZ3RoLnZhbHVlO1xuICAgICAgICAgICAgaWYgKHRvb0JpZyB8fCB0b29TbWFsbCkge1xuICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiB0b29CaWcgPyBab2RJc3N1ZUNvZGUudG9vX2JpZyA6IFpvZElzc3VlQ29kZS50b29fc21hbGwsXG4gICAgICAgICAgICAgICAgICAgIG1pbmltdW06ICh0b29TbWFsbCA/IGRlZi5leGFjdExlbmd0aC52YWx1ZSA6IHVuZGVmaW5lZCksXG4gICAgICAgICAgICAgICAgICAgIG1heGltdW06ICh0b29CaWcgPyBkZWYuZXhhY3RMZW5ndGgudmFsdWUgOiB1bmRlZmluZWQpLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZXhhY3Q6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGRlZi5leGFjdExlbmd0aC5tZXNzYWdlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChkZWYubWluTGVuZ3RoICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoY3R4LmRhdGEubGVuZ3RoIDwgZGVmLm1pbkxlbmd0aC52YWx1ZSkge1xuICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX3NtYWxsLFxuICAgICAgICAgICAgICAgICAgICBtaW5pbXVtOiBkZWYubWluTGVuZ3RoLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBkZWYubWluTGVuZ3RoLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlZi5tYXhMZW5ndGggIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChjdHguZGF0YS5sZW5ndGggPiBkZWYubWF4TGVuZ3RoLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fYmlnLFxuICAgICAgICAgICAgICAgICAgICBtYXhpbXVtOiBkZWYubWF4TGVuZ3RoLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBkZWYubWF4TGVuZ3RoLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChbLi4uY3R4LmRhdGFdLm1hcCgoaXRlbSwgaSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZWYudHlwZS5fcGFyc2VBc3luYyhuZXcgUGFyc2VJbnB1dExhenlQYXRoKGN0eCwgaXRlbSwgY3R4LnBhdGgsIGkpKTtcbiAgICAgICAgICAgIH0pKS50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUGFyc2VTdGF0dXMubWVyZ2VBcnJheShzdGF0dXMsIHJlc3VsdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSBbLi4uY3R4LmRhdGFdLm1hcCgoaXRlbSwgaSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGRlZi50eXBlLl9wYXJzZVN5bmMobmV3IFBhcnNlSW5wdXRMYXp5UGF0aChjdHgsIGl0ZW0sIGN0eC5wYXRoLCBpKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gUGFyc2VTdGF0dXMubWVyZ2VBcnJheShzdGF0dXMsIHJlc3VsdCk7XG4gICAgfVxuICAgIGdldCBlbGVtZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnR5cGU7XG4gICAgfVxuICAgIG1pbihtaW5MZW5ndGgsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RBcnJheSh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBtaW5MZW5ndGg6IHsgdmFsdWU6IG1pbkxlbmd0aCwgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBtYXgobWF4TGVuZ3RoLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kQXJyYXkoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgbWF4TGVuZ3RoOiB7IHZhbHVlOiBtYXhMZW5ndGgsIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbGVuZ3RoKGxlbiwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZEFycmF5KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIGV4YWN0TGVuZ3RoOiB7IHZhbHVlOiBsZW4sIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbm9uZW1wdHkobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5taW4oMSwgbWVzc2FnZSk7XG4gICAgfVxufVxuWm9kQXJyYXkuY3JlYXRlID0gKHNjaGVtYSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RBcnJheSh7XG4gICAgICAgIHR5cGU6IHNjaGVtYSxcbiAgICAgICAgbWluTGVuZ3RoOiBudWxsLFxuICAgICAgICBtYXhMZW5ndGg6IG51bGwsXG4gICAgICAgIGV4YWN0TGVuZ3RoOiBudWxsLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEFycmF5LFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuZnVuY3Rpb24gZGVlcFBhcnRpYWxpZnkoc2NoZW1hKSB7XG4gICAgaWYgKHNjaGVtYSBpbnN0YW5jZW9mIFpvZE9iamVjdCkge1xuICAgICAgICBjb25zdCBuZXdTaGFwZSA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBzY2hlbWEuc2hhcGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkU2NoZW1hID0gc2NoZW1hLnNoYXBlW2tleV07XG4gICAgICAgICAgICBuZXdTaGFwZVtrZXldID0gWm9kT3B0aW9uYWwuY3JlYXRlKGRlZXBQYXJ0aWFsaWZ5KGZpZWxkU2NoZW1hKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICAgICAgLi4uc2NoZW1hLl9kZWYsXG4gICAgICAgICAgICBzaGFwZTogKCkgPT4gbmV3U2hhcGUsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIGlmIChzY2hlbWEgaW5zdGFuY2VvZiBab2RBcnJheSkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZEFycmF5KHtcbiAgICAgICAgICAgIC4uLnNjaGVtYS5fZGVmLFxuICAgICAgICAgICAgdHlwZTogZGVlcFBhcnRpYWxpZnkoc2NoZW1hLmVsZW1lbnQpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc2NoZW1hIGluc3RhbmNlb2YgWm9kT3B0aW9uYWwpIHtcbiAgICAgICAgcmV0dXJuIFpvZE9wdGlvbmFsLmNyZWF0ZShkZWVwUGFydGlhbGlmeShzY2hlbWEudW53cmFwKCkpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc2NoZW1hIGluc3RhbmNlb2YgWm9kTnVsbGFibGUpIHtcbiAgICAgICAgcmV0dXJuIFpvZE51bGxhYmxlLmNyZWF0ZShkZWVwUGFydGlhbGlmeShzY2hlbWEudW53cmFwKCkpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc2NoZW1hIGluc3RhbmNlb2YgWm9kVHVwbGUpIHtcbiAgICAgICAgcmV0dXJuIFpvZFR1cGxlLmNyZWF0ZShzY2hlbWEuaXRlbXMubWFwKChpdGVtKSA9PiBkZWVwUGFydGlhbGlmeShpdGVtKSkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHNjaGVtYTtcbiAgICB9XG59XG5jbGFzcyBab2RPYmplY3QgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5fY2FjaGVkID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBkZXByZWNhdGVkIEluIG1vc3QgY2FzZXMsIHRoaXMgaXMgbm8gbG9uZ2VyIG5lZWRlZCAtIHVua25vd24gcHJvcGVydGllcyBhcmUgbm93IHNpbGVudGx5IHN0cmlwcGVkLlxuICAgICAgICAgKiBJZiB5b3Ugd2FudCB0byBwYXNzIHRocm91Z2ggdW5rbm93biBwcm9wZXJ0aWVzLCB1c2UgYC5wYXNzdGhyb3VnaCgpYCBpbnN0ZWFkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ub25zdHJpY3QgPSB0aGlzLnBhc3N0aHJvdWdoO1xuICAgICAgICAvLyBleHRlbmQ8XG4gICAgICAgIC8vICAgQXVnbWVudGF0aW9uIGV4dGVuZHMgWm9kUmF3U2hhcGUsXG4gICAgICAgIC8vICAgTmV3T3V0cHV0IGV4dGVuZHMgdXRpbC5mbGF0dGVuPHtcbiAgICAgICAgLy8gICAgIFtrIGluIGtleW9mIEF1Z21lbnRhdGlvbiB8IGtleW9mIE91dHB1dF06IGsgZXh0ZW5kcyBrZXlvZiBBdWdtZW50YXRpb25cbiAgICAgICAgLy8gICAgICAgPyBBdWdtZW50YXRpb25ba11bXCJfb3V0cHV0XCJdXG4gICAgICAgIC8vICAgICAgIDogayBleHRlbmRzIGtleW9mIE91dHB1dFxuICAgICAgICAvLyAgICAgICA/IE91dHB1dFtrXVxuICAgICAgICAvLyAgICAgICA6IG5ldmVyO1xuICAgICAgICAvLyAgIH0+LFxuICAgICAgICAvLyAgIE5ld0lucHV0IGV4dGVuZHMgdXRpbC5mbGF0dGVuPHtcbiAgICAgICAgLy8gICAgIFtrIGluIGtleW9mIEF1Z21lbnRhdGlvbiB8IGtleW9mIElucHV0XTogayBleHRlbmRzIGtleW9mIEF1Z21lbnRhdGlvblxuICAgICAgICAvLyAgICAgICA/IEF1Z21lbnRhdGlvbltrXVtcIl9pbnB1dFwiXVxuICAgICAgICAvLyAgICAgICA6IGsgZXh0ZW5kcyBrZXlvZiBJbnB1dFxuICAgICAgICAvLyAgICAgICA/IElucHV0W2tdXG4gICAgICAgIC8vICAgICAgIDogbmV2ZXI7XG4gICAgICAgIC8vICAgfT5cbiAgICAgICAgLy8gPihcbiAgICAgICAgLy8gICBhdWdtZW50YXRpb246IEF1Z21lbnRhdGlvblxuICAgICAgICAvLyApOiBab2RPYmplY3Q8XG4gICAgICAgIC8vICAgZXh0ZW5kU2hhcGU8VCwgQXVnbWVudGF0aW9uPixcbiAgICAgICAgLy8gICBVbmtub3duS2V5cyxcbiAgICAgICAgLy8gICBDYXRjaGFsbCxcbiAgICAgICAgLy8gICBOZXdPdXRwdXQsXG4gICAgICAgIC8vICAgTmV3SW5wdXRcbiAgICAgICAgLy8gPiB7XG4gICAgICAgIC8vICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICAvLyAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAvLyAgICAgc2hhcGU6ICgpID0+ICh7XG4gICAgICAgIC8vICAgICAgIC4uLnRoaXMuX2RlZi5zaGFwZSgpLFxuICAgICAgICAvLyAgICAgICAuLi5hdWdtZW50YXRpb24sXG4gICAgICAgIC8vICAgICB9KSxcbiAgICAgICAgLy8gICB9KSBhcyBhbnk7XG4gICAgICAgIC8vIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBkZXByZWNhdGVkIFVzZSBgLmV4dGVuZGAgaW5zdGVhZFxuICAgICAgICAgKiAgKi9cbiAgICAgICAgdGhpcy5hdWdtZW50ID0gdGhpcy5leHRlbmQ7XG4gICAgfVxuICAgIF9nZXRDYWNoZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9jYWNoZWQgIT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2FjaGVkO1xuICAgICAgICBjb25zdCBzaGFwZSA9IHRoaXMuX2RlZi5zaGFwZSgpO1xuICAgICAgICBjb25zdCBrZXlzID0gdXRpbC5vYmplY3RLZXlzKHNoYXBlKTtcbiAgICAgICAgcmV0dXJuICh0aGlzLl9jYWNoZWQgPSB7IHNoYXBlLCBrZXlzIH0pO1xuICAgIH1cbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgICAgICBpZiAocGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5vYmplY3QpIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUub2JqZWN0LFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBzdGF0dXMsIGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgY29uc3QgeyBzaGFwZSwga2V5czogc2hhcGVLZXlzIH0gPSB0aGlzLl9nZXRDYWNoZWQoKTtcbiAgICAgICAgY29uc3QgZXh0cmFLZXlzID0gW107XG4gICAgICAgIGlmICghKHRoaXMuX2RlZi5jYXRjaGFsbCBpbnN0YW5jZW9mIFpvZE5ldmVyICYmXG4gICAgICAgICAgICB0aGlzLl9kZWYudW5rbm93bktleXMgPT09IFwic3RyaXBcIikpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIGN0eC5kYXRhKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzaGFwZUtleXMuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBleHRyYUtleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYWlycyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBzaGFwZUtleXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleVZhbGlkYXRvciA9IHNoYXBlW2tleV07XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGN0eC5kYXRhW2tleV07XG4gICAgICAgICAgICBwYWlycy5wdXNoKHtcbiAgICAgICAgICAgICAgICBrZXk6IHsgc3RhdHVzOiBcInZhbGlkXCIsIHZhbHVlOiBrZXkgfSxcbiAgICAgICAgICAgICAgICB2YWx1ZToga2V5VmFsaWRhdG9yLl9wYXJzZShuZXcgUGFyc2VJbnB1dExhenlQYXRoKGN0eCwgdmFsdWUsIGN0eC5wYXRoLCBrZXkpKSxcbiAgICAgICAgICAgICAgICBhbHdheXNTZXQ6IGtleSBpbiBjdHguZGF0YSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9kZWYuY2F0Y2hhbGwgaW5zdGFuY2VvZiBab2ROZXZlcikge1xuICAgICAgICAgICAgY29uc3QgdW5rbm93bktleXMgPSB0aGlzLl9kZWYudW5rbm93bktleXM7XG4gICAgICAgICAgICBpZiAodW5rbm93bktleXMgPT09IFwicGFzc3Rocm91Z2hcIikge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIGV4dHJhS2V5cykge1xuICAgICAgICAgICAgICAgICAgICBwYWlycy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleTogeyBzdGF0dXM6IFwidmFsaWRcIiwgdmFsdWU6IGtleSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHsgc3RhdHVzOiBcInZhbGlkXCIsIHZhbHVlOiBjdHguZGF0YVtrZXldIH0sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHVua25vd25LZXlzID09PSBcInN0cmljdFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGV4dHJhS2V5cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnVucmVjb2duaXplZF9rZXlzLFxuICAgICAgICAgICAgICAgICAgICAgICAga2V5czogZXh0cmFLZXlzLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodW5rbm93bktleXMgPT09IFwic3RyaXBcIikgO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnRlcm5hbCBab2RPYmplY3QgZXJyb3I6IGludmFsaWQgdW5rbm93bktleXMgdmFsdWUuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBydW4gY2F0Y2hhbGwgdmFsaWRhdGlvblxuICAgICAgICAgICAgY29uc3QgY2F0Y2hhbGwgPSB0aGlzLl9kZWYuY2F0Y2hhbGw7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBleHRyYUtleXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGN0eC5kYXRhW2tleV07XG4gICAgICAgICAgICAgICAgcGFpcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGtleTogeyBzdGF0dXM6IFwidmFsaWRcIiwgdmFsdWU6IGtleSB9LFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogY2F0Y2hhbGwuX3BhcnNlKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCB2YWx1ZSwgY3R4LnBhdGgsIGtleSkgLy8sIGN0eC5jaGlsZChrZXkpLCB2YWx1ZSwgZ2V0UGFyc2VkVHlwZSh2YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgYWx3YXlzU2V0OiBrZXkgaW4gY3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuICAgICAgICAgICAgICAgIC50aGVuKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzeW5jUGFpcnMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHBhaXIgb2YgcGFpcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gYXdhaXQgcGFpci5rZXk7XG4gICAgICAgICAgICAgICAgICAgIHN5bmNQYWlycy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBhd2FpdCBwYWlyLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWx3YXlzU2V0OiBwYWlyLmFsd2F5c1NldCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBzeW5jUGFpcnM7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChzeW5jUGFpcnMpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUGFyc2VTdGF0dXMubWVyZ2VPYmplY3RTeW5jKHN0YXR1cywgc3luY1BhaXJzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFBhcnNlU3RhdHVzLm1lcmdlT2JqZWN0U3luYyhzdGF0dXMsIHBhaXJzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgc2hhcGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuc2hhcGUoKTtcbiAgICB9XG4gICAgc3RyaWN0KG1lc3NhZ2UpIHtcbiAgICAgICAgZXJyb3JVdGlsLmVyclRvT2JqO1xuICAgICAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICB1bmtub3duS2V5czogXCJzdHJpY3RcIixcbiAgICAgICAgICAgIC4uLihtZXNzYWdlICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JNYXA6IChpc3N1ZSwgY3R4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkZWZhdWx0RXJyb3IgPSAoX2MgPSAoX2IgPSAoX2EgPSB0aGlzLl9kZWYpLmVycm9yTWFwKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgaXNzdWUsIGN0eCkubWVzc2FnZSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogY3R4LmRlZmF1bHRFcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc3N1ZS5jb2RlID09PSBcInVucmVjb2duaXplZF9rZXlzXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogKF9kID0gZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpLm1lc3NhZ2UpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IGRlZmF1bHRFcnJvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBkZWZhdWx0RXJyb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICA6IHt9KSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0cmlwKCkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICB1bmtub3duS2V5czogXCJzdHJpcFwiLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcGFzc3Rocm91Z2goKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIHVua25vd25LZXlzOiBcInBhc3N0aHJvdWdoXCIsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBjb25zdCBBdWdtZW50RmFjdG9yeSA9XG4gICAgLy8gICA8RGVmIGV4dGVuZHMgWm9kT2JqZWN0RGVmPihkZWY6IERlZikgPT5cbiAgICAvLyAgIDxBdWdtZW50YXRpb24gZXh0ZW5kcyBab2RSYXdTaGFwZT4oXG4gICAgLy8gICAgIGF1Z21lbnRhdGlvbjogQXVnbWVudGF0aW9uXG4gICAgLy8gICApOiBab2RPYmplY3Q8XG4gICAgLy8gICAgIGV4dGVuZFNoYXBlPFJldHVyblR5cGU8RGVmW1wic2hhcGVcIl0+LCBBdWdtZW50YXRpb24+LFxuICAgIC8vICAgICBEZWZbXCJ1bmtub3duS2V5c1wiXSxcbiAgICAvLyAgICAgRGVmW1wiY2F0Y2hhbGxcIl1cbiAgICAvLyAgID4gPT4ge1xuICAgIC8vICAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgLy8gICAgICAgLi4uZGVmLFxuICAgIC8vICAgICAgIHNoYXBlOiAoKSA9PiAoe1xuICAgIC8vICAgICAgICAgLi4uZGVmLnNoYXBlKCksXG4gICAgLy8gICAgICAgICAuLi5hdWdtZW50YXRpb24sXG4gICAgLy8gICAgICAgfSksXG4gICAgLy8gICAgIH0pIGFzIGFueTtcbiAgICAvLyAgIH07XG4gICAgZXh0ZW5kKGF1Z21lbnRhdGlvbikge1xuICAgICAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBzaGFwZTogKCkgPT4gKHtcbiAgICAgICAgICAgICAgICAuLi50aGlzLl9kZWYuc2hhcGUoKSxcbiAgICAgICAgICAgICAgICAuLi5hdWdtZW50YXRpb24sXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByaW9yIHRvIHpvZEAxLjAuMTIgdGhlcmUgd2FzIGEgYnVnIGluIHRoZVxuICAgICAqIGluZmVycmVkIHR5cGUgb2YgbWVyZ2VkIG9iamVjdHMuIFBsZWFzZVxuICAgICAqIHVwZ3JhZGUgaWYgeW91IGFyZSBleHBlcmllbmNpbmcgaXNzdWVzLlxuICAgICAqL1xuICAgIG1lcmdlKG1lcmdpbmcpIHtcbiAgICAgICAgY29uc3QgbWVyZ2VkID0gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgICAgICB1bmtub3duS2V5czogbWVyZ2luZy5fZGVmLnVua25vd25LZXlzLFxuICAgICAgICAgICAgY2F0Y2hhbGw6IG1lcmdpbmcuX2RlZi5jYXRjaGFsbCxcbiAgICAgICAgICAgIHNoYXBlOiAoKSA9PiAoe1xuICAgICAgICAgICAgICAgIC4uLnRoaXMuX2RlZi5zaGFwZSgpLFxuICAgICAgICAgICAgICAgIC4uLm1lcmdpbmcuX2RlZi5zaGFwZSgpLFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE9iamVjdCxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBtZXJnZWQ7XG4gICAgfVxuICAgIC8vIG1lcmdlPFxuICAgIC8vICAgSW5jb21pbmcgZXh0ZW5kcyBBbnlab2RPYmplY3QsXG4gICAgLy8gICBBdWdtZW50YXRpb24gZXh0ZW5kcyBJbmNvbWluZ1tcInNoYXBlXCJdLFxuICAgIC8vICAgTmV3T3V0cHV0IGV4dGVuZHMge1xuICAgIC8vICAgICBbayBpbiBrZXlvZiBBdWdtZW50YXRpb24gfCBrZXlvZiBPdXRwdXRdOiBrIGV4dGVuZHMga2V5b2YgQXVnbWVudGF0aW9uXG4gICAgLy8gICAgICAgPyBBdWdtZW50YXRpb25ba11bXCJfb3V0cHV0XCJdXG4gICAgLy8gICAgICAgOiBrIGV4dGVuZHMga2V5b2YgT3V0cHV0XG4gICAgLy8gICAgICAgPyBPdXRwdXRba11cbiAgICAvLyAgICAgICA6IG5ldmVyO1xuICAgIC8vICAgfSxcbiAgICAvLyAgIE5ld0lucHV0IGV4dGVuZHMge1xuICAgIC8vICAgICBbayBpbiBrZXlvZiBBdWdtZW50YXRpb24gfCBrZXlvZiBJbnB1dF06IGsgZXh0ZW5kcyBrZXlvZiBBdWdtZW50YXRpb25cbiAgICAvLyAgICAgICA/IEF1Z21lbnRhdGlvbltrXVtcIl9pbnB1dFwiXVxuICAgIC8vICAgICAgIDogayBleHRlbmRzIGtleW9mIElucHV0XG4gICAgLy8gICAgICAgPyBJbnB1dFtrXVxuICAgIC8vICAgICAgIDogbmV2ZXI7XG4gICAgLy8gICB9XG4gICAgLy8gPihcbiAgICAvLyAgIG1lcmdpbmc6IEluY29taW5nXG4gICAgLy8gKTogWm9kT2JqZWN0PFxuICAgIC8vICAgZXh0ZW5kU2hhcGU8VCwgUmV0dXJuVHlwZTxJbmNvbWluZ1tcIl9kZWZcIl1bXCJzaGFwZVwiXT4+LFxuICAgIC8vICAgSW5jb21pbmdbXCJfZGVmXCJdW1widW5rbm93bktleXNcIl0sXG4gICAgLy8gICBJbmNvbWluZ1tcIl9kZWZcIl1bXCJjYXRjaGFsbFwiXSxcbiAgICAvLyAgIE5ld091dHB1dCxcbiAgICAvLyAgIE5ld0lucHV0XG4gICAgLy8gPiB7XG4gICAgLy8gICBjb25zdCBtZXJnZWQ6IGFueSA9IG5ldyBab2RPYmplY3Qoe1xuICAgIC8vICAgICB1bmtub3duS2V5czogbWVyZ2luZy5fZGVmLnVua25vd25LZXlzLFxuICAgIC8vICAgICBjYXRjaGFsbDogbWVyZ2luZy5fZGVmLmNhdGNoYWxsLFxuICAgIC8vICAgICBzaGFwZTogKCkgPT5cbiAgICAvLyAgICAgICBvYmplY3RVdGlsLm1lcmdlU2hhcGVzKHRoaXMuX2RlZi5zaGFwZSgpLCBtZXJnaW5nLl9kZWYuc2hhcGUoKSksXG4gICAgLy8gICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kT2JqZWN0LFxuICAgIC8vICAgfSkgYXMgYW55O1xuICAgIC8vICAgcmV0dXJuIG1lcmdlZDtcbiAgICAvLyB9XG4gICAgc2V0S2V5KGtleSwgc2NoZW1hKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmF1Z21lbnQoeyBba2V5XTogc2NoZW1hIH0pO1xuICAgIH1cbiAgICAvLyBtZXJnZTxJbmNvbWluZyBleHRlbmRzIEFueVpvZE9iamVjdD4oXG4gICAgLy8gICBtZXJnaW5nOiBJbmNvbWluZ1xuICAgIC8vICk6IC8vWm9kT2JqZWN0PFQgJiBJbmNvbWluZ1tcIl9zaGFwZVwiXSwgVW5rbm93bktleXMsIENhdGNoYWxsPiA9IChtZXJnaW5nKSA9PiB7XG4gICAgLy8gWm9kT2JqZWN0PFxuICAgIC8vICAgZXh0ZW5kU2hhcGU8VCwgUmV0dXJuVHlwZTxJbmNvbWluZ1tcIl9kZWZcIl1bXCJzaGFwZVwiXT4+LFxuICAgIC8vICAgSW5jb21pbmdbXCJfZGVmXCJdW1widW5rbm93bktleXNcIl0sXG4gICAgLy8gICBJbmNvbWluZ1tcIl9kZWZcIl1bXCJjYXRjaGFsbFwiXVxuICAgIC8vID4ge1xuICAgIC8vICAgLy8gY29uc3QgbWVyZ2VkU2hhcGUgPSBvYmplY3RVdGlsLm1lcmdlU2hhcGVzKFxuICAgIC8vICAgLy8gICB0aGlzLl9kZWYuc2hhcGUoKSxcbiAgICAvLyAgIC8vICAgbWVyZ2luZy5fZGVmLnNoYXBlKClcbiAgICAvLyAgIC8vICk7XG4gICAgLy8gICBjb25zdCBtZXJnZWQ6IGFueSA9IG5ldyBab2RPYmplY3Qoe1xuICAgIC8vICAgICB1bmtub3duS2V5czogbWVyZ2luZy5fZGVmLnVua25vd25LZXlzLFxuICAgIC8vICAgICBjYXRjaGFsbDogbWVyZ2luZy5fZGVmLmNhdGNoYWxsLFxuICAgIC8vICAgICBzaGFwZTogKCkgPT5cbiAgICAvLyAgICAgICBvYmplY3RVdGlsLm1lcmdlU2hhcGVzKHRoaXMuX2RlZi5zaGFwZSgpLCBtZXJnaW5nLl9kZWYuc2hhcGUoKSksXG4gICAgLy8gICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kT2JqZWN0LFxuICAgIC8vICAgfSkgYXMgYW55O1xuICAgIC8vICAgcmV0dXJuIG1lcmdlZDtcbiAgICAvLyB9XG4gICAgY2F0Y2hhbGwoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgY2F0Y2hhbGw6IGluZGV4LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcGljayhtYXNrKSB7XG4gICAgICAgIGNvbnN0IHNoYXBlID0ge307XG4gICAgICAgIHV0aWwub2JqZWN0S2V5cyhtYXNrKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgIGlmIChtYXNrW2tleV0gJiYgdGhpcy5zaGFwZVtrZXldKSB7XG4gICAgICAgICAgICAgICAgc2hhcGVba2V5XSA9IHRoaXMuc2hhcGVba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIHNoYXBlOiAoKSA9PiBzaGFwZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG9taXQobWFzaykge1xuICAgICAgICBjb25zdCBzaGFwZSA9IHt9O1xuICAgICAgICB1dGlsLm9iamVjdEtleXModGhpcy5zaGFwZSkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICBpZiAoIW1hc2tba2V5XSkge1xuICAgICAgICAgICAgICAgIHNoYXBlW2tleV0gPSB0aGlzLnNoYXBlW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBzaGFwZTogKCkgPT4gc2hhcGUsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAqL1xuICAgIGRlZXBQYXJ0aWFsKCkge1xuICAgICAgICByZXR1cm4gZGVlcFBhcnRpYWxpZnkodGhpcyk7XG4gICAgfVxuICAgIHBhcnRpYWwobWFzaykge1xuICAgICAgICBjb25zdCBuZXdTaGFwZSA9IHt9O1xuICAgICAgICB1dGlsLm9iamVjdEtleXModGhpcy5zaGFwZSkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmaWVsZFNjaGVtYSA9IHRoaXMuc2hhcGVba2V5XTtcbiAgICAgICAgICAgIGlmIChtYXNrICYmICFtYXNrW2tleV0pIHtcbiAgICAgICAgICAgICAgICBuZXdTaGFwZVtrZXldID0gZmllbGRTY2hlbWE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZXdTaGFwZVtrZXldID0gZmllbGRTY2hlbWEub3B0aW9uYWwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIHNoYXBlOiAoKSA9PiBuZXdTaGFwZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlcXVpcmVkKG1hc2spIHtcbiAgICAgICAgY29uc3QgbmV3U2hhcGUgPSB7fTtcbiAgICAgICAgdXRpbC5vYmplY3RLZXlzKHRoaXMuc2hhcGUpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgaWYgKG1hc2sgJiYgIW1hc2tba2V5XSkge1xuICAgICAgICAgICAgICAgIG5ld1NoYXBlW2tleV0gPSB0aGlzLnNoYXBlW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmaWVsZFNjaGVtYSA9IHRoaXMuc2hhcGVba2V5XTtcbiAgICAgICAgICAgICAgICBsZXQgbmV3RmllbGQgPSBmaWVsZFNjaGVtYTtcbiAgICAgICAgICAgICAgICB3aGlsZSAobmV3RmllbGQgaW5zdGFuY2VvZiBab2RPcHRpb25hbCkge1xuICAgICAgICAgICAgICAgICAgICBuZXdGaWVsZCA9IG5ld0ZpZWxkLl9kZWYuaW5uZXJUeXBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuZXdTaGFwZVtrZXldID0gbmV3RmllbGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBzaGFwZTogKCkgPT4gbmV3U2hhcGUsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBrZXlvZigpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVpvZEVudW0odXRpbC5vYmplY3RLZXlzKHRoaXMuc2hhcGUpKTtcbiAgICB9XG59XG5ab2RPYmplY3QuY3JlYXRlID0gKHNoYXBlLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgIHNoYXBlOiAoKSA9PiBzaGFwZSxcbiAgICAgICAgdW5rbm93bktleXM6IFwic3RyaXBcIixcbiAgICAgICAgY2F0Y2hhbGw6IFpvZE5ldmVyLmNyZWF0ZSgpLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE9iamVjdCxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcblpvZE9iamVjdC5zdHJpY3RDcmVhdGUgPSAoc2hhcGUsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgc2hhcGU6ICgpID0+IHNoYXBlLFxuICAgICAgICB1bmtub3duS2V5czogXCJzdHJpY3RcIixcbiAgICAgICAgY2F0Y2hhbGw6IFpvZE5ldmVyLmNyZWF0ZSgpLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE9iamVjdCxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcblpvZE9iamVjdC5sYXp5Y3JlYXRlID0gKHNoYXBlLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgIHNoYXBlLFxuICAgICAgICB1bmtub3duS2V5czogXCJzdHJpcFwiLFxuICAgICAgICBjYXRjaGFsbDogWm9kTmV2ZXIuY3JlYXRlKCksXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kT2JqZWN0LFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kVW5pb24gZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgeyBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLl9kZWYub3B0aW9ucztcbiAgICAgICAgZnVuY3Rpb24gaGFuZGxlUmVzdWx0cyhyZXN1bHRzKSB7XG4gICAgICAgICAgICAvLyByZXR1cm4gZmlyc3QgaXNzdWUtZnJlZSB2YWxpZGF0aW9uIGlmIGl0IGV4aXN0c1xuICAgICAgICAgICAgZm9yIChjb25zdCByZXN1bHQgb2YgcmVzdWx0cykge1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQucmVzdWx0LnN0YXR1cyA9PT0gXCJ2YWxpZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQucmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3QgcmVzdWx0IG9mIHJlc3VsdHMpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnJlc3VsdC5zdGF0dXMgPT09IFwiZGlydHlcIikge1xuICAgICAgICAgICAgICAgICAgICAvLyBhZGQgaXNzdWVzIGZyb20gZGlydHkgb3B0aW9uXG4gICAgICAgICAgICAgICAgICAgIGN0eC5jb21tb24uaXNzdWVzLnB1c2goLi4ucmVzdWx0LmN0eC5jb21tb24uaXNzdWVzKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gcmV0dXJuIGludmFsaWRcbiAgICAgICAgICAgIGNvbnN0IHVuaW9uRXJyb3JzID0gcmVzdWx0cy5tYXAoKHJlc3VsdCkgPT4gbmV3IFpvZEVycm9yKHJlc3VsdC5jdHguY29tbW9uLmlzc3VlcykpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdW5pb24sXG4gICAgICAgICAgICAgICAgdW5pb25FcnJvcnMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwob3B0aW9ucy5tYXAoYXN5bmMgKG9wdGlvbikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkQ3R4ID0ge1xuICAgICAgICAgICAgICAgICAgICAuLi5jdHgsXG4gICAgICAgICAgICAgICAgICAgIGNvbW1vbjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4uY3R4LmNvbW1vbixcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzc3VlczogW10sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudDogbnVsbCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDogYXdhaXQgb3B0aW9uLl9wYXJzZUFzeW5jKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IGNoaWxkQ3R4LFxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgY3R4OiBjaGlsZEN0eCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSkpLnRoZW4oaGFuZGxlUmVzdWx0cyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgZGlydHkgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjb25zdCBpc3N1ZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgb3B0aW9uIG9mIG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZEN0eCA9IHtcbiAgICAgICAgICAgICAgICAgICAgLi4uY3R4LFxuICAgICAgICAgICAgICAgICAgICBjb21tb246IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmN0eC5jb21tb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBpc3N1ZXM6IFtdLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IG51bGwsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBvcHRpb24uX3BhcnNlU3luYyh7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBjaGlsZEN0eCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnN0YXR1cyA9PT0gXCJ2YWxpZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlc3VsdC5zdGF0dXMgPT09IFwiZGlydHlcIiAmJiAhZGlydHkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlydHkgPSB7IHJlc3VsdCwgY3R4OiBjaGlsZEN0eCB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY2hpbGRDdHguY29tbW9uLmlzc3Vlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgaXNzdWVzLnB1c2goY2hpbGRDdHguY29tbW9uLmlzc3Vlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRpcnR5KSB7XG4gICAgICAgICAgICAgICAgY3R4LmNvbW1vbi5pc3N1ZXMucHVzaCguLi5kaXJ0eS5jdHguY29tbW9uLmlzc3Vlcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRpcnR5LnJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHVuaW9uRXJyb3JzID0gaXNzdWVzLm1hcCgoaXNzdWVzKSA9PiBuZXcgWm9kRXJyb3IoaXNzdWVzKSk7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF91bmlvbixcbiAgICAgICAgICAgICAgICB1bmlvbkVycm9ycyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IG9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYub3B0aW9ucztcbiAgICB9XG59XG5ab2RVbmlvbi5jcmVhdGUgPSAodHlwZXMsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kVW5pb24oe1xuICAgICAgICBvcHRpb25zOiB0eXBlcyxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RVbmlvbixcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vLy8vLy8vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vLy8vLy8vLy9cbi8vLy8vLy8vLy8gICAgICBab2REaXNjcmltaW5hdGVkVW5pb24gICAgICAvLy8vLy8vLy8vXG4vLy8vLy8vLy8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8vLy8vLy8vL1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5jb25zdCBnZXREaXNjcmltaW5hdG9yID0gKHR5cGUpID0+IHtcbiAgICBpZiAodHlwZSBpbnN0YW5jZW9mIFpvZExhenkpIHtcbiAgICAgICAgcmV0dXJuIGdldERpc2NyaW1pbmF0b3IodHlwZS5zY2hlbWEpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kRWZmZWN0cykge1xuICAgICAgICByZXR1cm4gZ2V0RGlzY3JpbWluYXRvcih0eXBlLmlubmVyVHlwZSgpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSBpbnN0YW5jZW9mIFpvZExpdGVyYWwpIHtcbiAgICAgICAgcmV0dXJuIFt0eXBlLnZhbHVlXTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSBpbnN0YW5jZW9mIFpvZEVudW0pIHtcbiAgICAgICAgcmV0dXJuIHR5cGUub3B0aW9ucztcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSBpbnN0YW5jZW9mIFpvZE5hdGl2ZUVudW0pIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGJhbi9iYW5cbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHR5cGUuZW51bSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgaW5zdGFuY2VvZiBab2REZWZhdWx0KSB7XG4gICAgICAgIHJldHVybiBnZXREaXNjcmltaW5hdG9yKHR5cGUuX2RlZi5pbm5lclR5cGUpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kVW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBbdW5kZWZpbmVkXTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSBpbnN0YW5jZW9mIFpvZE51bGwpIHtcbiAgICAgICAgcmV0dXJuIFtudWxsXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn07XG5jbGFzcyBab2REaXNjcmltaW5hdGVkVW5pb24gZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgeyBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGlmIChjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5vYmplY3QpIHtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUub2JqZWN0LFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGlzY3JpbWluYXRvciA9IHRoaXMuZGlzY3JpbWluYXRvcjtcbiAgICAgICAgY29uc3QgZGlzY3JpbWluYXRvclZhbHVlID0gY3R4LmRhdGFbZGlzY3JpbWluYXRvcl07XG4gICAgICAgIGNvbnN0IG9wdGlvbiA9IHRoaXMub3B0aW9uc01hcC5nZXQoZGlzY3JpbWluYXRvclZhbHVlKTtcbiAgICAgICAgaWYgKCFvcHRpb24pIHtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3VuaW9uX2Rpc2NyaW1pbmF0b3IsXG4gICAgICAgICAgICAgICAgb3B0aW9uczogQXJyYXkuZnJvbSh0aGlzLm9wdGlvbnNNYXAua2V5cygpKSxcbiAgICAgICAgICAgICAgICBwYXRoOiBbZGlzY3JpbWluYXRvcl0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XG4gICAgICAgICAgICByZXR1cm4gb3B0aW9uLl9wYXJzZUFzeW5jKHtcbiAgICAgICAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbi5fcGFyc2VTeW5jKHtcbiAgICAgICAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBkaXNjcmltaW5hdG9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLmRpc2NyaW1pbmF0b3I7XG4gICAgfVxuICAgIGdldCBvcHRpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLm9wdGlvbnM7XG4gICAgfVxuICAgIGdldCBvcHRpb25zTWFwKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLm9wdGlvbnNNYXA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBjb25zdHJ1Y3RvciBvZiB0aGUgZGlzY3JpbWluYXRlZCB1bmlvbiBzY2hlbWEuIEl0cyBiZWhhdmlvdXIgaXMgdmVyeSBzaW1pbGFyIHRvIHRoYXQgb2YgdGhlIG5vcm1hbCB6LnVuaW9uKCkgY29uc3RydWN0b3IuXG4gICAgICogSG93ZXZlciwgaXQgb25seSBhbGxvd3MgYSB1bmlvbiBvZiBvYmplY3RzLCBhbGwgb2Ygd2hpY2ggbmVlZCB0byBzaGFyZSBhIGRpc2NyaW1pbmF0b3IgcHJvcGVydHkuIFRoaXMgcHJvcGVydHkgbXVzdFxuICAgICAqIGhhdmUgYSBkaWZmZXJlbnQgdmFsdWUgZm9yIGVhY2ggb2JqZWN0IGluIHRoZSB1bmlvbi5cbiAgICAgKiBAcGFyYW0gZGlzY3JpbWluYXRvciB0aGUgbmFtZSBvZiB0aGUgZGlzY3JpbWluYXRvciBwcm9wZXJ0eVxuICAgICAqIEBwYXJhbSB0eXBlcyBhbiBhcnJheSBvZiBvYmplY3Qgc2NoZW1hc1xuICAgICAqIEBwYXJhbSBwYXJhbXNcbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlKGRpc2NyaW1pbmF0b3IsIG9wdGlvbnMsIHBhcmFtcykge1xuICAgICAgICAvLyBHZXQgYWxsIHRoZSB2YWxpZCBkaXNjcmltaW5hdG9yIHZhbHVlc1xuICAgICAgICBjb25zdCBvcHRpb25zTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICAvLyB0cnkge1xuICAgICAgICBmb3IgKGNvbnN0IHR5cGUgb2Ygb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgZGlzY3JpbWluYXRvclZhbHVlcyA9IGdldERpc2NyaW1pbmF0b3IodHlwZS5zaGFwZVtkaXNjcmltaW5hdG9yXSk7XG4gICAgICAgICAgICBpZiAoIWRpc2NyaW1pbmF0b3JWYWx1ZXMpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEEgZGlzY3JpbWluYXRvciB2YWx1ZSBmb3Iga2V5IFxcYCR7ZGlzY3JpbWluYXRvcn1cXGAgY291bGQgbm90IGJlIGV4dHJhY3RlZCBmcm9tIGFsbCBzY2hlbWEgb3B0aW9uc2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiBkaXNjcmltaW5hdG9yVmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnNNYXAuaGFzKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYERpc2NyaW1pbmF0b3IgcHJvcGVydHkgJHtTdHJpbmcoZGlzY3JpbWluYXRvcil9IGhhcyBkdXBsaWNhdGUgdmFsdWUgJHtTdHJpbmcodmFsdWUpfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvcHRpb25zTWFwLnNldCh2YWx1ZSwgdHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBab2REaXNjcmltaW5hdGVkVW5pb24oe1xuICAgICAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2REaXNjcmltaW5hdGVkVW5pb24sXG4gICAgICAgICAgICBkaXNjcmltaW5hdG9yLFxuICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgIG9wdGlvbnNNYXAsXG4gICAgICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG1lcmdlVmFsdWVzKGEsIGIpIHtcbiAgICBjb25zdCBhVHlwZSA9IGdldFBhcnNlZFR5cGUoYSk7XG4gICAgY29uc3QgYlR5cGUgPSBnZXRQYXJzZWRUeXBlKGIpO1xuICAgIGlmIChhID09PSBiKSB7XG4gICAgICAgIHJldHVybiB7IHZhbGlkOiB0cnVlLCBkYXRhOiBhIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKGFUeXBlID09PSBab2RQYXJzZWRUeXBlLm9iamVjdCAmJiBiVHlwZSA9PT0gWm9kUGFyc2VkVHlwZS5vYmplY3QpIHtcbiAgICAgICAgY29uc3QgYktleXMgPSB1dGlsLm9iamVjdEtleXMoYik7XG4gICAgICAgIGNvbnN0IHNoYXJlZEtleXMgPSB1dGlsXG4gICAgICAgICAgICAub2JqZWN0S2V5cyhhKVxuICAgICAgICAgICAgLmZpbHRlcigoa2V5KSA9PiBiS2V5cy5pbmRleE9mKGtleSkgIT09IC0xKTtcbiAgICAgICAgY29uc3QgbmV3T2JqID0geyAuLi5hLCAuLi5iIH07XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIHNoYXJlZEtleXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHNoYXJlZFZhbHVlID0gbWVyZ2VWYWx1ZXMoYVtrZXldLCBiW2tleV0pO1xuICAgICAgICAgICAgaWYgKCFzaGFyZWRWYWx1ZS52YWxpZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbGlkOiBmYWxzZSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3T2JqW2tleV0gPSBzaGFyZWRWYWx1ZS5kYXRhO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHZhbGlkOiB0cnVlLCBkYXRhOiBuZXdPYmogfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYVR5cGUgPT09IFpvZFBhcnNlZFR5cGUuYXJyYXkgJiYgYlR5cGUgPT09IFpvZFBhcnNlZFR5cGUuYXJyYXkpIHtcbiAgICAgICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IGZhbHNlIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV3QXJyYXkgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGEubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtQSA9IGFbaW5kZXhdO1xuICAgICAgICAgICAgY29uc3QgaXRlbUIgPSBiW2luZGV4XTtcbiAgICAgICAgICAgIGNvbnN0IHNoYXJlZFZhbHVlID0gbWVyZ2VWYWx1ZXMoaXRlbUEsIGl0ZW1CKTtcbiAgICAgICAgICAgIGlmICghc2hhcmVkVmFsdWUudmFsaWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB2YWxpZDogZmFsc2UgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ld0FycmF5LnB1c2goc2hhcmVkVmFsdWUuZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IHRydWUsIGRhdGE6IG5ld0FycmF5IH07XG4gICAgfVxuICAgIGVsc2UgaWYgKGFUeXBlID09PSBab2RQYXJzZWRUeXBlLmRhdGUgJiZcbiAgICAgICAgYlR5cGUgPT09IFpvZFBhcnNlZFR5cGUuZGF0ZSAmJlxuICAgICAgICArYSA9PT0gK2IpIHtcbiAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IHRydWUsIGRhdGE6IGEgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB7IHZhbGlkOiBmYWxzZSB9O1xuICAgIH1cbn1cbmNsYXNzIFpvZEludGVyc2VjdGlvbiBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IHN0YXR1cywgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBjb25zdCBoYW5kbGVQYXJzZWQgPSAocGFyc2VkTGVmdCwgcGFyc2VkUmlnaHQpID0+IHtcbiAgICAgICAgICAgIGlmIChpc0Fib3J0ZWQocGFyc2VkTGVmdCkgfHwgaXNBYm9ydGVkKHBhcnNlZFJpZ2h0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbWVyZ2VkID0gbWVyZ2VWYWx1ZXMocGFyc2VkTGVmdC52YWx1ZSwgcGFyc2VkUmlnaHQudmFsdWUpO1xuICAgICAgICAgICAgaWYgKCFtZXJnZWQudmFsaWQpIHtcbiAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfaW50ZXJzZWN0aW9uX3R5cGVzLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzRGlydHkocGFyc2VkTGVmdCkgfHwgaXNEaXJ0eShwYXJzZWRSaWdodCkpIHtcbiAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogbWVyZ2VkLmRhdGEgfTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgdGhpcy5fZGVmLmxlZnQuX3BhcnNlQXN5bmMoe1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIHRoaXMuX2RlZi5yaWdodC5fcGFyc2VBc3luYyh7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBjdHgsXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBdKS50aGVuKChbbGVmdCwgcmlnaHRdKSA9PiBoYW5kbGVQYXJzZWQobGVmdCwgcmlnaHQpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVQYXJzZWQodGhpcy5fZGVmLmxlZnQuX3BhcnNlU3luYyh7XG4gICAgICAgICAgICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgcGFyZW50OiBjdHgsXG4gICAgICAgICAgICB9KSwgdGhpcy5fZGVmLnJpZ2h0Ll9wYXJzZVN5bmMoe1xuICAgICAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgfVxufVxuWm9kSW50ZXJzZWN0aW9uLmNyZWF0ZSA9IChsZWZ0LCByaWdodCwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RJbnRlcnNlY3Rpb24oe1xuICAgICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgICByaWdodDogcmlnaHQsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kSW50ZXJzZWN0aW9uLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kVHVwbGUgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgeyBzdGF0dXMsIGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgaWYgKGN0eC5wYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLmFycmF5KSB7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLmFycmF5LFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN0eC5kYXRhLmxlbmd0aCA8IHRoaXMuX2RlZi5pdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fc21hbGwsXG4gICAgICAgICAgICAgICAgbWluaW11bTogdGhpcy5fZGVmLml0ZW1zLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdCA9IHRoaXMuX2RlZi5yZXN0O1xuICAgICAgICBpZiAoIXJlc3QgJiYgY3R4LmRhdGEubGVuZ3RoID4gdGhpcy5fZGVmLml0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19iaWcsXG4gICAgICAgICAgICAgICAgbWF4aW11bTogdGhpcy5fZGVmLml0ZW1zLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXRlbXMgPSBbLi4uY3R4LmRhdGFdXG4gICAgICAgICAgICAubWFwKChpdGVtLCBpdGVtSW5kZXgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNjaGVtYSA9IHRoaXMuX2RlZi5pdGVtc1tpdGVtSW5kZXhdIHx8IHRoaXMuX2RlZi5yZXN0O1xuICAgICAgICAgICAgaWYgKCFzY2hlbWEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICByZXR1cm4gc2NoZW1hLl9wYXJzZShuZXcgUGFyc2VJbnB1dExhenlQYXRoKGN0eCwgaXRlbSwgY3R4LnBhdGgsIGl0ZW1JbmRleCkpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmZpbHRlcigoeCkgPT4gISF4KTsgLy8gZmlsdGVyIG51bGxzXG4gICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoaXRlbXMpLnRoZW4oKHJlc3VsdHMpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUGFyc2VTdGF0dXMubWVyZ2VBcnJheShzdGF0dXMsIHJlc3VsdHMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gUGFyc2VTdGF0dXMubWVyZ2VBcnJheShzdGF0dXMsIGl0ZW1zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgaXRlbXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuaXRlbXM7XG4gICAgfVxuICAgIHJlc3QocmVzdCkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZFR1cGxlKHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIHJlc3QsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cblpvZFR1cGxlLmNyZWF0ZSA9IChzY2hlbWFzLCBwYXJhbXMpID0+IHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoc2NoZW1hcykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWW91IG11c3QgcGFzcyBhbiBhcnJheSBvZiBzY2hlbWFzIHRvIHoudHVwbGUoWyAuLi4gXSlcIik7XG4gICAgfVxuICAgIHJldHVybiBuZXcgWm9kVHVwbGUoe1xuICAgICAgICBpdGVtczogc2NoZW1hcyxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RUdXBsZSxcbiAgICAgICAgcmVzdDogbnVsbCxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNsYXNzIFpvZFJlY29yZCBleHRlbmRzIFpvZFR5cGUge1xuICAgIGdldCBrZXlTY2hlbWEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYua2V5VHlwZTtcbiAgICB9XG4gICAgZ2V0IHZhbHVlU2NoZW1hKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnZhbHVlVHlwZTtcbiAgICB9XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgc3RhdHVzLCBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGlmIChjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5vYmplY3QpIHtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUub2JqZWN0LFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFpcnMgPSBbXTtcbiAgICAgICAgY29uc3Qga2V5VHlwZSA9IHRoaXMuX2RlZi5rZXlUeXBlO1xuICAgICAgICBjb25zdCB2YWx1ZVR5cGUgPSB0aGlzLl9kZWYudmFsdWVUeXBlO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBjdHguZGF0YSkge1xuICAgICAgICAgICAgcGFpcnMucHVzaCh7XG4gICAgICAgICAgICAgICAga2V5OiBrZXlUeXBlLl9wYXJzZShuZXcgUGFyc2VJbnB1dExhenlQYXRoKGN0eCwga2V5LCBjdHgucGF0aCwga2V5KSksXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlVHlwZS5fcGFyc2UobmV3IFBhcnNlSW5wdXRMYXp5UGF0aChjdHgsIGN0eC5kYXRhW2tleV0sIGN0eC5wYXRoLCBrZXkpKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XG4gICAgICAgICAgICByZXR1cm4gUGFyc2VTdGF0dXMubWVyZ2VPYmplY3RBc3luYyhzdGF0dXMsIHBhaXJzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBQYXJzZVN0YXR1cy5tZXJnZU9iamVjdFN5bmMoc3RhdHVzLCBwYWlycyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGVsZW1lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYudmFsdWVUeXBlO1xuICAgIH1cbiAgICBzdGF0aWMgY3JlYXRlKGZpcnN0LCBzZWNvbmQsIHRoaXJkKSB7XG4gICAgICAgIGlmIChzZWNvbmQgaW5zdGFuY2VvZiBab2RUeXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFpvZFJlY29yZCh7XG4gICAgICAgICAgICAgICAga2V5VHlwZTogZmlyc3QsXG4gICAgICAgICAgICAgICAgdmFsdWVUeXBlOiBzZWNvbmQsXG4gICAgICAgICAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RSZWNvcmQsXG4gICAgICAgICAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyh0aGlyZCksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFpvZFJlY29yZCh7XG4gICAgICAgICAgICBrZXlUeXBlOiBab2RTdHJpbmcuY3JlYXRlKCksXG4gICAgICAgICAgICB2YWx1ZVR5cGU6IGZpcnN0LFxuICAgICAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RSZWNvcmQsXG4gICAgICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHNlY29uZCksXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmNsYXNzIFpvZE1hcCBleHRlbmRzIFpvZFR5cGUge1xuICAgIGdldCBrZXlTY2hlbWEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYua2V5VHlwZTtcbiAgICB9XG4gICAgZ2V0IHZhbHVlU2NoZW1hKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnZhbHVlVHlwZTtcbiAgICB9XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgc3RhdHVzLCBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGlmIChjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5tYXApIHtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUubWFwLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qga2V5VHlwZSA9IHRoaXMuX2RlZi5rZXlUeXBlO1xuICAgICAgICBjb25zdCB2YWx1ZVR5cGUgPSB0aGlzLl9kZWYudmFsdWVUeXBlO1xuICAgICAgICBjb25zdCBwYWlycyA9IFsuLi5jdHguZGF0YS5lbnRyaWVzKCldLm1hcCgoW2tleSwgdmFsdWVdLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBrZXk6IGtleVR5cGUuX3BhcnNlKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCBrZXksIGN0eC5wYXRoLCBbaW5kZXgsIFwia2V5XCJdKSksXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlVHlwZS5fcGFyc2UobmV3IFBhcnNlSW5wdXRMYXp5UGF0aChjdHgsIHZhbHVlLCBjdHgucGF0aCwgW2luZGV4LCBcInZhbHVlXCJdKSksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpbmFsTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcGFpciBvZiBwYWlycykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBhd2FpdCBwYWlyLmtleTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBhd2FpdCBwYWlyLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5LnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIgfHwgdmFsdWUuc3RhdHVzID09PSBcImFib3J0ZWRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleS5zdGF0dXMgPT09IFwiZGlydHlcIiB8fCB2YWx1ZS5zdGF0dXMgPT09IFwiZGlydHlcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZmluYWxNYXAuc2V0KGtleS52YWx1ZSwgdmFsdWUudmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IGZpbmFsTWFwIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGZpbmFsTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBwYWlyIG9mIHBhaXJzKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gcGFpci5rZXk7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBwYWlyLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmIChrZXkuc3RhdHVzID09PSBcImFib3J0ZWRcIiB8fCB2YWx1ZS5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoa2V5LnN0YXR1cyA9PT0gXCJkaXJ0eVwiIHx8IHZhbHVlLnN0YXR1cyA9PT0gXCJkaXJ0eVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbE1hcC5zZXQoa2V5LnZhbHVlLCB2YWx1ZS52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IGZpbmFsTWFwIH07XG4gICAgICAgIH1cbiAgICB9XG59XG5ab2RNYXAuY3JlYXRlID0gKGtleVR5cGUsIHZhbHVlVHlwZSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RNYXAoe1xuICAgICAgICB2YWx1ZVR5cGUsXG4gICAgICAgIGtleVR5cGUsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kTWFwLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kU2V0IGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgc3RhdHVzLCBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGlmIChjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5zZXQpIHtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUuc2V0LFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGVmID0gdGhpcy5fZGVmO1xuICAgICAgICBpZiAoZGVmLm1pblNpemUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChjdHguZGF0YS5zaXplIDwgZGVmLm1pblNpemUudmFsdWUpIHtcbiAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19zbWFsbCxcbiAgICAgICAgICAgICAgICAgICAgbWluaW11bTogZGVmLm1pblNpemUudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwic2V0XCIsXG4gICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBkZWYubWluU2l6ZS5tZXNzYWdlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChkZWYubWF4U2l6ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGN0eC5kYXRhLnNpemUgPiBkZWYubWF4U2l6ZS52YWx1ZSkge1xuICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX2JpZyxcbiAgICAgICAgICAgICAgICAgICAgbWF4aW11bTogZGVmLm1heFNpemUudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwic2V0XCIsXG4gICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBkZWYubWF4U2l6ZS5tZXNzYWdlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZhbHVlVHlwZSA9IHRoaXMuX2RlZi52YWx1ZVR5cGU7XG4gICAgICAgIGZ1bmN0aW9uIGZpbmFsaXplU2V0KGVsZW1lbnRzKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWRTZXQgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgZWxlbWVudHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5zdGF0dXMgPT09IFwiZGlydHlcIilcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgcGFyc2VkU2V0LmFkZChlbGVtZW50LnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogcGFyc2VkU2V0IH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZWxlbWVudHMgPSBbLi4uY3R4LmRhdGEudmFsdWVzKCldLm1hcCgoaXRlbSwgaSkgPT4gdmFsdWVUeXBlLl9wYXJzZShuZXcgUGFyc2VJbnB1dExhenlQYXRoKGN0eCwgaXRlbSwgY3R4LnBhdGgsIGkpKSk7XG4gICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoZWxlbWVudHMpLnRoZW4oKGVsZW1lbnRzKSA9PiBmaW5hbGl6ZVNldChlbGVtZW50cykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZpbmFsaXplU2V0KGVsZW1lbnRzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBtaW4obWluU2l6ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZFNldCh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBtaW5TaXplOiB7IHZhbHVlOiBtaW5TaXplLCBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG1heChtYXhTaXplLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kU2V0KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIG1heFNpemU6IHsgdmFsdWU6IG1heFNpemUsIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2l6ZShzaXplLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbihzaXplLCBtZXNzYWdlKS5tYXgoc2l6ZSwgbWVzc2FnZSk7XG4gICAgfVxuICAgIG5vbmVtcHR5KG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWluKDEsIG1lc3NhZ2UpO1xuICAgIH1cbn1cblpvZFNldC5jcmVhdGUgPSAodmFsdWVUeXBlLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZFNldCh7XG4gICAgICAgIHZhbHVlVHlwZSxcbiAgICAgICAgbWluU2l6ZTogbnVsbCxcbiAgICAgICAgbWF4U2l6ZTogbnVsbCxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RTZXQsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5jbGFzcyBab2RGdW5jdGlvbiBleHRlbmRzIFpvZFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnZhbGlkYXRlID0gdGhpcy5pbXBsZW1lbnQ7XG4gICAgfVxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgaWYgKGN0eC5wYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLmZ1bmN0aW9uKSB7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLmZ1bmN0aW9uLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbWFrZUFyZ3NJc3N1ZShhcmdzLCBlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIG1ha2VJc3N1ZSh7XG4gICAgICAgICAgICAgICAgZGF0YTogYXJncyxcbiAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICBlcnJvck1hcHM6IFtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmNvbW1vbi5jb250ZXh0dWFsRXJyb3JNYXAsXG4gICAgICAgICAgICAgICAgICAgIGN0eC5zY2hlbWFFcnJvck1hcCxcbiAgICAgICAgICAgICAgICAgICAgZ2V0RXJyb3JNYXAoKSxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JNYXAsXG4gICAgICAgICAgICAgICAgXS5maWx0ZXIoKHgpID0+ICEheCksXG4gICAgICAgICAgICAgICAgaXNzdWVEYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX2FyZ3VtZW50cyxcbiAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRzRXJyb3I6IGVycm9yLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBtYWtlUmV0dXJuc0lzc3VlKHJldHVybnMsIGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gbWFrZUlzc3VlKHtcbiAgICAgICAgICAgICAgICBkYXRhOiByZXR1cm5zLFxuICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgIGVycm9yTWFwczogW1xuICAgICAgICAgICAgICAgICAgICBjdHguY29tbW9uLmNvbnRleHR1YWxFcnJvck1hcCxcbiAgICAgICAgICAgICAgICAgICAgY3R4LnNjaGVtYUVycm9yTWFwLFxuICAgICAgICAgICAgICAgICAgICBnZXRFcnJvck1hcCgpLFxuICAgICAgICAgICAgICAgICAgICBlcnJvck1hcCxcbiAgICAgICAgICAgICAgICBdLmZpbHRlcigoeCkgPT4gISF4KSxcbiAgICAgICAgICAgICAgICBpc3N1ZURhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfcmV0dXJuX3R5cGUsXG4gICAgICAgICAgICAgICAgICAgIHJldHVyblR5cGVFcnJvcjogZXJyb3IsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IHsgZXJyb3JNYXA6IGN0eC5jb21tb24uY29udGV4dHVhbEVycm9yTWFwIH07XG4gICAgICAgIGNvbnN0IGZuID0gY3R4LmRhdGE7XG4gICAgICAgIGlmICh0aGlzLl9kZWYucmV0dXJucyBpbnN0YW5jZW9mIFpvZFByb21pc2UpIHtcbiAgICAgICAgICAgIC8vIFdvdWxkIGxvdmUgYSB3YXkgdG8gYXZvaWQgZGlzYWJsaW5nIHRoaXMgcnVsZSwgYnV0IHdlIG5lZWRcbiAgICAgICAgICAgIC8vIGFuIGFsaWFzICh1c2luZyBhbiBhcnJvdyBmdW5jdGlvbiB3YXMgd2hhdCBjYXVzZWQgMjY1MSkuXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXRoaXMtYWxpYXNcbiAgICAgICAgICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiBPSyhhc3luYyBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IFpvZEVycm9yKFtdKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWRBcmdzID0gYXdhaXQgbWUuX2RlZi5hcmdzXG4gICAgICAgICAgICAgICAgICAgIC5wYXJzZUFzeW5jKGFyZ3MsIHBhcmFtcylcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yLmFkZElzc3VlKG1ha2VBcmdzSXNzdWUoYXJncywgZSkpO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBSZWZsZWN0LmFwcGx5KGZuLCB0aGlzLCBwYXJzZWRBcmdzKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWRSZXR1cm5zID0gYXdhaXQgbWUuX2RlZi5yZXR1cm5zLl9kZWYudHlwZVxuICAgICAgICAgICAgICAgICAgICAucGFyc2VBc3luYyhyZXN1bHQsIHBhcmFtcylcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yLmFkZElzc3VlKG1ha2VSZXR1cm5zSXNzdWUocmVzdWx0LCBlKSk7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZWRSZXR1cm5zO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBXb3VsZCBsb3ZlIGEgd2F5IHRvIGF2b2lkIGRpc2FibGluZyB0aGlzIHJ1bGUsIGJ1dCB3ZSBuZWVkXG4gICAgICAgICAgICAvLyBhbiBhbGlhcyAodXNpbmcgYW4gYXJyb3cgZnVuY3Rpb24gd2FzIHdoYXQgY2F1c2VkIDI2NTEpLlxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby10aGlzLWFsaWFzXG4gICAgICAgICAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gT0soZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWRBcmdzID0gbWUuX2RlZi5hcmdzLnNhZmVQYXJzZShhcmdzLCBwYXJhbXMpO1xuICAgICAgICAgICAgICAgIGlmICghcGFyc2VkQXJncy5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBab2RFcnJvcihbbWFrZUFyZ3NJc3N1ZShhcmdzLCBwYXJzZWRBcmdzLmVycm9yKV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBSZWZsZWN0LmFwcGx5KGZuLCB0aGlzLCBwYXJzZWRBcmdzLmRhdGEpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZFJldHVybnMgPSBtZS5fZGVmLnJldHVybnMuc2FmZVBhcnNlKHJlc3VsdCwgcGFyYW1zKTtcbiAgICAgICAgICAgICAgICBpZiAoIXBhcnNlZFJldHVybnMuc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgWm9kRXJyb3IoW21ha2VSZXR1cm5zSXNzdWUocmVzdWx0LCBwYXJzZWRSZXR1cm5zLmVycm9yKV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VkUmV0dXJucy5kYXRhO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcGFyYW1ldGVycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5hcmdzO1xuICAgIH1cbiAgICByZXR1cm5UeXBlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnJldHVybnM7XG4gICAgfVxuICAgIGFyZ3MoLi4uaXRlbXMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RGdW5jdGlvbih7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBhcmdzOiBab2RUdXBsZS5jcmVhdGUoaXRlbXMpLnJlc3QoWm9kVW5rbm93bi5jcmVhdGUoKSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm5zKHJldHVyblR5cGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RGdW5jdGlvbih7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICByZXR1cm5zOiByZXR1cm5UeXBlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaW1wbGVtZW50KGZ1bmMpIHtcbiAgICAgICAgY29uc3QgdmFsaWRhdGVkRnVuYyA9IHRoaXMucGFyc2UoZnVuYyk7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZWRGdW5jO1xuICAgIH1cbiAgICBzdHJpY3RJbXBsZW1lbnQoZnVuYykge1xuICAgICAgICBjb25zdCB2YWxpZGF0ZWRGdW5jID0gdGhpcy5wYXJzZShmdW5jKTtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlZEZ1bmM7XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGUoYXJncywgcmV0dXJucywgcGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kRnVuY3Rpb24oe1xuICAgICAgICAgICAgYXJnczogKGFyZ3NcbiAgICAgICAgICAgICAgICA/IGFyZ3NcbiAgICAgICAgICAgICAgICA6IFpvZFR1cGxlLmNyZWF0ZShbXSkucmVzdChab2RVbmtub3duLmNyZWF0ZSgpKSksXG4gICAgICAgICAgICByZXR1cm5zOiByZXR1cm5zIHx8IFpvZFVua25vd24uY3JlYXRlKCksXG4gICAgICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEZ1bmN0aW9uLFxuICAgICAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgICAgICB9KTtcbiAgICB9XG59XG5jbGFzcyBab2RMYXp5IGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgZ2V0IHNjaGVtYSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5nZXR0ZXIoKTtcbiAgICB9XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBjb25zdCBsYXp5U2NoZW1hID0gdGhpcy5fZGVmLmdldHRlcigpO1xuICAgICAgICByZXR1cm4gbGF6eVNjaGVtYS5fcGFyc2UoeyBkYXRhOiBjdHguZGF0YSwgcGF0aDogY3R4LnBhdGgsIHBhcmVudDogY3R4IH0pO1xuICAgIH1cbn1cblpvZExhenkuY3JlYXRlID0gKGdldHRlciwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RMYXp5KHtcbiAgICAgICAgZ2V0dGVyOiBnZXR0ZXIsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kTGF6eSxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNsYXNzIFpvZExpdGVyYWwgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgaWYgKGlucHV0LmRhdGEgIT09IHRoaXMuX2RlZi52YWx1ZSkge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX2xpdGVyYWwsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IHRoaXMuX2RlZi52YWx1ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBcInZhbGlkXCIsIHZhbHVlOiBpbnB1dC5kYXRhIH07XG4gICAgfVxuICAgIGdldCB2YWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi52YWx1ZTtcbiAgICB9XG59XG5ab2RMaXRlcmFsLmNyZWF0ZSA9ICh2YWx1ZSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RMaXRlcmFsKHtcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZExpdGVyYWwsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5mdW5jdGlvbiBjcmVhdGVab2RFbnVtKHZhbHVlcywgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBab2RFbnVtKHtcbiAgICAgICAgdmFsdWVzLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEVudW0sXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbmNsYXNzIFpvZEVudW0gZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dC5kYXRhICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgICAgICBjb25zdCBleHBlY3RlZFZhbHVlcyA9IHRoaXMuX2RlZi52YWx1ZXM7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogdXRpbC5qb2luVmFsdWVzKGV4cGVjdGVkVmFsdWVzKSxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2RlZi52YWx1ZXMuaW5kZXhPZihpbnB1dC5kYXRhKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgIGNvbnN0IGV4cGVjdGVkVmFsdWVzID0gdGhpcy5fZGVmLnZhbHVlcztcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9lbnVtX3ZhbHVlLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGV4cGVjdGVkVmFsdWVzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT0soaW5wdXQuZGF0YSk7XG4gICAgfVxuICAgIGdldCBvcHRpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnZhbHVlcztcbiAgICB9XG4gICAgZ2V0IGVudW0oKSB7XG4gICAgICAgIGNvbnN0IGVudW1WYWx1ZXMgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCB2YWwgb2YgdGhpcy5fZGVmLnZhbHVlcykge1xuICAgICAgICAgICAgZW51bVZhbHVlc1t2YWxdID0gdmFsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbnVtVmFsdWVzO1xuICAgIH1cbiAgICBnZXQgVmFsdWVzKCkge1xuICAgICAgICBjb25zdCBlbnVtVmFsdWVzID0ge307XG4gICAgICAgIGZvciAoY29uc3QgdmFsIG9mIHRoaXMuX2RlZi52YWx1ZXMpIHtcbiAgICAgICAgICAgIGVudW1WYWx1ZXNbdmFsXSA9IHZhbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZW51bVZhbHVlcztcbiAgICB9XG4gICAgZ2V0IEVudW0oKSB7XG4gICAgICAgIGNvbnN0IGVudW1WYWx1ZXMgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCB2YWwgb2YgdGhpcy5fZGVmLnZhbHVlcykge1xuICAgICAgICAgICAgZW51bVZhbHVlc1t2YWxdID0gdmFsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbnVtVmFsdWVzO1xuICAgIH1cbiAgICBleHRyYWN0KHZhbHVlcykge1xuICAgICAgICByZXR1cm4gWm9kRW51bS5jcmVhdGUodmFsdWVzKTtcbiAgICB9XG4gICAgZXhjbHVkZSh2YWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIFpvZEVudW0uY3JlYXRlKHRoaXMub3B0aW9ucy5maWx0ZXIoKG9wdCkgPT4gIXZhbHVlcy5pbmNsdWRlcyhvcHQpKSk7XG4gICAgfVxufVxuWm9kRW51bS5jcmVhdGUgPSBjcmVhdGVab2RFbnVtO1xuY2xhc3MgWm9kTmF0aXZlRW51bSBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCBuYXRpdmVFbnVtVmFsdWVzID0gdXRpbC5nZXRWYWxpZEVudW1WYWx1ZXModGhpcy5fZGVmLnZhbHVlcyk7XG4gICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgaWYgKGN0eC5wYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLnN0cmluZyAmJlxuICAgICAgICAgICAgY3R4LnBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUubnVtYmVyKSB7XG4gICAgICAgICAgICBjb25zdCBleHBlY3RlZFZhbHVlcyA9IHV0aWwub2JqZWN0VmFsdWVzKG5hdGl2ZUVudW1WYWx1ZXMpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IHV0aWwuam9pblZhbHVlcyhleHBlY3RlZFZhbHVlcyksXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuYXRpdmVFbnVtVmFsdWVzLmluZGV4T2YoaW5wdXQuZGF0YSkgPT09IC0xKSB7XG4gICAgICAgICAgICBjb25zdCBleHBlY3RlZFZhbHVlcyA9IHV0aWwub2JqZWN0VmFsdWVzKG5hdGl2ZUVudW1WYWx1ZXMpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX2VudW1fdmFsdWUsXG4gICAgICAgICAgICAgICAgb3B0aW9uczogZXhwZWN0ZWRWYWx1ZXMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPSyhpbnB1dC5kYXRhKTtcbiAgICB9XG4gICAgZ2V0IGVudW0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYudmFsdWVzO1xuICAgIH1cbn1cblpvZE5hdGl2ZUVudW0uY3JlYXRlID0gKHZhbHVlcywgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2ROYXRpdmVFbnVtKHtcbiAgICAgICAgdmFsdWVzOiB2YWx1ZXMsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kTmF0aXZlRW51bSxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNsYXNzIFpvZFByb21pc2UgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICB1bndyYXAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYudHlwZTtcbiAgICB9XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBpZiAoY3R4LnBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUucHJvbWlzZSAmJlxuICAgICAgICAgICAgY3R4LmNvbW1vbi5hc3luYyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUucHJvbWlzZSxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByb21pc2lmaWVkID0gY3R4LnBhcnNlZFR5cGUgPT09IFpvZFBhcnNlZFR5cGUucHJvbWlzZVxuICAgICAgICAgICAgPyBjdHguZGF0YVxuICAgICAgICAgICAgOiBQcm9taXNlLnJlc29sdmUoY3R4LmRhdGEpO1xuICAgICAgICByZXR1cm4gT0socHJvbWlzaWZpZWQudGhlbigoZGF0YSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi50eXBlLnBhcnNlQXN5bmMoZGF0YSwge1xuICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgIGVycm9yTWFwOiBjdHguY29tbW9uLmNvbnRleHR1YWxFcnJvck1hcCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KSk7XG4gICAgfVxufVxuWm9kUHJvbWlzZS5jcmVhdGUgPSAoc2NoZW1hLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZFByb21pc2Uoe1xuICAgICAgICB0eXBlOiBzY2hlbWEsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kUHJvbWlzZSxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNsYXNzIFpvZEVmZmVjdHMgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBpbm5lclR5cGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuc2NoZW1hO1xuICAgIH1cbiAgICBzb3VyY2VUeXBlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnNjaGVtYS5fZGVmLnR5cGVOYW1lID09PSBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kRWZmZWN0c1xuICAgICAgICAgICAgPyB0aGlzLl9kZWYuc2NoZW1hLnNvdXJjZVR5cGUoKVxuICAgICAgICAgICAgOiB0aGlzLl9kZWYuc2NoZW1hO1xuICAgIH1cbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgeyBzdGF0dXMsIGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgY29uc3QgZWZmZWN0ID0gdGhpcy5fZGVmLmVmZmVjdCB8fCBudWxsO1xuICAgICAgICBjb25zdCBjaGVja0N0eCA9IHtcbiAgICAgICAgICAgIGFkZElzc3VlOiAoYXJnKSA9PiB7XG4gICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCBhcmcpO1xuICAgICAgICAgICAgICAgIGlmIChhcmcuZmF0YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmFib3J0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0IHBhdGgoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGN0eC5wYXRoO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgY2hlY2tDdHguYWRkSXNzdWUgPSBjaGVja0N0eC5hZGRJc3N1ZS5iaW5kKGNoZWNrQ3R4KTtcbiAgICAgICAgaWYgKGVmZmVjdC50eXBlID09PSBcInByZXByb2Nlc3NcIikge1xuICAgICAgICAgICAgY29uc3QgcHJvY2Vzc2VkID0gZWZmZWN0LnRyYW5zZm9ybShjdHguZGF0YSwgY2hlY2tDdHgpO1xuICAgICAgICAgICAgaWYgKGN0eC5jb21tb24uaXNzdWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1czogXCJkaXJ0eVwiLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogY3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShwcm9jZXNzZWQpLnRoZW4oKHByb2Nlc3NlZCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnNjaGVtYS5fcGFyc2VBc3luYyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBwcm9jZXNzZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZWYuc2NoZW1hLl9wYXJzZVN5bmMoe1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiBwcm9jZXNzZWQsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZWZmZWN0LnR5cGUgPT09IFwicmVmaW5lbWVudFwiKSB7XG4gICAgICAgICAgICBjb25zdCBleGVjdXRlUmVmaW5lbWVudCA9IChhY2NcbiAgICAgICAgICAgIC8vIGVmZmVjdDogUmVmaW5lbWVudEVmZmVjdDxhbnk+XG4gICAgICAgICAgICApID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBlZmZlY3QucmVmaW5lbWVudChhY2MsIGNoZWNrQ3R4KTtcbiAgICAgICAgICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFzeW5jIHJlZmluZW1lbnQgZW5jb3VudGVyZWQgZHVyaW5nIHN5bmNocm9ub3VzIHBhcnNlIG9wZXJhdGlvbi4gVXNlIC5wYXJzZUFzeW5jIGluc3RlYWQuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlubmVyID0gdGhpcy5fZGVmLnNjaGVtYS5fcGFyc2VTeW5jKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoaW5uZXIuc3RhdHVzID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgICAgICAgaWYgKGlubmVyLnN0YXR1cyA9PT0gXCJkaXJ0eVwiKVxuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICAvLyByZXR1cm4gdmFsdWUgaXMgaWdub3JlZFxuICAgICAgICAgICAgICAgIGV4ZWN1dGVSZWZpbmVtZW50KGlubmVyLnZhbHVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IGlubmVyLnZhbHVlIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnNjaGVtYVxuICAgICAgICAgICAgICAgICAgICAuX3BhcnNlQXN5bmMoeyBkYXRhOiBjdHguZGF0YSwgcGF0aDogY3R4LnBhdGgsIHBhcmVudDogY3R4IH0pXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKChpbm5lcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5uZXIuc3RhdHVzID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5uZXIuc3RhdHVzID09PSBcImRpcnR5XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV4ZWN1dGVSZWZpbmVtZW50KGlubmVyLnZhbHVlKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogaW5uZXIudmFsdWUgfTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVmZmVjdC50eXBlID09PSBcInRyYW5zZm9ybVwiKSB7XG4gICAgICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBiYXNlID0gdGhpcy5fZGVmLnNjaGVtYS5fcGFyc2VTeW5jKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzVmFsaWQoYmFzZSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBiYXNlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGVmZmVjdC50cmFuc2Zvcm0oYmFzZS52YWx1ZSwgY2hlY2tDdHgpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQXN5bmNocm9ub3VzIHRyYW5zZm9ybSBlbmNvdW50ZXJlZCBkdXJpbmcgc3luY2hyb25vdXMgcGFyc2Ugb3BlcmF0aW9uLiBVc2UgLnBhcnNlQXN5bmMgaW5zdGVhZC5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiByZXN1bHQgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZWYuc2NoZW1hXG4gICAgICAgICAgICAgICAgICAgIC5fcGFyc2VBc3luYyh7IGRhdGE6IGN0eC5kYXRhLCBwYXRoOiBjdHgucGF0aCwgcGFyZW50OiBjdHggfSlcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oKGJhc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1ZhbGlkKGJhc2UpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJhc2U7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZWZmZWN0LnRyYW5zZm9ybShiYXNlLnZhbHVlLCBjaGVja0N0eCkpLnRoZW4oKHJlc3VsdCkgPT4gKHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiByZXN1bHQgfSkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHV0aWwuYXNzZXJ0TmV2ZXIoZWZmZWN0KTtcbiAgICB9XG59XG5ab2RFZmZlY3RzLmNyZWF0ZSA9IChzY2hlbWEsIGVmZmVjdCwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RFZmZlY3RzKHtcbiAgICAgICAgc2NoZW1hLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEVmZmVjdHMsXG4gICAgICAgIGVmZmVjdCxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcblpvZEVmZmVjdHMuY3JlYXRlV2l0aFByZXByb2Nlc3MgPSAocHJlcHJvY2Vzcywgc2NoZW1hLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZEVmZmVjdHMoe1xuICAgICAgICBzY2hlbWEsXG4gICAgICAgIGVmZmVjdDogeyB0eXBlOiBcInByZXByb2Nlc3NcIiwgdHJhbnNmb3JtOiBwcmVwcm9jZXNzIH0sXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kRWZmZWN0cyxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNsYXNzIFpvZE9wdGlvbmFsIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICAgICAgaWYgKHBhcnNlZFR5cGUgPT09IFpvZFBhcnNlZFR5cGUudW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gT0sodW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLmlubmVyVHlwZS5fcGFyc2UoaW5wdXQpO1xuICAgIH1cbiAgICB1bndyYXAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuaW5uZXJUeXBlO1xuICAgIH1cbn1cblpvZE9wdGlvbmFsLmNyZWF0ZSA9ICh0eXBlLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZE9wdGlvbmFsKHtcbiAgICAgICAgaW5uZXJUeXBlOiB0eXBlLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE9wdGlvbmFsLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY2xhc3MgWm9kTnVsbGFibGUgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgICAgICBpZiAocGFyc2VkVHlwZSA9PT0gWm9kUGFyc2VkVHlwZS5udWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gT0sobnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5pbm5lclR5cGUuX3BhcnNlKGlucHV0KTtcbiAgICB9XG4gICAgdW53cmFwKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLmlubmVyVHlwZTtcbiAgICB9XG59XG5ab2ROdWxsYWJsZS5jcmVhdGUgPSAodHlwZSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2ROdWxsYWJsZSh7XG4gICAgICAgIGlubmVyVHlwZTogdHlwZSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2ROdWxsYWJsZSxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNsYXNzIFpvZERlZmF1bHQgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgeyBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGxldCBkYXRhID0gY3R4LmRhdGE7XG4gICAgICAgIGlmIChjdHgucGFyc2VkVHlwZSA9PT0gWm9kUGFyc2VkVHlwZS51bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGRhdGEgPSB0aGlzLl9kZWYuZGVmYXVsdFZhbHVlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5pbm5lclR5cGUuX3BhcnNlKHtcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVtb3ZlRGVmYXVsdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5pbm5lclR5cGU7XG4gICAgfVxufVxuWm9kRGVmYXVsdC5jcmVhdGUgPSAodHlwZSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2REZWZhdWx0KHtcbiAgICAgICAgaW5uZXJUeXBlOiB0eXBlLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZERlZmF1bHQsXG4gICAgICAgIGRlZmF1bHRWYWx1ZTogdHlwZW9mIHBhcmFtcy5kZWZhdWx0ID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICAgID8gcGFyYW1zLmRlZmF1bHRcbiAgICAgICAgICAgIDogKCkgPT4gcGFyYW1zLmRlZmF1bHQsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5jbGFzcyBab2RDYXRjaCBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgLy8gbmV3Q3R4IGlzIHVzZWQgdG8gbm90IGNvbGxlY3QgaXNzdWVzIGZyb20gaW5uZXIgdHlwZXMgaW4gY3R4XG4gICAgICAgIGNvbnN0IG5ld0N0eCA9IHtcbiAgICAgICAgICAgIC4uLmN0eCxcbiAgICAgICAgICAgIGNvbW1vbjoge1xuICAgICAgICAgICAgICAgIC4uLmN0eC5jb21tb24sXG4gICAgICAgICAgICAgICAgaXNzdWVzOiBbXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX2RlZi5pbm5lclR5cGUuX3BhcnNlKHtcbiAgICAgICAgICAgIGRhdGE6IG5ld0N0eC5kYXRhLFxuICAgICAgICAgICAgcGF0aDogbmV3Q3R4LnBhdGgsXG4gICAgICAgICAgICBwYXJlbnQ6IHtcbiAgICAgICAgICAgICAgICAuLi5uZXdDdHgsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGlzQXN5bmMocmVzdWx0KSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IFwidmFsaWRcIixcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHJlc3VsdC5zdGF0dXMgPT09IFwidmFsaWRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgPyByZXN1bHQudmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdGhpcy5fZGVmLmNhdGNoVmFsdWUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldCBlcnJvcigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBab2RFcnJvcihuZXdDdHguY29tbW9uLmlzc3Vlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dDogbmV3Q3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN0YXR1czogXCJ2YWxpZFwiLFxuICAgICAgICAgICAgICAgIHZhbHVlOiByZXN1bHQuc3RhdHVzID09PSBcInZhbGlkXCJcbiAgICAgICAgICAgICAgICAgICAgPyByZXN1bHQudmFsdWVcbiAgICAgICAgICAgICAgICAgICAgOiB0aGlzLl9kZWYuY2F0Y2hWYWx1ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXQgZXJyb3IoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBab2RFcnJvcihuZXdDdHguY29tbW9uLmlzc3Vlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQ6IG5ld0N0eC5kYXRhLFxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVtb3ZlQ2F0Y2goKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuaW5uZXJUeXBlO1xuICAgIH1cbn1cblpvZENhdGNoLmNyZWF0ZSA9ICh0eXBlLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZENhdGNoKHtcbiAgICAgICAgaW5uZXJUeXBlOiB0eXBlLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZENhdGNoLFxuICAgICAgICBjYXRjaFZhbHVlOiB0eXBlb2YgcGFyYW1zLmNhdGNoID09PSBcImZ1bmN0aW9uXCIgPyBwYXJhbXMuY2F0Y2ggOiAoKSA9PiBwYXJhbXMuY2F0Y2gsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5jbGFzcyBab2ROYU4gZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgICAgICBpZiAocGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5uYW4pIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUubmFuLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBcInZhbGlkXCIsIHZhbHVlOiBpbnB1dC5kYXRhIH07XG4gICAgfVxufVxuWm9kTmFOLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZE5hTih7XG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kTmFOLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuY29uc3QgQlJBTkQgPSBTeW1ib2woXCJ6b2RfYnJhbmRcIik7XG5jbGFzcyBab2RCcmFuZGVkIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBjb25zdCBkYXRhID0gY3R4LmRhdGE7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYudHlwZS5fcGFyc2Uoe1xuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgcGFyZW50OiBjdHgsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB1bndyYXAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYudHlwZTtcbiAgICB9XG59XG5jbGFzcyBab2RQaXBlbGluZSBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IHN0YXR1cywgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlQXN5bmMgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5SZXN1bHQgPSBhd2FpdCB0aGlzLl9kZWYuaW4uX3BhcnNlQXN5bmMoe1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChpblJlc3VsdC5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAgICAgICBpZiAoaW5SZXN1bHQuc3RhdHVzID09PSBcImRpcnR5XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBESVJUWShpblJlc3VsdC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVmLm91dC5fcGFyc2VBc3luYyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBpblJlc3VsdC52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBjdHgsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlQXN5bmMoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGluUmVzdWx0ID0gdGhpcy5fZGVmLmluLl9wYXJzZVN5bmMoe1xuICAgICAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoaW5SZXN1bHQuc3RhdHVzID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAgIGlmIChpblJlc3VsdC5zdGF0dXMgPT09IFwiZGlydHlcIikge1xuICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1czogXCJkaXJ0eVwiLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogaW5SZXN1bHQudmFsdWUsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZWYub3V0Ll9wYXJzZVN5bmMoe1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiBpblJlc3VsdC52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGUoYSwgYikge1xuICAgICAgICByZXR1cm4gbmV3IFpvZFBpcGVsaW5lKHtcbiAgICAgICAgICAgIGluOiBhLFxuICAgICAgICAgICAgb3V0OiBiLFxuICAgICAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RQaXBlbGluZSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuY2xhc3MgWm9kUmVhZG9ubHkgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fZGVmLmlubmVyVHlwZS5fcGFyc2UoaW5wdXQpO1xuICAgICAgICBpZiAoaXNWYWxpZChyZXN1bHQpKSB7XG4gICAgICAgICAgICByZXN1bHQudmFsdWUgPSBPYmplY3QuZnJlZXplKHJlc3VsdC52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG5ab2RSZWFkb25seS5jcmVhdGUgPSAodHlwZSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RSZWFkb25seSh7XG4gICAgICAgIGlubmVyVHlwZTogdHlwZSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RSZWFkb25seSxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmNvbnN0IGN1c3RvbSA9IChjaGVjaywgcGFyYW1zID0ge30sIFxuLyoqXG4gKiBAZGVwcmVjYXRlZFxuICpcbiAqIFBhc3MgYGZhdGFsYCBpbnRvIHRoZSBwYXJhbXMgb2JqZWN0IGluc3RlYWQ6XG4gKlxuICogYGBgdHNcbiAqIHouc3RyaW5nKCkuY3VzdG9tKCh2YWwpID0+IHZhbC5sZW5ndGggPiA1LCB7IGZhdGFsOiBmYWxzZSB9KVxuICogYGBgXG4gKlxuICovXG5mYXRhbCkgPT4ge1xuICAgIGlmIChjaGVjaylcbiAgICAgICAgcmV0dXJuIFpvZEFueS5jcmVhdGUoKS5zdXBlclJlZmluZSgoZGF0YSwgY3R4KSA9PiB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgaWYgKCFjaGVjayhkYXRhKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHAgPSB0eXBlb2YgcGFyYW1zID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICAgICAgICAgICAgPyBwYXJhbXMoZGF0YSlcbiAgICAgICAgICAgICAgICAgICAgOiB0eXBlb2YgcGFyYW1zID09PSBcInN0cmluZ1wiXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHsgbWVzc2FnZTogcGFyYW1zIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIDogcGFyYW1zO1xuICAgICAgICAgICAgICAgIGNvbnN0IF9mYXRhbCA9IChfYiA9IChfYSA9IHAuZmF0YWwpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZhdGFsKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHAyID0gdHlwZW9mIHAgPT09IFwic3RyaW5nXCIgPyB7IG1lc3NhZ2U6IHAgfSA6IHA7XG4gICAgICAgICAgICAgICAgY3R4LmFkZElzc3VlKHsgY29kZTogXCJjdXN0b21cIiwgLi4ucDIsIGZhdGFsOiBfZmF0YWwgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIHJldHVybiBab2RBbnkuY3JlYXRlKCk7XG59O1xuY29uc3QgbGF0ZSA9IHtcbiAgICBvYmplY3Q6IFpvZE9iamVjdC5sYXp5Y3JlYXRlLFxufTtcbnZhciBab2RGaXJzdFBhcnR5VHlwZUtpbmQ7XG4oZnVuY3Rpb24gKFpvZEZpcnN0UGFydHlUeXBlS2luZCkge1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZFN0cmluZ1wiXSA9IFwiWm9kU3RyaW5nXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kTnVtYmVyXCJdID0gXCJab2ROdW1iZXJcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2ROYU5cIl0gPSBcIlpvZE5hTlwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZEJpZ0ludFwiXSA9IFwiWm9kQmlnSW50XCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kQm9vbGVhblwiXSA9IFwiWm9kQm9vbGVhblwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZERhdGVcIl0gPSBcIlpvZERhdGVcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RTeW1ib2xcIl0gPSBcIlpvZFN5bWJvbFwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZFVuZGVmaW5lZFwiXSA9IFwiWm9kVW5kZWZpbmVkXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kTnVsbFwiXSA9IFwiWm9kTnVsbFwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZEFueVwiXSA9IFwiWm9kQW55XCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kVW5rbm93blwiXSA9IFwiWm9kVW5rbm93blwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZE5ldmVyXCJdID0gXCJab2ROZXZlclwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZFZvaWRcIl0gPSBcIlpvZFZvaWRcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RBcnJheVwiXSA9IFwiWm9kQXJyYXlcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RPYmplY3RcIl0gPSBcIlpvZE9iamVjdFwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZFVuaW9uXCJdID0gXCJab2RVbmlvblwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZERpc2NyaW1pbmF0ZWRVbmlvblwiXSA9IFwiWm9kRGlzY3JpbWluYXRlZFVuaW9uXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kSW50ZXJzZWN0aW9uXCJdID0gXCJab2RJbnRlcnNlY3Rpb25cIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RUdXBsZVwiXSA9IFwiWm9kVHVwbGVcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RSZWNvcmRcIl0gPSBcIlpvZFJlY29yZFwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZE1hcFwiXSA9IFwiWm9kTWFwXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kU2V0XCJdID0gXCJab2RTZXRcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RGdW5jdGlvblwiXSA9IFwiWm9kRnVuY3Rpb25cIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RMYXp5XCJdID0gXCJab2RMYXp5XCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kTGl0ZXJhbFwiXSA9IFwiWm9kTGl0ZXJhbFwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZEVudW1cIl0gPSBcIlpvZEVudW1cIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RFZmZlY3RzXCJdID0gXCJab2RFZmZlY3RzXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kTmF0aXZlRW51bVwiXSA9IFwiWm9kTmF0aXZlRW51bVwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZE9wdGlvbmFsXCJdID0gXCJab2RPcHRpb25hbFwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZE51bGxhYmxlXCJdID0gXCJab2ROdWxsYWJsZVwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZERlZmF1bHRcIl0gPSBcIlpvZERlZmF1bHRcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RDYXRjaFwiXSA9IFwiWm9kQ2F0Y2hcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RQcm9taXNlXCJdID0gXCJab2RQcm9taXNlXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kQnJhbmRlZFwiXSA9IFwiWm9kQnJhbmRlZFwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZFBpcGVsaW5lXCJdID0gXCJab2RQaXBlbGluZVwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZFJlYWRvbmx5XCJdID0gXCJab2RSZWFkb25seVwiO1xufSkoWm9kRmlyc3RQYXJ0eVR5cGVLaW5kIHx8IChab2RGaXJzdFBhcnR5VHlwZUtpbmQgPSB7fSkpO1xuY29uc3QgaW5zdGFuY2VPZlR5cGUgPSAoXG4vLyBjb25zdCBpbnN0YW5jZU9mVHlwZSA9IDxUIGV4dGVuZHMgbmV3ICguLi5hcmdzOiBhbnlbXSkgPT4gYW55PihcbmNscywgcGFyYW1zID0ge1xuICAgIG1lc3NhZ2U6IGBJbnB1dCBub3QgaW5zdGFuY2Ugb2YgJHtjbHMubmFtZX1gLFxufSkgPT4gY3VzdG9tKChkYXRhKSA9PiBkYXRhIGluc3RhbmNlb2YgY2xzLCBwYXJhbXMpO1xuY29uc3Qgc3RyaW5nVHlwZSA9IFpvZFN0cmluZy5jcmVhdGU7XG5jb25zdCBudW1iZXJUeXBlID0gWm9kTnVtYmVyLmNyZWF0ZTtcbmNvbnN0IG5hblR5cGUgPSBab2ROYU4uY3JlYXRlO1xuY29uc3QgYmlnSW50VHlwZSA9IFpvZEJpZ0ludC5jcmVhdGU7XG5jb25zdCBib29sZWFuVHlwZSA9IFpvZEJvb2xlYW4uY3JlYXRlO1xuY29uc3QgZGF0ZVR5cGUgPSBab2REYXRlLmNyZWF0ZTtcbmNvbnN0IHN5bWJvbFR5cGUgPSBab2RTeW1ib2wuY3JlYXRlO1xuY29uc3QgdW5kZWZpbmVkVHlwZSA9IFpvZFVuZGVmaW5lZC5jcmVhdGU7XG5jb25zdCBudWxsVHlwZSA9IFpvZE51bGwuY3JlYXRlO1xuY29uc3QgYW55VHlwZSA9IFpvZEFueS5jcmVhdGU7XG5jb25zdCB1bmtub3duVHlwZSA9IFpvZFVua25vd24uY3JlYXRlO1xuY29uc3QgbmV2ZXJUeXBlID0gWm9kTmV2ZXIuY3JlYXRlO1xuY29uc3Qgdm9pZFR5cGUgPSBab2RWb2lkLmNyZWF0ZTtcbmNvbnN0IGFycmF5VHlwZSA9IFpvZEFycmF5LmNyZWF0ZTtcbmNvbnN0IG9iamVjdFR5cGUgPSBab2RPYmplY3QuY3JlYXRlO1xuY29uc3Qgc3RyaWN0T2JqZWN0VHlwZSA9IFpvZE9iamVjdC5zdHJpY3RDcmVhdGU7XG5jb25zdCB1bmlvblR5cGUgPSBab2RVbmlvbi5jcmVhdGU7XG5jb25zdCBkaXNjcmltaW5hdGVkVW5pb25UeXBlID0gWm9kRGlzY3JpbWluYXRlZFVuaW9uLmNyZWF0ZTtcbmNvbnN0IGludGVyc2VjdGlvblR5cGUgPSBab2RJbnRlcnNlY3Rpb24uY3JlYXRlO1xuY29uc3QgdHVwbGVUeXBlID0gWm9kVHVwbGUuY3JlYXRlO1xuY29uc3QgcmVjb3JkVHlwZSA9IFpvZFJlY29yZC5jcmVhdGU7XG5jb25zdCBtYXBUeXBlID0gWm9kTWFwLmNyZWF0ZTtcbmNvbnN0IHNldFR5cGUgPSBab2RTZXQuY3JlYXRlO1xuY29uc3QgZnVuY3Rpb25UeXBlID0gWm9kRnVuY3Rpb24uY3JlYXRlO1xuY29uc3QgbGF6eVR5cGUgPSBab2RMYXp5LmNyZWF0ZTtcbmNvbnN0IGxpdGVyYWxUeXBlID0gWm9kTGl0ZXJhbC5jcmVhdGU7XG5jb25zdCBlbnVtVHlwZSA9IFpvZEVudW0uY3JlYXRlO1xuY29uc3QgbmF0aXZlRW51bVR5cGUgPSBab2ROYXRpdmVFbnVtLmNyZWF0ZTtcbmNvbnN0IHByb21pc2VUeXBlID0gWm9kUHJvbWlzZS5jcmVhdGU7XG5jb25zdCBlZmZlY3RzVHlwZSA9IFpvZEVmZmVjdHMuY3JlYXRlO1xuY29uc3Qgb3B0aW9uYWxUeXBlID0gWm9kT3B0aW9uYWwuY3JlYXRlO1xuY29uc3QgbnVsbGFibGVUeXBlID0gWm9kTnVsbGFibGUuY3JlYXRlO1xuY29uc3QgcHJlcHJvY2Vzc1R5cGUgPSBab2RFZmZlY3RzLmNyZWF0ZVdpdGhQcmVwcm9jZXNzO1xuY29uc3QgcGlwZWxpbmVUeXBlID0gWm9kUGlwZWxpbmUuY3JlYXRlO1xuY29uc3Qgb3N0cmluZyA9ICgpID0+IHN0cmluZ1R5cGUoKS5vcHRpb25hbCgpO1xuY29uc3Qgb251bWJlciA9ICgpID0+IG51bWJlclR5cGUoKS5vcHRpb25hbCgpO1xuY29uc3Qgb2Jvb2xlYW4gPSAoKSA9PiBib29sZWFuVHlwZSgpLm9wdGlvbmFsKCk7XG5jb25zdCBjb2VyY2UgPSB7XG4gICAgc3RyaW5nOiAoKGFyZykgPT4gWm9kU3RyaW5nLmNyZWF0ZSh7IC4uLmFyZywgY29lcmNlOiB0cnVlIH0pKSxcbiAgICBudW1iZXI6ICgoYXJnKSA9PiBab2ROdW1iZXIuY3JlYXRlKHsgLi4uYXJnLCBjb2VyY2U6IHRydWUgfSkpLFxuICAgIGJvb2xlYW46ICgoYXJnKSA9PiBab2RCb29sZWFuLmNyZWF0ZSh7XG4gICAgICAgIC4uLmFyZyxcbiAgICAgICAgY29lcmNlOiB0cnVlLFxuICAgIH0pKSxcbiAgICBiaWdpbnQ6ICgoYXJnKSA9PiBab2RCaWdJbnQuY3JlYXRlKHsgLi4uYXJnLCBjb2VyY2U6IHRydWUgfSkpLFxuICAgIGRhdGU6ICgoYXJnKSA9PiBab2REYXRlLmNyZWF0ZSh7IC4uLmFyZywgY29lcmNlOiB0cnVlIH0pKSxcbn07XG5jb25zdCBORVZFUiA9IElOVkFMSUQ7XG5cbnZhciB6ID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBkZWZhdWx0RXJyb3JNYXA6IGVycm9yTWFwLFxuICAgIHNldEVycm9yTWFwOiBzZXRFcnJvck1hcCxcbiAgICBnZXRFcnJvck1hcDogZ2V0RXJyb3JNYXAsXG4gICAgbWFrZUlzc3VlOiBtYWtlSXNzdWUsXG4gICAgRU1QVFlfUEFUSDogRU1QVFlfUEFUSCxcbiAgICBhZGRJc3N1ZVRvQ29udGV4dDogYWRkSXNzdWVUb0NvbnRleHQsXG4gICAgUGFyc2VTdGF0dXM6IFBhcnNlU3RhdHVzLFxuICAgIElOVkFMSUQ6IElOVkFMSUQsXG4gICAgRElSVFk6IERJUlRZLFxuICAgIE9LOiBPSyxcbiAgICBpc0Fib3J0ZWQ6IGlzQWJvcnRlZCxcbiAgICBpc0RpcnR5OiBpc0RpcnR5LFxuICAgIGlzVmFsaWQ6IGlzVmFsaWQsXG4gICAgaXNBc3luYzogaXNBc3luYyxcbiAgICBnZXQgdXRpbCAoKSB7IHJldHVybiB1dGlsOyB9LFxuICAgIGdldCBvYmplY3RVdGlsICgpIHsgcmV0dXJuIG9iamVjdFV0aWw7IH0sXG4gICAgWm9kUGFyc2VkVHlwZTogWm9kUGFyc2VkVHlwZSxcbiAgICBnZXRQYXJzZWRUeXBlOiBnZXRQYXJzZWRUeXBlLFxuICAgIFpvZFR5cGU6IFpvZFR5cGUsXG4gICAgWm9kU3RyaW5nOiBab2RTdHJpbmcsXG4gICAgWm9kTnVtYmVyOiBab2ROdW1iZXIsXG4gICAgWm9kQmlnSW50OiBab2RCaWdJbnQsXG4gICAgWm9kQm9vbGVhbjogWm9kQm9vbGVhbixcbiAgICBab2REYXRlOiBab2REYXRlLFxuICAgIFpvZFN5bWJvbDogWm9kU3ltYm9sLFxuICAgIFpvZFVuZGVmaW5lZDogWm9kVW5kZWZpbmVkLFxuICAgIFpvZE51bGw6IFpvZE51bGwsXG4gICAgWm9kQW55OiBab2RBbnksXG4gICAgWm9kVW5rbm93bjogWm9kVW5rbm93bixcbiAgICBab2ROZXZlcjogWm9kTmV2ZXIsXG4gICAgWm9kVm9pZDogWm9kVm9pZCxcbiAgICBab2RBcnJheTogWm9kQXJyYXksXG4gICAgWm9kT2JqZWN0OiBab2RPYmplY3QsXG4gICAgWm9kVW5pb246IFpvZFVuaW9uLFxuICAgIFpvZERpc2NyaW1pbmF0ZWRVbmlvbjogWm9kRGlzY3JpbWluYXRlZFVuaW9uLFxuICAgIFpvZEludGVyc2VjdGlvbjogWm9kSW50ZXJzZWN0aW9uLFxuICAgIFpvZFR1cGxlOiBab2RUdXBsZSxcbiAgICBab2RSZWNvcmQ6IFpvZFJlY29yZCxcbiAgICBab2RNYXA6IFpvZE1hcCxcbiAgICBab2RTZXQ6IFpvZFNldCxcbiAgICBab2RGdW5jdGlvbjogWm9kRnVuY3Rpb24sXG4gICAgWm9kTGF6eTogWm9kTGF6eSxcbiAgICBab2RMaXRlcmFsOiBab2RMaXRlcmFsLFxuICAgIFpvZEVudW06IFpvZEVudW0sXG4gICAgWm9kTmF0aXZlRW51bTogWm9kTmF0aXZlRW51bSxcbiAgICBab2RQcm9taXNlOiBab2RQcm9taXNlLFxuICAgIFpvZEVmZmVjdHM6IFpvZEVmZmVjdHMsXG4gICAgWm9kVHJhbnNmb3JtZXI6IFpvZEVmZmVjdHMsXG4gICAgWm9kT3B0aW9uYWw6IFpvZE9wdGlvbmFsLFxuICAgIFpvZE51bGxhYmxlOiBab2ROdWxsYWJsZSxcbiAgICBab2REZWZhdWx0OiBab2REZWZhdWx0LFxuICAgIFpvZENhdGNoOiBab2RDYXRjaCxcbiAgICBab2ROYU46IFpvZE5hTixcbiAgICBCUkFORDogQlJBTkQsXG4gICAgWm9kQnJhbmRlZDogWm9kQnJhbmRlZCxcbiAgICBab2RQaXBlbGluZTogWm9kUGlwZWxpbmUsXG4gICAgWm9kUmVhZG9ubHk6IFpvZFJlYWRvbmx5LFxuICAgIGN1c3RvbTogY3VzdG9tLFxuICAgIFNjaGVtYTogWm9kVHlwZSxcbiAgICBab2RTY2hlbWE6IFpvZFR5cGUsXG4gICAgbGF0ZTogbGF0ZSxcbiAgICBnZXQgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kICgpIHsgcmV0dXJuIFpvZEZpcnN0UGFydHlUeXBlS2luZDsgfSxcbiAgICBjb2VyY2U6IGNvZXJjZSxcbiAgICBhbnk6IGFueVR5cGUsXG4gICAgYXJyYXk6IGFycmF5VHlwZSxcbiAgICBiaWdpbnQ6IGJpZ0ludFR5cGUsXG4gICAgYm9vbGVhbjogYm9vbGVhblR5cGUsXG4gICAgZGF0ZTogZGF0ZVR5cGUsXG4gICAgZGlzY3JpbWluYXRlZFVuaW9uOiBkaXNjcmltaW5hdGVkVW5pb25UeXBlLFxuICAgIGVmZmVjdDogZWZmZWN0c1R5cGUsXG4gICAgJ2VudW0nOiBlbnVtVHlwZSxcbiAgICAnZnVuY3Rpb24nOiBmdW5jdGlvblR5cGUsXG4gICAgJ2luc3RhbmNlb2YnOiBpbnN0YW5jZU9mVHlwZSxcbiAgICBpbnRlcnNlY3Rpb246IGludGVyc2VjdGlvblR5cGUsXG4gICAgbGF6eTogbGF6eVR5cGUsXG4gICAgbGl0ZXJhbDogbGl0ZXJhbFR5cGUsXG4gICAgbWFwOiBtYXBUeXBlLFxuICAgIG5hbjogbmFuVHlwZSxcbiAgICBuYXRpdmVFbnVtOiBuYXRpdmVFbnVtVHlwZSxcbiAgICBuZXZlcjogbmV2ZXJUeXBlLFxuICAgICdudWxsJzogbnVsbFR5cGUsXG4gICAgbnVsbGFibGU6IG51bGxhYmxlVHlwZSxcbiAgICBudW1iZXI6IG51bWJlclR5cGUsXG4gICAgb2JqZWN0OiBvYmplY3RUeXBlLFxuICAgIG9ib29sZWFuOiBvYm9vbGVhbixcbiAgICBvbnVtYmVyOiBvbnVtYmVyLFxuICAgIG9wdGlvbmFsOiBvcHRpb25hbFR5cGUsXG4gICAgb3N0cmluZzogb3N0cmluZyxcbiAgICBwaXBlbGluZTogcGlwZWxpbmVUeXBlLFxuICAgIHByZXByb2Nlc3M6IHByZXByb2Nlc3NUeXBlLFxuICAgIHByb21pc2U6IHByb21pc2VUeXBlLFxuICAgIHJlY29yZDogcmVjb3JkVHlwZSxcbiAgICBzZXQ6IHNldFR5cGUsXG4gICAgc3RyaWN0T2JqZWN0OiBzdHJpY3RPYmplY3RUeXBlLFxuICAgIHN0cmluZzogc3RyaW5nVHlwZSxcbiAgICBzeW1ib2w6IHN5bWJvbFR5cGUsXG4gICAgdHJhbnNmb3JtZXI6IGVmZmVjdHNUeXBlLFxuICAgIHR1cGxlOiB0dXBsZVR5cGUsXG4gICAgJ3VuZGVmaW5lZCc6IHVuZGVmaW5lZFR5cGUsXG4gICAgdW5pb246IHVuaW9uVHlwZSxcbiAgICB1bmtub3duOiB1bmtub3duVHlwZSxcbiAgICAndm9pZCc6IHZvaWRUeXBlLFxuICAgIE5FVkVSOiBORVZFUixcbiAgICBab2RJc3N1ZUNvZGU6IFpvZElzc3VlQ29kZSxcbiAgICBxdW90ZWxlc3NKc29uOiBxdW90ZWxlc3NKc29uLFxuICAgIFpvZEVycm9yOiBab2RFcnJvclxufSk7XG5cbmV4cG9ydCB7IEJSQU5ELCBESVJUWSwgRU1QVFlfUEFUSCwgSU5WQUxJRCwgTkVWRVIsIE9LLCBQYXJzZVN0YXR1cywgWm9kVHlwZSBhcyBTY2hlbWEsIFpvZEFueSwgWm9kQXJyYXksIFpvZEJpZ0ludCwgWm9kQm9vbGVhbiwgWm9kQnJhbmRlZCwgWm9kQ2F0Y2gsIFpvZERhdGUsIFpvZERlZmF1bHQsIFpvZERpc2NyaW1pbmF0ZWRVbmlvbiwgWm9kRWZmZWN0cywgWm9kRW51bSwgWm9kRXJyb3IsIFpvZEZpcnN0UGFydHlUeXBlS2luZCwgWm9kRnVuY3Rpb24sIFpvZEludGVyc2VjdGlvbiwgWm9kSXNzdWVDb2RlLCBab2RMYXp5LCBab2RMaXRlcmFsLCBab2RNYXAsIFpvZE5hTiwgWm9kTmF0aXZlRW51bSwgWm9kTmV2ZXIsIFpvZE51bGwsIFpvZE51bGxhYmxlLCBab2ROdW1iZXIsIFpvZE9iamVjdCwgWm9kT3B0aW9uYWwsIFpvZFBhcnNlZFR5cGUsIFpvZFBpcGVsaW5lLCBab2RQcm9taXNlLCBab2RSZWFkb25seSwgWm9kUmVjb3JkLCBab2RUeXBlIGFzIFpvZFNjaGVtYSwgWm9kU2V0LCBab2RTdHJpbmcsIFpvZFN5bWJvbCwgWm9kRWZmZWN0cyBhcyBab2RUcmFuc2Zvcm1lciwgWm9kVHVwbGUsIFpvZFR5cGUsIFpvZFVuZGVmaW5lZCwgWm9kVW5pb24sIFpvZFVua25vd24sIFpvZFZvaWQsIGFkZElzc3VlVG9Db250ZXh0LCBhbnlUeXBlIGFzIGFueSwgYXJyYXlUeXBlIGFzIGFycmF5LCBiaWdJbnRUeXBlIGFzIGJpZ2ludCwgYm9vbGVhblR5cGUgYXMgYm9vbGVhbiwgY29lcmNlLCBjdXN0b20sIGRhdGVUeXBlIGFzIGRhdGUsIHogYXMgZGVmYXVsdCwgZXJyb3JNYXAgYXMgZGVmYXVsdEVycm9yTWFwLCBkaXNjcmltaW5hdGVkVW5pb25UeXBlIGFzIGRpc2NyaW1pbmF0ZWRVbmlvbiwgZWZmZWN0c1R5cGUgYXMgZWZmZWN0LCBlbnVtVHlwZSBhcyBlbnVtLCBmdW5jdGlvblR5cGUgYXMgZnVuY3Rpb24sIGdldEVycm9yTWFwLCBnZXRQYXJzZWRUeXBlLCBpbnN0YW5jZU9mVHlwZSBhcyBpbnN0YW5jZW9mLCBpbnRlcnNlY3Rpb25UeXBlIGFzIGludGVyc2VjdGlvbiwgaXNBYm9ydGVkLCBpc0FzeW5jLCBpc0RpcnR5LCBpc1ZhbGlkLCBsYXRlLCBsYXp5VHlwZSBhcyBsYXp5LCBsaXRlcmFsVHlwZSBhcyBsaXRlcmFsLCBtYWtlSXNzdWUsIG1hcFR5cGUgYXMgbWFwLCBuYW5UeXBlIGFzIG5hbiwgbmF0aXZlRW51bVR5cGUgYXMgbmF0aXZlRW51bSwgbmV2ZXJUeXBlIGFzIG5ldmVyLCBudWxsVHlwZSBhcyBudWxsLCBudWxsYWJsZVR5cGUgYXMgbnVsbGFibGUsIG51bWJlclR5cGUgYXMgbnVtYmVyLCBvYmplY3RUeXBlIGFzIG9iamVjdCwgb2JqZWN0VXRpbCwgb2Jvb2xlYW4sIG9udW1iZXIsIG9wdGlvbmFsVHlwZSBhcyBvcHRpb25hbCwgb3N0cmluZywgcGlwZWxpbmVUeXBlIGFzIHBpcGVsaW5lLCBwcmVwcm9jZXNzVHlwZSBhcyBwcmVwcm9jZXNzLCBwcm9taXNlVHlwZSBhcyBwcm9taXNlLCBxdW90ZWxlc3NKc29uLCByZWNvcmRUeXBlIGFzIHJlY29yZCwgc2V0VHlwZSBhcyBzZXQsIHNldEVycm9yTWFwLCBzdHJpY3RPYmplY3RUeXBlIGFzIHN0cmljdE9iamVjdCwgc3RyaW5nVHlwZSBhcyBzdHJpbmcsIHN5bWJvbFR5cGUgYXMgc3ltYm9sLCBlZmZlY3RzVHlwZSBhcyB0cmFuc2Zvcm1lciwgdHVwbGVUeXBlIGFzIHR1cGxlLCB1bmRlZmluZWRUeXBlIGFzIHVuZGVmaW5lZCwgdW5pb25UeXBlIGFzIHVuaW9uLCB1bmtub3duVHlwZSBhcyB1bmtub3duLCB1dGlsLCB2b2lkVHlwZSBhcyB2b2lkLCB6IH07XG4iXSwibmFtZXMiOlsidXRpbCIsImFzc2VydEVxdWFsIiwidmFsIiwiYXNzZXJ0SXMiLCJfYXJnIiwiYXNzZXJ0TmV2ZXIiLCJfeCIsIkVycm9yIiwiYXJyYXlUb0VudW0iLCJpdGVtcyIsIm9iaiIsIml0ZW0iLCJnZXRWYWxpZEVudW1WYWx1ZXMiLCJ2YWxpZEtleXMiLCJvYmplY3RLZXlzIiwiZmlsdGVyIiwiayIsImZpbHRlcmVkIiwib2JqZWN0VmFsdWVzIiwibWFwIiwiZSIsIk9iamVjdCIsImtleXMiLCJvYmplY3QiLCJrZXkiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJwdXNoIiwiZmluZCIsImFyciIsImNoZWNrZXIiLCJ1bmRlZmluZWQiLCJpc0ludGVnZXIiLCJOdW1iZXIiLCJpc0Zpbml0ZSIsIk1hdGgiLCJmbG9vciIsImpvaW5WYWx1ZXMiLCJhcnJheSIsInNlcGFyYXRvciIsImpvaW4iLCJqc29uU3RyaW5naWZ5UmVwbGFjZXIiLCJfIiwidmFsdWUiLCJ0b1N0cmluZyIsIm9iamVjdFV0aWwiLCJtZXJnZVNoYXBlcyIsImZpcnN0Iiwic2Vjb25kIiwiWm9kUGFyc2VkVHlwZSIsImdldFBhcnNlZFR5cGUiLCJkYXRhIiwidCIsInN0cmluZyIsImlzTmFOIiwibmFuIiwibnVtYmVyIiwiYm9vbGVhbiIsImZ1bmN0aW9uIiwiYmlnaW50Iiwic3ltYm9sIiwiQXJyYXkiLCJpc0FycmF5IiwibnVsbCIsInRoZW4iLCJjYXRjaCIsInByb21pc2UiLCJNYXAiLCJTZXQiLCJzZXQiLCJEYXRlIiwiZGF0ZSIsInVua25vd24iLCJab2RJc3N1ZUNvZGUiLCJxdW90ZWxlc3NKc29uIiwianNvbiIsIkpTT04iLCJzdHJpbmdpZnkiLCJyZXBsYWNlIiwiWm9kRXJyb3IiLCJjb25zdHJ1Y3RvciIsImlzc3VlcyIsImFkZElzc3VlIiwic3ViIiwiYWRkSXNzdWVzIiwic3VicyIsImFjdHVhbFByb3RvIiwic2V0UHJvdG90eXBlT2YiLCJfX3Byb3RvX18iLCJuYW1lIiwiZXJyb3JzIiwiZm9ybWF0IiwiX21hcHBlciIsIm1hcHBlciIsImlzc3VlIiwibWVzc2FnZSIsImZpZWxkRXJyb3JzIiwiX2Vycm9ycyIsInByb2Nlc3NFcnJvciIsImVycm9yIiwiY29kZSIsInVuaW9uRXJyb3JzIiwicmV0dXJuVHlwZUVycm9yIiwiYXJndW1lbnRzRXJyb3IiLCJwYXRoIiwibGVuZ3RoIiwiY3VyciIsImkiLCJlbCIsInRlcm1pbmFsIiwiaXNFbXB0eSIsImZsYXR0ZW4iLCJmb3JtRXJyb3JzIiwiY3JlYXRlIiwiZXJyb3JNYXAiLCJfY3R4IiwiaW52YWxpZF90eXBlIiwicmVjZWl2ZWQiLCJleHBlY3RlZCIsImludmFsaWRfbGl0ZXJhbCIsInVucmVjb2duaXplZF9rZXlzIiwiaW52YWxpZF91bmlvbiIsImludmFsaWRfdW5pb25fZGlzY3JpbWluYXRvciIsIm9wdGlvbnMiLCJpbnZhbGlkX2VudW1fdmFsdWUiLCJpbnZhbGlkX2FyZ3VtZW50cyIsImludmFsaWRfcmV0dXJuX3R5cGUiLCJpbnZhbGlkX2RhdGUiLCJpbnZhbGlkX3N0cmluZyIsInZhbGlkYXRpb24iLCJpbmNsdWRlcyIsInBvc2l0aW9uIiwic3RhcnRzV2l0aCIsImVuZHNXaXRoIiwidG9vX3NtYWxsIiwidHlwZSIsImV4YWN0IiwiaW5jbHVzaXZlIiwibWluaW11bSIsInRvb19iaWciLCJtYXhpbXVtIiwiY3VzdG9tIiwiaW52YWxpZF9pbnRlcnNlY3Rpb25fdHlwZXMiLCJub3RfbXVsdGlwbGVfb2YiLCJtdWx0aXBsZU9mIiwibm90X2Zpbml0ZSIsImRlZmF1bHRFcnJvciIsIm92ZXJyaWRlRXJyb3JNYXAiLCJzZXRFcnJvck1hcCIsImdldEVycm9yTWFwIiwibWFrZUlzc3VlIiwicGFyYW1zIiwiZXJyb3JNYXBzIiwiaXNzdWVEYXRhIiwiZnVsbFBhdGgiLCJmdWxsSXNzdWUiLCJlcnJvck1lc3NhZ2UiLCJtYXBzIiwibSIsInNsaWNlIiwicmV2ZXJzZSIsIkVNUFRZX1BBVEgiLCJhZGRJc3N1ZVRvQ29udGV4dCIsImN0eCIsImNvbW1vbiIsImNvbnRleHR1YWxFcnJvck1hcCIsInNjaGVtYUVycm9yTWFwIiwieCIsIlBhcnNlU3RhdHVzIiwiZGlydHkiLCJhYm9ydCIsIm1lcmdlQXJyYXkiLCJzdGF0dXMiLCJyZXN1bHRzIiwiYXJyYXlWYWx1ZSIsInMiLCJJTlZBTElEIiwibWVyZ2VPYmplY3RBc3luYyIsInBhaXJzIiwic3luY1BhaXJzIiwicGFpciIsIm1lcmdlT2JqZWN0U3luYyIsImZpbmFsT2JqZWN0IiwiYWx3YXlzU2V0IiwiZnJlZXplIiwiRElSVFkiLCJPSyIsImlzQWJvcnRlZCIsImlzRGlydHkiLCJpc1ZhbGlkIiwiaXNBc3luYyIsIlByb21pc2UiLCJlcnJvclV0aWwiLCJlcnJUb09iaiIsIlBhcnNlSW5wdXRMYXp5UGF0aCIsInBhcmVudCIsIl9jYWNoZWRQYXRoIiwiX3BhdGgiLCJfa2V5IiwiaGFuZGxlUmVzdWx0IiwicmVzdWx0Iiwic3VjY2VzcyIsIl9lcnJvciIsInByb2Nlc3NDcmVhdGVQYXJhbXMiLCJpbnZhbGlkX3R5cGVfZXJyb3IiLCJyZXF1aXJlZF9lcnJvciIsImRlc2NyaXB0aW9uIiwiY3VzdG9tTWFwIiwiaXNzIiwiWm9kVHlwZSIsImRlZiIsInNwYSIsInNhZmVQYXJzZUFzeW5jIiwiX2RlZiIsInBhcnNlIiwiYmluZCIsInNhZmVQYXJzZSIsInBhcnNlQXN5bmMiLCJyZWZpbmUiLCJyZWZpbmVtZW50Iiwic3VwZXJSZWZpbmUiLCJvcHRpb25hbCIsIm51bGxhYmxlIiwibnVsbGlzaCIsIm9yIiwiYW5kIiwidHJhbnNmb3JtIiwiYnJhbmQiLCJkZWZhdWx0IiwiZGVzY3JpYmUiLCJwaXBlIiwicmVhZG9ubHkiLCJpc051bGxhYmxlIiwiaXNPcHRpb25hbCIsIl9nZXRUeXBlIiwiaW5wdXQiLCJfZ2V0T3JSZXR1cm5DdHgiLCJwYXJzZWRUeXBlIiwiX3Byb2Nlc3NJbnB1dFBhcmFtcyIsIl9wYXJzZVN5bmMiLCJfcGFyc2UiLCJfcGFyc2VBc3luYyIsInJlc29sdmUiLCJfYSIsImFzeW5jIiwibWF5YmVBc3luY1Jlc3VsdCIsImNoZWNrIiwiZ2V0SXNzdWVQcm9wZXJ0aWVzIiwiX3JlZmluZW1lbnQiLCJzZXRFcnJvciIsInJlZmluZW1lbnREYXRhIiwiWm9kRWZmZWN0cyIsInNjaGVtYSIsInR5cGVOYW1lIiwiWm9kRmlyc3RQYXJ0eVR5cGVLaW5kIiwiZWZmZWN0IiwiWm9kT3B0aW9uYWwiLCJab2ROdWxsYWJsZSIsIlpvZEFycmF5IiwiWm9kUHJvbWlzZSIsIm9wdGlvbiIsIlpvZFVuaW9uIiwiaW5jb21pbmciLCJab2RJbnRlcnNlY3Rpb24iLCJkZWZhdWx0VmFsdWVGdW5jIiwiWm9kRGVmYXVsdCIsImlubmVyVHlwZSIsImRlZmF1bHRWYWx1ZSIsIlpvZEJyYW5kZWQiLCJjYXRjaFZhbHVlRnVuYyIsIlpvZENhdGNoIiwiY2F0Y2hWYWx1ZSIsIlRoaXMiLCJ0YXJnZXQiLCJab2RQaXBlbGluZSIsIlpvZFJlYWRvbmx5IiwiY3VpZFJlZ2V4IiwiY3VpZDJSZWdleCIsInVsaWRSZWdleCIsInV1aWRSZWdleCIsImVtYWlsUmVnZXgiLCJfZW1vamlSZWdleCIsImVtb2ppUmVnZXgiLCJpcHY0UmVnZXgiLCJpcHY2UmVnZXgiLCJkYXRldGltZVJlZ2V4IiwiYXJncyIsInByZWNpc2lvbiIsIm9mZnNldCIsIlJlZ0V4cCIsImlzVmFsaWRJUCIsImlwIiwidmVyc2lvbiIsInRlc3QiLCJab2RTdHJpbmciLCJjb2VyY2UiLCJTdHJpbmciLCJjaGVja3MiLCJraW5kIiwidG9vQmlnIiwidG9vU21hbGwiLCJVUkwiLCJyZWdleCIsImxhc3RJbmRleCIsInRlc3RSZXN1bHQiLCJ0cmltIiwidG9Mb3dlckNhc2UiLCJ0b1VwcGVyQ2FzZSIsIl9yZWdleCIsIl9hZGRDaGVjayIsImVtYWlsIiwidXJsIiwiZW1vamkiLCJ1dWlkIiwiY3VpZCIsImN1aWQyIiwidWxpZCIsImRhdGV0aW1lIiwibWluIiwibWluTGVuZ3RoIiwibWF4IiwibWF4TGVuZ3RoIiwibGVuIiwibm9uZW1wdHkiLCJpc0RhdGV0aW1lIiwiY2giLCJpc0VtYWlsIiwiaXNVUkwiLCJpc0Vtb2ppIiwiaXNVVUlEIiwiaXNDVUlEIiwiaXNDVUlEMiIsImlzVUxJRCIsImlzSVAiLCJmbG9hdFNhZmVSZW1haW5kZXIiLCJzdGVwIiwidmFsRGVjQ291bnQiLCJzcGxpdCIsInN0ZXBEZWNDb3VudCIsImRlY0NvdW50IiwidmFsSW50IiwicGFyc2VJbnQiLCJ0b0ZpeGVkIiwic3RlcEludCIsInBvdyIsIlpvZE51bWJlciIsImFyZ3VtZW50cyIsImd0ZSIsImx0ZSIsInNldExpbWl0IiwiZ3QiLCJsdCIsImludCIsInBvc2l0aXZlIiwibmVnYXRpdmUiLCJub25wb3NpdGl2ZSIsIm5vbm5lZ2F0aXZlIiwiZmluaXRlIiwic2FmZSIsIk1JTl9TQUZFX0lOVEVHRVIiLCJNQVhfU0FGRV9JTlRFR0VSIiwibWluVmFsdWUiLCJtYXhWYWx1ZSIsImlzSW50IiwiWm9kQmlnSW50IiwiQmlnSW50IiwiWm9kQm9vbGVhbiIsIkJvb2xlYW4iLCJab2REYXRlIiwiZ2V0VGltZSIsIm1pbkRhdGUiLCJtYXhEYXRlIiwiWm9kU3ltYm9sIiwiWm9kVW5kZWZpbmVkIiwiWm9kTnVsbCIsIlpvZEFueSIsIl9hbnkiLCJab2RVbmtub3duIiwiX3Vua25vd24iLCJab2ROZXZlciIsIm5ldmVyIiwiWm9kVm9pZCIsInZvaWQiLCJleGFjdExlbmd0aCIsImFsbCIsImVsZW1lbnQiLCJkZWVwUGFydGlhbGlmeSIsIlpvZE9iamVjdCIsIm5ld1NoYXBlIiwic2hhcGUiLCJmaWVsZFNjaGVtYSIsInVud3JhcCIsIlpvZFR1cGxlIiwiX2NhY2hlZCIsIm5vbnN0cmljdCIsInBhc3N0aHJvdWdoIiwiYXVnbWVudCIsImV4dGVuZCIsIl9nZXRDYWNoZWQiLCJzaGFwZUtleXMiLCJleHRyYUtleXMiLCJjYXRjaGFsbCIsInVua25vd25LZXlzIiwia2V5VmFsaWRhdG9yIiwic3RyaWN0IiwiX2IiLCJfYyIsIl9kIiwic3RyaXAiLCJhdWdtZW50YXRpb24iLCJtZXJnZSIsIm1lcmdpbmciLCJtZXJnZWQiLCJzZXRLZXkiLCJpbmRleCIsInBpY2siLCJtYXNrIiwiZm9yRWFjaCIsIm9taXQiLCJkZWVwUGFydGlhbCIsInBhcnRpYWwiLCJyZXF1aXJlZCIsIm5ld0ZpZWxkIiwia2V5b2YiLCJjcmVhdGVab2RFbnVtIiwic3RyaWN0Q3JlYXRlIiwibGF6eWNyZWF0ZSIsImhhbmRsZVJlc3VsdHMiLCJjaGlsZEN0eCIsInR5cGVzIiwiZ2V0RGlzY3JpbWluYXRvciIsIlpvZExhenkiLCJab2RMaXRlcmFsIiwiWm9kRW51bSIsIlpvZE5hdGl2ZUVudW0iLCJlbnVtIiwiWm9kRGlzY3JpbWluYXRlZFVuaW9uIiwiZGlzY3JpbWluYXRvciIsImRpc2NyaW1pbmF0b3JWYWx1ZSIsIm9wdGlvbnNNYXAiLCJnZXQiLCJmcm9tIiwiZGlzY3JpbWluYXRvclZhbHVlcyIsImhhcyIsIm1lcmdlVmFsdWVzIiwiYSIsImIiLCJhVHlwZSIsImJUeXBlIiwidmFsaWQiLCJiS2V5cyIsInNoYXJlZEtleXMiLCJpbmRleE9mIiwibmV3T2JqIiwic2hhcmVkVmFsdWUiLCJuZXdBcnJheSIsIml0ZW1BIiwiaXRlbUIiLCJoYW5kbGVQYXJzZWQiLCJwYXJzZWRMZWZ0IiwicGFyc2VkUmlnaHQiLCJsZWZ0IiwicmlnaHQiLCJyZXN0IiwiaXRlbUluZGV4Iiwic2NoZW1hcyIsIlpvZFJlY29yZCIsImtleVNjaGVtYSIsImtleVR5cGUiLCJ2YWx1ZVNjaGVtYSIsInZhbHVlVHlwZSIsInRoaXJkIiwiWm9kTWFwIiwiZW50cmllcyIsImZpbmFsTWFwIiwiWm9kU2V0IiwibWluU2l6ZSIsInNpemUiLCJtYXhTaXplIiwiZmluYWxpemVTZXQiLCJlbGVtZW50cyIsInBhcnNlZFNldCIsImFkZCIsInZhbHVlcyIsIlpvZEZ1bmN0aW9uIiwidmFsaWRhdGUiLCJpbXBsZW1lbnQiLCJtYWtlQXJnc0lzc3VlIiwibWFrZVJldHVybnNJc3N1ZSIsInJldHVybnMiLCJmbiIsIm1lIiwicGFyc2VkQXJncyIsIlJlZmxlY3QiLCJhcHBseSIsInBhcnNlZFJldHVybnMiLCJwYXJhbWV0ZXJzIiwicmV0dXJuVHlwZSIsImZ1bmMiLCJ2YWxpZGF0ZWRGdW5jIiwic3RyaWN0SW1wbGVtZW50IiwiZ2V0dGVyIiwibGF6eVNjaGVtYSIsImV4cGVjdGVkVmFsdWVzIiwiZW51bVZhbHVlcyIsIlZhbHVlcyIsIkVudW0iLCJleHRyYWN0IiwiZXhjbHVkZSIsIm9wdCIsIm5hdGl2ZUVudW1WYWx1ZXMiLCJwcm9taXNpZmllZCIsInNvdXJjZVR5cGUiLCJjaGVja0N0eCIsImFyZyIsImZhdGFsIiwicHJvY2Vzc2VkIiwiZXhlY3V0ZVJlZmluZW1lbnQiLCJhY2MiLCJpbm5lciIsImJhc2UiLCJjcmVhdGVXaXRoUHJlcHJvY2VzcyIsInByZXByb2Nlc3MiLCJyZW1vdmVEZWZhdWx0IiwibmV3Q3R4IiwicmVtb3ZlQ2F0Y2giLCJab2ROYU4iLCJCUkFORCIsIlN5bWJvbCIsImhhbmRsZUFzeW5jIiwiaW5SZXN1bHQiLCJpbiIsIm91dCIsInAiLCJfZmF0YWwiLCJwMiIsImxhdGUiLCJpbnN0YW5jZU9mVHlwZSIsImNscyIsInN0cmluZ1R5cGUiLCJudW1iZXJUeXBlIiwibmFuVHlwZSIsImJpZ0ludFR5cGUiLCJib29sZWFuVHlwZSIsImRhdGVUeXBlIiwic3ltYm9sVHlwZSIsInVuZGVmaW5lZFR5cGUiLCJudWxsVHlwZSIsImFueVR5cGUiLCJ1bmtub3duVHlwZSIsIm5ldmVyVHlwZSIsInZvaWRUeXBlIiwiYXJyYXlUeXBlIiwib2JqZWN0VHlwZSIsInN0cmljdE9iamVjdFR5cGUiLCJ1bmlvblR5cGUiLCJkaXNjcmltaW5hdGVkVW5pb25UeXBlIiwiaW50ZXJzZWN0aW9uVHlwZSIsInR1cGxlVHlwZSIsInJlY29yZFR5cGUiLCJtYXBUeXBlIiwic2V0VHlwZSIsImZ1bmN0aW9uVHlwZSIsImxhenlUeXBlIiwibGl0ZXJhbFR5cGUiLCJlbnVtVHlwZSIsIm5hdGl2ZUVudW1UeXBlIiwicHJvbWlzZVR5cGUiLCJlZmZlY3RzVHlwZSIsIm9wdGlvbmFsVHlwZSIsIm51bGxhYmxlVHlwZSIsInByZXByb2Nlc3NUeXBlIiwicGlwZWxpbmVUeXBlIiwib3N0cmluZyIsIm9udW1iZXIiLCJvYm9vbGVhbiIsIk5FVkVSIiwieiIsImRlZmF1bHRFcnJvck1hcCIsIlpvZFRyYW5zZm9ybWVyIiwiU2NoZW1hIiwiWm9kU2NoZW1hIiwiYW55IiwiZGlzY3JpbWluYXRlZFVuaW9uIiwiaW50ZXJzZWN0aW9uIiwibGF6eSIsImxpdGVyYWwiLCJuYXRpdmVFbnVtIiwicGlwZWxpbmUiLCJyZWNvcmQiLCJzdHJpY3RPYmplY3QiLCJ0cmFuc2Zvcm1lciIsInR1cGxlIiwidW5pb24iLCJpbnN0YW5jZW9mIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/zod@3.22.4/node_modules/zod/lib/index.mjs\n");

/***/ })

};
;